<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>C#学习笔记 | flashfish777</title><meta name="author" content="青女"><meta name="copyright" content="青女"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="在学了一段时间Unity后发现C#基础语法还是有些欠缺，所以又去重新学习然后补了这篇笔记..."><meta property="og:type" content="article"><meta property="og:title" content="C#学习笔记"><meta property="og:url" content="http://www.flashfish777.cn/posts/9526375f.html"><meta property="og:site_name" content="flashfish777"><meta property="og:description" content="在学了一段时间Unity后发现C#基础语法还是有些欠缺，所以又去重新学习然后补了这篇笔记..."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://image.flashfish777.cn/img/posttop_10.jpg"><meta property="article:published_time" content="2024-10-12T15:00:00.000Z"><meta property="article:modified_time" content="2024-10-12T15:00:00.000Z"><meta property="article:author" content="青女"><meta property="article:tag" content="C#"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://image.flashfish777.cn/img/posttop_10.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C#学习笔记",
  "url": "http://www.flashfish777.cn/posts/9526375f.html",
  "image": "https://image.flashfish777.cn/img/posttop_10.jpg",
  "datePublished": "2024-10-12T15:00:00.000Z",
  "dateModified": "2024-10-12T15:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "青女",
      "url": "http://www.flashfish777.cn/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/144.png"><link rel="canonical" href="http://www.flashfish777.cn/posts/9526375f.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="baidu-site-verification" content="青女的博客 - 千载白衣酒，一生青女霜"><link rel="manifest" href="/manifest"><link rel="apple-touch-icon" sizes="180x180" href="/img/128.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/16.png"><link rel="mask-icon" href="/img/128.png" color="#5bbad5"><link rel="stylesheet" href="/css/index.css?v=5.3.5"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>(() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 5 || hour >= 20
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'medium_zoom',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"C#学习笔记",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/custom.css"><div id="myscoll"></div><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.css"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="flashfish777" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')</script><link rel="stylesheet" href="/css/progress_bar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg" style="background-image:url(https://image.flashfish777.cn/img/bg.jpg)"></div><div id="an_music_bg" style="background-image:url(https://image.flashfish777.cn/img/bg.jpg)"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/head.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i> <span>文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i> <span>收藏</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/menus/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/menus/poem/"><i class="fa-fw fas fa-pen"></i> <span>神秘</span></a></li><li><a class="site-page child" href="/menus/link/"><i class="fa-fw fas fa-link"></i> <span>Links</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i> <span>说说</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:toRandomPost()"><i class="fa-fw fas fa-bus"></i> <span>随机文章</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://image.flashfish777.cn/img/posttop_10.jpg)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/144.png" alt="Logo"><span class="site-name">flashfish777</span></a><a class="nav-page-title" href="/"><span class="site-name">C#学习笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i> <span>文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i> <span>收藏</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/menus/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/menus/poem/"><i class="fa-fw fas fa-pen"></i> <span>神秘</span></a></li><li><a class="site-page child" href="/menus/link/"><i class="fa-fw fas fa-link"></i> <span>Links</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i> <span>说说</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:toRandomPost()"><i class="fa-fw fas fa-bus"></i> <span>随机文章</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C#学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-10-12T15:00:00.000Z" title="发表于 2024-10-12 15:00:00">2024-10-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">21.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>78分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div class="note info flat"><p><strong>CSharp知识点</strong></p></div><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><table><thead><tr><th align="left">类型</th><th align="left">描述</th><th align="left">范围</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">bool</td><td align="left">布尔值</td><td align="left">True 或 False</td><td align="left">False</td></tr><tr><td align="left">byte</td><td align="left">8 位无符号整数</td><td align="left">0 到 255</td><td align="left">0</td></tr><tr><td align="left">char</td><td align="left">16 位 Unicode 字符</td><td align="left">U +0000 到 U +ffff</td><td align="left">‘\0’</td></tr><tr><td align="left">decimal</td><td align="left">128 位精确的十进制值，28-29 有效位数</td><td align="left">(-7.9 x 1028 到 7.9 x 1028) &#x2F; 100 到 28</td><td align="left">0.0M</td></tr><tr><td align="left">double</td><td align="left">64 位双精度浮点型</td><td align="left">(+&#x2F;-)5.0 x 10-324 到 (+&#x2F;-)1.7 x 10308</td><td align="left">0.0D</td></tr><tr><td align="left">float</td><td align="left">32 位单精度浮点型</td><td align="left">-3.4 x 1038 到 + 3.4 x 1038</td><td align="left">0.0F</td></tr><tr><td align="left">int</td><td align="left">32 位有符号整数类型</td><td align="left">-2,147,483,648 到 2,147,483,647</td><td align="left">0</td></tr><tr><td align="left">long</td><td align="left">64 位有符号整数类型</td><td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td><td align="left">0L</td></tr><tr><td align="left">sbyte</td><td align="left">8 位有符号整数类型</td><td align="left">-128 到 127</td><td align="left">0</td></tr><tr><td align="left">short</td><td align="left">16 位有符号整数类型</td><td align="left">-32,768 到 32,767</td><td align="left">0</td></tr><tr><td align="left">uint</td><td align="left">32 位无符号整数类型</td><td align="left">0 到 4,294,967,295</td><td align="left">0</td></tr><tr><td align="left">ulong</td><td align="left">64 位无符号整数类型</td><td align="left">0 到 18,446,744,073,709,551,615</td><td align="left">0</td></tr><tr><td align="left">ushort</td><td align="left">16 位无符号整数类型</td><td align="left">0 到 65,535</td><td align="left">0</td></tr></tbody></table><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。</p><p>换句话说，它们指的是一个内存位置。使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是由一个变量改变的，其他变量会自动反映这种值的变化。<strong>内置的</strong> 引用类型有：<strong>object</strong>、<strong>dynamic</strong> 和 <strong>string</strong>。</p><h3 id="对象（Object）类型"><a href="#对象（Object）类型" class="headerlink" title="对象（Object）类型"></a>对象（Object）类型</h3><p><strong>对象（Object）类型</strong> 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 <code>System.Object</code> 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。</p><p>当一个值类型转换为对象类型时，则被称为 <strong>装箱</strong>；另一方面，当一个对象类型转换为值类型时，则被称为 <strong>拆箱</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> obj;</span><br><span class="line">obj = <span class="number">100</span>; <span class="comment">// 这是装箱</span></span><br></pre></td></tr></table></figure><h3 id="动态（Dynamic）类型"><a href="#动态（Dynamic）类型" class="headerlink" title="动态（Dynamic）类型"></a>动态（Dynamic）类型</h3><p>您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。</p><p>声明动态类型的语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> &lt;variable_name&gt; = <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> d = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。</p><h3 id="字符串（String）类型"><a href="#字符串（String）类型" class="headerlink" title="字符串（String）类型"></a>字符串（String）类型</h3><p><strong>字符串（String）类型</strong> 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：引号和 @引号。</p><p>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;runoob.com&quot;</span>;</span><br></pre></td></tr></table></figure><p>一个 @引号字符串：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">@&quot;runoob.com&quot;</span>;</span><br></pre></td></tr></table></figure><p>C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\）当作普通字符对待，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">@&quot;C:\Windows&quot;</span>;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;C:\\Windows&quot;</span>;</span><br></pre></td></tr></table></figure><p>@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">@&quot;&lt;script type=&quot;&quot;text/javascript&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;!--</span></span><br><span class="line"><span class="string">    --&gt;</span></span><br><span class="line"><span class="string">&lt;/script&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>用户自定义引用类型有：class（类）、interface（接口） 或 delegate（委托）。我们将在以后的章节中讨论这些类型。</p><h2 id="指针类型（不安全代码）"><a href="#指针类型（不安全代码）" class="headerlink" title="指针类型（不安全代码）"></a>指针类型（不安全代码）</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。</p><p>声明指针类型的语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type* identifier;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span>* cptr;</span><br><span class="line"><span class="built_in">int</span>* p1, p2, p3;</span><br><span class="line"><span class="built_in">int</span>*[] p4; <span class="comment">// p4是 指针的数组 而不是 数组的指针</span></span><br><span class="line"><span class="keyword">void</span>* p5; <span class="comment">// 指向未知类型的指针</span></span><br><span class="line"><span class="built_in">int</span>** p6; <span class="comment">// 指针的指针</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>当一个代码块使用 <strong>unsafe</strong> 修饰符标记时，C# 允许在函数中使用指针变量。<strong>不安全代码</strong>或非托管代码是指使用了<strong>指针</strong>变量的代码块</p><p>您可以使用 <strong>ToString()</strong> 方法检索存储在指针变量所引用位置的数据。下面的实例演示了这点：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UnsafeCodeApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">unsafe</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> <span class="keyword">var</span> = <span class="number">20</span>;</span><br><span class="line">                <span class="built_in">int</span>* p = &amp;<span class="keyword">var</span>;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Data is: &#123;0&#125; &quot;</span> , <span class="keyword">var</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Data is: &#123;0&#125; &quot;</span> , p-&gt;ToString());</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Address is: &#123;0&#125; &quot;</span> , (<span class="built_in">int</span>)p);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Data is: 20</span><br><span class="line">Data is: 20</span><br><span class="line">Address is: 77128984</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>为了编译不安全代码，您必须切换到命令行编译器指定 <strong>&#x2F;unsafe</strong> 命令行。</p><p>例如，为了编译包含不安全代码的名为 prog1.cs 的程序，需在命令行中输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csc /unsafe prog1.cs</span><br></pre></td></tr></table></figure><hr><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul><li>在namespace语句块中声明枚举（常用）</li><li>在class、struct语句块中也可以声明枚举</li><li><strong>枚举不能在函数语句块中声明！</strong></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Enum_practise</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">enum</span> Day &#123;</span><br><span class="line">        Sun,</span><br><span class="line">        Mon,</span><br><span class="line">        Tue,</span><br><span class="line">        Wed,</span><br><span class="line">        Thu,</span><br><span class="line">        Fri,</span><br><span class="line">        Sat</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnumTest</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Day today = Day.Sun;</span><br><span class="line">            <span class="keyword">switch</span> (today)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> Day.Sun:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期日&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Mon:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期一&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Tue:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期二&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Wed:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期三&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Thu:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;V我50&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Fri:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期五&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Sat:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期六&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量类型可以是所有变量类型</span></span><br><span class="line"><span class="built_in">int</span>[] arr1;</span><br><span class="line"><span class="built_in">int</span>[] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">int</span>[] arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] arr4 = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] arr5 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[,] arr;</span><br><span class="line"><span class="built_in">int</span>[,] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">int</span>[,] arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>, <span class="number">3</span>] &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                              &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">                              &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">int</span>[,] arr4 = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                              &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">                              &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">int</span>[,] arr5 = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">                &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><h2 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h2><p><strong>真正的数组的数组。与二维数组的区别：每个一维数组的长度可以不一样。</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[][] arr;</span><br><span class="line"><span class="built_in">int</span>[][] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][];</span><br><span class="line"><span class="built_in">int</span>[][] arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][] &#123; <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                              <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">5</span> &#125;,</span><br><span class="line">                              <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">6</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">int</span>[][] arr4 = <span class="keyword">new</span> <span class="built_in">int</span>[][] &#123; <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                              <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">5</span> &#125;,</span><br><span class="line">                              <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">6</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">int</span>[][] arr5 = &#123; <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                 <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">5</span> &#125;,</span><br><span class="line">                 <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">6</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h1><h2 id="ref-和-out"><a href="#ref-和-out" class="headerlink" title="ref 和 out"></a>ref 和 out</h2><h3 id="按引用传递参数（ref）"><a href="#按引用传递参数（ref）" class="headerlink" title="按引用传递参数（ref）"></a>按引用传递参数（ref）</h3><p>引用参数是一个对变量的<strong>内存位置的引用</strong>。当按引用传递参数时，与值参数不同的是，它不会为这些参数创建一个新的存储位置。引用参数表示与提供给方法的实际参数具有相同的内存位置。</p><p>在 C# 中，使用 <strong>ref</strong> 关键字声明引用参数。下面的实例演示了这点：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> x, <span class="keyword">ref</span> <span class="built_in">int</span> y</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">int</span> temp;</span><br><span class="line"></span><br><span class="line">         temp = x; <span class="comment">/* 保存 x 的值 */</span></span><br><span class="line">         x = y;    <span class="comment">/* 把 y 赋值给 x */</span></span><br><span class="line">         y = temp; <span class="comment">/* 把 temp 赋值给 y */</span></span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         NumberManipulator n = <span class="keyword">new</span> NumberManipulator();</span><br><span class="line">         <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">         <span class="built_in">int</span> a = <span class="number">100</span>;</span><br><span class="line">         <span class="built_in">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在交换之前，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在交换之前，b 的值： &#123;0&#125;&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 调用函数来交换值 */</span></span><br><span class="line">         n.swap(<span class="keyword">ref</span> a, <span class="keyword">ref</span> b);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在交换之后，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在交换之后，b 的值： &#123;0&#125;&quot;</span>, b);</span><br><span class="line"> </span><br><span class="line">         Console.ReadLine();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在交换之前，a 的值：100</span><br><span class="line">在交换之前，b 的值：200</span><br><span class="line">在交换之后，a 的值：200</span><br><span class="line">在交换之后，b 的值：100</span><br></pre></td></tr></table></figure><p>结果表明，<em>swap</em> 函数内的值改变了，且这个改变可以在 <em>Main</em> 函数中反映出来。</p><h3 id="按输出传递参数（out）"><a href="#按输出传递参数（out）" class="headerlink" title="按输出传递参数（out）"></a>按输出传递参数（out）</h3><p>return 语句可用于只从函数中返回一个值。但是，可以使用 <strong>输出参数</strong> 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。</p><p>下面的实例演示了这点：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> x </span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">int</span> temp = <span class="number">5</span>;</span><br><span class="line">         x = temp;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         NumberManipulator n = <span class="keyword">new</span> NumberManipulator();</span><br><span class="line">         <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">         <span class="built_in">int</span> a = <span class="number">100</span>;</span><br><span class="line">         </span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在方法调用之前，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">/* 调用函数来获取值 */</span></span><br><span class="line">         n.getValue(<span class="keyword">out</span> a);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在方法调用之后，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在方法调用之前，a 的值： 100</span><br><span class="line">在方法调用之后，a 的值： 5</span><br></pre></td></tr></table></figure><p>提供给输出参数的变量不需要赋值。当需要从一个参数没有指定初始值的方法中返回值时，输出参数特别有用。请看下面的实例，来理解这一点：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValues</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> x, <span class="keyword">out</span> <span class="built_in">int</span> y </span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;请输入第一个值： &quot;</span>);</span><br><span class="line">          x = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;请输入第二个值： &quot;</span>);</span><br><span class="line">          y = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         NumberManipulator n = <span class="keyword">new</span> NumberManipulator();</span><br><span class="line">         <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">         <span class="built_in">int</span> a , b;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">/* 调用函数来获取值 */</span></span><br><span class="line">         n.getValues(<span class="keyword">out</span> a, <span class="keyword">out</span> b);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在方法调用之后，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在方法调用之后，b 的值： &#123;0&#125;&quot;</span>, b);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果（取决于用户输入）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请输入第一个值：</span><br><span class="line">7</span><br><span class="line">请输入第二个值：</span><br><span class="line">8</span><br><span class="line">在方法调用之后，a 的值： 7</span><br><span class="line">在方法调用之后，b 的值： 8</span><br></pre></td></tr></table></figure><h3 id="ref-和-out的区别"><a href="#ref-和-out的区别" class="headerlink" title="ref 和 out的区别"></a>ref 和 out的区别</h3><ul><li>ref 传入的变量必须初始化，out 不用 （买票上车）</li><li>out 传入的变量必须在内部赋值，ref 不用 （买票下车）</li></ul><h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><p>变长参数允许在调用方法时传入不定长度的参数。变长参数是一个语法糖，本质上还是基于数组的实现</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>使用 params 关键字可以指定被params修饰的参数在传参时数目可变：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseParams</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">object</span>[] list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(list[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>调用方式主要有三种，第一种是传一个数组，第二种是传n个参数，第三种是不传入参数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UseParams(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="string">&quot;test&quot;</span>&#125;); <span class="comment">// 传入数组</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UseParams(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">// 传入多个参数</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UseParams(); <span class="comment">// 不传参</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>params关键字后面必为数组</li><li>数组类型可以是任意的类型</li><li>函数参数可以有别的参数和params关键字修饰的参数</li><li>函数参数中只能最多出现一个params关键字并且一定是在最后一组参数，前面可以有n个其他参数</li></ul><h2 id="命名实参"><a href="#命名实参" class="headerlink" title="命名实参"></a>命名实参</h2><p>通过命名实参，你可以为形参指定实参，方法是将实参与该形参的名称匹配，而不是与形参在形参列表中的位置匹配。有了命名实参，将不再需要将实参的顺序与所调用方法的形参列表中的形参顺序相匹配。 每个形参的实参都可按形参名称进行指定。 例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintOrderDetails(<span class="string">&quot;Gift Shop&quot;</span>, <span class="number">31</span>, <span class="string">&quot;Red Mug&quot;</span>);</span><br><span class="line"><span class="comment">// 卖家姓名、订单号和产品名称</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用命名实参调用</span></span><br><span class="line">PrintOrderDetails(orderNum: <span class="number">31</span>, productName: <span class="string">&quot;Red Mug&quot;</span>, sellerName: <span class="string">&quot;Gift Shop&quot;</span>);</span><br><span class="line">PrintOrderDetails(productName: <span class="string">&quot;Red Mug&quot;</span>, sellerName: <span class="string">&quot;Gift Shop&quot;</span>, orderNum: <span class="number">31</span>);</span><br></pre></td></tr></table></figure><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>有<strong>参数默认值</strong>的参数，一般称为可选参数。当调用函数时可以不传入该参数，不传就会使用默认值作为参数的值。</p><p>例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExampleMethod</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">required</span>, <span class="built_in">string</span> optionalstr = <span class="string">&quot;default string&quot;</span>, <span class="built_in">int</span> optionalint = <span class="number">10</span></span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line">anExample.ExampleMethod(<span class="number">3</span>); <span class="comment">// 后两个参数为默认值</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li><p>支持多参数默认值，每个参数都可以有默认值</p></li><li><p>如果要混用，可选参数必须写在普通参数后面</p></li><li><p>默认值必须是以下类型的表达式之一：</p><ul><li>常量表达式</li><li><code>new ValType()</code> 形式的表达式，其中 <code>ValType</code> 是值类型，例如 <code>enum</code> 或 <code>struct</code></li><li><code>default(ValType)</code> 形式的表达式，其中 <code>ValType</code> 是值类型</li></ul></li><li><p>如果调用方为一系列可选形参中的任意一个形参提供了实参，则它必须为前面的所有可选形参提供实参，实参列表中不支持使用逗号分隔的间隔，如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//anExample.ExampleMethod(3, ,4);</span></span><br></pre></td></tr></table></figure><p>如果想要选择性提供实参，可以使用命名实参来实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anExample.ExampleMethod(<span class="number">3</span>, optionalint: <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>重载允许在<strong>同一作用域内定义多个同名函数</strong>，但这些函数<strong>必须在参数类型、个数或顺序上存在区别</strong>，以便编译器可以根据传递给函数的参数来确定调用哪个函数。在C#中，函数的重载是通过函数签名（函数名称和参数类型、数目以及顺序）来确定的，并不包括返回类型。可以定义相同函数名的函数，只要它们的参数有所不同即可。如果有多个函数符合调用条件，则编译器会选择最匹配的函数。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>命名一组功能相似的函数，减少函数名的数量，避免命名空间的污染</li><li>提升代码复用性与可读性</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ClassOverload CO = <span class="keyword">new</span> ClassOverload();</span><br><span class="line">        CO.GetInfo();</span><br><span class="line">        CO.GetInfo(<span class="number">2</span>);</span><br><span class="line">        CO.GetInfo(<span class="string">&quot;我是第3个重载方法&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        CO.GetInfo(<span class="number">2</span>, <span class="string">&quot;我是第4个重载方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ClassOverload</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是第1个重载方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo</span>(<span class="params"><span class="built_in">int</span> Num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;我是第<span class="subst">&#123;Num&#125;</span>个重载方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo</span>(<span class="params"><span class="built_in">string</span> Name, <span class="built_in">int</span> Num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Name&#125;</span>我有<span class="subst">&#123;Num&#125;</span>个参数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo</span>(<span class="params"><span class="built_in">int</span> Num, <span class="built_in">string</span> Name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Name&#125;</span>我有<span class="subst">&#123;Num&#125;</span>个参数,我的参数顺序与第3个方法不同&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol><li><p>在使用重载时只能通过不同的参数样式</p></li><li><p>不能通过访问权限、返回类型进行重新加载</p></li><li><p>方法的数目不会对重新加载造成影响</p></li><li><p>对于继承来说，如果某一方法在父类中是访问权限是private，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果</p></li><li><p>接口不能重载</p></li></ol><hr><h1 id="结构体（与类的区别）"><a href="#结构体（与类的区别）" class="headerlink" title="结构体（与类的区别）"></a>结构体（与类的区别）</h1><p>结构体提供了一种轻量级的数据类型，适用于表示简单的数据结构，具有较好的性能特性和值语义。</p><p><strong>与类的区别</strong></p><p>类和结构体在设计和使用时有不同的考虑因素，类适合表示复杂的对象和行为，支持继承和多态性，而结构体则更适合表示轻量级数据和值类型，以提高性能并避免引用的管理开销。</p><p>类和结构体有以下几个基本的不同点：</p><p><strong>数据类型：</strong></p><ul><li><strong>结构体是值类型（Value Type）：</strong> 结构体是值类型，它们在栈上分配内存，而不是在堆上。当将结构体实例传递给方法或赋值给另一个变量时，将复制整个结构体的内容。</li><li><strong>类是引用类型（Reference Type）：</strong> 类是引用类型，它们在堆上分配内存。当将类实例传递给方法或赋值给另一个变量时，实际上是传递引用（内存地址）而不是整个对象的副本。</li></ul><p><strong>变量：</strong></p><ul><li>结构体中声明的变量不能直接初始化。</li><li>类可以在声明时对变量初始化。</li></ul><p><strong>继承和多态性：</strong></p><ul><li><strong>结构体不能继承：</strong> 结构体不能继承其他结构体或类，也不能作为其他结构体或类的基类。结构体成员不能指定为 abstract、virtual 或 protected。</li><li><strong>类支持继承：</strong> 类支持继承和多态性，可以通过派生新类来扩展现有类的功能。</li></ul><p><strong>默认构造函数：</strong></p><ul><li><strong>结构体不能有无参数的构造函数、不能定义析构函数：</strong> 结构体不能包含无参数的构造函数。每个结构体都必须有至少一个有参数的构造函数。不能定义析构函数。</li><li><strong>类可以有无参数的构造函数：</strong> 类可以包含无参数的构造函数，如果没有提供构造函数，系统会提供默认的无参数构造函数。</li></ul><p><strong>实例：</strong></p><ul><li>类必须使用 New 操作符才能被实例化。</li><li>结构体可以不使用 New 操作符即可被实例化。如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。</li></ul><p><strong>赋值行为：</strong></p><ul><li>类型为类的变量在赋值时存储的是引用，因此两个变量指向同一个对象。</li><li>结构体变量在赋值时会复制整个结构，因此每个变量都有自己的独立副本。</li></ul><p><strong>传递方式：</strong></p><ul><li>类型为类的对象在方法调用时通过引用传递，这意味着在方法中对对象所做的更改会影响到原始对象。</li><li>结构体对象通常通过值传递，这意味着传递的是结构体的副本，而不是原始结构体对象本身。因此，在方法中对结构体所做的更改不会影响到原始对象。</li></ul><p><strong>可空性：</strong></p><ul><li><strong>结构体是值类型，不能直接设置为 null：</strong> 因为 <strong>null</strong> 是引用类型的默认值，而不是值类型的默认值。如果你需要表示结构体变量的缺失或无效状态，可以使用 <code>Nullable&lt;T&gt;</code> 或称为 <strong>T?</strong> 的可空类型。</li><li><strong>类默认可为null：</strong> 类的实例默认可以为 <code>null</code>，因为它们是引用类型。</li></ul><p><strong>性能和内存分配：</strong></p><ul><li><strong>结构体通常更轻量：</strong> 由于结构体是值类型且在栈上分配内存，它们通常比类更轻量，适用于简单的数据表示。</li><li><strong>类可能有更多开销：</strong> 由于类是引用类型，可能涉及更多的内存开销和管理。</li></ul><hr><h1 id="面向对象理论"><a href="#面向对象理论" class="headerlink" title="面向对象理论"></a>面向对象理论</h1><h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><p><strong>类中一般包含：</strong></p><ul><li>特征——成员变量</li><li>行为——成员方法</li><li>保护特征——成员属性</li><li>构造函数和析构函数</li><li>索引器</li><li>运算符重载</li><li>静态成员</li></ul><p><strong>对象</strong>是类创建出来的，相当于申明一个指定类的变量，类创建对象的过程一般称为实例化对象，类对象都是引用类型的。</p><p><strong>实例化</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p;</span><br><span class="line">Person p2 = <span class="literal">null</span>; <span class="comment">// 与上面相同，没有分配堆内存，栈中为null</span></span><br><span class="line">Person p3 = <span class="keyword">new</span> Person(); <span class="comment">// 分配了堆内存</span></span><br></pre></td></tr></table></figure><h4 id="成员变量和访问修饰符"><a href="#成员变量和访问修饰符" class="headerlink" title="成员变量和访问修饰符"></a>成员变量和访问修饰符</h4><p><strong>成员变量基本规则</strong></p><ul><li>申明在类语句块中</li><li>用来描述对象的特征</li><li>可以是任意变量类型</li><li>数量不作限制</li><li>可以初始化</li><li>是否赋值根据需求来定</li></ul><p><strong>访问修饰符</strong></p><table><thead><tr><th></th><th>当前类</th><th>当前程序集下的类</th><th>其他程序集下的子类</th><th>其他程序集下的类</th></tr></thead><tbody><tr><td>public</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>protected</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>internal（默认）</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>private</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table><p><code>protected internal</code>: 成员可以由当前程序集或子类中的代码访问。</p><p><code>private protected</code>: 成员可以在其定义的类及子类中被访问，但仅当这些子类在同一个程序集中时。</p><p><strong>注意：</strong> 如果没有指定，则使用默认的访问标识符。类的默认访问标识符是 <strong>internal</strong>，成员的默认访问标识符是 <strong>private</strong>。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><strong>基本概念：</strong> 类的 <strong>构造函数</strong> 是类的一个特殊的成员函数，当创建类的新对象时执行。在实例化对象时，会调用的用于初始化的函数。</p><p><strong>写法：</strong></p><ul><li><strong>构造函数的名称与类的名称完全相同</strong>，它没有任何返回类型。</li><li><strong>默认的构造函数</strong>没有任何参数。但是如果你需要一个带有参数的构造函数可以有参数，这种构造函数叫做<strong>参数化构造函数</strong>。</li><li>没有特殊需求时一般都是public的</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>构造函数可以被重载</li><li><code>this</code>关键字代表当前调用该函数的对象自己，数据类型为当前对象</li><li>如果不自己实现无参构造函数而实现了有参构造函数，会失去默认的无参构造</li></ul><p><strong>特殊写法：</strong></p><p>可以通过 <code>:</code> 运算符重用其他构造函数代码，例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Manager</span> : <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span>(<span class="params"><span class="built_in">int</span> annualSalary</span>) : <span class="title">base</span>(<span class="params">annualSalary</span>) <span class="comment">// 使用基类构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Add further instructions here.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">int</span> weeklySalary, <span class="built_in">int</span> numberOfWeeks</span>) : <span class="title">this</span>(<span class="params">weeklySalary * numberOfWeeks</span>) <span class="comment">// 使用当前类其他构造函数</span></span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做时，当使用此构造函数，函数会先调用 <code>:</code> 之后的构造函数，再执行当前构造函数的代码。</p><h4 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h4><p>主构造函数是 C# 12 中的一项新功能，可用于直接在构造函数参数列表中定义和初始化属性。此功能消除了对重复代码的需要，并使代码更加简洁和可读。</p><p><strong>概念：</strong> 主构造函数是一种简洁的语法，用于声明一个构造函数，其参数在类型的主体中的任何位置都可用。</p><p><strong>注意：</strong> 主构造函数的参数在整个类定义的范围内，因此可以使用它们来初始化属性、字段或其他成员。但是，默认情况下，它们不会存储为字段或属性，除非您显式将它们分配给一个字段或属性。它们也不能作为 或 访问，因为它们不是类的成员。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">string</span> firstName, <span class="built_in">string</span> lastName, DateTime hireDate, <span class="built_in">decimal</span> salary</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; = firstName;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; = lastName;  </span><br><span class="line">    <span class="keyword">public</span> DateTime HireDate &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; = hireDate;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Salary &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; = salary;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码等效于以下没有主构造函数的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> DateTime HireDate &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Salary &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">string</span> firstName, <span class="built_in">string</span> lastName, DateTime hireDate, <span class="built_in">decimal</span> salary</span>)</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        FirstName = firstName;  </span><br><span class="line">        LastName = lastName;  </span><br><span class="line">        HireDate = hireDate;  </span><br><span class="line">        Salary = salary;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特殊写法：</strong> 使用主构造参数时仍可使用 <code>this</code> 或 <code>base</code> 关键字，使用特殊写法调用其他构造函数。</p><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p><strong>基本概念：</strong> 类的 <strong>析构函数</strong> 是类的一个特殊的成员函数，当类的对象超出范围时执行。当引用类型的堆内存被回收时，会调用该函数</p><p><strong>写法</strong>： 析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。</p><p><strong>注意：</strong></p><ul><li>析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载</li><li>对于需要手动管理内存的语言（比如c++），需要在析构函数中做一些内存回收处理，但是c#中存在自动垃圾回收机制GC，所以几乎不会这怎么使用析构函数，除非你想在某一个对象被垃圾回收时，做一些特殊处理</li><li>在Unity开发中析构函数几乎不会使用，所以该知识点只做了解即可</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Person() &#123;&#125; <span class="comment">// 析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="垃圾回收机制（GC）"><a href="#垃圾回收机制（GC）" class="headerlink" title="垃圾回收机制（GC）"></a>垃圾回收机制（GC）</h4><p><strong>概念：</strong></p><p>在编写程序时，会产生很多的数据 比如:int string 变量，这些数据都存储在内存里，如果不合理的管理他们，就会内存溢出导致程序崩溃。C#内置了自动垃圾回收GC，在编写代码时可以不需要担心内存溢出的问题 变量失去引用后 GC会帮我们自动回收，但不包括数据流，和一些数据库的连接，这就需要我们手动的释放资源</p><p><strong>垃圾回收</strong>，英文简写<strong>GC</strong>（<code>Garbage Collector</code>）。垃圾回收的过程是在遍历堆（Heap）上动态分配的所有对象，通过识别它们是否被引用来确定哪些对象是垃圾，哪些对象仍要被使用。所谓的垃圾就是没有被任何变量、对象引用的内容，垃圾就需要被回收释放。</p><p>垃圾回收有很多种算法，比如引用计数（Reference Counting）、标记清除（Mark Sweep）、标记整理（Mark Compact）、复制整合（Copy Collection）等。</p><p><strong>机制：</strong></p><p>代的概念：代是垃圾回收机制使用的一种算法（分代算法），新分配的对象都会被配置在弟0代内存中，每次分配都可能会进行垃圾回收以释放内存（0代内存满时），大对象总被认为是第二代内存，不会对大对象进行搬迁压缩，目的是减少性能损耗，85000字节（83kb）以上的对象为大对象。</p><p>过程：垃圾回收共分3代，每次创建对象的时候 都是在第0代分配内存，并且每一代都配有初始内存空间。假设现在程序已经跑了一段时间了，而第0代分配的空间已经满了，<strong>这时候就会进行垃圾回收，把失去引用的对象释放</strong>，此时未使用完的对象将进入到第1代。垃圾回收后，第0代就已经空了，后面创建的对象就会重新放入第0代，以此类推。0代满后，又会重新垃圾回收，还在使用的对象又会放入第1代，此后运行一段时间 1代也已经满了，而0代还在使用的对象也会移动到1代，这时候已经不够放了，又会进行垃圾回收，1代的将移动到2代，0代的将移动到1代（即1代进行垃圾回收时0代也会同时进行垃圾回收），以此类推。假如代数都满了，但对象都还在使用，并没有回收多少，这时GC就会自动的把初始内存给扩大，比如原来2MB扩大到4MB，还不够使用的情况下内存就满了，就会抛出异常。</p><p>**注意：**GC只负责堆内存的垃圾回收，引用类型都是存在堆中的，所以它们的分配和释放都通过垃圾回收机制来管理。栈上的内存是由系统自动管理的，值类型是在栈中分配内存的，它们有自己的生命周期，不用对他们进行管理，会自动分配和释放。</p><p><strong>手动执行垃圾回收：</strong></p><p>垃圾回收一般情况下是自动执行，如果想要手动执行垃圾回收，需要调动此行代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GC.Collect();</span><br></pre></td></tr></table></figure><p>一般情况下不会频繁进行垃圾回收，因为垃圾回收过程比较复杂耗时，可能会造成程序卡顿，通常在Loading界面时顺便进行一次垃圾回收。</p><h4 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h4><p><strong>概念：</strong></p><p>用于保护成员变量，为成员变量的获取和赋值添加逻辑处理。解决访问修饰符的局限性。属性可以让成员变量在外部只能获取不能修改或者只能修改不能获取。</p><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符  属性类型  属性名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span>&#123;&#125; <span class="comment">//get需要返回值，没有返回值就会报错</span></span><br><span class="line">    <span class="keyword">set</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 可以在设置之前添加一些逻辑规则</span></span><br><span class="line">            <span class="comment">// 实现加密等操作</span></span><br><span class="line">            name = <span class="keyword">value</span>; </span><br><span class="line">            <span class="comment">// value关键字，表示外部传入的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 可以在返回之前添加一些逻辑规则</span></span><br><span class="line">            <span class="comment">// 实现解密等操作</span></span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">            <span class="comment">// 这个属性可以获取内容</span></span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">p.Name = <span class="string">&quot;LiMing&quot;</span>; <span class="comment">// &#x27;=&#x27; 默认调用set</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(p.Name); <span class="comment">// 直接使用默认调用get</span></span><br></pre></td></tr></table></figure><p><strong>成员属性中get和set前可以加访问修饰符：</strong> 默认不加会使用属性声明时的权限，加的访问修饰符要低于属性的访问权限，不能让set和get的访问权限都低于属性权限。</p><p><strong>自动属性</strong><br>类似于自动的成员变量，set和get会自动生成成员变量将他们包裹起来。</p><p>作用：外部能得不能改的特征，如果类中有一个特征是只希望外部能得不能改的，又没有什么特殊处理，就可以直接使用自动属性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> Height</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//没有在set,get中写逻辑的需求或者想法</span></span><br><span class="line">    <span class="keyword">get</span>;</span><br><span class="line">    <span class="keyword">set</span>;</span><br><span class="line">    <span class="comment">//可以添加访问修饰符</span></span><br><span class="line">    <span class="comment">//如：private set;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> Sex &#123; <span class="keyword">set</span>; <span class="keyword">get</span>; &#125; = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h4><p><strong>概念：</strong> 索引器允许通过类实例的索引来访问该类的实例成员。它的声明类似于属性，但具有参数。通常情况下，索引器用于允许类的实例像数组一样通过索引进行访问。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Person[] friends;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Person <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> friends[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// value代表传入的值</span></span><br><span class="line">            friends[index] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">p[<span class="number">0</span>] = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>索引器支持多维索引</li><li>C#允许对索引器进行重载</li><li>索引器可以具有多个参数，但每个参数的类型必须唯一</li><li>索引器的参数可以是值类型或引用类型</li><li>可以根据需要只声明 get 或 set 访问器，但至少必须实现其中一个</li></ul><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p><strong>概念：</strong></p><p>静态关键字：<code>static</code>，用static修饰的成员变量，方法，属性等称为静态成员。静态成员可以直接用类名点出来使用。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//静态成员变量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">float</span> PI=<span class="number">3.1415926f</span>;</span><br><span class="line">   <span class="comment">//成员变量</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> testInt=<span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//静态成员方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">CalcCircle</span>(<span class="params"><span class="built_in">float</span> r</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> PI*r*r;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//成员方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">     Console.WriteLine(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(Test.PI);</span><br><span class="line">Console.WriteLine（Test.CalcCircle(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p><strong>原理：</strong></p><p>为什么可以点出来使用：静态成员会有一片静态存储空间，与程序同生共死，一般不参与垃圾回收机制（除非静态引用变量定义为Null,才会参与垃圾回收）</p><p>程序不是无中生有的，我们要使用对象，变量，函数都是要在内存中分配内存空间，在程序中产生一个抽象的对象。</p><p>静态成员的特点：程序开始运行时就分配内存空间，所以我们可以直接使用。静态成员与程序同生共死，只要使用了它，直到程序结束才会被释放，一个静态成员有唯一的小房间，静态成员就有了唯一性。</p><p><strong>注意：</strong></p><ul><li>静态函数不能使用非静态成员，非静态函数可以使用静态成员</li><li>const常量和静态变量都可以通过类名点出来使用，但const常量必须初始化，不能修改，static没有这个规则，static可以修饰很多。const常量一定是写在访问修饰符后面，而static没有这个要求。</li></ul><h4 id="静态类和静态构造函数"><a href="#静态类和静态构造函数" class="headerlink" title="静态类和静态构造函数"></a>静态类和静态构造函数</h4><p><strong>静态类：</strong> 用<code>static</code>关键字修饰的类称作静态类，静态类只能包含静态成员且不能被实例化。例如<strong>Console</strong>就是一个静态类。</p><p><strong>作用：</strong> 将常用的静态成员写在静态类中，方便使用。静态类不能被实例化，更能体现工具类的唯一性。</p><p><strong>静态构造函数：</strong> 用<code>static</code>关键字修饰的构造函数为静态构造函数，静态类和普通类都可以有静态构造函数。静态构造函数不能使用访问修饰符、不能有参数且只会自动调用一次。</p><p><strong>作用：</strong> 静态构造函数用于初始化静态变量。</p><p>静态构造函数不可继承、不可被直接调用，当创建类实例或引用任何静态成员之前，静态构造函数被自动执行，并且只执行一次。</p><h4 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h4><p><strong>概念：</strong> 为现有的非静态变量类型添加新方法。</p><p><strong>作用：</strong></p><ul><li>提升程序拓展性</li><li>不需要在对象中重新写方法</li><li>不需要继承来添加方法</li><li>为别人封装的类型写额外的方法</li></ul><p><strong>特点：</strong></p><ul><li>一定是写在静态类中</li><li>一定是个静态函数</li><li>第一个参数为拓展目标</li><li>第一个参数用this修饰</li></ul><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 返回值 函数名(<span class="keyword">this</span> 拓展类名 参数名, 参数类型 参数名, 参数类型 参数名, ...)</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为int拓展了一个成员方法</span></span><br><span class="line">    <span class="comment">//成员方法是需要实例化对象后才能使用的</span></span><br><span class="line">    <span class="comment">//value代表使用该方法的实例化对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpeakValue</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拓展的方法的逻辑</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;为int的拓展方法&quot;</span> + <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpeakStringInfo</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> str, <span class="built_in">string</span> str2, <span class="built_in">string</span> str3</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;为string拓展的方法&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;调用方法的对象&quot;</span> + str);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;传的参数&quot;</span> + str2 + str3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun2</span>(<span class="params"><span class="keyword">this</span> Test t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是为Test类拓展的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是自带的成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">i.SpeakValue();</span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;000&quot;</span>;</span><br><span class="line">str.SpeakStringInfo(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line">t.Fun2();</span><br></pre></td></tr></table></figure><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p><strong>概念：</strong> 让自定义类和结构体能够使用运算符。</p><p><strong>关键字：</strong> <code>operator</code></p><p><strong>特点：</strong></p><ul><li>一定是一个公共的静态方法</li><li>返回值写在operator前</li><li>逻辑处理自定义</li></ul><p><strong>作用：</strong> 让自定义类和结构体对象可以进行运算。</p><p><strong>注意：</strong></p><ul><li><p>二元运算符需要成对实现</p><ul><li><p><code>==</code>（相等）对应 <code>!=</code>（不等）</p></li><li><p><code>&gt;</code>（大于）对应 <code>&lt;</code>（小于）</p></li><li><p><code>&gt;=</code>（大于等于）对应 <code>&lt;=</code>（小于等于）</p></li></ul></li><li><p>一个符号可以多个重载</p></li><li><p>不能使用 ref 和 out</p></li><li><p>参数列表至少要有一个当前类（或结构体）类型的参数</p></li></ul><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回类型 <span class="keyword">operator</span> 运算符( 参数列表 )</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> x;</span><br><span class="line">    <span class="built_in">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span>+(Point p1, Point p2)</span><br><span class="line">    &#123;</span><br><span class="line">        Point p = <span class="keyword">new</span> Point();</span><br><span class="line">        p.x = p1.x + p2.x;</span><br><span class="line">        p.y = p1.y + p2.y;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point();</span><br><span class="line">p.x = <span class="number">1</span>;</span><br><span class="line">p.y = <span class="number">1</span>;</span><br><span class="line">Point p2 = <span class="keyword">new</span> Point();</span><br><span class="line">p2.x = <span class="number">2</span>;</span><br><span class="line">p2.y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">Point p3 = p + p2;</span><br></pre></td></tr></table></figure><h4 id="内部类和分部类"><a href="#内部类和分部类" class="headerlink" title="内部类和分部类"></a>内部类和分部类</h4><p><strong>内部类：</strong> 在一个类中声明的类。</p><p><strong>特点：</strong> 使用时要用包裹者点出自己。</p><p><strong>作用：</strong> 亲密关系的变现 。</p><p><strong>注意：</strong> 访问修饰符作用很大。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> Body body;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Body</span></span><br><span class="line">    &#123;</span><br><span class="line">        Arm leftArm;</span><br><span class="line">        Arm rightArm;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">class</span> <span class="title">Arm</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person.Body body = <span class="keyword">new</span> Person.Body();</span><br></pre></td></tr></table></figure><p><strong>分部类：</strong> 把一个类分成几部分声明（关键字：<code>partial</code>）。</p><p><strong>作用：</strong> 增加程序的拓展性。</p><p><strong>注意：</strong></p><ul><li>分部类可以写在不同的脚本文件中</li><li>分部类的访问修饰符要一致</li><li>分部类中不能有重复成员</li></ul><p><strong>分部方法：</strong> 将方法的声明和实现分离（局限性大，了解即可）。</p><p><strong>特点：</strong></p><ul><li>不能加访问修饰符，默认私有</li><li>只能在分部类中声明</li><li>返回值只能是void</li><li>可以有参数但不能用 out 关键字</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> number;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"><span class="built_in">int</span> speed</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetHeight</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"><span class="built_in">int</span> speed</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承的基本原则"><a href="#继承的基本原则" class="headerlink" title="继承的基本原则"></a>继承的基本原则</h4><p><strong>基本概念：</strong> 当一个类A继承一个类B时，类A将会继承类B的所有成员，A类将拥有B类的所有特征和行为。被继承的类称为父类、基类、超类，继承的类称为子类、派生类。子类可以有自己的特征和行为。</p><p><strong>特点：</strong></p><ul><li>单根性：子类只能有一个父类（单继承）</li><li>传递性：子类可以间接继承父类的父类</li></ul><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 : 被继承的类名</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同名成员：</strong> 在子类中出现与父类同名的成员，默认将父类的成员覆盖，也可以使用<code>new</code>关键字表示覆盖，但极其不建议使用同名成员。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">new</span> <span class="built_in">string</span> name;</span><br></pre></td></tr></table></figure><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><p>里氏替换原则是面向对象七大原则中最重要的原则</p><p><strong>基本概念：</strong> 任何父类出现的地方，子类都可替代。</p><p><strong>重点：</strong> 语法表现——父类容器装子类对象，因为子类对象包含了父类的所有内容。</p><p><strong>作用：</strong> 方便进行对象存储和管理。</p><p><strong>基本实现：</strong> 用父类容器装载子类对象</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Monster</span> : <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Boss</span> : <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">GameObject player = <span class="keyword">new</span> Player();</span><br><span class="line">GameObject[] objects = <span class="keyword">new</span> GameObject[] &#123; <span class="keyword">new</span> Player(), <span class="keyword">new</span> Monster(), <span class="keyword">new</span> Boss() &#125;;</span><br></pre></td></tr></table></figure><p><strong>is 和 as 关键字：</strong></p><ol><li><p><code>is</code>：判断一个类对象是否是指定类对象，返回值为<code>bool</code>，是为真，不是为假</p></li><li><p><code>as</code>：将一个对象转换为指定类对象，返回值为指定类型对象，成功返回指定类型对象，失败返回<code>null</code></p></li><li><p>基本语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 书接上回</span></span><br><span class="line"><span class="keyword">if</span> (player <span class="keyword">is</span> Player)</span><br><span class="line">&#123;</span><br><span class="line">    Player p = player <span class="keyword">as</span> Player;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注：不能用子类容器装父类对象</strong></p><h4 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h4><p><strong>特点：</strong> 当声明一个子类对象时，先执行父类的构造函数，再执行子类的构造函数。</p><p><strong>注意：</strong> 父类的无参构造很重要。子类可以通过base关键字代表父类，调用父类构造。</p><p><strong>继承中构造函数的执行顺序：</strong> 父类的父类的构造 -&gt; 父类构造 -&gt; 子类构造。子类实例化时，默认自动调用的是父类的无参构造，所以如果父类的无参构造被顶掉，会出错。</p><p><strong>通过base调用指定的父类构造：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Son</span> : <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span>(<span class="params"><span class="built_in">int</span> i</span>) : <span class="title">base</span>(<span class="params">i</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="万物之父和装箱拆箱"><a href="#万物之父和装箱拆箱" class="headerlink" title="万物之父和装箱拆箱"></a>万物之父和装箱拆箱</h4><p><strong>万物之父：</strong> <code>object</code> 是所有类型的基类，它是一个类（引用类型）。</p><p><strong>作用：</strong> 可以利用里氏替换原则，用 <code>object</code> 容器装所有对象。可以用来表示不确定类型，作为函数参数类型。</p><p><strong>装箱拆箱：</strong></p><ul><li>装箱：把值类型用引用类型存储（栈内存会迁移到堆内存中）</li><li>拆箱：把引用类型存储的值取出来（堆内存会迁移到栈内存中）</li><li>好处：不确定类型时可以方便参数的存储和传递</li><li>坏处：存在内存迁移，增加性能消耗</li></ul><h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><p><strong>概念：</strong> 密封类是使用 <code>sealed</code> 密封关键字修饰的类。密封类无法被继承。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Son</span> : <span class="title">Father</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p><strong>作用：</strong> 在面向对象程序设计中，密封类的主要作用就是不允许最底层子类被继承，可以保证程序的规范性，安全性。</p><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="Vob"><a href="#Vob" class="headerlink" title="Vob"></a>Vob</h4><p><strong>多态的概念：</strong> 多态按字面的意思就是“多种状态”，让继承同一父类的子类们 在执行相同方法时有不同的表现（状态）。</p><p><strong>多态的实现：</strong></p><ul><li>编译时多态——函数重载</li><li>运行时多态：Vob、抽象函数、接口</li></ul><p><strong>Vob：</strong></p><ul><li>v： <code>virtual</code>（虚函数）</li><li>o： <code>override</code> （重写）</li><li>b： <code>base</code> （父类）</li><li>（n）： <code>new</code> （覆盖）</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GameObject</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//虚函数 可以被子类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;游戏对象进行攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//重写虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//base的作用</span></span><br><span class="line">        <span class="comment">//代表父类 可以通过base来保留父类的行为</span></span><br><span class="line">        <span class="keyword">base</span>.Atk();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;玩家对象进行攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Monster</span> : <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monster</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;怪物对象进行攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要目的：</strong> 同一父类的对象 执行相同行为（方法）有不同的表现。</p><p><strong>解决的问题：</strong> 让同一个对象有唯一行为的特征。</p><h4 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h4><p><strong>概念：</strong> 被抽象关键字 <code>abstract</code> 修饰的类为抽象类，方法称为抽象方法。</p><p><strong>特点：</strong></p><ul><li>抽象类不能被实例化，但仍可以使用里氏替换原则装它的子类</li><li>抽象方法只能在抽象类中声明，抽象方法没有方法体且不能是私有的</li><li>继承抽象类必须重写其抽象方法</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The dog barks.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The cat meows.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p><strong>概念：</strong> 接口是行为的抽象规范，它也是一种自定义类型。关键字： <code>interface</code> 。</p><p><strong>接口声明的规范：</strong></p><ol><li>不能包含成员变量</li><li>只能包含方法、属性、索引器、事件</li><li>成员不能被实现</li><li>成员不能是私有的，但可以不写访问修饰符，默认是公共的</li><li>接口不能继承类，但可以继承另一个接口</li></ol><p><strong>接口的使用规范：</strong></p><ol><li>类可以继承多个接口</li><li>类继承接口后，必须实现接口中所有成员</li></ol><p><strong>特点：</strong></p><ol><li>和类的声明类似</li><li>接口只能用来继承，不能被实例化，但可以作为容器存储对象（里氏替换原则）</li><li>接口名称通常以大写字母 “I” 开头，表示接口（Interface）的含义，然后跟随具体的接口名称</li></ol><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;攻击&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IExampleInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Method1</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method2</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IExampleInterface2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method4</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IExampleInterfaceSon</span> : <span class="title">IExampleInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Method3</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Book</span> : <span class="title">GameObject</span>, <span class="title">IExampleInterfaceSon</span>, <span class="title">IExampleInterface2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method2</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method3</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method4</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显式实现接口：</strong></p><p>当一个类继承多个接口，但接口中存在同名方法时，可以使用显式实现接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Atk</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ISuperAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Atk</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">IAtk</span>, <span class="title">ISuperAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> IAtk.Atk() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> ISuperAtk.Atk() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong> 显式实现接口不能写访问修饰符。</p><h4 id="密封方法"><a href="#密封方法" class="headerlink" title="密封方法"></a>密封方法</h4><p><strong>概念：</strong> 密封方法是使用 <code>sealed</code> 密封关键字修饰的重写方法，让虚方法或抽象方法在之后不能再被重写。</p><p><strong>特点：</strong> 和 <code>override</code> 一起出现。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="面向对象七大原则"><a href="#面向对象七大原则" class="headerlink" title="面向对象七大原则"></a>面向对象七大原则</h2><h3 id="开闭原则OCP"><a href="#开闭原则OCP" class="headerlink" title="开闭原则OCP"></a>开闭原则OCP</h3><p>开闭原则是设计原则基础的基础，是面向对象的核心原则，其它原则均围绕开闭原则进行展开。</p><p><strong>开闭原则指的是一个软件实体应对对扩展开放，对修改关闭(Software entities should be open for extension, but closed for modification)。</strong> 这个原则是说在设计一个模块的时候，应对使这个模块可以在不被修改的前提下被扩展，换言之，应对可以不必修改源代码的情况下改变这个模块的行为。</p><p><strong>满足开闭原则的软件系统的优越性：</strong></p><ul><li><p>通过扩展已有的软件系统，可以提供新的行为，以满足对软件的新需求，使变化中的软件系统有一定的适应性和灵活性</p></li><li><p>已有的软件模块，特别是最重要的抽象层模块不能再修改，这就使变化中的软件系统有一定的稳定性和延续性</p></li></ul><p><strong>实现开闭原则的关键：</strong></p><p>抽象化是解决问题的关键，在面向对象的编程语言里，可以给系统定义出一套相对较为固定的抽象设计，此设计允许无穷无尽的行为在实现层被实现。在语言里，可以给出一个或多个抽象类或者接口，规定出所有的具体类必须提供的方法的特征作为系统设计的抽象层。这个抽象层预见了所有的可扩展性，因此，在任何扩展情况下都不会改变。这就使得系统的抽象不需要修改，从而满足了开闭原则的第二条，对修改关闭。</p><p>同时，由于从抽象层导出一个或多个新的具体类可以改变系统的行为，因此系统的设计对扩展是开放的，这就满足了开闭原则的第一条。</p><p><strong>对可变性的封装原则：</strong></p><p><strong>把变化的东西封装起来，把不变的抽象出来。</strong> 这是对开闭原则的另外一种描述，它讲的是找到一个系统的可变因素，将之封装起来。该原则意味着两点:</p><ul><li><p>一种可变性不应当散落在代码的很多角落，而应当封装到一个对象里面。继承应当被看做是封装变化的方法，而不应该被认为是一种从一般对象生成特殊对象的方法</p></li><li><p>一种可变性不应当与另外一种可变性混合在一起。这意味着一般的继承层次不会超过两层</p></li></ul><h3 id="里氏替换原则LSP"><a href="#里氏替换原则LSP" class="headerlink" title="里氏替换原则LSP"></a>里氏替换原则LSP</h3><p>任何基类可以出现的地方，子类一定可以出现。<strong>即父类存在的地方，子类是可以替换的。</strong> 替换后行为不变，结果会变化。调用子类行为。 子类和父类必须有相同行为才能完全地实现替换。</p><p>实现开闭原则的关键是抽象化，而里氏代换原则中的基类和子类的继承关系正是抽象化的具体体现，所以里氏代换原则是对实现抽象化的具体步骤的规范。违反里氏代换原则一个最经典的例子便是把正方形设计成长方形的子类。</p><h3 id="依赖倒置原则DIP"><a href="#依赖倒置原则DIP" class="headerlink" title="依赖倒置原则DIP"></a>依赖倒置原则DIP</h3><p><strong>要依赖于抽象，不要依赖于实现。</strong> 说的白一点就是要依赖于抽象类和接口不要依赖具体类，具体类也就是我们可以用new关键字实例化的类。依赖倒转原则是实现开闭原则的一个手段。</p><h3 id="单一职责原则SRP（体现高内聚）"><a href="#单一职责原则SRP（体现高内聚）" class="headerlink" title="单一职责原则SRP（体现高内聚）"></a>单一职责原则SRP（体现高内聚）</h3><p><strong>每一个类应该专注于做一件事情。</strong></p><h3 id="接口隔离原则ISP"><a href="#接口隔离原则ISP" class="headerlink" title="接口隔离原则ISP"></a>接口隔离原则ISP</h3><p><strong>应当为客户端提供尽可能小的单独接口，而不要提供大的总接口。</strong> 暴露行为让后面的实现类知道的越少越好。</p><h3 id="迪米特法则（体现松偶合）"><a href="#迪米特法则（体现松偶合）" class="headerlink" title="迪米特法则（体现松偶合）"></a>迪米特法则（体现松偶合）</h3><p><strong>又叫最少知识原则，一个对象对另一个对象知道的越少越好，即一个软件实体应当尽可能少的与其他实体发生相互作用。</strong></p><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p><strong>要尽量使用合成&#x2F;聚合达到复用，而不是继承关系达到复用的目的。尽量少用继承。</strong> 就如我们前面说的，如果为了复用，便使用继承的方式将两个不相干的类联系在一起，这样的方式是违反合成&#x2F;聚合复用原则的，更进一步的后果那便是违反里氏代换原则。合成&#x2F;聚合复用和里氏代换原则相辅相成，合成&#x2F;聚合复用原则要求我们在复用时首先考虑合成&#x2F;聚合关系，而里氏代换原则是要求我们在使用继承时，必须满足一定的条件。</p><p><strong>原则：一个类中有另一个类的对象。</strong></p><hr><h2 id="面向对象设计模式"><a href="#面向对象设计模式" class="headerlink" title="面向对象设计模式"></a>面向对象设计模式</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/JSANXWT/article/details/126479362">面向对象设计的23种设计模式</a></p><hr><h2 id="面向对象相关"><a href="#面向对象相关" class="headerlink" title="面向对象相关"></a>面向对象相关</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>命名空间是用来组织和重用代码的，就像是一个工具包，类就像是一件一件的工具，都是声明在命名空间中的。命名空间的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。</p><p><strong>定义：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">namespace_name</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>命名空间可以分开声明且可以嵌套：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyGame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyGame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">UI</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">TestUI</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">Image</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">TestImage</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同一命名空间下不能含有同名类，不同命名空间下可以含有同名类：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Run</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Move</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Fly</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Move</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>1.使用 <code>using</code> 关键字引用其他命名空间使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MyGame; <span class="comment">// 只如此引用仍要通过指明出处才能引用该命名空间下的命名空间的类</span></span><br><span class="line"><span class="keyword">using</span> MyGame.UI; <span class="comment">// 如此引用只能使用UI命名空间的类，可以与MyGame同时引用</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Now</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameObject gameobject = <span class="keyword">new</span> GameObject();</span><br><span class="line">        Player player = <span class="keyword">new</span> Player();</span><br><span class="line">        TestUI testUI = <span class="keyword">new</span> TestUI();</span><br><span class="line">        </span><br><span class="line">        MyGame.Image.TestImage testImage = <span class="keyword">new</span> MyGame.Image.TestImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.指明出处使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Now</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.Console.WriteLine(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        MyGame.GameObject gameObject = <span class="keyword">new</span> MyGame.GameObject();</span><br><span class="line">        MyGame.Player player = <span class="keyword">new</span> MyGame.Player();</span><br><span class="line">        MyGame.Image.TestImage testImage = <span class="keyword">new</span> MyGame.Image.TestImage();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同名类只能通过指明出处使用</span></span><br><span class="line">        Run.Move move1 = <span class="keyword">new</span> Run.Move();</span><br><span class="line">        Fly.Move move2 = <span class="keyword">new</span> Fly.Move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（引用命名空间后也可指明出处使用）</p><p><strong>注：命名空间中的类默认为 internal 。</strong></p><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><h4 id="object中的静态方法"><a href="#object中的静态方法" class="headerlink" title="object中的静态方法"></a>object中的静态方法</h4><p><strong>静态方法 <code>Equals</code> ：</strong></p><p>判断两个对象是否相等。最终的判断权交给左侧对象的 Equals 成员方法，不管值类型还是引用类型都会按照左侧对象的 Equals 成员方法的规则来进行比较。</p><p><strong>静态方法 <code>ReferenceEquals</code> ：</strong></p><p>比较两个对象是否是相同的引用，主要是用来比较引用类型的对象，值类型对象返回值始终是 false 。</p><h4 id="object中的成员方法"><a href="#object中的成员方法" class="headerlink" title="object中的成员方法"></a>object中的成员方法</h4><p><strong>普通方法 <code>GetType</code> ：</strong></p><p>该方法的主要作用是获取对象运行时的类型 Type ，通过 Type 结合反射相关知识点可以做很多关于对象的操作。该方法在反射相关知识点中是非常重要的方法。</p><p><strong>普通方法 <code>MemberwiseClone</code> ：</strong></p><p>该方法用于获取对象的浅拷贝对象，意思就是会返回一个新的对象，但是新对象中的引用变量会和老对象中的一致。</p><h4 id="object中的虚方法"><a href="#object中的虚方法" class="headerlink" title="object中的虚方法"></a>object中的虚方法</h4><p><strong>虚方法 <code>Equals</code> ：</strong></p><p>默认实现还是比较两者是否为同一个引用，即相当于 <code>ReferenceEquals</code> 。但是微软在所有类型值的基类 <code>System.ValueType</code> 中重写了该方法，用来比较值相等。我们也可以重写该方法，定义自己的比较规则。</p><p><strong>虚方法 <code>GetHashCode</code> ：</strong></p><p>该方法时获取对象的哈希码（一种通过算法算出的，表示对象的唯一编码，不同对象的哈希码有可能一样，具体值根据哈希算法决定），我们可以通过重写该函数来自己定义对象的哈希码算法，正常情况下，基本不用。</p><p><strong>虚方法 <code>ToString</code> ：</strong></p><p>该方法用于返回当前对象代表的字符串，我们可以重写它定义我们自己的对象转字符串规则，该方法非常常用。当我们调用打印方法时，默认使用的就是对象的 <code>ToString</code> 方法后打印出来的内容。</p><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>, <span class="number">1</span>, <span class="number">3333</span>);</span><br><span class="line">Console.Write(str);</span><br><span class="line"><span class="comment">// 输出 13333</span></span><br></pre></td></tr></table></figure><h4 id="正向查找字符位置"><a href="#正向查找字符位置" class="headerlink" title="正向查找字符位置"></a>正向查找字符位置</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> index = str.IndexOf(<span class="string">&quot;好&quot;</span>); <span class="comment">// 找不到返回-1</span></span><br><span class="line">Console.Write(index);</span><br><span class="line"><span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><h4 id="反向查找指定字符串位置"><a href="#反向查找指定字符串位置" class="headerlink" title="反向查找指定字符串位置"></a>反向查找指定字符串位置</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> index = str.LastIndexOf(<span class="string">&quot;哈哈&quot;</span>); <span class="comment">// 找不到返回-1</span></span><br><span class="line">Console.Write(index);</span><br><span class="line"><span class="comment">// 输出 4</span></span><br></pre></td></tr></table></figure><h4 id="移除指定位置后的字符（包括指定位置）"><a href="#移除指定位置后的字符（包括指定位置）" class="headerlink" title="移除指定位置后的字符（包括指定位置）"></a>移除指定位置后的字符（包括指定位置）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Remove(<span class="number">3</span>); <span class="comment">// 只会返回新字符串，不会修改原字符串</span></span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 你好哈</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Remove(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">// 第二个参数决定移除的字符个数</span></span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 你好哈哈哈</span></span><br></pre></td></tr></table></figure><h4 id="替换指定字符串"><a href="#替换指定字符串" class="headerlink" title="替换指定字符串"></a>替换指定字符串</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Replace(<span class="string">&quot;哈哈&quot;</span>, <span class="string">&quot;嘻嘻&quot;</span>);</span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 你好嘻嘻哈哈</span></span><br></pre></td></tr></table></figure><h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;jhsdgfhsdgfs&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.ToUpper(); <span class="comment">// 转大写</span></span><br><span class="line">newstr = str.ToLower(); <span class="comment">// 转小写</span></span><br></pre></td></tr></table></figure><h4 id="字符串截取（包含指定位置）"><a href="#字符串截取（包含指定位置）" class="headerlink" title="字符串截取（包含指定位置）"></a>字符串截取（包含指定位置）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Substring(<span class="number">2</span>); <span class="comment">// 截取从指定位置开始之后的字符串</span></span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 哈哈哈哈</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Substring(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 第二个参数表示截取指定个数</span></span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 哈哈</span></span><br></pre></td></tr></table></figure><h4 id="字符串切割"><a href="#字符串切割" class="headerlink" title="字符串切割"></a>字符串切割</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;1,2,3,4,5,6,7,8&quot;</span>;</span><br><span class="line"><span class="built_in">string</span>[] strs = str.Split(<span class="string">&#x27;,&#x27;</span>); <span class="comment">// 以逗号切割</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; strs.Length; i ++)</span><br><span class="line">    Console.Write(strs[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">// 输出 1 2 3 4 5 6 7 8</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p><code>string</code> 是特殊的引用，每次重新赋值或者拼接时会分配新的内存空间，如果一个字符串经常改变会非常浪费空间。</p><p><code>StringBuilder</code> 是c#提供的一个用于处理字符串的公共类，主要解决的问题是：直接修改字符串而不创建新的对象，需要频繁修改和拼接的字符串可以使用它，可以提升性能。</p><p><strong>注意使用时需要引用命名空间</strong></p><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;12213123123&quot;</span>, <span class="number">50</span>); <span class="comment">// 初始化与指定容量（可选）</span></span><br><span class="line"><span class="comment">// StringBuilder始终会有空余容量，超过会自动扩容，每次自动扩容容量翻一倍</span></span><br><span class="line">Console.WriteLine(str.Capacity); <span class="comment">// 获取容量</span></span><br><span class="line">Console.WriteLine(str.Length); <span class="comment">// 获取字符串长度</span></span><br></pre></td></tr></table></figure><p><strong>方法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加</span></span><br><span class="line">str.Append(<span class="string">&quot;8888&quot;</span>); <span class="comment">// 加到字符串末尾</span></span><br><span class="line">str.AppendFormat(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>, <span class="number">444</span>, <span class="number">666</span>); <span class="comment">// 通过拼接的形式添加</span></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">str.Insert(<span class="number">0</span>, <span class="string">&quot;2784356&quot;</span>); <span class="comment">// 插入位置 插入内容</span></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">str.Remove(<span class="number">0</span>, <span class="number">10</span>); <span class="comment">// 起始位置 删除个数</span></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">str.Clear();</span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="comment">// str[1] 直接索引</span></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 直接修改</span></span><br><span class="line"><span class="comment">// 替换</span></span><br><span class="line">str.Replace(<span class="string">&quot;34&quot;</span>, <span class="string">&quot;283645&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>StringBuilder</code> 的所有方法执行后都会直接修改原字符串，不需要重新定义。</p><hr><h1 id="数据结构类"><a href="#数据结构类" class="headerlink" title="数据结构类"></a>数据结构类</h1><h2 id="ArrayList类（可变数组）"><a href="#ArrayList类（可变数组）" class="headerlink" title="ArrayList类（可变数组）"></a>ArrayList类（可变数组）</h2><p><strong>概念：</strong> <code>ArrayList</code> 本质是一个 <code>object</code>类型的数组，实现了很多方法。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引用命名空间 System.Collections</span></span><br><span class="line">ArrayList array = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个增加</span></span><br><span class="line">array.Add(<span class="number">1</span>);</span><br><span class="line">array.Add(<span class="string">&quot;3424&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量增加（把另一个List容器里面的内容全部加到后面）</span></span><br><span class="line">array.AddRange(array2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">array.Insert(<span class="number">1</span>, <span class="string">&quot;12345&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.Remove(<span class="string">&quot;ghfjk&quot;</span>); <span class="comment">// 删除第一个指定元素</span></span><br><span class="line">array.RemoveAt(<span class="number">0</span>); <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">array.Clear(); <span class="comment">// 清空</span></span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到指定位置的元素</span></span><br><span class="line">Console.WriteLine(array[<span class="number">0</span>]); <span class="comment">// 直接读取下标</span></span><br><span class="line"><span class="comment">// 查看元素是否存在</span></span><br><span class="line">array.Contains(<span class="string">&quot;123&quot;</span>); <span class="comment">// 返回bool类型，有就返回true，没有返回false</span></span><br><span class="line"><span class="comment">// 正向查找元素位置</span></span><br><span class="line"><span class="built_in">int</span> index = array.IndexOf(<span class="string">&quot;gfh&quot;</span>); <span class="comment">// 返回元素下标，没有返回-1</span></span><br><span class="line"><span class="comment">// 反向查找元素位置</span></span><br><span class="line">index = array.LastIndexOf(<span class="string">&quot;111&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">0</span>] = <span class="string">&quot;3334&quot;</span>; <span class="comment">// 直接修改</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>装箱拆箱：</strong></p><p><code>ArrayList</code> 本质上是一个可以自动扩容的 <code>object</code> 数组，当往其中进行值类型存储时就是在装箱，当值类型对象取出来转换使用时就是在拆箱，所以 <code>ArrayList</code> 尽量少用，有更好的数据容器。</p><p><strong>注：</strong> <code>ArrayList</code> 同样具有容量，原理和作用与 <code>StringBuilder</code> 相同。</p><h2 id="Stack类（栈）"><a href="#Stack类（栈）" class="headerlink" title="Stack类（栈）"></a>Stack类（栈）</h2><p><strong>概念：</strong> <code>Stack</code> 的本质也是 <code>object</code> 数组，封装了栈的存储规则，栈是一种先进后出的数据结构。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引用命名空间 System.Collections</span></span><br><span class="line">stack stack = <span class="keyword">new</span> Stack();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压栈</span></span><br><span class="line">stack.Push(<span class="number">0</span>);</span><br><span class="line">stack.Push(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>取出</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弹栈</span></span><br><span class="line"><span class="built_in">object</span> v = stack.Pop();</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈无法查看指定位置的元素，只能查看栈顶的内容</span></span><br><span class="line">v = stack.Peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看元素是否存在于栈中</span></span><br><span class="line">stack.Contains(<span class="string">&quot;123&quot;</span>); <span class="comment">// true / false</span></span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈无法改变其中的元素，只能压和弹，实在要改，只有清空</span></span><br><span class="line">stack.Clear();</span><br></pre></td></tr></table></figure></li></ul><h2 id="Queue类（队列）"><a href="#Queue类（队列）" class="headerlink" title="Queue类（队列）"></a>Queue类（队列）</h2><p><strong>概念：</strong> <code>Queue</code> 的本质也是 <code>object</code> 数组，封装了队列的存储规则，队列是一种先进先出的数据结构。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引用命名空间 System.Collections</span></span><br><span class="line">Queue queue = <span class="keyword">new</span> Queue();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.Enqueue(<span class="number">1</span>);</span><br><span class="line">queue.Enqueue(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>取出</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> v = queue.Dequeue();</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看队列头部元素</span></span><br><span class="line">v = queue.Peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看元素是否在队列中</span></span><br><span class="line">queue.Contains(<span class="string">&quot;123&quot;</span>); <span class="comment">// true / false</span></span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列无法改变其中的元素，只能进和出，实在要改，只有清空</span></span><br><span class="line">queue.Clear();</span><br></pre></td></tr></table></figure></li></ul><h2 id="Hashtable类（哈希表）"><a href="#Hashtable类（哈希表）" class="headerlink" title="Hashtable类（哈希表）"></a>Hashtable类（哈希表）</h2><p><strong>概念：</strong> <code>Hashtable</code> （又称散列表）是基于键的哈希代码组织起来的键值对集合，它的主要作用是提高数据查询的效率，使用键来访问集合中的元素。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引用命名空间 System.Collections</span></span><br><span class="line">Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：不能出现相同键</span></span><br><span class="line">hashtable.Add(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">hashtable.Add(<span class="number">2</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">hashtable.Add(<span class="string">&quot;123&quot;</span>, <span class="number">2</span>); <span class="comment">// 第一个参数是key</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接通过键删除</span></span><br><span class="line">hashtable.Remove(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">hashtable.Clear();</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过键查找值 找不到会返回空</span></span><br><span class="line">Console.WriteLine(hashtable[<span class="string">&quot;key&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看是否存在</span></span><br><span class="line"><span class="comment">// 根据键检测</span></span><br><span class="line">hashtable.Contains(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">hashtable.ContainsKey(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="comment">// 根据值检测</span></span><br><span class="line">hashtable.Contains.ContainsValue(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能改键对应的内容，无法修改键</span></span><br><span class="line">hashtable[<span class="string">&quot;123&quot;</span>] = <span class="number">100.5f</span>;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型-1"><a href="#泛型-1" class="headerlink" title="泛型"></a>泛型</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>泛型实现了类型参数化，达到代码重用的目的，通过类型参数化来实现同一份代码上操作多种类型。</p><p>泛型相当于类型占位符，定义类或方法时使用替代符代表变量类型，当真正使用类或者方法时再具体指定类型。</p><h3 id="泛型类和接口"><a href="#泛型类和接口" class="headerlink" title="泛型类和接口"></a>泛型类和接口</h3><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestClass1</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestClass1</span> &#123; &#125; </span><br><span class="line"><span class="comment">// 泛型属于类名的一部分，即使它们名字相同，如果泛型不同（是否引用泛型、泛型引用个数），它们也不是同一个类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ITest</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型占位字母可以有多个，用逗号分开</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestClass2</span>&lt;<span class="title">T</span>, <span class="title">E</span>, <span class="title">M</span>, <span class="title">XXX</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T value1;</span><br><span class="line">    <span class="keyword">public</span> E value2;</span><br><span class="line">    <span class="keyword">public</span> XXX value3;</span><br><span class="line">    <span class="keyword">public</span> M value4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TestClass1&lt;<span class="built_in">int</span>&gt; t1 = <span class="keyword">new</span> TestClass1&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">t1.<span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line">TestClass1&lt;<span class="built_in">string</span>&gt; t2 = <span class="keyword">new</span> TestClass1&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">t2.<span class="keyword">value</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line">TestClass2&lt;<span class="built_in">int</span>, <span class="built_in">string</span>, <span class="built_in">float</span>, <span class="built_in">bool</span>&gt; t3 = <span class="keyword">new</span> TestClass2&lt;<span class="built_in">int</span>, <span class="built_in">string</span>, <span class="built_in">float</span>, <span class="built_in">bool</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>继承：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承时实现指定</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span> : <span class="title">ITest</span>&lt;<span class="title">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p><strong>普通类中的泛型方法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun1</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span> &#123; <span class="comment">/* 函数逻辑 */</span> &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 泛型可以有多个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun2</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt;()</span></span><br><span class="line">    &#123;</span><br><span class="line">        T t = <span class="literal">default</span>(T);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 可以用泛型类型做一些逻辑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 泛型作返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">TestFun3</span>&lt;<span class="title">T</span>&gt;()</span></span><br><span class="line">    &#123;</span><br><span class="line">        T Value;</span><br><span class="line">        <span class="keyword">return</span> Value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Test1 t1 = <span class="keyword">new</span> Test2();</span><br><span class="line"></span><br><span class="line">t1.TestFun1&lt;<span class="built_in">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">t1.TestFun1&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;12321312&quot;</span>);</span><br><span class="line"></span><br><span class="line">t1.TestFun2&lt;<span class="built_in">bool</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = t1.TestFun3&lt;<span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>泛型类中的泛型方法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T Value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这种不是泛型方法，T是类的泛型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">T t</span>)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这种才算泛型方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">E</span>&gt;(<span class="params">E e</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test2&lt;<span class="built_in">int</span>&gt; t2 = <span class="keyword">new</span> Test2&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">t2.TestFun&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;123213&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h3><ul><li>不同类型对象的相同逻辑处理就可以用泛型</li><li>使用泛型可以一定程度上避免装箱拆箱</li></ul><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><h3 id="什么是泛型约束"><a href="#什么是泛型约束" class="headerlink" title="什么是泛型约束"></a>什么是泛型约束</h3><p><strong>概念：</strong> 让泛型的类型有一定的限制。</p><p><strong>关键字：</strong> <code>where</code></p><p><strong>泛型约束一共有6种：</strong></p><ol><li>值类型： <code>where 泛型字母 : struct</code></li><li>引用类型： <code>where 泛型字母 : class</code></li><li>存在无参公共构造函数： <code>where 泛型字母 : new()</code></li><li>某个类本身或其派生类： <code>where 泛型字母 : 类名</code></li><li>某个接口的派生类型： <code>where 泛型字母 : 接口名</code></li><li>另一个泛型类型本身或者派生类型： <code>where 泛型字母 : 另一个泛型字母</code></li></ol><h3 id="约束的组合使用"><a href="#约束的组合使用" class="headerlink" title="约束的组合使用"></a>约束的组合使用</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span>, <span class="title">new</span>() &#123; &#125;</span><br><span class="line"><span class="comment">// 可以通过逗号组合使用</span></span><br></pre></td></tr></table></figure><h3 id="多个泛型有约束"><a href="#多个泛型有约束" class="headerlink" title="多个泛型有约束"></a>多个泛型有约束</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>, <span class="title">M</span>, <span class="title">E</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span>, <span class="title">new</span>() <span class="keyword">where</span> <span class="title">M</span> : <span class="title">new</span>() <span class="keyword">where</span> <span class="title">E</span> : <span class="title">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="泛型数据结构类"><a href="#泛型数据结构类" class="headerlink" title="泛型数据结构类"></a>泛型数据结构类</h1><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p><strong>概念：</strong> <code>List</code> 本质是一个可变类型的泛型数组，实现了很多方法。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入命名空间 System.Collections.Generic</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.Add(<span class="number">1</span>); <span class="comment">// 单加</span></span><br><span class="line">list.AddRange(list2); <span class="comment">// 批量加</span></span><br><span class="line">list.Insert(<span class="number">0</span>, <span class="number">999</span>); <span class="comment">// 插入</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.Remove(<span class="number">1</span>); <span class="comment">// 删除指定元素</span></span><br><span class="line">list.RemoveAt(<span class="number">0</span>); <span class="comment">// 删除指定位置元素</span></span><br><span class="line">list.Clear(); <span class="comment">// 清空</span></span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list[0] // 直接通过下标查找指定位置元素</span></span><br><span class="line">list.Contains(<span class="number">1</span>); <span class="comment">// 查看元素是否存在</span></span><br><span class="line">list.IndexOf(<span class="number">2</span>); <span class="comment">// 正向查找元素位置</span></span><br><span class="line">list.LastIndexOf(<span class="number">2</span>); <span class="comment">// 反向查找元素位置</span></span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list[<span class="number">0</span>] = <span class="number">99</span>; <span class="comment">// 直接修改</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>List排序</strong></p><ul><li><p>List自带的排序方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">list.Sort(); <span class="comment">// 默认升序</span></span><br></pre></td></tr></table></figure></li><li><p>自定义类的排序</p><p>继承并实现 <code>ICompareble</code> 接口或 <code>ICompareble&lt;T&gt;</code> 接口中的 <code>CompareTo</code> 方法，自定义排序规则，再使用 <code>Sort</code> 方法。</p></li><li><p>通过委托函数进行排序</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Fun</span>(<span class="params">自定义类名 a, 自定义类名 b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 传入的两个对象为列表中的两个对象</span></span><br><span class="line">    <span class="comment">// 进行两两比较</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现排序规则（返回值规则与CompareTo一样）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.Sort(Fun); <span class="comment">// 将排序函数传入Sort执行</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h2><p><strong>概念：</strong> 可以将 <code>Dictionary</code> 理解为拥有泛型的 <code>Hashtable</code> ，它也是基于键的哈希代码组织起来的键值对，键值对类型从 <code>object</code> 变为了可以自己制定的泛型。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入命名空间 System.Collections.Generic</span></span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意不能出现相同键</span></span><br><span class="line">dictionary.Add();</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能通过键删除</span></span><br><span class="line">dictionary.Remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">dictionary.Clear();</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dictionary[4] // 通过键查看值，找不到会返回空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看是否存在</span></span><br><span class="line"><span class="comment">// 根据键检测</span></span><br><span class="line">dictionary.ContainsKey(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 根据值检测</span></span><br><span class="line">dictionary.ContainsValue(<span class="string">&quot;23874&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary[<span class="number">1</span>] = <span class="string">&quot;555&quot;</span>; <span class="comment">// 直接修改</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="LinkedList（链表）"><a href="#LinkedList（链表）" class="headerlink" title="LinkedList（链表）"></a>LinkedList（链表）</h2><p><strong>概念：</strong> <code>LinkedList</code> 本质是一个可变类型的泛型双向链表</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入命名空间 System.Collections.Generic</span></span><br><span class="line">LinkedList&lt;<span class="built_in">int</span>&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表尾部添加元素</span></span><br><span class="line">linkedList.AddLast(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 在链表头部添加元素</span></span><br><span class="line">linkedList.AddFirst(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 在某一个节点之后添加一个节点</span></span><br><span class="line">linkedList.AddAfter(node, <span class="number">15</span>);</span><br><span class="line"><span class="comment">// 在某一个节点之前添加一个节点</span></span><br><span class="line">linkedList.AddBefore(node, <span class="number">20</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除头节点</span></span><br><span class="line">linkedList.RemoveFirst();</span><br><span class="line"><span class="comment">// 移除尾节点</span></span><br><span class="line">linkedList.RemoveLast();</span><br><span class="line"><span class="comment">// 移除指定元素（不是指定位置的元素）</span></span><br><span class="line">linkedList.Remove(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">linkedList.Clear();</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头节点</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; first = linkedList.First;</span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; last = linkedList.Last;</span><br><span class="line"><span class="comment">// 找到指定值的节点,找不到返回空</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; node = linkedList.Find(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 判断是否存在</span></span><br><span class="line">linkedList.Contains(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先得到节点，再修改值</span></span><br><span class="line">node.Value = <span class="number">8</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="泛型栈和队列"><a href="#泛型栈和队列" class="headerlink" title="泛型栈和队列"></a>泛型栈和队列</h2><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入命名空间 System.Collections.Generic</span></span><br><span class="line"><span class="comment">// 名称不变，加上泛型即可</span></span><br><span class="line">Stack&lt;<span class="built_in">int</span>&gt; stack = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">Queue&lt;<span class="built_in">string</span>&gt; queue = <span class="keyword">new</span> Queue&lt;<span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>使用上与普通栈和队列基本没有区别。</strong></p><hr><h1 id="委托和事件"><a href="#委托和事件" class="headerlink" title="委托和事件"></a>委托和事件</h1><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><strong>委托是函数的容器。</strong> 可以理解为表示函数的变量类型，用来存储和传递函数。委托的本质是一个类，用来定义函数的类型（返回值和参数的类型），不同的函数必须对应和各自“格式”一致的委托。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><strong>关键字：</strong> <code>delegate</code></p><p><strong>语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="built_in">delegate</span> 返回值 委托名(参数列表);</span><br></pre></td></tr></table></figure><p><strong>可以声明在namespace和class语句块中，更多的写在namespace中，访问修饰符默认为public。</strong></p><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyFun1</span>()</span>; <span class="comment">// 声明了一个可以用来存储无参无返回值的函数的容器</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyFun2</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span>()</span> &#123; &#125; <span class="comment">// 无参无返回</span></span><br><span class="line"></span><br><span class="line">MyFun1 f1 = <span class="keyword">new</span> MyFun(Fun); <span class="comment">//装载Fun函数</span></span><br><span class="line">MyFun1 f2 = Fun; <span class="comment">// 另一种实现方法</span></span><br><span class="line"></span><br><span class="line">f1.Invoke(); <span class="comment">// 调用委托</span></span><br><span class="line">f2(); <span class="comment">// 另一种调用方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Fun2</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123; <span class="keyword">return</span> x; &#125; <span class="comment">// 有参有返回</span></span><br><span class="line"></span><br><span class="line">MyFun2 ff1 = Fun2;</span><br><span class="line">ff1(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>委托常用在：</p><ul><li>作为类的成员</li><li>作为函数的参数</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MyFun1 fun1;</span><br><span class="line">    <span class="keyword">public</span> MyFun2 fun2;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">MyFun1 fun1, MyFun2 Fun2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        fun1();</span><br><span class="line">        fun2(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多播委托（存储多个函数）"><a href="#多播委托（存储多个函数）" class="headerlink" title="多播委托（存储多个函数）"></a>多播委托（存储多个函数）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyFun1 f1 = Fun;</span><br><span class="line"></span><br><span class="line">f1 += Fun; <span class="comment">// 存了两个Fun函数</span></span><br><span class="line">f1 += Funa;</span><br><span class="line">f1 += Funb; <span class="comment">// 存储多个函数</span></span><br><span class="line"></span><br><span class="line">f1(); <span class="comment">// 调用委托时全部执行（按添加顺序）</span></span><br><span class="line"></span><br><span class="line">f1 -= FUn; <span class="comment">// 从f1委托中移除Fun函数</span></span><br><span class="line"></span><br><span class="line">f1 = <span class="literal">null</span>; <span class="comment">// 相当于清空委托 </span></span><br></pre></td></tr></table></figure><h3 id="系统定义好的委托"><a href="#系统定义好的委托" class="headerlink" title="系统定义好的委托"></a>系统定义好的委托</h3><p>使用系统自带委托，需要引用 <code>System</code> 命名空间。</p><p><strong>Action</strong></p><p>一个无参无返回的委托。</p><p><strong>Func&lt;out&gt;</strong></p><p>可以指定返回值类型的泛型委托。</p><p><strong>Action&lt;in…&gt;</strong></p><p>可以传n个参数的委托，系统提供了1到16个参数的委托。</p><p><strong>Func&lt;in…, out&gt;</strong></p><p>可以传n个参数的有返回值的委托，系统也提供了1到16个参数的写法。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>事件是一种特殊的变量类型。事件是基于委托的存在，是委托的安全包裹，让委托的使用更有安全性。</p><h3 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h3><p>委托怎么用，事件就怎么用。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">event</span> 委托类型 时间名;</span><br></pre></td></tr></table></figure><p><strong>与委托的区别：</strong></p><ul><li>事件只能作为成员存在于类和接口以及结构体中</li><li>事件不能在类的外部赋值</li><li>事件不能在类的外部调用</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 委托成员变量</span></span><br><span class="line">    <span class="keyword">public</span> Action myFun;</span><br><span class="line">    <span class="comment">// 事件成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action myEvent;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 事件的使用与委托一样</span></span><br><span class="line">        myFun = TestFun;</span><br><span class="line">        myFun += TestFun;</span><br><span class="line">        myFun();</span><br><span class="line">        myFun.Invoke();</span><br><span class="line">        </span><br><span class="line">        myEvent = TestFun;</span><br><span class="line">        myEvent += TestFun;</span><br><span class="line">        myEvent();</span><br><span class="line">        myEvent.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托可以在外部赋值</span></span><br><span class="line">t.myFun = <span class="literal">null</span>;</span><br><span class="line">t.myFun = TestFun;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件不能在外部赋值，但可以添加和移除记录的函数</span></span><br><span class="line"><span class="comment">// t.myEvent = TestFun;</span></span><br><span class="line">t.myEvent += TestFun;</span><br><span class="line">t.myEvent -= TestFun;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托可以在外部调用，事件不能在外面调用</span></span><br><span class="line">t.myFun();</span><br></pre></td></tr></table></figure><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ol><li>防止外部随意置空委托</li><li>防止外部随意调用委托</li><li>事件相当于对委托进行了一次封装，让其更加安全</li></ol><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>匿名函数，就是没有名字的函数。匿名函数的使用主要是配合委托和事件进行使用，脱离委托和事件一般不会用到匿名函数。</p><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delegate</span> (参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 函数逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h3><p>在函数中传递委托参数时和委托或事件赋值时使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Action a = <span class="built_in">delegate</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我是匿名函数&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">a += <span class="built_in">delegate</span> () &#123; <span class="comment">/* 函数逻辑 */</span> &#125;;</span><br><span class="line"></span><br><span class="line">Action&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; b = <span class="built_in">delegate</span> (<span class="built_in">int</span> x, <span class="built_in">string</span> str) &#123; <span class="comment">/* 函数逻辑 */</span> &#125;; <span class="comment">// 有参</span></span><br><span class="line"></span><br><span class="line">Func&lt;<span class="built_in">string</span>&gt; c = <span class="built_in">delegate</span> () &#123; <span class="keyword">return</span> <span class="string">&quot;123&quot;</span> &#125;; <span class="comment">// 有返回</span></span><br></pre></td></tr></table></figure><p>作为函数参数传递或作为函数返回值使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Action action;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 作为参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun1</span>(<span class="params"><span class="built_in">int</span> a, Action fun</span>)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 作为返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">Fun2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">delegate</span> () &#123;</span><br><span class="line">            <span class="comment">// 函数逻辑</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数传递</span></span><br><span class="line">t.Fun1(<span class="number">20</span>, <span class="built_in">delegate</span> () &#123;</span><br><span class="line">    <span class="comment">// 函数逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line">Action ac = t.Fun2(); <span class="comment">// 存起来</span></span><br><span class="line">t.Fun2()(); <span class="comment">// 直接调用</span></span><br></pre></td></tr></table></figure><h3 id="匿名函数的缺点"><a href="#匿名函数的缺点" class="headerlink" title="匿名函数的缺点"></a>匿名函数的缺点</h3><p>因为没有名字，所以添加到委托或事件中后不记录无法单独移除。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p>lambda表达式可以理解为匿名函数的简写，它除了写法不同外，使用上和匿名函数一模一样，都是配合委托或事件使用的。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用-6"><a href="#使用-6" class="headerlink" title="使用"></a>使用</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Action a = () =&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line">Action&lt;<span class="built_in">int</span>&gt; b = (<span class="built_in">int</span> x) =&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>参数类型也可省略，与委托和事件一致</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; a = <span class="literal">null</span>;</span><br><span class="line">a += (str, x) =&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>大括号和小括号也可省略，省略大括号默认是返回值且只有一行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; a = (x) =&gt; &#123; <span class="keyword">return</span> x * <span class="number">5</span>; &#125;; <span class="comment">// 有返回值</span></span><br><span class="line">a += x =&gt; x * <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>内层的函数可以引用包含在它外层的函数的变量，即使外层函数的执行已经终止。</p><p>注：该变量提供的值并非变量创建时的值，而是在父函数范围内的最终值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action action;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里就形成了闭包</span></span><br><span class="line">        <span class="comment">// 因为当构造函数执行完毕时，其中声明的临时变量value的生命周期被改变了</span></span><br><span class="line">        action = () =&gt; &#123;</span><br><span class="line">            Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="协变逆变"><a href="#协变逆变" class="headerlink" title="协变逆变"></a>协变逆变</h1><h2 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h2><p><strong>协变：</strong> 和谐的变化，自然的变化。例如因为里氏替换原则，所以子类变父类是和谐的。</p><p><strong>逆变：</strong> 逆常规的变化，不正常的变化。例如父类变子类是不和谐的。</p><p>逆变和协变是用来修饰泛型的，关键字：</p><ul><li>协变： <code>out</code></li><li>逆变： <code>in</code></li></ul><p>是用于在泛型中修饰泛型字母的，只有泛型接口和泛型委托能使用。</p><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p><strong>返回值和参数：</strong></p><p>用 <code>out</code> 修饰的泛型只能作为返回值，用 <code>in</code> 修饰的泛型只能作为参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">TestOut</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TestIn</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;()</span>;</span><br></pre></td></tr></table></figure><p><strong>结合里氏替换原则：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协变 父类总是能被子类替换</span></span><br><span class="line">TestOut&lt;Son&gt; os = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Son();</span><br><span class="line">&#125;;</span><br><span class="line">TestOut&lt;Father&gt; of = os;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆变 父类总是能被子类替换</span></span><br><span class="line">TestIn&lt;Father&gt; iF = <span class="keyword">value</span> =&gt; &#123; &#125;;</span><br><span class="line">TestIn&lt;Son&gt; iS = iF;</span><br><span class="line">iS(<span class="keyword">new</span> Son()); <span class="comment">// 实际上调用的是iF</span></span><br></pre></td></tr></table></figure><hr><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><a href="https://www.flashfish777.cn/posts/fdbe57b8.html#%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">blog</a></p><h2 id="相关语法"><a href="#相关语法" class="headerlink" title="相关语法"></a>相关语法</h2><p>C#提供了线程类 <code>Tread</code> ，需要引用命名空间 <code>System.Threading</code> 使用。</p><p><strong>声明一个线程：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread类重载了四种构造函数，最常用的需要传入一个无参无返回委托（或函数）</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(NewThreadFun);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NewThreadFun</span>()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p><strong>启动线程：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.Start();</span><br></pre></td></tr></table></figure><p><strong>设置为后台线程：</strong></p><p>声明的线程默认为前台线程，当前台线程都结束的时候整个程序才会结束，即使还有后台线程正在运行。后台线程不会防止应用程序的进程被终止掉，因此如果有线程没有设置为后台线程，此线程还未结束的话，可能导致进程无法正常关闭。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.IsBackground = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><strong>关闭释放一个线程：</strong></p><p>如果开启的线程不是死循环，是能够结束的逻辑，那么不用刻意的去关闭它。</p><p>如果想要终止一个线程，可以通过线程提供的方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.Abort(); <span class="comment">// 终止线程</span></span><br><span class="line">t = <span class="literal">null</span>; <span class="comment">// 置空（GC自动回收）</span></span><br></pre></td></tr></table></figure><p><strong>线程休眠：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tread.Sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 线程类的静态函数，让线程休眠n毫秒再继续执行</span></span><br><span class="line"><span class="comment">// 在哪个线程内部执行休眠的就是哪个线程</span></span><br></pre></td></tr></table></figure><h2 id="线程之间共享数据"><a href="#线程之间共享数据" class="headerlink" title="线程之间共享数据"></a>线程之间共享数据</h2><p>多个线程使用的内存是共享的，都属于该应用程序（进程），所以要注意，当多线程同时操作同一片内存区域时可能会出现问题，可以通过加锁的形式避免问题。</p><p>关键字： <code>lock</code></p><p>原理：当我们在多个线程当中想要访问同样的东西进行逻辑处理时，为了避免不必要的逻辑顺序执行的差错，可以使用 <code>lock</code> 锁避免同时执行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="keyword">lock</span>( obj ) <span class="comment">// 需要传入一个引用类型变量，这里以obj为例</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 语句...</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    Console.WriteLine(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">lock</span>( obj )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 语句...</span></span><br><span class="line">    a = <span class="number">99</span>;</span><br><span class="line">    Console.WriteLine(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当程序执行到 <code>lock</code> 语句块时，会先检测传入的引用类型变量，如果该变量（ <code>obj</code> ）被锁住了，程序就会一直等到 <code>obj</code> 解锁之后再运行 <code>lock</code> 语句块中的逻辑；相反，如果 <code>obj</code> 没被锁，程序就会执行 <code>lock</code> 语句块中的逻辑，同时将 <code>obj</code> 锁住，在逻辑执行完毕后解锁 <code>obj</code> 。</p><h2 id="多线程的意义"><a href="#多线程的意义" class="headerlink" title="多线程的意义"></a>多线程的意义</h2><p>多线程可以用来处理一些复杂耗时的逻辑，比如寻路、网络通信等等，可以专门开一个线程异步处理逻辑，避免卡顿。</p><hr><h1 id="预处理器指令"><a href="#预处理器指令" class="headerlink" title="预处理器指令"></a>预处理器指令</h1><h2 id="什么是预处理器指令"><a href="#什么是预处理器指令" class="headerlink" title="什么是预处理器指令"></a>什么是预处理器指令</h2><p><strong>预处理器指令是指导编译器在实际编译开始之前对信息进行预处理的指令。</strong> 预处理器指令都是以 <code>‘#’</code> 开始，且因为它们不是语句，所以不以分号结束。</p><h2 id="常见的预处理器指令"><a href="#常见的预处理器指令" class="headerlink" title="常见的预处理器指令"></a>常见的预处理器指令</h2><table><thead><tr><th align="left">指令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>#define</code></td><td align="left">定义一个符号，可以用于条件编译。</td></tr><tr><td align="left"><code>#undef</code></td><td align="left">取消定义一个符号。</td></tr><tr><td align="left"><code>#if</code></td><td align="left">开始一个条件编译块，如果符号被定义则包含代码块。</td></tr><tr><td align="left"><code>#elif</code></td><td align="left">如果前面的 <code>#if</code> 或 <code>#elif</code> 条件不满足，且当前条件满足，则包含代码块。</td></tr><tr><td align="left"><code>#else</code></td><td align="left">如果前面的 <code>#if</code> 或 <code>#elif</code> 条件不满足，则包含代码块。</td></tr><tr><td align="left"><code>#endif</code></td><td align="left">结束一个条件编译块。</td></tr><tr><td align="left"><code>#warning</code></td><td align="left">生成编译器警告信息。</td></tr><tr><td align="left"><code>#error</code></td><td align="left">生成编译器错误信息。</td></tr><tr><td align="left"><code>#region</code></td><td align="left">标记一段代码区域，可以在IDE中折叠和展开这段代码，便于代码的组织和阅读。</td></tr><tr><td align="left"><code>#endregion</code></td><td align="left">结束一个代码区域。</td></tr><tr><td align="left"><code>#line</code></td><td align="left">更改编译器输出中的行号和文件名，可以用于调试或生成工具的代码。</td></tr><tr><td align="left"><code>#pragma</code></td><td align="left">用于给编译器发送特殊指令，例如禁用或恢复特定的警告。</td></tr><tr><td align="left"><code>#nullable</code></td><td align="left">控制可空性上下文和注释，允许启用或禁用对可空引用类型的编译器检查。</td></tr></tbody></table><hr><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="程序集"><a href="#程序集" class="headerlink" title="程序集"></a>程序集</h2><p>程序集是经由编译器编译得到的，供进一步编译执行的中间产物，在windows系统中，它一般表现为 <code>.dll（代码库文件）</code> 或 <code>.exe（可执行文件）</code> 的格式。</p><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>元数据就是用来描述数据的数据。</p><p>例如程序中的类，类中的函数、变量等信息就是程序的元数据。有关程序以及类型的数据被称为元数据，它们保存在程序集中。</p><h2 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h2><p>程序正在运行时，可以查看其他程序集或者自身的元数据。一个运行的程序查看本身或者其他程序的元数据的行为就叫做反射。</p><h2 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h2><p>因为反射可以在程序编译后获得信息，所以它提高了程序的拓展性和灵活性。</p><ol><li>程序运行时得到所有元数据，包括元数据的特性</li><li>程序运行时实例化对象，操作对象</li><li>程序运行时创建对象，用这些对象执行任务</li></ol><h2 id="相关语法-1"><a href="#相关语法-1" class="headerlink" title="相关语法"></a>相关语法</h2><p>这里先放一个例子类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">string</span> str</span>) : <span class="title">this</span>(<span class="params">i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">string</span> str</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Type类"><a href="#Type类" class="headerlink" title="Type类"></a>Type类</h3><p><code>Type（类的信息类）</code> 是反射功能的基础，它是访问元数据的主要方式。使用 <code>Type</code> 的成员获取有关类型声明的信息，有关类型的成员（如构造函数、方法、字段、属性和类的事件）。</p><p><strong>获取Type：</strong></p><ol><li><p><code>object</code> 类中的 <code>GetType()</code> 方法可以获取对象的Type：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">42</span>;</span><br><span class="line">Type type = a.GetType();</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>typeof</code> 关键字传入类名，也可以等到对象的Type：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type type = <span class="keyword">typeof</span>(Test);</span><br></pre></td></tr></table></figure></li><li><p>通过类的名字也可以获取类型（注意类名必须包含命名空间，不然找不到）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type type = Type.GetType(<span class="string">&quot;System.Int32&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p><strong>得到类的程序集信息：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(type.Assembly);</span><br></pre></td></tr></table></figure><p><strong>获取类中的所有公共成员：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先得到Type</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span><br><span class="line"><span class="comment">// 然后得到所有公共成员</span></span><br><span class="line"><span class="comment">// 需要引用命名空间 System.Reflection</span></span><br><span class="line">MemberInfo[] infos = t.GetMembers();</span><br></pre></td></tr></table></figure><p><strong>获取类的公共构造函数并调用：</strong></p><ol><li><p>获取所有构造函数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConstructorInfo[] ctors = t.GetConstructors();</span><br></pre></td></tr></table></figure></li><li><p>获取其中一个构造函数并执行</p><p>得构造函数传入Type数组，数组中内容按顺序是参数类型；</p><p>执行构造函数传入object数组，表示按顺序传入的参数。</p><ol><li><p>得到无参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConstructorInfo info = t.GetConstructor(<span class="keyword">new</span> Type[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>执行无参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造没有参数需要传null，该方法会返回object对象</span></span><br><span class="line">Test test = info.Invoke(<span class="literal">null</span>) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure></li><li><p>得到有参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConstructorInfo info = t.GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br><span class="line"><span class="comment">// 获取只有一个int类型参数的构造函数</span></span><br><span class="line">ConstructorInfo info = t.GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">typeof</span>(<span class="built_in">string</span>) &#125;);</span><br><span class="line"><span class="comment">// 获取两个参数的构造函数</span></span><br></pre></td></tr></table></figure><p>执行有参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test test1 = info.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">88</span> &#125;) <span class="keyword">as</span> Test;</span><br><span class="line">Test test2 = info.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">88</span>, <span class="string">&quot;Hello&quot;</span>&#125;) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><strong>获取类的公共成员变量：</strong></p><ol><li><p>得到所有成员变量：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FieldInfo[] fieldInfos = t.GetFields();</span><br></pre></td></tr></table></figure></li><li><p>得到指定名称的公共成员变量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FieldInfo infoJ = t.GetField(<span class="string">&quot;j&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过反射获取和设置对象的值</p><ol><li><p>通过反射获取对象的某个变量的值</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line">test.j = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(infoJ.GetValue(test));</span><br></pre></td></tr></table></figure></li><li><p>通过反射设置指定对象的某个变量的值</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infoJ.SetValue(test, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><strong>获取类的公共成员方法：</strong></p><ol><li><p>得到所有成员方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodInfo[] methods = t.GetMethods();</span><br></pre></td></tr></table></figure></li><li><p>获取一个成员方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果存在方法重载，用Type数组表示参数类型</span></span><br><span class="line">MethodInfo method1 = t.GetMethod(<span class="string">&quot;Speak&quot;</span>, <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">typeof</span>(<span class="built_in">string</span>) &#125;);</span><br><span class="line">MethodInfo method2 = t.GetMethod(<span class="string">&quot;Speak&quot;</span>, <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br></pre></td></tr></table></figure></li><li><p>调用方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数相当于是那个对象要执行这个成员方法</span></span><br><span class="line"><span class="comment">// 如果是静态方法，第一个参数传null即可</span></span><br><span class="line">method1.Invoke(test, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">1</span>, <span class="string">&quot;123&quot;</span> &#125;);</span><br><span class="line">method2.Invoke(test, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure></li></ol><p><strong>其他：</strong></p><ul><li>得枚举： <code>GetEnumName</code> 、 <code>GetEnumNames</code></li><li>得事件： <code>GetEvent</code> 、 <code>GetEvents</code></li><li>得接口： <code>GetInterface</code> 、 <code>GetInterfaces</code></li><li>得属性： <code>GetProperty</code> 、 <code>GetPropertys</code></li></ul><h3 id="Assembly类"><a href="#Assembly类" class="headerlink" title="Assembly类"></a>Assembly类</h3><p>程序集类。主要用来加载其他程序集，加载后才能用Type来使用其他程序集的信息，如果想要使用不是当前程序集的内容，需要先加载程序集。比如 <code>dll（库文件）</code> ，简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。</p><p>三种加载程序集的函数：</p><ul><li><p>一般用来加载在同一文件下的其他程序集</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assembly assembly1 = Assembly.Load(<span class="string">&quot;程序集名称&quot;</span>)；</span><br></pre></td></tr></table></figure></li><li><p>一般用来加载不在同一文件下的其他程序集</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Assembly assembly2 = Assembly.LoadFrom(<span class="string">&quot;包含程序集清单的文件的名称或路径&quot;</span>);</span><br><span class="line">Assembly assembly3 = Assembly.LoadFile(<span class="string">&quot;要加载的文件的完全限定路径&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先加载一个指定程序集</span></span><br><span class="line">Assembly assembly Assembly.LoadFrom(<span class="string">&quot;...&quot;</span>);</span><br><span class="line"><span class="comment">// 获取所有Type</span></span><br><span class="line">Type[] types = assembly.GetTypes();</span><br><span class="line"><span class="comment">// 加载程序集中的一个类对象，之后才能使用反射</span></span><br><span class="line">Type icon = assembly.GetType(<span class="string">&quot;...&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Activator类"><a href="#Activator类" class="headerlink" title="Activator类"></a>Activator类</h3><p>实例化对象的类，用于将Type对象快捷实例化为对象。</p><ol><li><p>无参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span><br><span class="line">Test testObj = Activator.CreateInstance(t) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure></li><li><p>有参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testObj = Activator.CreateInstance(t, <span class="number">99</span>) <span class="keyword">as</span> Test; <span class="comment">// 一个参数的</span></span><br><span class="line">testObj = Activator.CreateInstance(t, <span class="number">99</span>, <span class="string">&quot;123&quot;</span>) <span class="keyword">as</span> Test; <span class="comment">// 两个参数的</span></span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h2><p>特性是允许我们向程序的程序集添加元数据的语言结构，它是用于保存程序结构信息的某种特殊类型的类。特性提供功能强大的方法以将声明信息与C#代码（类型、方法、属性等）相关联。特性与程序实体关联后，即可在运行时使用反射查询特性信息。特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集中，它可以放置在几乎所有的声明中（类、变量、函数等等）。</p><p><strong>简而言之：特性本质上是个类，我们可以利用特性类为元数据添加额外信息。比如一个类、成员变量、成员方法等等为它们添加更多的额外信息，之后可以通过反射来获取这些额外信息。</strong></p><h2 id="自定义特性"><a href="#自定义特性" class="headerlink" title="自定义特性"></a>自定义特性</h2><p>声明一个类继承特性基类 <code>Attribute</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyTestAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 根据需求来写特性中的成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> info;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestAttribute</span>(<span class="params"><span class="built_in">string</span> info</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用特性"><a href="#使用特性" class="headerlink" title="使用特性"></a>使用特性</h2><p>基本语法： <code>[特性名(参数列表)]</code></p><p>本质上就是在调用特性类的构造函数，写在类、函数、变量上一行，表示它们具有该特性信息。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MyTest(<span class="string">&quot;这是一个类&quot;</span>)</span>] <span class="comment">// 特性名中的Attribute系统会默认省略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可以加到成员变量前</span></span><br><span class="line">    [<span class="meta">MyTest(<span class="string">&quot;这是一个成员变量&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以加到函数前</span></span><br><span class="line">    [<span class="meta">MyTest(<span class="string">&quot;这是一个函数&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 甚至可以加到函数参数前</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun2</span>(<span class="params"> [MyTest(<span class="string">&quot;这是一个函数参数&quot;</span></span>)]<span class="built_in">int</span> x )</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限制特性使用范围"><a href="#限制特性使用范围" class="headerlink" title="限制特性使用范围"></a>限制特性使用范围</h2><p>通过为特性类加特性限制其使用范围</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)</span>]</span><br><span class="line"><span class="comment">// 参数一：AttributeTargets —— 特性能够用在哪些地方</span></span><br><span class="line"><span class="comment">// 参数二：AllowMultiple —— 是否允许多个特性实例用在同一个目标上</span></span><br><span class="line"><span class="comment">// 参数三：Inherited —— 特性是否能被派生类和重写成员继承</span></span><br></pre></td></tr></table></figure><h2 id="系统自带特性"><a href="#系统自带特性" class="headerlink" title="系统自带特性"></a>系统自带特性</h2><h3 id="过时特性"><a href="#过时特性" class="headerlink" title="过时特性"></a>过时特性</h3><p><strong>关键字：</strong> <code>Obsolete</code> 特性</p><p>用于提示用户使用的方法等成员已经过时，建议使用新方法。一般加在函数前的特性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数一：调用过时方法时提示的内容</span></span><br><span class="line"><span class="comment">// 参数二：是否禁止调用该方法（true：报错 false：仅警告）</span></span><br><span class="line">[<span class="meta">Obsolete(<span class="string">&quot;Speak方法过时了，建议使用新的方法&quot;</span>， false)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用者信息特性"><a href="#调用者信息特性" class="headerlink" title="调用者信息特性"></a>调用者信息特性</h3><p>使用时需要引用命名空间 <code>System.Runtime.CompilerServices</code> ，一般作为参数的特性。</p><ul><li>获取哪个文件调用： <code>CallerFilePath</code> 特性</li><li>获取哪一行调用： <code>CallerLineNumber</code> 特性</li><li>获取哪个函数调用： <code>CallerMemberName</code> 特性</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpeakCaller</span>(<span class="params"><span class="built_in">string</span> str, [CallerFilePath]<span class="built_in">string</span> fileName = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       [CallerLineNumber]<span class="built_in">int</span> line = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                                    [CallerMemberName]<span class="built_in">string</span> memberName = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(str);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用的文件是&quot;</span> + fileName);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用的行数是&quot;</span> + line);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用的方法名是&quot;</span> + memberName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件编译特性"><a href="#条件编译特性" class="headerlink" title="条件编译特性"></a>条件编译特性</h3><p><strong>关键字：</strong> <code>Conditional</code> 特性</p><p>它会和预处理指令 <code>#define</code> 配合使用，需要引用命名空间 <code>System.Diagnostics</code> ，主要可以用在一些调试代码上（有时想执行有时不想执行的代码）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#defiine Fun</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">Conditional(<span class="string">&quot;Fun&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">Fun(); <span class="comment">// 加了这个特性函数才会执行</span></span><br></pre></td></tr></table></figure><h3 id="外部dll包函数特性"><a href="#外部dll包函数特性" class="headerlink" title="外部dll包函数特性"></a>外部dll包函数特性</h3><p><strong>关键字：</strong> <code>DllImport</code> 特性</p><p>用来标记非 <code>.Net（C#）</code> 的函数，表明该函数在一个外部的DLL中定义。一般用来调用 C 或 C++ 的DLL包写好的方法。使用时需要引用命名空间 <code>System.Runtime.InteropServices</code> 。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">&quot;Test.dll&quot;</span>)</span>] <span class="comment">// 假如用一个Test包中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h2><p><strong>迭代器（iterator）</strong> 又称光标（cursor）是程序设计的软件设计模式。迭代器模式提供一个方法顺序访问一个聚合对象中的各个元素而又不暴露其内部的标识。</p><p>从表面效果上看，迭代器是可以在容器对象（例如链表或数组）上遍历访问的接口，设计人员无需关心容器对象的内存分配的实现细节，可以用 <code>foreach</code> 遍历的类，都是实现了迭代器的。</p><h2 id="标准迭代器的实现方法"><a href="#标准迭代器的实现方法" class="headerlink" title="标准迭代器的实现方法"></a>标准迭代器的实现方法</h2><p><strong>关键接口：</strong> <code>IEnumerator</code> ， <code>IEnumerable</code></p><p><strong>命名空间：</strong> <code>System.Collections</code></p><p>可以通过同时继承 <code>IEnumerator</code> 和 <code>IEnumerable</code> 实现其中的方法。</p><h2 id="用-yield-return-语法糖实现迭代器"><a href="#用-yield-return-语法糖实现迭代器" class="headerlink" title="用 yield return 语法糖实现迭代器"></a>用 yield return 语法糖实现迭代器</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] list;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomList</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// yield 关键字 配合迭代器使用</span></span><br><span class="line">            <span class="comment">// 可以理解为 暂时返回 保留当前状态</span></span><br><span class="line">            <span class="comment">// 一会还会再回来</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用-yield-return-语法糖为泛型类实现迭代器"><a href="#用-yield-return-语法糖为泛型类实现迭代器" class="headerlink" title="用 yield return 语法糖为泛型类实现迭代器"></a>用 yield return 语法糖为泛型类实现迭代器</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span>&lt;<span class="title">T</span>&gt; : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="特殊语法"><a href="#特殊语法" class="headerlink" title="特殊语法"></a>特殊语法</h1><h2 id="var隐式类型"><a href="#var隐式类型" class="headerlink" title="var隐式类型"></a>var隐式类型</h2><p>概念： <code>var</code> 是一种特殊的变量类型，它可以用来表示任意类型的变量。</p><p>注意：</p><ul><li><code>var</code> 不能作为类的成员，只能用于临时变量声明</li><li><code>var</code> 变量必须初始化</li></ul><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><h2 id="设置对象初始值"><a href="#设置对象初始值" class="headerlink" title="设置对象初始值"></a>设置对象初始值</h2><p>概念：声明对象时，可以直接写大括号的形式初始化公共成员变量和属性。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test t1 = <span class="keyword">new</span> Test() &#123; x = <span class="number">1</span>, str = <span class="string">&quot;123&quot;</span>, Name = <span class="string">&quot;xxx&quot;</span> &#125;;</span><br><span class="line">Test t2 = <span class="keyword">new</span> Test() &#123; Name = <span class="string">&quot;yyy&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 先执行构造函数再执行初始化的内容</span></span><br></pre></td></tr></table></figure><h2 id="设置集合初始值"><a href="#设置集合初始值" class="headerlink" title="设置集合初始值"></a>设置集合初始值</h2><p>概念：声明集合对象时也可以通过大括号直接初始化内部属性。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] array1 = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list1 = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">List&lt;Test&gt; list2 = <span class="keyword">new</span> List&lt;Test&gt;() &#123;</span><br><span class="line">    <span class="keyword">new</span> Test(),</span><br><span class="line">    <span class="keyword">new</span> Test() &#123; Name = <span class="string">&quot;xxx&quot;</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Test() &#123; x = <span class="number">1</span>, str = <span class="string">&quot;123&quot;</span>, Name = <span class="string">&quot;yyy&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;() &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="string">&quot;123&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">2</span>, <span class="string">&quot;34655&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">3</span>, <span class="string">&quot;45676&quot;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h2><p>概念：变量可以使用 <code>var</code> 声明为自定义的匿名类型。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> &#123; age = <span class="number">10</span>, money = <span class="number">11</span>, name = <span class="string">&quot;小明&quot;</span> &#125;;</span><br><span class="line">COnsole.WriteLine(v.age);</span><br><span class="line"><span class="comment">// 匿名类型无法声明成员方法</span></span><br></pre></td></tr></table></figure><h2 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h2><p>概念：值类型不能赋值为空，但再声明时在值类型后面加 <code>?</code> 表示这是一个可空类型，就可以赋值为空了。</p><p>示例;</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? c = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="keyword">if</span> (c.HasValue)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全获取可空类型值</span></span><br><span class="line">COnsole.WriteLine(Value.GetValueOrDefault(<span class="number">100</span>));</span><br><span class="line"><span class="comment">// 有值就返回值，空的就返回括号里的参数，无参默认返回该类型的默认值</span></span><br></pre></td></tr></table></figure><p><code>?</code> 还可判断一个对象是否为空：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> o = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (o != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    o.Tostring();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于以上代码 能帮我们自动判断o是否为空</span></span><br><span class="line"><span class="comment">// 如果是null就不会执行，也不会报错</span></span><br><span class="line">o?.Tostring();</span><br></pre></td></tr></table></figure><h2 id="空合并操作符"><a href="#空合并操作符" class="headerlink" title="空合并操作符"></a>空合并操作符</h2><p>概念：空合并操作符 <code>??</code> ，如果左边值为空，就返回右边值，否则返回左边值，只要是可以为空的类型都能使用。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? v = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>? i = v == <span class="literal">null</span> ? <span class="number">100</span> : v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于以上代码</span></span><br><span class="line">i = v ?? <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h2 id="内插字符串"><a href="#内插字符串" class="headerlink" title="内插字符串"></a>内插字符串</h2><p>概念：用 <code>$</code> 来构造字符串，让字符串可以拼接变量。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;你好，<span class="subst">&#123;name&#125;</span>，年龄<span class="subst">&#123;age&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="单句逻辑简略写法"><a href="#单句逻辑简略写法" class="headerlink" title="单句逻辑简略写法"></a>单句逻辑简略写法</h2><p>概念：使用 <code>=&gt;</code> 省略大括号，需要返回值则同时省略 <code>return</code> ，只要是只有一句代码都可以这样用。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        <span class="keyword">set</span> =&gt; sex = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> =&gt; a + b; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;12312321&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>end</p></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>C#学习笔记</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="http://www.flashfish777.cn/posts/9526375f.html">http://www.flashfish777.cn/posts/9526375f.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>青女</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-10-12</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-10-12</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C#</a></div><div class="post-share"><div class="social-share" data-image="https://image.flashfish777.cn/img/posttop_10.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload='this.media="all"'><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/css/coin/coin.css" media="defer" onload='this.media="all"'><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">V我50</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://image.flashfish777.cn/img/zanshang.jpg" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/zanshang.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li></ul></div></button></div><script defer src="/js/coin/coin.js"></script><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/5a49393d.html" title="LecSnake - 3d贪吃蛇"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/posttop_11.jpg" onerror='onerror=null,src="https://image.flashfish777.cn/img/404page.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">LecSnake - 3d贪吃蛇</div></div><div class="info-2"><div class="info-item-1">使用Unity引擎开发的一个以Lec为背景的3d贪吃蛇小游戏，是我在暑假期间完全独立探索出的第一款Unity小游戏...</div></div></div></a><a class="pagination-related" href="/posts/a985624f.html" title="Unity日记：存档系统"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/posttop_7_9.jpg" onerror='onerror=null,src="https://image.flashfish777.cn/img/404page.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Unity日记：存档系统</div></div><div class="info-2"><div class="info-item-1">一个完美的存档系统对一款小游戏来说无异于是一种锦上添花的存在，本文将介绍关于Unity PlayerPrefs和JSON存档的实现，以及它们的优缺点...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/5a49393d.html" title="LecSnake - 3d贪吃蛇"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/posttop_11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-15</div><div class="info-item-2">LecSnake - 3d贪吃蛇</div></div><div class="info-2"><div class="info-item-1">使用Unity引擎开发的一个以Lec为背景的3d贪吃蛇小游戏，是我在暑假期间完全独立探索出的第一款Unity小游戏...</div></div></div></a><a class="pagination-related" href="/posts/a985624f.html" title="Unity日记：存档系统"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/posttop_7_9.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-25</div><div class="info-item-2">Unity日记：存档系统</div></div><div class="info-2"><div class="info-item-1">一个完美的存档系统对一款小游戏来说无异于是一种锦上添花的存在，本文将介绍关于Unity PlayerPrefs和JSON存档的实现，以及它们的优缺点...</div></div></div></a><a class="pagination-related" href="/posts/fdbe57b8.html" title="Unity日记：场景切换与并发编程"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/posttop_8.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-10</div><div class="info-item-2">Unity日记：场景切换与并发编程</div></div><div class="info-2"><div class="info-item-1">从加载进度条到Unity的进程、线程与协程...</div></div></div></a><a class="pagination-related" href="/posts/bf08e6b6.html" title="Unity日记：小地图"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/posttop_7_9.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-05</div><div class="info-item-2">Unity日记：小地图</div></div><div class="info-2"><div class="info-item-1">小地图可是一些游戏的灵魂所在，来学着做一个小地图吧...</div></div></div></a><a class="pagination-related" href="/posts/e1d7977f.html" title="Unity日记：UGUI与单例模式"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/posttop_16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">Unity日记：UGUI与单例模式</div></div><div class="info-2"><div class="info-item-1">在项目开发过程中对于UI的管理与设计模式有了很多新的认识与思考...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div class="comment-switch"><span class="first-comment">Twikoo</span><span id="switch-btn"></span><span class="second-comment">Giscus</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="card-info-avatar"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/head.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="https://lskypro.acozycotage.net/LightPicture/2022/12/fe1dc0402e623096.jpg">🥵</g-emoji><span>有点火热</span></div></div></div><div class="author-info-name">青女</div><div class="author-info-description">SWPU-Lec团队青训部部长</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/flashfish777"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:13602092772@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a><a class="social-icon" href="https://image.flashfish777.cn/img/QQ.jpg" target="_blank" title="QQ"><i class="fab fa-qq" style="color:#10a4ff"></i></a><a class="social-icon" href="https://image.flashfish777.cn/img/wechat.jpg" target="_blank" title="微信"><i class="fab fa-weixin" style="color:#00bf03"></i></a><a class="social-icon" href="https://bilibili.com" target="_blank" title="bilibili"><i class="fab fa-bilibili" style="color:#ffaae6"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">值类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%EF%BC%88Object%EF%BC%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">对象（Object）类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%EF%BC%88Dynamic%EF%BC%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">动态（Dynamic）类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">字符串（String）类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%8D%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">指针类型（不安全代码）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-number">1.3.3.</span> <span class="toc-text">编译</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">2.1.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.2.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">3.1.</span> <span class="toc-text">一维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">3.2.</span> <span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E9%94%99%E6%95%B0%E7%BB%84"><span class="toc-number">3.3.</span> <span class="toc-text">交错数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">方法（函数）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ref-%E5%92%8C-out"><span class="toc-number">4.1.</span> <span class="toc-text">ref 和 out</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%EF%BC%88ref%EF%BC%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">按引用传递参数（ref）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E8%BE%93%E5%87%BA%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%EF%BC%88out%EF%BC%89"><span class="toc-number">4.1.2.</span> <span class="toc-text">按输出传递参数（out）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref-%E5%92%8C-out%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.3.</span> <span class="toc-text">ref 和 out的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">变长参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E5%AE%9E%E5%8F%82"><span class="toc-number">4.3.</span> <span class="toc-text">命名实参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">可选参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">4.5.</span> <span class="toc-text">重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">4.5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">4.5.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.5.3.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-1"><span class="toc-number">4.5.4.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">结构体（与类的区别）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%AE%BA"><span class="toc-number">6.</span> <span class="toc-text">面向对象理论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">6.1.</span> <span class="toc-text">面向对象三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">6.1.1.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">类和对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">成员变量和访问修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.1.3.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.1.4.</span> <span class="toc-text">主构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.1.5.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%88GC%EF%BC%89"><span class="toc-number">6.1.1.6.</span> <span class="toc-text">垃圾回收机制（GC）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7"><span class="toc-number">6.1.1.7.</span> <span class="toc-text">成员属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%99%A8"><span class="toc-number">6.1.1.8.</span> <span class="toc-text">索引器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">6.1.1.9.</span> <span class="toc-text">静态成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.1.10.</span> <span class="toc-text">静态类和静态构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.1.11.</span> <span class="toc-text">扩展方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">6.1.1.12.</span> <span class="toc-text">运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%88%86%E9%83%A8%E7%B1%BB"><span class="toc-number">6.1.1.13.</span> <span class="toc-text">内部类和分部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">6.1.2.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">继承的基本原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">里氏替换原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.2.3.</span> <span class="toc-text">继承中的构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E5%92%8C%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1"><span class="toc-number">6.1.2.4.</span> <span class="toc-text">万物之父和装箱拆箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB"><span class="toc-number">6.1.2.5.</span> <span class="toc-text">密封类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">6.1.3.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vob"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">Vob</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.3.2.</span> <span class="toc-text">抽象类和抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.1.3.3.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.3.4.</span> <span class="toc-text">密封方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">6.2.</span> <span class="toc-text">面向对象七大原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99OCP"><span class="toc-number">6.2.1.</span> <span class="toc-text">开闭原则OCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99LSP"><span class="toc-number">6.2.2.</span> <span class="toc-text">里氏替换原则LSP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99DIP"><span class="toc-number">6.2.3.</span> <span class="toc-text">依赖倒置原则DIP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99SRP%EF%BC%88%E4%BD%93%E7%8E%B0%E9%AB%98%E5%86%85%E8%81%9A%EF%BC%89"><span class="toc-number">6.2.4.</span> <span class="toc-text">单一职责原则SRP（体现高内聚）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99ISP"><span class="toc-number">6.2.5.</span> <span class="toc-text">接口隔离原则ISP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%EF%BC%88%E4%BD%93%E7%8E%B0%E6%9D%BE%E5%81%B6%E5%90%88%EF%BC%89"><span class="toc-number">6.2.6.</span> <span class="toc-text">迪米特法则（体现松偶合）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">6.2.7.</span> <span class="toc-text">合成复用原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text">面向对象设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3"><span class="toc-number">6.4.</span> <span class="toc-text">面向对象相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">6.4.1.</span> <span class="toc-text">命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-2"><span class="toc-number">6.4.1.2.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E7%B1%BB"><span class="toc-number">6.4.2.</span> <span class="toc-text">Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#object%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.2.1.</span> <span class="toc-text">object中的静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#object%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.2.2.</span> <span class="toc-text">object中的成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#object%E4%B8%AD%E7%9A%84%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.2.3.</span> <span class="toc-text">object中的虚方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-number">6.4.3.</span> <span class="toc-text">String类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-number">6.4.3.1.</span> <span class="toc-text">字符串拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE"><span class="toc-number">6.4.3.2.</span> <span class="toc-text">正向查找字符位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%8D%E7%BD%AE"><span class="toc-number">6.4.3.3.</span> <span class="toc-text">反向查找指定字符串位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%90%8E%E7%9A%84%E5%AD%97%E7%AC%A6%EF%BC%88%E5%8C%85%E6%8B%AC%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">6.4.3.4.</span> <span class="toc-text">移除指定位置后的字符（包括指定位置）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.4.3.5.</span> <span class="toc-text">替换指定字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.4.3.6.</span> <span class="toc-text">大小写转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96%EF%BC%88%E5%8C%85%E5%90%AB%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">6.4.3.7.</span> <span class="toc-text">字符串截取（包含指定位置）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E5%89%B2"><span class="toc-number">6.4.3.8.</span> <span class="toc-text">字符串切割</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder%E7%B1%BB"><span class="toc-number">6.4.4.</span> <span class="toc-text">StringBuilder类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">数据结构类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E7%B1%BB%EF%BC%88%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">ArrayList类（可变数组）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stack%E7%B1%BB%EF%BC%88%E6%A0%88%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">Stack类（栈）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue%E7%B1%BB%EF%BC%88%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">Queue类（队列）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hashtable%E7%B1%BB%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="toc-number">7.4.</span> <span class="toc-text">Hashtable类（哈希表）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-1"><span class="toc-number">8.1.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">8.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.1.2.</span> <span class="toc-text">泛型类和接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.3.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">8.1.4.</span> <span class="toc-text">泛型的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">8.2.</span> <span class="toc-text">泛型约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">8.2.1.</span> <span class="toc-text">什么是泛型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E7%9A%84%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">8.2.2.</span> <span class="toc-text">约束的组合使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E6%B3%9B%E5%9E%8B%E6%9C%89%E7%BA%A6%E6%9D%9F"><span class="toc-number">8.2.3.</span> <span class="toc-text">多个泛型有约束</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">泛型数据结构类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#List%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">List（列表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dictionary%EF%BC%88%E5%AD%97%E5%85%B8%EF%BC%89"><span class="toc-number">9.2.</span> <span class="toc-text">Dictionary（字典）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">9.3.</span> <span class="toc-text">LinkedList（链表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">9.4.</span> <span class="toc-text">泛型栈和队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.</span> <span class="toc-text">委托和事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98"><span class="toc-number">10.1.</span> <span class="toc-text">委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-3"><span class="toc-number">10.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">10.1.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-3"><span class="toc-number">10.1.3.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%92%AD%E5%A7%94%E6%89%98%EF%BC%88%E5%AD%98%E5%82%A8%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">10.1.4.</span> <span class="toc-text">多播委托（存储多个函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%AE%9A%E4%B9%89%E5%A5%BD%E7%9A%84%E5%A7%94%E6%89%98"><span class="toc-number">10.1.5.</span> <span class="toc-text">系统定义好的委托</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.2.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-4"><span class="toc-number">10.2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-4"><span class="toc-number">10.2.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E4%B9%89"><span class="toc-number">10.2.3.</span> <span class="toc-text">意义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.</span> <span class="toc-text">匿名函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-5"><span class="toc-number">10.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-number">10.3.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-5"><span class="toc-number">10.3.3.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">10.3.4.</span> <span class="toc-text">匿名函数的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">10.4.</span> <span class="toc-text">Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-6"><span class="toc-number">10.4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">10.4.2.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-6"><span class="toc-number">10.4.3.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">10.4.4.</span> <span class="toc-text">闭包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98%E9%80%86%E5%8F%98"><span class="toc-number">11.</span> <span class="toc-text">协变逆变</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-7"><span class="toc-number">11.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="toc-number">11.2.</span> <span class="toc-text">作用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">12.1.</span> <span class="toc-text">相关概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E8%AF%AD%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">相关语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="toc-number">12.3.</span> <span class="toc-text">线程之间共享数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">12.4.</span> <span class="toc-text">多线程的意义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">13.</span> <span class="toc-text">预处理器指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">13.1.</span> <span class="toc-text">什么是预处理器指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">13.2.</span> <span class="toc-text">常见的预处理器指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">14.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%9B%86"><span class="toc-number">14.1.</span> <span class="toc-text">程序集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">14.2.</span> <span class="toc-text">元数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">14.3.</span> <span class="toc-text">反射的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">14.4.</span> <span class="toc-text">反射的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E8%AF%AD%E6%B3%95-1"><span class="toc-number">14.5.</span> <span class="toc-text">相关语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Type%E7%B1%BB"><span class="toc-number">14.5.1.</span> <span class="toc-text">Type类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Assembly%E7%B1%BB"><span class="toc-number">14.5.2.</span> <span class="toc-text">Assembly类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Activator%E7%B1%BB"><span class="toc-number">14.5.3.</span> <span class="toc-text">Activator类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">15.</span> <span class="toc-text">特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-8"><span class="toc-number">15.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7"><span class="toc-number">15.2.</span> <span class="toc-text">自定义特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%89%B9%E6%80%A7"><span class="toc-number">15.3.</span> <span class="toc-text">使用特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E7%89%B9%E6%80%A7%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">15.4.</span> <span class="toc-text">限制特性使用范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E7%89%B9%E6%80%A7"><span class="toc-number">15.5.</span> <span class="toc-text">系统自带特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%97%B6%E7%89%B9%E6%80%A7"><span class="toc-number">15.5.1.</span> <span class="toc-text">过时特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E8%80%85%E4%BF%A1%E6%81%AF%E7%89%B9%E6%80%A7"><span class="toc-number">15.5.2.</span> <span class="toc-text">调用者信息特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E7%89%B9%E6%80%A7"><span class="toc-number">15.5.3.</span> <span class="toc-text">条件编译特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8dll%E5%8C%85%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7"><span class="toc-number">15.5.4.</span> <span class="toc-text">外部dll包函数特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">16.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-9"><span class="toc-number">16.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">16.2.</span> <span class="toc-text">标准迭代器的实现方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8-yield-return-%E8%AF%AD%E6%B3%95%E7%B3%96%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">16.3.</span> <span class="toc-text">用 yield return 语法糖实现迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8-yield-return-%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B8%BA%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">16.4.</span> <span class="toc-text">用 yield return 语法糖为泛型类实现迭代器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95"><span class="toc-number">17.</span> <span class="toc-text">特殊语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#var%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">17.1.</span> <span class="toc-text">var隐式类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-number">17.2.</span> <span class="toc-text">设置对象初始值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%9B%86%E5%90%88%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-number">17.3.</span> <span class="toc-text">设置集合初始值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">17.4.</span> <span class="toc-text">匿名类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">17.5.</span> <span class="toc-text">可空类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">17.6.</span> <span class="toc-text">空合并操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%8F%92%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">17.7.</span> <span class="toc-text">内插字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%8F%A5%E9%80%BB%E8%BE%91%E7%AE%80%E7%95%A5%E5%86%99%E6%B3%95"><span class="toc-number">17.8.</span> <span class="toc-text">单句逻辑简略写法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/5c266b64.html" title="Docker笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/posttop_27.jpg" onerror='this.onerror=null,this.src="https://image.flashfish777.cn/img/404page.jpg"' alt="Docker笔记"></a><div class="content"><a class="title" href="/posts/5c266b64.html" title="Docker笔记">Docker笔记</a><time datetime="2025-03-29T17:18:23.000Z" title="发表于 2025-03-29 17:18:23">2025-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9285b404.html" title="Lua学习笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/posttop_26.jpg" onerror='this.onerror=null,this.src="https://image.flashfish777.cn/img/404page.jpg"' alt="Lua学习笔记"></a><div class="content"><a class="title" href="/posts/9285b404.html" title="Lua学习笔记">Lua学习笔记</a><time datetime="2025-01-20T15:00:00.000Z" title="发表于 2025-01-20 15:00:00">2025-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/174932e5.html" title="微派冬令营面试"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/posttop_25.jpg" onerror='this.onerror=null,this.src="https://image.flashfish777.cn/img/404page.jpg"' alt="微派冬令营面试"></a><div class="content"><a class="title" href="/posts/174932e5.html" title="微派冬令营面试">微派冬令营面试</a><time datetime="2024-12-30T19:00:00.000Z" title="发表于 2024-12-30 19:00:00">2024-12-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By 青女</div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://flashfish777.cn">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()">播放音乐</div><meting-js id="12414190713" server="netease" type="playlist" mutex="true" preload="auto" theme="var(--anzhiyu-main)" data-lrctype="0" order="list"></meting-js></div><div><script src="/js/utils.js?v=5.3.5"></script><script src="/js/main.js?v=5.3.5"></script><script src="/js/tw_cn.js?v=5.3.5"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.flashfish777.cn/',
      region: 'ap-chengdu',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo.flashfish777.cn/',
      region: 'ap-chengdu',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'flashfish777/flashfish777.github.io',
      'data-repo-id': 'R_kgDOMfbyxw',
      'data-category-id': 'DIC_kwDOMfbyx84ChdVD',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Twikoo' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Twikoo' === 'Giscus' || !true) {
    if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer src="/js/cursor.js"></script><script defer src="/js/title.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer data-pjax src="/js/cat.js"></script><script src="/anzhiyu/random.js"></script><script data-pjax src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/lunar.js"></script><script defer src="/js/day.js"></script><script async data-pjax src="/js/anzhiyu.js"></script><script async data-pjax src="/js/anzhiyufunction.js"></script><script async src="/js/anzhiyuOnlyOne.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/click-show-text.min.js" data-mobile="true" data-text="I,Love,Coding" data-fontsize="20px" data-random="false" async></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:description\"]","link[rel=\"canonical\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false 
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.3.5"></script></div></div><script data-pjax>function butterfly_clock_anzhiyu_injector_config(){var a=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载butterfly_clock_anzhiyu"),a&&a.insertAdjacentHTML("afterbegin",'<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",qweather_key="f8e7354f981e465d92a83a91f6fa9e9e",gaud_map_key="e901330ac19a7c00ed720e378b8c998b",baidu_ak_key="undefined",flag=0,clock_rectangle="104.161659,30.834258",clock_default_rectangle_enable="false",i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;"all"===epage&&0==flag?butterfly_clock_anzhiyu_injector_config():epage===cpage&&butterfly_clock_anzhiyu_injector_config()</script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.js"></script><script data-pjax>function butterfly_footer_beautify_injector_config(){var t=document.getElementById("footer-wrap");console.log("已挂载butterfly_footer_beautify"),t.insertAdjacentHTML("beforeend",'<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题应用Butterfly" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;"all"===epage&&0==flag?butterfly_footer_beautify_injector_config():epage===cpage&&butterfly_footer_beautify_injector_config()</script><script async src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.js"></script><script data-pjax>function butterfly_swiper_injector_config(){var a=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),a.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9526375f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/posttop_10.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9526375f.html&quot;);" href="javascript:void(0);" alt="">C#学习笔记</a><div class="blog-slider__text">在学了一段时间Unity后发现C#基础语法还是有些欠缺，所以又去重新学习然后补了这篇笔记...</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9526375f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/fdbe57b8.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/posttop_8.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/fdbe57b8.html&quot;);" href="javascript:void(0);" alt="">Unity日记：场景切换与并发编程</a><div class="blog-slider__text">从加载进度条到Unity的进程、线程与协程...</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/fdbe57b8.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/961490cd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/posttop_3.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-21</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/961490cd.html&quot;);" href="javascript:void(0);" alt="">Roefian的大冒险：初识面向对象!</a><div class="blog-slider__text">关于一些小项目以及对于程序设计方法的学习与理解...</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/961490cd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a985624f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/posttop_7_9.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a985624f.html&quot;);" href="javascript:void(0);" alt="">Unity日记：存档系统</a><div class="blog-slider__text">一个完美的存档系统对一款小游戏来说无异于是一种锦上添花的存在，本文将介绍关于Unity PlayerPrefs和JSON存档的实现，以及它们的优缺点...</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a985624f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c5a23961.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image.flashfish777.cn/img/posttop_5.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-05-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c5a23961.html&quot;);" href="javascript:void(0);" alt="">VSCode插件推荐</a><div class="blog-slider__text">VSCode一些好用的插件...</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c5a23961.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;"all"===epage&&0==flag?butterfly_swiper_injector_config():epage===cpage&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","30"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("article-sort-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__slideInRight"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/unitychan.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/"})</script></body></html>