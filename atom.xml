<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>flashfish777_blog</title>
  
  <subtitle>我的博客</subtitle>
  <link href="http://flashfish777.cn/atom.xml" rel="self"/>
  
  <link href="http://flashfish777.cn/"/>
  <updated>2024-08-20T12:52:45.366Z</updated>
  <id>http://flashfish777.cn/</id>
  
  <author>
    <name>青女</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity日记：存档系统</title>
    <link href="http://flashfish777.cn/posts/a985624f.html"/>
    <id>http://flashfish777.cn/posts/a985624f.html</id>
    <published>2024-07-25T14:00:00.000Z</published>
    <updated>2024-08-20T12:52:45.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在游戏开发的世界中，存档系统是不可或缺的一部分，它让玩家的游戏进度得以保存，增强了游戏的可玩性和用户体验。今天分享一下如何在Unity中实现游戏存档的功能，特别是<strong>PlayerPrefs</strong>和<strong>JSON存档</strong>这两种常见方式，帮助开发者理解它们的适用场景、优缺点以及如何有效使用它们来构建强大的存档机制。</p><p>随着游戏复杂度的提升，存档系统的设计和实现变得尤为重要。合理的存档策略能够显著提升玩家的满意度和忠诚度。然而，Unity自带的PlayerPrefs虽然简单易用，但在处理复杂数据或大量数据时显得力不从心。而JSON作为一种轻量级的数据交换格式，因其易于人阅读和编写，以及良好的跨平台特性，在游戏存档中得到了广泛应用。因此，本文将简单介绍这两种方法，帮助开发者根据项目需求做出最佳选择。</p><p><strong>Unity存档系统的用途</strong>：</p><ul><li><strong>保存游戏进度</strong>：让玩家能够在退出游戏后重新加载之前的游戏状态。</li><li><strong>设置和配置保存</strong>：存储玩家的游戏设置，如音量、难度等。</li><li><strong>成就和解锁内容</strong>：记录玩家的成就和已解锁的内容，作为游戏进度的一部分。</li><li><strong>跨平台同步</strong>：在支持云存档的情况下，实现不同设备间的游戏进度同步。</li></ul><h1 id="PlayerPrefs"><a href="#PlayerPrefs" class="headerlink" title="PlayerPrefs"></a>PlayerPrefs</h1><h2 id="PlayerPrefs存储数据"><a href="#PlayerPrefs存储数据" class="headerlink" title="PlayerPrefs存储数据"></a>PlayerPrefs存储数据</h2><p><code>PlayerPrefs</code>是Unity提供的一个简单的数据持久化系统，用于保存和加载玩家偏好设置和游戏数据。它仅支持存储和检索<code>整型（int）</code>、<code>浮点型（float）</code>和<code>字符串（string）</code>数据。</p><p>Unity的<code>PlayerPrefs</code>是Unity引擎提供的一个用于存储和检索玩家偏好设置和游戏状态数据的简单数据持久化系统。它允许开发者跨会话（即游戏运行之间）保存和加载简单的数据类型，如整型（<code>int</code>）、浮点型（<code>float</code>）和字符串（<code>string</code>）。这些数据通常存储在设备的本地存储中，如注册表（在Windows上）或偏好设置文件（在macOS和iOS上）等，具体取决于目标平台。</p><h2 id="PlayerPrefs的特点"><a href="#PlayerPrefs的特点" class="headerlink" title="PlayerPrefs的特点"></a>PlayerPrefs的特点</h2><ol><li><strong>简单易用</strong>：<code>PlayerPrefs</code> API 非常直观，易于上手。只需几行代码就可以实现数据的保存和加载。</li><li><strong>跨平台</strong>：<code>PlayerPrefs</code> 数据在不同的Unity支持平台上具有高度的可移植性。无论游戏在哪个平台上运行，<code>PlayerPrefs</code> 都能以相同的方式工作。</li><li><strong>限制</strong>：尽管<code>PlayerPrefs</code> 非常方便，但它也有一些限制。首先，它只支持整型、浮点型和字符串数据类型。其次，由于数据存储在一个统一的命名空间中，不同游戏或应用可能会无意中覆盖彼此的<code>PlayerPrefs</code> 数据（尽管这可以通过在键名中包含唯一标识符来避免）。最后，<code>PlayerPrefs</code> 数据的存储量也有限制，虽然这个限制对于大多数用途来说都足够大，但在处理大量数据时可能会成为问题。</li></ol><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>使用简单，无需额外配置。</td><td>数据类型有限，不支持复杂数据结构（如数组、列表、字典等）。</td></tr><tr><td>跨平台兼容性好，适用于大多数Unity支持的平台。</td><td>存储容量有限，不适合存储大量数据。</td></tr><tr><td></td><td>安全性较低，数据容易被用户修改。</td></tr></tbody></table><h2 id="PlayerPrefs的基本用法"><a href="#PlayerPrefs的基本用法" class="headerlink" title="PlayerPrefs的基本用法"></a>PlayerPrefs的基本用法</h2><h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>使用<code>PlayerPrefs.SetInt</code>、<code>PlayerPrefs.SetFloat</code>和<code>PlayerPrefs.SetString</code>等静态方法将数据保存到<code>PlayerPrefs</code>中。调用<code>PlayerPrefs.Save()</code>可以手动保存更改，但通常这不是必需的，因为Unity会在游戏结束时自动保存<code>PlayerPrefs</code>数据。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetInt</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span>; <span class="comment">// key 键 value 值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetFloat</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">float</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.SetInt(<span class="string">&quot;score&quot;</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><h3 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h3><p>使用<code>PlayerPrefs.GetInt</code>、<code>PlayerPrefs.GetFloat</code>和<code>PlayerPrefs.GetString</code>等静态方法从<code>PlayerPrefs</code>中检索数据。这些方法需要一个键名作为参数，并返回与该键名关联的数据。如果指定的键名不存在，则可以提供一个默认值作为第二个参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetInt</span>(<span class="params"><span class="built_in">string</span> key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">GetFloat</span>(<span class="params"><span class="built_in">string</span> key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetString</span>(<span class="params"><span class="built_in">string</span> key</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> highScore = PlayerPrefs.GetInt(<span class="string">&quot;HighScore&quot;</span>, <span class="number">0</span>); <span class="comment">// 如果HighScore不存在，则返回0</span></span><br><span class="line"><span class="built_in">string</span> username = PlayerPrefs.GetString(<span class="string">&quot;Username&quot;</span>, <span class="string">&quot;Guest&quot;</span>); <span class="comment">// 如果Username不存在，则返回&quot;Guest&quot;</span></span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>使用<code>PlayerPrefs.DeleteKey</code>方法可以删除<code>PlayerPrefs</code>中的单个键值对。<code>PlayerPrefs.DeleteAll</code>方法会删除<code>PlayerPrefs</code>中的所有数据。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.DeleteKey(<span class="string">&quot;HighScore&quot;</span>); <span class="comment">// 删除HighScore键值对</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">PlayerPrefs.DeleteAll(); <span class="comment">// 删除所有PlayerPrefs数据，慎用！</span></span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerData</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> playerName; <span class="comment">// 角色名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> playerHealth; <span class="comment">// 角色血量</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 playerPosition; <span class="comment">// 角色位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Score; <span class="comment">// 得分</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        LoadFromPlayerPrefs(); <span class="comment">// 游戏开始时加载调用存储的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当保存并退出按钮被触发时执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveAndBack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        SaveByPlayerPrefs(); <span class="comment">// 保存数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveByPlayerPrefs</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PlayerPrefs.SetString(<span class="string">&quot;PlayerName&quot;</span>, playerName);</span><br><span class="line">        PlayerPrefs.SetFloat(<span class="string">&quot;PlayerHealth&quot;</span>, playerHealth);</span><br><span class="line">        PlayerPrefs.Setint(<span class="string">&quot;Score&quot;</span>, Score);</span><br><span class="line">        PlayerPrefs.SetFloat(<span class="string">&quot;PlayerPo_x&quot;</span>, playerPosition.x);</span><br><span class="line">        PlayerPrefs.SetFloat(<span class="string">&quot;PlayerPo_y&quot;</span>, playerPosition.y);</span><br><span class="line">        PlayerPrefs.SetFloat(<span class="string">&quot;PlayerPo_z&quot;</span>, playerPosition.z);</span><br><span class="line">        PlayerPrefs.Save();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadFromPlayerPrefs</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        playerName = PlayerPrefs.GetString(<span class="string">&quot;PlayerName&quot;</span>, <span class="string">&quot;None&quot;</span>);</span><br><span class="line">        playerHealth = PlayerPrefs.GetFloat(<span class="string">&quot;PlayerHealth&quot;</span>, <span class="number">100f</span>);</span><br><span class="line">        Score = PlayerPrefs.Getint(<span class="string">&quot;Score&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        playerPosition = <span class="keyword">new</span>(PlayerPrefs.GetFloat(<span class="string">&quot;PlayerPo_x&quot;</span>, <span class="number">0f</span>),</span><br><span class="line">                             PlayerPrefs.GetFloat(<span class="string">&quot;PlayerPo_y&quot;</span>, <span class="number">0f</span>), </span><br><span class="line">                             PlayerPrefs.GetFloat(<span class="string">&quot;PlayerPo_z&quot;</span>, <span class="number">0f</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>由于<code>PlayerPrefs</code>数据存储在设备的本地存储中，因此它可能受到设备存储空间或用户隐私设置的影响。</li><li>在使用<code>PlayerPrefs</code>时，建议为键名添加前缀或后缀，以确保它们在不同游戏或应用之间保持唯一性。</li><li>虽然<code>PlayerPrefs</code>提供了基本的数据持久化功能，但对于需要处理复杂数据结构或大量数据的游戏来说，可能需要考虑使用更高级的数据存储解决方案，如数据库或文件系统。</li></ul><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p><strong>PlayerPrefs适合用来存储暂时性数据，如：</strong></p><ul><li>玩家设定偏好</li><li>简单的数据</li><li>游戏原型制作时暂时的存储方案</li></ul><mark class="hl-label orange">总之，PlayerPrefs设计的初衷就不是为了真正的玩家存档而服务的，但它有其存在的理由，如何使用好这个工具，才是我们作为游戏制作者应该掌握的关键。</mark> <p><strong>相关资料 -&gt;</strong> <a href="https://docs.unity3d.com/ScriptReference/PlayerPrefs.html">https://docs.unity3d.com/ScriptReference/PlayerPrefs.html</a></p><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p><code>JSON</code>是<code>JavaScript Object Notation（JavaScript对象注释/表示法）</code>的简称，是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成。在Unity中，我们可以通过序列化&#x2F;反序列化对象到JSON字符串的方式来实现存档功能。</p><p><strong>参考资料 -&gt;</strong> <a href="https://www.json.org/json-zh.html">https://www.json.org/json-zh.html</a></p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>JSON是一种基于文本的格式，用于表示数据。它使用键值对来表示对象，使用数组来表示一组值。例如，一个表示玩家的JSON对象可能如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;gold&quot;</span><span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;equipment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;剑&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;武器&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;盾&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;防具&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>支持复杂数据结构，如数组、列表、字典等。</li><li>数据量大小无限制（受限于系统存储空间）。</li><li>安全性较高，可通过加密等手段保护数据。</li><li>跨平台兼容性好，JSON是标准的文本格式，易于在不同平台间交换数据。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>需要编写额外的序列化&#x2F;反序列化代码。</li><li>相对于PlayerPrefs，使用上稍显复杂。</li></ul><h3 id="与PlayerPrefs对比"><a href="#与PlayerPrefs对比" class="headerlink" title="与PlayerPrefs对比"></a>与PlayerPrefs对比</h3><ul><li>JSON更适合存储复杂数据结构和大量数据。</li><li>JSON提供了更高的灵活性和可扩展性。</li><li>在处理简单数据类型和少量数据时，PlayerPrefs可能更便捷。</li></ul><h2 id="JsonUtility"><a href="#JsonUtility" class="headerlink" title="JsonUtility"></a>JsonUtility</h2><p>在Unity中，要将对象保存为JSON字符串，需要对其进行序列化；同样，要从JSON字符串恢复对象，需要对其进行反序列化。Unity提供了<code>JsonUtility</code>类来简化这一过程。</p><ul><li><strong>序列化</strong>：使用<code>JsonUtility.ToJson()</code>方法将对象转换为JSON字符串。</li><li><strong>反序列化</strong>：使用<code>JsonUtility.FromJson&lt;T&gt;()</code>方法将JSON字符串转换回对象。</li></ul><p><img src="https://s2.loli.net/2024/08/15/83eOAQ2m7DMXdyb.png"></p><h2 id="使用JsonUtility进行存档"><a href="#使用JsonUtility进行存档" class="headerlink" title="使用JsonUtility进行存档"></a>使用JsonUtility进行存档</h2><h3 id="定义可序列化的类"><a href="#定义可序列化的类" class="headerlink" title="定义可序列化的类"></a>定义可序列化的类</h3><p>在Unity中，只有标记为<code>[Serializable]</code>的类才能被<code>JsonUtility</code>序列化。因此，需要为要存档的数据定义可序列化的类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> level;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> gold;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Equipment&gt; equipment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Equipment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意，并不是所有数据都可以被正常的序列化：</p><p><img src="https://s2.loli.net/2024/08/15/z9n16XI3uceahAG.jpg"></p><p><img src="https://s2.loli.net/2024/08/15/P9NeZ53baFxLzRI.jpg"></p><p><img src="https://s2.loli.net/2024/08/15/McJIefSvCxDOnRz.jpg"></p><h3 id="序列化并保存数据"><a href="#序列化并保存数据" class="headerlink" title="序列化并保存数据"></a>序列化并保存数据</h3><p>在Unity中，可以通过以下步骤将<code>PlayerData</code>对象序列化为JSON字符串，并保存到文件中：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SavePlayerData</span>(<span class="params">PlayerData playerData, <span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将数据序列化</span></span><br><span class="line">    <span class="built_in">string</span> json = JsonUtility.ToJson(playerData);</span><br><span class="line">    <span class="comment">// 获取存储文件地址</span></span><br><span class="line">    <span class="built_in">string</span> filePath = Path.Combine(Application.persistentDataPath, fileName + <span class="string">&quot;.json&quot;</span>);</span><br><span class="line">    <span class="comment">// 将JSON写入文件中</span></span><br><span class="line">    File.WriteAllText(filePath, json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取并反序列化数据"><a href="#读取并反序列化数据" class="headerlink" title="读取并反序列化数据"></a>读取并反序列化数据</h3><p>当需要加载存档时，可以从文件中读取JSON字符串，并使用<code>JsonUtility.FromJson&lt;T&gt;()</code>方法将其反序列化为<code>PlayerData</code>对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PlayerData <span class="title">LoadPlayerData</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取存储文件地址</span></span><br><span class="line">    <span class="built_in">string</span> filePath = Path.Combine(Application.persistentDataPath, fileName + <span class="string">&quot;.json&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断是否有对应文件</span></span><br><span class="line">    <span class="keyword">if</span> (File.Exists(filePath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取JSON字符串</span></span><br><span class="line">        <span class="built_in">string</span> json = File.ReadAllText(filePath);</span><br><span class="line">        <span class="comment">// 将JSON反序列化</span></span><br><span class="line">        PlayerData playerData = JsonUtility.FromJson&lt;PlayerData&gt;(json);</span><br><span class="line">        <span class="keyword">return</span> playerData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有文件打印提示</span></span><br><span class="line">        Debug.LogError(<span class="string">$&quot;File <span class="subst">&#123;filePath&#125;</span> not found!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>首先创建一个公有的静态类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SaveSystemTutorial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SaveSystem</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 存档</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveByJson</span>(<span class="params"><span class="built_in">string</span> saveFileName, <span class="built_in">object</span> data</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> json = JsonUtility.ToJson(data);</span><br><span class="line">            <span class="keyword">var</span> path = Path.Combine(Application.persistentDataPath, saveFileName);</span><br><span class="line">            <span class="comment">/* Application.persistentDataPath用来提供一个存储永久数据的路径，并且</span></span><br><span class="line"><span class="comment">             当我们将游戏打包发布在不同平台上时，这个路径会随着我们发布的平台自动变更 */</span></span><br><span class="line">            </span><br><span class="line">            Debug.Log(<span class="string">$&quot;save data to <span class="subst">&#123;path&#125;</span>.&quot;</span>); <span class="comment">// 这里我们可以输出这个路径找到文件</span></span><br><span class="line"></span><br><span class="line">            File.WriteAllText(path, json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读档</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">LoadFromJson</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> saveFileName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> path = Path.Combine(Application.persistentDataPath, saveFileName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> json = File.ReadAllText(path);</span><br><span class="line">            <span class="keyword">var</span> data = JsonUtility.FromJson&lt;T&gt;(json);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteSaveFile</span>(<span class="params"><span class="built_in">string</span> saveFileName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> path = Path.Combine(Application.persistentDataPath, saveFileName);</span><br><span class="line"></span><br><span class="line">            File.Delete(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再其他脚本中使用<code>SaveSystemTutorial</code>命名空间并实现存储数据函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> SaveSystemTutorial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> name; <span class="comment">// 角色名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> health; <span class="comment">// 角色血量</span></span><br><span class="line">   <span class="keyword">public</span> Vector3 position; <span class="comment">// 角色位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> score; <span class="comment">// 得分</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;GameObject&gt; enermy; <span class="comment">// 敌人列表</span></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">System.Serializable</span>]</span><br><span class="line">    <span class="keyword">class</span> <span class="title">SaveData</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> playerName; <span class="comment">// 角色名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> playerHealth; <span class="comment">// 角色血量</span></span><br><span class="line">   <span class="keyword">public</span> Vector3 playerPosition; <span class="comment">// 角色位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Score; <span class="comment">// 得分</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;GameObject&gt; Enermy; <span class="comment">// 敌人列表</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveAndBack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SaveData data = <span class="keyword">new</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            playerName = name;</span><br><span class="line">    playerHealth = health;</span><br><span class="line">   playerPosition = position;</span><br><span class="line">    Score = score;</span><br><span class="line">        Enermy = enermy;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        SaveSystem.SaveByJson(<span class="string">&quot;player.save&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadData</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取文件地址判断文件是否存在</span></span><br><span class="line">        <span class="keyword">var</span> Path = Application.persistentDataPath + <span class="string">&quot;\\player.save&quot;</span>;</span><br><span class="line">        SaveData data;</span><br><span class="line">        <span class="keyword">if</span> (File.Exists(HistoryPath))</span><br><span class="line">        &#123;</span><br><span class="line">            data = SaveSystem.LoadFromJson&lt;SaveData&gt;(<span class="string">&quot;player.save&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将数据赋回</span></span><br><span class="line">        name = data.playerName;</span><br><span class="line">        health = data.playerHealth;</span><br><span class="line">        position = data.playerPosition;</span><br><span class="line">        score = data.Score;</span><br><span class="line">        enermy = data.Enermy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> Debug.Log(<span class="string">&quot;Not Found!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后通过输出的文件路径就可以找到我们的存档啦：</p><p><img src="https://s2.loli.net/2024/08/15/pKWsrT2CBDm6Py4.png"></p><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><strong>数据安全性</strong>：直接以明文形式保存JSON文件可能会带来数据泄露的风险。在需要保护用户数据的情况下，应考虑对JSON数据进行加密。</li><li><strong>跨平台兼容性</strong>：<code>Application.persistentDataPath</code>会自动处理不同平台上的文件路径差异，使得存档系统能够跨平台工作。</li><li><strong>性能考虑</strong>：对于大型游戏或频繁存档的场景，需要关注序列化&#x2F;反序列化操作对性能的影响。</li><li><strong>错误处理</strong>：在文件读写过程中，应添加适当的错误处理逻辑，以应对文件不存在、磁盘空间不足等异常情况。</li></ol><h2 id="使用JSON文件而不是PlayerPrefs的原因"><a href="#使用JSON文件而不是PlayerPrefs的原因" class="headerlink" title="使用JSON文件而不是PlayerPrefs的原因"></a>使用JSON文件而不是PlayerPrefs的原因</h2><p>前面提到过<strong>PlayerPrefs</strong>可以存储字符串类型的数据，而JSON数据实际上就是字符串，所以PlayerPrefs实际上也可以存储JSON数据。</p><p>不建议用PlayerPrefs存JSON的原因主要有以下几点：</p><h3 id="存储效率与灵活性"><a href="#存储效率与灵活性" class="headerlink" title="存储效率与灵活性"></a>存储效率与灵活性</h3><p>PlayerPrefs的存储方式相对简单直接，但这也限制了其存储效率和灵活性。当需要存储大量数据时，PlayerPrefs可能会因为频繁地读写磁盘而导致性能下降。此外，由于PlayerPrefs只支持简单的数据类型，因此在处理复杂数据结构时，往往需要将数据转换为字符串进行存储，这在读取时又需要反序列化回原始数据结构，增加了额外的处理步骤和可能的性能开销。相比之下，直接使用JSON文件或其他数据库系统存储复杂数据，可以更加高效和灵活地管理数据。</p><h3 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h3><p>虽然PlayerPrefs本身在数据安全方面并没有直接的漏洞，但由于其存储的数据类型简单且易于访问，因此如果游戏或应用程序中涉及敏感信息（如用户密码、支付信息等），则不建议使用PlayerPrefs进行存储。此外，由于PlayerPrefs的数据通常存储在用户设备的文件系统中，因此如果设备被恶意软件攻击或用户拥有足够的权限，那么存储在PlayerPrefs中的数据就有可能被非法读取或篡改。对于需要保护用户数据安全的场景，建议使用更加安全的数据存储方案。</p><h3 id="可扩展性和可维护性"><a href="#可扩展性和可维护性" class="headerlink" title="可扩展性和可维护性"></a>可扩展性和可维护性</h3><p>随着游戏或应用程序的不断发展，可能需要存储的数据量也会不断增加，数据结构也会变得更加复杂。如果一直使用PlayerPrefs来存储这些数据，那么随着数据的增加和数据结构的复杂化，代码的可读性、可维护性和可扩展性都会受到影响。相比之下，使用JSON文件或其他数据库系统来存储数据，可以更加方便地管理数据结构和数据变更，提高代码的可读性、可维护性和可扩展性。</p><p>所以，虽然PlayerPrefs在存储简单数据方面具有一定的优势，但在需要处理复杂数据结构、大量数据或敏感信息时，建议使用更加高效、灵活和安全的数据存储方案。对于JSON数据的存储和读取，建议使用Unity内置的JsonUtility类或其他第三方JSON库来实现序列化和反序列化操作，并将数据存储在文件系统或数据库中以便后续管理和使用。</p><h2 id="适用范围-1"><a href="#适用范围-1" class="headerlink" title="适用范围"></a>适用范围</h2><p><strong>联网</strong></p><ul><li>优秀的网络数据交换载体</li><li>云存档</li></ul><p><strong>本地存储</strong></p><ul><li>非敏感而需要大量读取的数据，如：Mod数据</li><li>玩家的偏好设置等</li></ul><p><strong>相关资料 -&gt;</strong> <a href="https://docs.unity3d.com/ScriptReference/JsonUtility.html">https://docs.unity3d.com/ScriptReference/JsonUtility.html</a></p><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>通过本文章的介绍，我们深入了解了Unity中的两种主要存档方式——PlayerPrefs和JSON存档。每种方法都有其独特的优势和适用场景。开发者应根据项目的具体需求、数据复杂度以及目标平台的特性来选择最合适的存档策略。无论是追求简单快捷的PlayerPrefs，还是注重数据复杂性和安全性的JSON存档，都能在Unity中找到实现方法，为玩家带来更加流畅和丰富的游戏体验。</p><p>—end—</p>]]></content>
    
    
    <summary type="html">一个完美的存档系统对一款小游戏来说无异于是一种锦上添花的存在，本文将介绍关于Unity PlayerPrefs和JSON存档的实现，以及它们的优缺点。</summary>
    
    
    
    <category term="Unity" scheme="http://flashfish777.cn/categories/Unity/"/>
    
    <category term="开发日记" scheme="http://flashfish777.cn/categories/Unity/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Unity" scheme="http://flashfish777.cn/tags/Unity/"/>
    
    <category term="C#" scheme="http://flashfish777.cn/tags/C/"/>
    
    <category term="JSON存档" scheme="http://flashfish777.cn/tags/JSON%E5%AD%98%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Unity日记：场景切换与并发编程</title>
    <link href="http://flashfish777.cn/posts/fdbe57b8.html"/>
    <id>http://flashfish777.cn/posts/fdbe57b8.html</id>
    <published>2024-07-10T14:00:00.000Z</published>
    <updated>2024-08-20T12:52:32.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity场景切换"><a href="#Unity场景切换" class="headerlink" title="Unity场景切换"></a>Unity场景切换</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在游戏开发中，场景切换，这一看似简单的操作，实则蕴含着提升游戏体验、增强故事叙述能力的无限潜力。今天，就让我们一同踏上这场Unity中场景切换的魔法之旅，揭开那些让游戏世界流畅衔接、引人入胜的秘密。</p><p>在快节奏的游戏开发中，场景切换往往被视为一个“必经之路”，而非核心功能。然而，正是这些看似不起眼的环节，构成了玩家游戏体验的重要组成部分。一个精心设计的场景切换不仅能有效减少加载时间带来的等待感，还能通过视觉和情感的引导，加深玩家对游戏世界的沉浸感。更重要的是，它还能作为游戏叙事的一部分，引导玩家逐步揭开故事的真相，体验更加丰富和深刻的游戏内容。想象一下，你的玩家正在紧张刺激的战斗后，通过一段华丽的过渡动画，瞬间穿越到宁静祥和的村庄；或者是在解开谜题后，随着一阵悠扬的音乐，眼前的景象逐渐模糊，再清晰时已是另一个充满挑战的关卡。这样的场景切换，不仅让玩家感受到游戏的连贯性和惊喜，更激发了他们对未知世界的好奇心和探索欲。而这，正是我们今天要探讨的——如何在Unity中利用场景切换的魔法，为你的游戏增添无限魅力。</p><p>撰写一篇关于在Unity中进行场景切换的博客文章是一个很好的主意，因为这对于开发任何类型的游戏或应用来说都是一项基础且重要的技能。以下是一个结构化的博客文章大纲，以及一些关键内容的建议，帮助你撰写这篇博客。</p><h2 id="什么是场景（Scene）？"><a href="#什么是场景（Scene）？" class="headerlink" title="什么是场景（Scene）？"></a>什么是场景（Scene）？</h2><p>在Unity中，<strong>场景（Scene）</strong>是构建游戏世界的基石。所有GameObject都在场景中，它包含了游戏运行时所需的所有元素，如3D模型、灯光、摄像机、UI界面、音效以及脚本逻辑等。每个场景都代表了一个独立的游戏环境或关卡，玩家在其中进行互动和探索。Unity编辑器提供了直观的工具来创建、编辑和管理多个场景。开发者可以轻松地添加、删除或修改场景中的元素，并通过场景管理器来组织和管理这些场景文件。游戏通常由多个场景组成，这些场景通过场景切换相互连接，共同构成了完整的游戏流程。场景切换不仅是技术上的实现，更是游戏叙事和玩家体验的重要组成部分。</p><p><img src="https://s2.loli.net/2024/08/14/xEsImaKgpVlbftw.png"></p><h2 id="如何切换场景"><a href="#如何切换场景" class="headerlink" title="如何切换场景"></a>如何切换场景</h2><h3 id="SceneManager类"><a href="#SceneManager类" class="headerlink" title="SceneManager类"></a>SceneManager类</h3><p><code>SceneManager</code>是Unity提供的一个用于<strong>管理场景加载、卸载和切换</strong>的类。它提供了丰富的API来支持场景的各种操作。</p><p>1.首先打开菜单栏的<code>File</code>-&gt; <code>Build Settings</code>，确保你的场景已经添加到这里，记住对应场景的序号。</p><p><img src="https://s2.loli.net/2024/08/14/4uz5WVoXSaGmUYP.png"></p><p>2.<code>SceneManager</code>类提供了<code>SceneManager.LoadScene</code>方法实现场景的加载与切换，以下是代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;  </span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement; <span class="comment">// 确保使用了UnityEngine.SceneManagement命名空间</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneSwitcher</span> : <span class="title">MonoBehaviour</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 场景切换函数，该函数可以通过按钮或在任何需要的情况下被调用，实现场景转换  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SceneChange</span>()</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 使用SceneManager的LoadScene方法来加载新场景  </span></span><br><span class="line">        <span class="comment">// 第一个参数是场景名称</span></span><br><span class="line">        <span class="comment">// 第二个参数是加载模式</span></span><br><span class="line">        SceneManager.LoadScene(<span class="string">&quot;nextScene&quot;</span>, LoadSceneMode.Single);</span><br><span class="line">        <span class="comment">// SceneManager.LoadScene(1); // 第一个参数可直接使用场景名称，也可使用对应的场景序号</span></span><br><span class="line">        <span class="comment">// 无论使用的是场景名称还是序号，场景都必须要被添加在Build中</span></span><br><span class="line">        <span class="comment">// 第二个参数一般情况下省略</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.函数被调用时，游戏会<strong>暂停当前场景的所有操作</strong>，等待新场景完全加载到内存中并激活后，再继续执行后续操作。这个过程是<strong>阻塞的</strong>，即<strong>直到新场景加载完成，游戏才会继续运行</strong>。这个过程，也被称为同步加载。</p><h3 id="同步加载"><a href="#同步加载" class="headerlink" title="同步加载"></a>同步加载</h3><p><strong>过程：</strong></p><ol><li><strong>触发加载</strong>：通过调用场景加载的方法，并传入要加载的场景名称或索引作为参数，来触发场景的加载过程。</li><li><strong>等待加载</strong>：在加载过程中，游戏会暂停当前场景的所有操作（如渲染、物理计算、用户输入响应等），直到新场景完全加载到内存中。</li><li><strong>场景切换</strong>：当新场景加载完成后，Unity会销毁当前场景（如果加载模式为Single），并激活新场景，然后游戏继续执行后续操作。</li></ol><p>可如果我们的目标场景数据十分庞大呢？这意味着我们在<strong>等待加载</strong>的过程中就会出现我们都遇到过的事情，那就是卡顿。我们需要等很长时间来加载目标场景的数据。这时如果我们使用同步加载，在这期间游戏处于暂停中，玩家很可能以为自己卡了，大大降低体验度。<strong>使用异步加载就可以解决这个问题。</strong></p><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p><strong>异步加载</strong>中加载新场景的行为是在<strong>后台线程</strong>中进行的，不影响主线程（即游戏当前场景）的运行。它的过程为<code>触发加载</code> -&gt; <code>后台加载</code> -&gt;  <code>场景切换</code> </p><p>使用了异步加载，我们就可以在等待加载的过程中播放一些其他操作，如待机画面、加载进度条等。</p><p>以下是使用异步加载进行场景切换并添加加载进度条与点击继续的操作示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;  </span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI; <span class="comment">// 引用UI相关命名空间</span></span><br><span class="line"><span class="keyword">using</span> TMPro;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneLoader</span> : <span class="title">MonoBehaviour</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> GameObject loadScreen; <span class="comment">// 加载界面Panel</span></span><br><span class="line">    <span class="keyword">public</span> Slider slider; <span class="comment">// 加载界面进度条</span></span><br><span class="line">    <span class="keyword">public</span> TextMeshProUGUI text; <span class="comment">// 进度文本</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadScene</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(Loadlevel()); <span class="comment">// 使用协程</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 异步加载场景，控制进度条</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Loadlevel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        loadScreen.SetActive(<span class="literal">true</span>); <span class="comment">// 显示加载界面</span></span><br><span class="line"></span><br><span class="line">        AsyncOperation operation = SceneManager.LoadSceneAsync(<span class="string">&quot;MainScene&quot;</span>);</span><br><span class="line">        <span class="comment">// SceneManager.LoadSceneAsync方法返回一个AsyncOperation对象，</span></span><br><span class="line">        <span class="comment">// 在加载过程中，你可以通过返回的AsyncOperation对象来获取加载进度、检查是否加载完成等。</span></span><br><span class="line"></span><br><span class="line">        operation.allowSceneActivation = <span class="literal">false</span>; <span class="comment">// 默认加载完成不切换场景</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!operation.isDone)</span><br><span class="line">        &#123;</span><br><span class="line">            slider.<span class="keyword">value</span> = operation.progress; <span class="comment">// 让进度条的值等于加载进度（slider与加载进度的值都是0~1的浮点数）</span></span><br><span class="line"></span><br><span class="line">            text.text = (<span class="built_in">int</span>)(operation.progress * <span class="number">100</span>) + <span class="string">&quot;%&quot;</span>; <span class="comment">// 显示加载进度百分数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (operation.progress &gt;= <span class="number">0.9f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                slider.<span class="keyword">value</span> = <span class="number">1</span>; <span class="comment">// 场景加载完成后，progress返回的值不是1，所以要单独设定进度条的值</span></span><br><span class="line">                text.text = <span class="string">&quot;点击任意位置继续&quot;</span>; <span class="comment">// 加载完成后百分比进度变为提示</span></span><br><span class="line">                <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    operation.allowSceneActivation = <span class="literal">true</span>; <span class="comment">// 切换场景</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了很大型的游戏项目之外，大部分情况下，场景的加载总是一瞬间完成的，如果仍然想要做出像大型游戏加载那样的加载界面效果，可以尝试使用异步加载制作伪加载进度条，即进度条的进度与播放时间由开发者设定，实际上与加载时间无关，实现过渡界面的效果。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table><thead><tr><th></th><th>同步加载</th><th>异步加载</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>加载新场景时，游戏会暂停当前场景的所有操作，等待新场景完全加载并激活后继续执行。</td><td>加载新场景的行为是在后台线程中进行的，不影响主线程（即游戏当前场景）的运行。</td></tr><tr><td><strong>过程</strong></td><td>1. 触发加载<br>2. 等待加载（游戏暂停）<br>3. 场景切换（加载完成后继续）</td><td>1. 触发加载<br>2. 后台加载（游戏继续运行）<br>3. 场景切换（加载完成后通过回调或检查状态继续）</td></tr></tbody></table><p><strong>对游戏流畅度的影响</strong>：</p><ul><li><strong>同步加载</strong>：由于加载过程中游戏会暂停，因此当加载的场景较大或资源较多时，会导致明显的卡顿或延迟，影响用户体验。</li><li><strong>异步加载</strong>：加载过程在后台进行，不影响游戏当前场景的运行，因此即使加载大型场景也不会造成游戏卡顿，提升了游戏的流畅度和用户体验。</li></ul><p><strong>使用场景</strong>：</p><ul><li><strong>同步加载</strong>：适用于场景较小、资源较少，或对加载时间要求不高的场合。</li><li><strong>异步加载</strong>：更适用于场景较大、资源较多，或对加载时间有较高要求的场合，如制作场景切换过程中的过渡界面、实现无缝加载等。</li></ul><p><strong>实现方式</strong>：</p><ul><li><strong>同步加载</strong>：直接调用加载场景的方法，并等待加载完成。</li><li><strong>异步加载</strong>：调用加载场景的方法时，需要处理返回的异步对象（如<code>AsyncOperation</code>），以便在加载过程中进行进度监控、加载完成后的回调等。</li></ul><p>同步加载和异步加载在Unity中各有其适用场景和优缺点。在实际开发中，应根据游戏的具体需求和资源情况来选择合适的加载方式。</p><h2 id="场景间的数据传递"><a href="#场景间的数据传递" class="headerlink" title="场景间的数据传递"></a>场景间的数据传递</h2><ul><li><strong>全局变量</strong>：使用静态类或单例模式存储全局数据，以便在不同场景之间共享信息。</li><li><strong>PlayerPrefs</strong>：适用于存储少量非敏感数据，如玩家设置。 <a class="btn-beautify green larger" href="/posts/a985624f.html#PlayerPrefs"   title="Unity日记：存档系统-PlayerPrefs"><i class="far fa-hand-point-right"></i><span>Unity日记：存档系统-PlayerPrefs</span></a></li><li><strong>SceneManager的<code>DontDestroyOnLoad</code>方法</strong>：用于在场景切换时保留某些对象，如游戏管理器或UI系统。</li></ul><hr><h1 id="关于并发编程"><a href="#关于并发编程" class="headerlink" title="关于并发编程"></a>关于并发编程</h1><p>在Unity中，我们刚刚探讨了场景切换的两种方式：同步加载与异步加载。特别是异步加载，通过<code>SceneManager.LoadSceneAsync</code>方法，我们能够在<strong>不阻塞主线程</strong>的情况下加载新场景，这种非阻塞的特性极大地提升了游戏的流畅度和用户体验。而实现这种异步加载背后，Unity的<code>协程（Coroutine）</code>机制扮演了至关重要的角色。<strong>协程</strong>允许我们在Unity的主线程上<strong>“伪并行”</strong>地执行代码块，每个协程在每次迭代后都会暂停，直到下一次主线程循环中再次被唤醒。这种机制虽然并非传统意义上的并行处理，但它有效地利用了Unity的单一更新循环，模拟了并发执行的效果。</p><p>那么，当我们谈论到并发编程时，我们实际上是在探讨如何在多个处理单元（如CPU核心）上同时执行多个任务，以充分利用硬件资源，提高程序的整体执行效率。在Unity这样的游戏开发环境中，并发编程不仅限于简单的协程使用，它还包括多线程编程、任务并行库（TPL）的使用（在Unity中不直接支持，但可通过C#的<code>System.Threading</code>和<code>System.Threading.Tasks</code>命名空间实现跨平台兼容性处理）、以及针对特定硬件优化的并行计算API（如Compute Shaders、Job System和Burst Compiler等Unity 2018及以后版本中引入的高级功能）。</p><p>从异步加载和协程的视角过渡到并发编程，我们可以理解为：<strong>协程为我们提供了一种在游戏主循环内管理复杂流程和异步操作的有效方式，而并发编程则是将这种思想扩展到了更广泛的层面，即跨越多个处理单元来并行执行多个任务。</strong>在Unity中，合理利用并发编程技术，可以显著减少游戏运行时的延迟，提升游戏性能，特别是在处理大量数据计算、物理模拟、AI决策等计算密集型任务时。</p><p>然而，并发编程也伴随着复杂性增加和潜在的资源竞争、死锁等问题。因此，在设计并发系统时，开发者需要仔细规划任务之间的依赖关系，合理使用同步机制，确保数据的一致性和系统的稳定性。在Unity的上下文中，这意味着要深入理解<a href="https://blog.csdn.net/xiaoyaoACi/article/details/119324146?spm=1001.2014.3001.5502">Unity的生命周期</a>、线程安全以及如何利用Unity提供的并发工具和最佳实践来优化游戏性能。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>并发编程</strong>是一种程序设计方法，‌它由若干个可同时执行的程序模块组成，‌这些模块被称为进程。‌这些进程可以同时在多台处理器上并行执行，‌也可以在一台处理器上交替执行。‌采用并发程序设计可以使外围设备和处理器并行工作，‌从而缩短程序执行时间，‌提高计算机系统效率。‌</p><p>在并发编程中，‌有几个核心概念需要理解：‌</p><ul><li><strong>进程与线程</strong>：‌进程是执行过程中分配和管理资源的基本单位，‌而线程是进程的一个执行单元，‌是进程内可调度的实体。‌线程也可以被称为轻量级进程，‌它是比进程更小的独立运行的基本单位。‌多个线程可以存在于一个进程中，‌并发执行并共享资源（‌如内存）‌，‌而不同的进程不共享这些资源。‌</li><li><strong>同步和异步</strong>：‌同步和异步通常用来形容一次方法调用。‌同步方法调用需要调用者等待方法调用返回后才能继续后续的行为，‌而异步方法调用一旦开始，‌方法调用就会立即返回，‌允许调用者继续执行其他操作，‌而异步方法在另一个线程中“真实”地执行。</li><li><strong>并发和并行</strong>：‌并发和并行都可以用来表示两个或多个任务一起执行，‌但侧重点不同。‌并发强调任务可以交替执行，‌而并行则强调真正的同时执行。‌在单核CPU下，‌通过任务调度器将CPU的时间片分配给不同的程序使用，‌由于CPU在时间片之间快速切换，‌人类感觉是同时运行的，‌这被称为并发。‌而在多核CPU下，‌多个核心可以同时处理多个线程，‌这才是真正的并行执行。</li><li><strong>临界区</strong>：‌临界区通常指共享数据，‌可以被多个线程使用。‌当有线程进入临界区时，‌其他线程或进程必须等待。‌例如，‌当一个线程正在修改共享变量时，‌其他试图访问该变量的线程必须等待直到第一个线程完成操作。‌</li></ul><h2 id="进程、线程与协程的关系"><a href="#进程、线程与协程的关系" class="headerlink" title="进程、线程与协程的关系"></a>进程、线程与协程的关系</h2><p><img src="https://s2.loli.net/2024/08/14/odIJbpK9kVWCFjB.png" alt="进程、线程与协程的关系"></p><p>线程和协程都是进程的子集，一个进程可以有多个协程，一线程也可以有多个协程，进程基于程序主体。</p><p><strong>IO密集型一般使用多线程或多进程</strong>。<strong>CPU密集型一般使用多进程</strong>。<strong>强调非阻塞异步并发的一般都用协程</strong>。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是系统分配资源和调度资源的一个独立单位，<strong>每个进程都有自己的独立内存空间</strong>，<strong>不同进程间可以进行进程间通信</strong>。进程<strong>重量级比较大</strong>，占据独立内存，上下文进程间的切换开销（栈寄存器、虚拟内存、文件句柄）比较大，但相对稳定安全。进程的上级为操作系统，有自己固定的堆栈。</p><p><strong>进程间通信（IPC）</strong></p><ul><li><strong>管道（Pipe）</strong>：管道是Unix中最古老的进程间通信的形式，我们把从一个进程连接到另一个进程的一个数据流称为一个“管道”。其本质是内核中固定大小的缓冲区。</li><li><strong>命名管道（Named Pipes）</strong>：“命名管道”又名“命名管线”（Named Pipes），命名管道支持可靠的、单向或双向的数据通信。不同于匿名管道的是：命名管道可以在不相关的进程之间和不同计算机之间使用，服务器建立命名管道时给它指定一个名字，任何进程都可以通过该名字打开管道的另一端，根据给定的权限和服务器进程通信。</li><li><strong>消息队列（MQ，Message Quene）</strong>：消息队列用于在进程间通信的过程中将消息按照队列存储起来，常见的MQ有ActiveMQ、RocketMQ、RabbitMQ、Kafka等。</li><li><strong>信号量（Semaphore）</strong>：有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前,线程必须获取一个信号量。</li><li><strong>共享内存（Share Memory）</strong>：共享内存是三个IPC机制中的一个。它允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在进行的进程之间传递数据的一种非常有效的方式。</li><li><strong>套接字（Socket）</strong>：就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。</li></ul><p>对于游戏开发者来说，最为常用的无疑是Socket，这是长连接网络游戏的核心。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程也被称为轻量级进程，是<strong>操作系统调度（CPU调度）执行的最小单位</strong>，是进程的子集。</p><p>线程<strong>本身基本不拥有资源</strong>，而是访问隶属于进程的资源，一个进程拥有至少一个或多个线程，<strong>线程间共享进程的地址空间</strong>。</p><p>由于<strong>线程是阻塞式</strong>的，如果想要同步执行IO，每个IO都必须开启一个新线程，<strong>多线程开销较大</strong>，适合多任务处理，进程崩溃不影响其他进程，而线程只是一个进程的不同执行路线。</p><p><strong>线程有自己的堆栈</strong>，却<strong>没有单独的地址空间</strong>，<strong>进程死就等于所有线程死</strong>，所以多进程要比多线程健壮。但在进程切换时，消耗资源较大，效率较差。</p><p>线程是并发的，且是阻塞式同步的，一旦资源死锁，线程将陷入混乱。在同步线程的执行过程中，<strong>线程的执行切换是由CPU轮转时间片的分配来决定的</strong>。</p><p><img src="https://s2.loli.net/2024/08/14/KeRThSdJEPGpFYy.png" alt="线程状态图"></p><ul><li>新建状态：new创建一个线程时，还没开始运行，就是新建状态。</li><li>就绪状态：新建后，调用start()方法，线程就处于就绪态，等待CPU调度。</li><li>运行状态：当线程获得了CPU时间后，进入运行状态，执行run()里的内容</li><li>阻塞状态：线程运行中随时可能被阻塞：比如调用sleep()方法；等待获取锁被阻塞；线程在等待其他触发条件。暂时让出CPU资源。</li><li>死亡状态：有两个原因导致线程死亡：run()方法正常结束；一个未捕获的异常终止了run()方法</li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><strong>Unity 中所有脚本运行公用一条主线程，而协程是开辟的伪线程。这个伪线程可以让一个方法分多次执行，相当于让主线程劈几个叉。</strong></p><p>协程还称微线程，纤程，<strong>本质是一个单线程</strong>。<strong>协程是比线程更轻量级的存在</strong>，协程<strong>不由操作系统内核所管理</strong>，而是完全由程序所控制（也就是在<strong>用户态执行</strong>）。</p><p>协程的好处是性能大幅提升，不会像线程切换那样消耗资源。同一时间只能执行某个协程，开辟<strong>多个协程开销不大</strong>。<strong>适合对任务进行分时处理</strong>。</p><p><strong>协程有自己的寄存器和上下文栈</strong>。协程调度切换时，将寄存器和<strong>上下文栈保存到其他地方</strong>，并在协程切换回来时<strong>恢复之前保存的寄存器和上下文栈</strong>。由于<strong>直接对栈进行操作</strong>，<strong>基本没有内核切换的开销</strong>，可以<strong>不加锁的访问全局变量</strong>，所以上下文切换非常快。</p><p>一个线程可以有多个协程，一个进程也可以单独拥有多个协程。<strong>线程和进程都是同步机制，而协程是异步机制，无需阻塞</strong>。协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用时的状态。多协程间对CPU的使用是依次进行的，每次只有一个协程工作，而其他协程处于休眠状态。</p><p>实际上多个协程是在一个线程中的，只不过每个协程对CPU进行分时。<strong>协程可以访问和使用Unity的所有方法和Component</strong>。<strong>函数（子程序）的调用是通过栈实现的</strong>，一个线程就是执行一个函数，函数调用总是一个入口，一个返回，调用顺序是明确的，而<strong>协程在函数内部是可以中断的</strong>，然后<strong>转而执行其他函数</strong>，在<strong>适当的时候再返回来继续执行</strong>。函数（子程序）的切换不是由线程切换，而是程序自身控制，因此没有线程切换开销。和多线程相比，线程越多，协程的性能优势就越明显，切协程因为依次执行，<strong>不存在线程安全问题，变量访问不会冲突</strong>，共享资源也无需加锁，只需要判断状态即可，所以执行效率比线程高很多。</p><p><strong>协程的语法</strong></p><ul><li><code>yield</code>：暂停，通常用 <code>yield return null</code> 来暂停协程。</li><li><code>StartCoroutine(方法名())</code>：恢复执行。</li><li><code>WaitForSeconds</code>：引入时间延迟，默认情况下，协程将在 yield 后的帧上恢复。使用 <code>yield return new WaitForSecond(.1f)</code> 后，将延迟0.1秒后执行协程。</li></ul><p>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> url = <span class="string">&quot;https://xxxx.xxxx.xxxx/xxxx.jpg&quot;</span>;</span><br><span class="line">WWW www = <span class="keyword">new</span> WWW(url);</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> WWW;</span><br><span class="line">renderer.material.mainTexture = www.texture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当程序执行到 <code>yield return WWW</code>; 时就不会直接往下执行了，而是等到网络请求结束后的第一帧的<code>WWW</code>协程节点触发时才继续执行，也就是说，当网络请求结束后，纹理才会被替换。</p><p><strong>yield return对象</strong></p><ul><li><code>null或数字</code>：在Update后执行，适合分解耗时的逻辑处理。</li><li><code>WaitForFixedUpdate</code>：在FixedUpdate后执行，适合分解物理操作。</li><li><code>WaitForSeconds</code>：在指定时间后执行，适合延迟调用。</li><li><code>WaitForSecondsRealtime</code>：在指定时间后执行，适合延迟调用。不受时间缩放影响。</li><li><code>WaitForEndOfFrame</code>：在每帧结束后执行，适合相机跟随操作。</li><li><code>Coroutine</code>：在另一个协程执行完毕后再执行。</li><li><code>WaitUntil</code>：在委托返回true时执行，适合等待某一操作。</li><li><code>WaitWhile</code>：在委托返回false时执行，适合等待某一操作。</li><li><code>WWW</code>：在请求结束后执行，适合加载数据，如文件、贴图、材质等。</li></ul><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>通过并发编程，我们可以实现更复杂的游戏逻辑，如大规模场景中的动态光照计算、复杂物理效果的实时模拟等，而无需担心这些任务会拖慢游戏的主循环。此外，随着Unity对并发编程支持的不断增强，开发者们将有更多机会探索和利用现代硬件的并行处理能力，为玩家带来更加流畅、逼真的游戏体验。</p><p>从场景切换的异步加载到并发编程的深入探索，我学到了很多。通过掌握并发编程的精髓，我们不仅能够提升游戏的运行效率，还能为游戏设计带来更多可能性，让创意与技术的碰撞绽放出更加璀璨的光芒。</p><p>—end—</p>]]></content>
    
    
    <summary type="html">从加载进度条到Unity的进程、线程与协程......</summary>
    
    
    
    <category term="Unity" scheme="http://flashfish777.cn/categories/Unity/"/>
    
    <category term="开发日记" scheme="http://flashfish777.cn/categories/Unity/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Unity" scheme="http://flashfish777.cn/tags/Unity/"/>
    
    <category term="C#" scheme="http://flashfish777.cn/tags/C/"/>
    
    <category term="并发编程" scheme="http://flashfish777.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Unity日记：小地图</title>
    <link href="http://flashfish777.cn/posts/bf08e6b6.html"/>
    <id>http://flashfish777.cn/posts/bf08e6b6.html</id>
    <published>2024-07-05T14:00:00.000Z</published>
    <updated>2024-08-20T12:52:09.135Z</updated>
    
    <content type="html"><![CDATA[<div class="note primary morden flat"><p><strong>今天分享一下如何在Unity小游戏中制作小地图！</strong></p></div><p>在Unity中制作小地图（或雷达）是游戏开发中常见的需求，用于展示游戏世界的局部或全局信息，帮助玩家更好地理解游戏环境。</p><h2 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h2><h3 id="搭建场景"><a href="#搭建场景" class="headerlink" title="搭建场景"></a>搭建场景</h3><p>首先，你需要在Unity中搭建一个简单的游戏场景。这可以包括玩家角色、敌人、障碍物等。</p><h3 id="创建新摄像机"><a href="#创建新摄像机" class="headerlink" title="创建新摄像机"></a>创建新摄像机</h3><ul><li><strong>新建摄像机</strong>：在Unity的层级列表（Hierarchy）中，直接右键选择<code>Camera</code>来创建一个新的摄像机。命名为<code>Minimap Camera</code>以区分主摄像机。</li><li><strong>设置摄像机位置</strong>：将<code>Minimap Camera</code>的位置设置为主角上方或其他你需要的地方，高度和角度都可以根据需要调整，确保摄像机可以捕捉到整个场景或你想要在小地图上显示的部分。</li><li><strong>移除Audio Listener</strong>：因为场景中只能有一个<code>Audio Listener</code>，所以需要从<code>Minimap Camera</code>中移除<code>Audio Listener</code>组件。</li></ul><h3 id="创建Render-Texture"><a href="#创建Render-Texture" class="headerlink" title="创建Render Texture"></a>创建Render Texture</h3><p>在Unity的Assets文件夹中，右键点击选择<code>Create</code> -&gt; <code>Render Texture</code>，创建一个新的Render Texture，命名为<code>Small Map</code>。</p><p><img src="https://s2.loli.net/2024/08/14/kDmMc3pjq8H4J5G.png"></p><h3 id="添加Raw-Image"><a href="#添加Raw-Image" class="headerlink" title="添加Raw Image"></a>添加Raw Image</h3><p>在Canvas中右键点击，选择<code>UI</code> -&gt; <code>Raw Image</code>来创建一个新的Raw Image，命名为<code>Minimap Image</code>。</p><p><img src="https://s2.loli.net/2024/08/14/E8bSOQ7DYuzNCZ1.png"></p><h2 id="配置摄像机"><a href="#配置摄像机" class="headerlink" title="配置摄像机"></a>配置摄像机</h2><h3 id="设置Render-Texture"><a href="#设置Render-Texture" class="headerlink" title="设置Render Texture"></a>设置Render Texture</h3><p><strong>分配Render Texture</strong>：选中<code>Minimap Camera</code>，在检视面板（Inspector）中找到<code>Target Texture</code>字段，将之前创建的<code>Minimap Render Texture</code>拖拽进去。</p><p><img src="https://s2.loli.net/2024/08/14/jE419cAVSPrINFx.png"></p><h3 id="设置Raw-Image"><a href="#设置Raw-Image" class="headerlink" title="设置Raw Image"></a>设置Raw Image</h3><ul><li><strong>分配Render Texture</strong>：将之前创建的<code>Minimap Render Texture</code>拖拽到<code>Minimap Image</code>的<code>Texture</code>字段中。</li></ul><p><img src="https://s2.loli.net/2024/08/14/Z56W3lRFpAkqLJU.png"></p><h3 id="调整大小和位置"><a href="#调整大小和位置" class="headerlink" title="调整大小和位置"></a>调整大小和位置</h3><p>最后根据需要调整<code>Minimap Image</code>的大小和位置，确保它适合你的UI布局，小地图就做好啦！</p><h2 id="丰富小地图操作"><a href="#丰富小地图操作" class="headerlink" title="丰富小地图操作"></a>丰富小地图操作</h2><p>除了简单的地图显示之外，还可以添加一些交互操作，丰富玩家的体验。</p><p>比如我增加了放大、缩小按钮，还实现了点击小地图全屏查看，再次点击恢复的操作。</p><p><img src="https://s2.loli.net/2024/08/14/4q2xDCr3c8dWgSw.png"></p><p><strong>示例：</strong></p><p>放大缩小：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MapSize</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject player; <span class="comment">// player</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 保持在玩家上方</span></span><br><span class="line">        transform.position = <span class="keyword">new</span> Vector3(player.transform.position.x, transform.position.y, player.transform.position.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将相机下移实现放大</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Big</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (transform.position.y &gt; <span class="number">20</span>)</span><br><span class="line">            transform.position = <span class="keyword">new</span> Vector3(transform.position.x, transform.position.y - <span class="number">20</span>, transform.position.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将相机上移实现缩小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Small</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (transform.position.y &lt; <span class="number">400</span>)</span><br><span class="line">            transform.position = <span class="keyword">new</span> Vector3(transform.position.x, transform.position.y + <span class="number">20</span>, transform.position.z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>点击全屏：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClickMap</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject Mapp; <span class="comment">// 地图</span></span><br><span class="line">    <span class="built_in">bool</span> isBig = <span class="literal">false</span>; <span class="comment">// 大小状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Click</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBig) smaller(); <span class="comment">// 变小</span></span><br><span class="line">        <span class="keyword">else</span> Bigger(); <span class="comment">// 变大</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过改变Raw Image在Canvas的大小和位置来实现全屏效果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bigger</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isBig = <span class="literal">true</span>;</span><br><span class="line">        Mapp.GetComponent&lt;RectTransform&gt;().sizeDelta = <span class="keyword">new</span> Vector2(<span class="number">1080</span>, <span class="number">1080</span>);</span><br><span class="line">        Mapp.GetComponent&lt;RectTransform&gt;().anchoredPosition = <span class="keyword">new</span> Vector2(<span class="number">960</span>, <span class="number">-540</span>);</span><br><span class="line">        GetComponent&lt;RectTransform&gt;().sizeDelta = <span class="keyword">new</span> Vector2(<span class="number">1080</span>, <span class="number">1080</span>);</span><br><span class="line">        GetComponent&lt;RectTransform&gt;().anchoredPosition = <span class="keyword">new</span> Vector2(<span class="number">960</span>, <span class="number">-540</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">smaller</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isBig = <span class="literal">false</span>;</span><br><span class="line">        Mapp.GetComponent&lt;RectTransform&gt;().sizeDelta = <span class="keyword">new</span> Vector2(<span class="number">320</span>, <span class="number">320</span>);</span><br><span class="line">        Mapp.GetComponent&lt;RectTransform&gt;().anchoredPosition = <span class="keyword">new</span> Vector2(<span class="number">160</span>, <span class="number">-160</span>);</span><br><span class="line">        GetComponent&lt;RectTransform&gt;().sizeDelta = <span class="keyword">new</span> Vector2(<span class="number">320</span>, <span class="number">320</span>);</span><br><span class="line">        GetComponent&lt;RectTransform&gt;().anchoredPosition = <span class="keyword">new</span> Vector2(<span class="number">160</span>, <span class="number">-160</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多有意思的操作层出不穷，这里只是做个示例哈。分享就到这里啦，别的文章再会！</p><p>—end—</p>]]></content>
    
    
    <summary type="html">小地图可是一些游戏的灵魂所在，来学着做一个小地图吧！</summary>
    
    
    
    <category term="Unity" scheme="http://flashfish777.cn/categories/Unity/"/>
    
    <category term="开发日记" scheme="http://flashfish777.cn/categories/Unity/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="Unity" scheme="http://flashfish777.cn/tags/Unity/"/>
    
    <category term="C#" scheme="http://flashfish777.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>我与口袋方舟的故事...</title>
    <link href="http://flashfish777.cn/posts/83f43b84.html"/>
    <id>http://flashfish777.cn/posts/83f43b84.html</id>
    <published>2024-06-30T04:00:00.000Z</published>
    <updated>2024-08-20T12:51:47.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直对游戏开发很感兴趣的我，经常在寻找与了解很多相关知识。</p><p>我们计算机与软件学院有幸组织了一次意义非凡的企业参访活动——走进成都西山居。这次活动让我对游戏行业有了更加深入的了解。</p><p>走进西山居的那一刻，我就被公司内浓厚的文化氛围和创意气息所吸引。位于中国（四川）自由贸易试验区成都高新区万象南路669号佳辰国际中心B座12层15号的西山居，不仅地理位置优越，更在行业内享有盛誉。作为一家以从事研究和试验发展为主的企业，西山居在游戏开发领域取得了令人瞩目的成就，特别是其经典游戏产品《剑侠情缘》系列，更是被誉为中国游戏第一品牌。</p><p>在参访过程中，人力资源总监曾荣竺老师为我们详细介绍了西山居的发展历程、公司文化以及在游戏领域的各项成果。她不仅让我们了解了西山居在游戏制作中的程序、策划、美术三大岗位的具体职责、技能要求以及发展方向，还通过生动的案例和深入浅出的讲解，为我们勾勒出了清晰的职业发展框架。这让我深刻认识到，在游戏行业这个充满挑战与机遇的领域中，只有不断学习、不断进步，才能立于不败之地。</p><p>除了企业介绍外，我们还聆听了正就职于西山居的往届学长的经验分享。他用自己的亲身经历告诉我们，如何通过参与项目制作、参加各类比赛积累实战经验，并最终成功入职西山居。他的建议让我受益匪浅，特别是关于如何尽早制定职业规划、关注行业动态与企业需求、重视实习与实践经历等方面的建议，更是为我未来的学习和实践提供了宝贵的指导。</p><p>在实地参观环节，我们走进了西山居的办公区，亲身感受到了游戏公司的日常工作环境与氛围。有序的办公空间、专注工作的团队成员、充满创意元素的装饰，都让我对游戏从业者的真实生活有了更加直观的了解。这种近距离的接触让我更加坚定了自己投身游戏行业的决心。</p><p>此次参访活动不仅让我对西山居公司有了更加深入的了解，也让我对游戏行业有了更加全面的认识。我深刻感受到，在这个充满竞争与机遇的时代里，只有不断学习、勇于创新、敢于挑战自我，才能在游戏行业这个充满魅力的领域中脱颖而出。同时，我也更加明确了自己的职业规划和发展方向。</p><p><img src="https://s2.loli.net/2024/08/13/4XCwe16O9cYkRgH.jpg" alt="参观照片"></p><p><img src="https://s2.loli.net/2024/08/13/NEhqxcQWyLAXBGf.jpg" alt="参观照片"></p><p><img src="https://s2.loli.net/2024/08/13/VwzPOA8y3NHvhER.jpg" alt="参观照片"></p><p>初次之外，我还报名了网易Y3高校游戏制作人大赛（尽管结果不尽人意…）</p><p><img src="https://s2.loli.net/2024/08/13/ZAFzMhxpiJ9rYRE.jpg"></p><p>直到我又看见口袋方舟的游戏创作训练营，毫不犹豫的报名了。</p><p><img src="https://s2.loli.net/2024/08/13/bpSKqeRXmWywIHM.jpg"></p><hr><div class="note success flat"><p><a href="https://creator.ark.online/">口袋方舟官网</a></p></div><h1 id="口袋方舟之旅"><a href="#口袋方舟之旅" class="headerlink" title="口袋方舟之旅"></a>口袋方舟之旅</h1><p>在这个充满无限创意与可能的时代，我有幸踏上了一段非凡的旅程——参与MetaApp的口袋方舟游戏开发训练营。这不仅是一次技术的探索，更是一场心灵的冒险，让我在游戏开发的浩瀚星海中找到了属于自己的小小方舟。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>口袋方舟编辑器以其低门槛、高自由度的特点，让即便是像我这样的游戏开发新手，也能轻松上手，实现自己的游戏创意。怀揣着对游戏开发的热爱与憧憬，我在学习与尝试中慢慢的熟悉了编辑器的使用。</p><p><img src="https://s2.loli.net/2024/08/13/TOeIniyaCwxVlRp.jpg" alt="口袋方舟编辑器"></p><h2 id="学习与开发"><a href="#学习与开发" class="headerlink" title="学习与开发"></a>学习与开发</h2><p>学习并开发小游戏的日子紧张而充实。从基础的编程知识到高级的游戏设计原理，从界面布局到交互逻辑，每一步都充满了挑战与收获。还有老师们细心解答问题，老师们不仅拥有深厚的专业知识，更有着对游戏开发的无限热情，他们耐心地解答我们的每一个疑问，鼓励我们大胆尝试，勇于创新。</p><p>在这个过程中，我逐渐掌握了使用口袋方舟编辑器开发游戏的各项技能。从构思游戏概念、设计关卡流程、使用预制体搭建游戏，到自己编写需要的代码、调试优化，每一个环节我都亲力亲为，深刻体会到了游戏开发的艰辛与乐趣。</p><p><img src="https://s2.loli.net/2024/08/13/8BqiOmh43dcPkaj.jpg" alt="TypeScript"></p><h2 id="两款小作品的诞生与发布"><a href="#两款小作品的诞生与发布" class="headerlink" title="两款小作品的诞生与发布"></a>两款小作品的诞生与发布</h2><p>经过无数个日夜的努力，我终于独立开发出了两款小游戏，并成功发布到了233平台上。第一款游戏《天空公主》是一款以帮助公主回家为主题的跑酷游戏，玩家需要操控主角越过各种障碍与陷阱，最终到达目的地。第二款游戏《探秘金字塔》则是一款find类游戏，玩家需要找到各种道具解开谜题，收集奖杯，找到最终宝藏。</p><p>这两款游戏的成功发布，不仅让我收获了满满的成就感，更让我看到了自己在游戏开发领域的潜力与可能。当第一个玩家进入游戏，我的心情无比激动！我收到了许多玩家的反馈与鼓励，他们的认可与支持成为了我继续前行的动力。</p><p><img src="https://s2.loli.net/2024/08/13/dUwXCyuzceZ6tMf.jpg" alt="天空公主"></p><p><img src="https://s2.loli.net/2024/08/13/ohxCrHu2qU9m1QF.jpg" alt="天空公主"></p><p><img src="https://s2.loli.net/2024/08/13/k8sIXaWpc3enN64.jpg" alt="探秘金字塔"></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>在参与训练营开发过程中，首先我收获了很多奖品与证书：</p><p><img src="https://s2.loli.net/2024/08/13/nr6xR1wFb9msDoh.jpg" alt="证书"></p><p><img src="https://s2.loli.net/2024/08/13/r7ZyI8XldO3kMfP.jpg" alt="证书"></p><p><img src="https://s2.loli.net/2024/08/13/Ot2jbmDFYWxQcv7.jpg" alt="鼠标垫"></p><p>其次，游戏本身也有广告收入：</p><p><img src="https://s2.loli.net/2024/08/13/O5fDV6STr4lkQHu.png" alt="游戏数据"></p><p>当然，回顾这段经历，我收获的更多的是知识与技能，更重要的是对游戏开发的热爱与坚持。我学会了如何在困难面前不屈不挠，如何在失败中寻找机遇，如何在成功中保持谦逊。这些宝贵的经验将伴随我走过未来的游戏开发之路。<strong>我十分感谢口袋方舟，让我实现了“做游戏给别人玩”的梦想。</strong></p><p>展望未来，我希望能继续深化自己在游戏开发领域的专业知识与技能，不断挑战自我，创作出更多优秀、有趣、富有创意的游戏作品。同时，我也期待能与更多志同道合的朋友一起交流学习，共同推动游戏开发行业的繁荣发展。</p><p>口袋方舟之旅虽然告一段落，但我的游戏开发之路才刚刚开始。我相信，只要心中有梦，脚下就有路。在未来的日子里，我将以更加饱满的热情和坚定的信念，继续在游戏开发的道路上勇往直前！</p><p>—end—</p>]]></content>
    
    
    <summary type="html">在使用口袋方舟编辑器进行小游戏开发的时候学到了很多，很棒的经历!</summary>
    
    
    
    <category term="项目" scheme="http://flashfish777.cn/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="项目" scheme="http://flashfish777.cn/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="游戏开发" scheme="http://flashfish777.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="MetaApp" scheme="http://flashfish777.cn/tags/MetaApp/"/>
    
  </entry>
  
  <entry>
    <title>VSCode插件推荐</title>
    <link href="http://flashfish777.cn/posts/c5a23961.html"/>
    <id>http://flashfish777.cn/posts/c5a23961.html</id>
    <published>2024-04-23T12:00:00.000Z</published>
    <updated>2024-08-20T12:52:22.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习编程的过程中，我有幸邂逅并深入使用了多款编译器与集成开发环境（IDE），如经典的<code>Dev-C++</code>，功能强大的<code>Visual Studio（VS）</code>，以及专为C&#x2F;C++和Python等语言设计的<code>CLion</code>，它们各自以其独特的魅力，在不同阶段陪伴并助力了我的学习与成长。</p><div class="note info no-icon flat"><p><strong>Dev-C++</strong></p></div><p>Dev-C++轻量级且易上手，是我初识编程时用的第一款编译器，让我能够快速上手C&#x2F;C++，打好基础。然而，随着学习的深入与项目规模的扩大和需求的复杂化，我开始意识到其在项目管理、代码补全及调试功能上的局限性。</p><div class="note primary no-icon flat"><p><strong>Visual Studio（VS）</strong></p></div><p>之后我接触到了VS2022这款IDE，最初相对Dev，我被它的高级感以及全面的开发能力、强大的调试工具和丰富的插件生态系统吸引。在VS的怀抱中，我感受到了前所未有的开发效率与便捷，虽然我学识尚浅，但我了解到无论是在Web开发、桌面应用还是游戏开发，VS都能提供强大的支持。但与此同时，VS的庞大体积与内存和偶尔的复杂配置也让我在追求轻量级与灵活性的项目中感到些许不便。</p><div class="note success no-icon flat"><p><strong>CLion</strong></p></div><p>CLion则以其对C&#x2F;C++的深入理解和优化，为我提供了更为专业和高效的C&#x2F;C++开发体验。智能的代码分析、快速重构工具以及无缝的集成调试，都让C&#x2F;C++项目的开发变得得心应手。然而，对于多语言支持或是特定框架的快速搭建，CLion或许不是最全面的选择。</p><p><strong>正是在这样的背景下，我遇到了<mark class="hl-label blue">VSCode</mark> 。VSCode以其轻量级、跨平台、高度可扩展的特点，迅速成为了我的新宠。它不仅能够提供流畅的代码编辑体验，还通过丰富的插件生态，支持几乎所有主流编程语言及框架，从前端到后端，从Web到移动应用，无所不能。更重要的是，VSCode的启动迅速、界面简洁，让我在快节奏的编程生活中能够保持高效与专注。</strong></p><p>因此，今天我想和大家分享一些我在使用VSCode过程中发现的好用插件，这些插件不仅极大地提升了我的开发效率，也让我对VSCode的热爱更加深厚。接下来，就让我们一起探索这些宝藏插件吧！</p><hr><h1 id="功能篇"><a href="#功能篇" class="headerlink" title="功能篇"></a>功能篇</h1><h2 id="Prettier-Code-formatter"><a href="#Prettier-Code-formatter" class="headerlink" title="Prettier - Code formatter"></a>Prettier - Code formatter</h2><p><img src="https://s2.loli.net/2024/08/11/hG4BqQYTbAXr9xo.png" alt="Prettier - Code formatter"></p><p><code>Prettier - Code formatter</code> 是一款用于代码格式化的插件，‌它支持多种编程语言的代码格式化，‌旨在确保代码风格的一致性。‌Prettier 提供了一种简单的方法来自动调整代码格式，‌使其符合一组预定义的规则，‌从而帮助开发者提高代码的可读性和一致性。‌以下是关于 Prettier - Code formatter 插件的一些详细介绍：‌</p><ul><li><p><strong>配置方式：‌</strong>Prettier 的配置可以通过多种方式进行，‌包括在项目的根目录创建 <code>.prettierrc</code> 文件（‌支持 YML、‌JSON 等格式）‌，‌创建 <code>.prettier.config.js</code> 文件，‌或者在 <code>package.json</code> 文件中添加 Prettier 配置属性。‌这些配置文件允许用户自定义 Prettier 的规则，‌如缩进大小、‌是否使用制表符、‌引号风格等。‌</p></li><li><p><strong>集成使用：‌</strong>Prettier 可以与多种编辑器和构建工具集成，‌包括 Visual Studio Code（‌VSCode）‌、‌GitHub Actions 等。‌在 VSCode 中，‌Prettier 插件可以在保存文件时自动格式化代码，‌确保代码风格的一致性。‌此外，‌Prettier 还可以与 ESLint 集成，‌以确保代码不仅格式正确，‌而且符合一定的编码规范。</p></li><li><p><strong>角色分工：‌</strong>Prettier 主要负责代码的格式化工作，‌而 ESLint 则专注于代码质量和风格的检查。‌通过这种结合使用，‌开发者可以确保代码既没有语法错误，‌又具有一致的格式。‌</p></li><li><p><strong>配置选项：‌</strong>Prettier 提供了丰富的配置选项，‌允许用户根据自己的需求调整代码格式化的具体规则。‌例如，‌可以设置打印宽度、‌制表符宽度、‌是否使用单引号或双引号等。‌</p></li></ul><p>  总的来说，‌Prettier - Code formatter 是一个强大的工具，‌它通过自动化代码格式化过程，‌帮助开发者提高代码的可读性和一致性，‌是现代软件开发中不可或缺的一部分。‌</p><p><a href="https://github.com/prettier/prettier-vscode">-&gt; GitHub仓库</a></p><h2 id="Path-Intellisense"><a href="#Path-Intellisense" class="headerlink" title="Path Intellisense"></a>Path Intellisense</h2><p><img src="https://s2.loli.net/2024/08/11/s9aeyhHjiknbV4g.png" alt="Path Intellisense"></p><p><code>Path Intellisense</code>是一个简单但极其实用的VSCode扩展，‌它能够智能感知并自动补全你在代码中引用的文件路径。‌这个扩展通过实时提供匹配的路径建议，‌大大提高了编码效率。‌以下是该扩展的主要特点和功能：‌</p><ul><li><strong>自动补全：‌</strong>一旦你开始键入文件或目录名称，‌插件会实时提供匹配的路径建议，‌帮助你快速找到目标文件。‌</li><li><strong>忽略配置：‌</strong>你可以通过设置禁用TypeScript和JavaScript的内置路径提示，‌以便Path Intellisense成为默认的补全源。‌</li><li><strong>Node包智能感知：‌</strong>配合<code>npm intellisense</code>插件，‌可以实现对Node.js包的智能补全。‌</li><li><strong>应用场景：‌</strong>适用于任何需要引入文件的场景，‌如导入模块、‌读取配置文件等，‌特别适用于大型项目，‌其中有很多层级目录和众多文件。‌</li><li><strong>项目特点：‌</strong>无论是在当前目录还是其他目录，‌Path Intellisense都能即时提供准确的路径建议。‌支持自定义设置，‌如是否显示隐藏文件、‌是否添加文件扩展名，‌以及自动触发下一个建议等功能。‌此外，‌它还尊重<code>tsconfig.json</code>配置，‌特别是<code>baseUrl</code>选项，‌无需重复定义。‌还允许自定义路径映射，‌方便使用绝对路径或者与<code>webpack</code>的r<code>esolve</code>选项搭配使用。‌<br>安装与使用方面，‌你可以在VSCode命令面板中选择“Install Extension”，‌搜索Path Intellisense进行安装。‌然后在设置中添加相关配置，‌即可启用插件。‌通过GIF图可以看到，‌在编写代码时，‌只需敲击几下键盘，‌Path Intellisense就会展示出相应的文件路径，‌让你轻松完成引用。‌</li></ul><p><a href="https://github.com/ChristianKohler/PathIntellisense">-&gt;GitHub仓库</a></p><h2 id="Image-preview"><a href="#Image-preview" class="headerlink" title="Image preview"></a>Image preview</h2><p><img src="https://s2.loli.net/2024/08/11/27jec9roxbSqLls.png" alt="Image preview"></p><p><code>Image Preview</code>是一个专为Visual Studio Code设计的高效扩展，‌它允许用户在代码文件中直接预览图片，‌无需离开当前的工作流，‌从而极大地提升了工作效率。‌这个扩展在代码行号旁显示图像预览，‌并且在鼠标悬停时也会出现预览，‌提供了实时预览功能，‌能够实时检测并解析代码中的图像路径，‌无论它们是相对路径还是绝对URL。‌Image Preview支持各种文件类型，‌如CSS、‌HTML、‌Markdown等，‌甚至可以识别数据URI。‌它还支持本地文件和网络URL，‌提供了高度自定义性，‌允许用户通过配置项调整预览样式，‌比如设置最大宽度和高度。‌</p><p><img src="https://s2.loli.net/2024/08/11/6P1T43txWzgX9qV.png" alt="示例"></p><p>Image Preview非常适合前端开发、‌Markdown写作以及图片资源管理。‌在编写CSS或HTML时，‌可以立即查看所引用图片的效果，‌而不需要频繁切换到浏览器预览。‌在编辑Markdown文档时，‌可以快速验证插入的图片是否正确展示。‌对于大型项目，‌它可以方便地查看代码中的所有图片，‌避免了手动查找的问题。‌Image Preview的安装过程简单快捷，‌只需通过Visual Studio Code扩展市场搜索并安装即可。‌无论用户是新手还是经验丰富的开发者，‌这个扩展都会成为日常工作中不可或缺的工具。‌</p><p>此外，‌Image Preview还具有智能更新的功能，‌能够自动检测代码变化，‌实时更新预览，‌确保信息始终同步。‌它的简洁直观的预览效果和全面支持的特性，‌以及高度定制化和智能更新的功能，‌使得Image Preview成为提高编码体验和开发生产效率的有力工具。‌</p><p><a href="https://github.com/kisstkondoros/gutter-preview">-&gt;GitHub仓库</a></p><h2 id="Error-Lens"><a href="#Error-Lens" class="headerlink" title="Error Lens"></a>Error Lens</h2><p><img src="https://s2.loli.net/2024/08/11/FOiKZRQ2tpNxE9U.png" alt="Error Lens"></p><p><code>Error Lens</code> 是一个非常有用的 Visual Studio Code 扩展，‌它主要改进了错误、‌警告和其他语言诊断的突出显示。‌通过安装这个扩展，‌你可以更直观地看到代码中的问题，‌从而更快地定位和解决错误。‌Error Lens 帮助开发者快速发现代码中的错误，‌直达问题所在，‌提高了代码调试的效率。‌安装完成后，‌需要重启 Visual Studio Code 以使扩展生效。‌此外，‌Error Lens 还提供了键盘快捷方式，‌使得操作更加便捷。‌通过按住 Alt 键，‌可以使用数字键选择和导航指示器，‌进一步提高了使用效率。‌</p><p><a href="https://github.com/kisstkondoros/gutter-preview">-&gt;GitHub仓库</a></p><h2 id="Competitive-Programming-Helper-cph"><a href="#Competitive-Programming-Helper-cph" class="headerlink" title="Competitive Programming Helper (cph)"></a>Competitive Programming Helper (cph)</h2><p><img src="https://s2.loli.net/2024/08/11/AQLCaIXTg1pPSju.png" alt="Competitive Programming Helper (cph)"></p><p><strong>超级好用超级推荐的扩展！特别适合热衷刷题以及算法竞赛的小伙伴！</strong></p><p><code>Competitive Programming Helper (cph)</code>是一个非常实用的扩展工具，‌专门为竞赛编程设计，‌旨在提高编程效率和准确性。‌</p><p>cph的主要功能特点包括：‌</p><ol><li><strong>跨平台支持：‌</strong>兼容多种竞赛平台，‌满足多样化的编程需求。‌</li><li><strong>多语言支持：‌</strong>支持包括C++, C, Rust, Go, Python, Java, JavaScript (Node.js)等多种常见编程语言。‌</li><li><strong>一键操作：‌</strong>通过快捷键（‌如Ctrl+Alt+B）‌可以运行测试用例，‌简化操作流程，‌提高使用便捷性。‌</li><li><strong>可定制化：‌</strong>用户可以根据自己的偏好调整设置，‌甚至参与项目的贡献和开发，‌增加使用的灵活性和个性化。‌</li><li><strong>样例测试：‌</strong>以样例的方式对代码进行测试，‌帮助用户检查代码的正确性。‌</li><li><strong>错误流输出：‌</strong>如果在代码执行过程中出现错误流，‌cph会额外显示错误流信息，‌方便用户进行调试。‌</li></ol><p>用户通过VSCode插件中心安装即可用，简单方便。‌此外，‌cph扩展还提供了一个网页插件，‌可以在刷题时打开要做的题目的页面，‌然后在VSCode中通过点击网页上面的绿色小按钮，‌自动创建文件并将所有的测试用例的输入输出复制粘贴过来，‌用户只需直接编写代码即可。‌编写完之后，‌可以通过一键运行判断对错，‌从而提高刷题效率。‌</p><p><img src="https://s2.loli.net/2024/08/11/7ukJX9GtpLPrE8K.png" alt="cph"></p><p><a href="https://github.com/agrawal-d/cph">-&gt;GitHub仓库</a></p><h2 id="Code-Runner"><a href="#Code-Runner" class="headerlink" title="Code Runner"></a>Code Runner</h2><p><img src="https://s2.loli.net/2024/08/11/p2jAsXHRwJxBdkl.png" alt="Code Runner"></p><p><code>Code Runner</code>扩展是一款强大的Visual Studio Code插件，‌支持运行多种编程语言的代码文件和代码片段。‌</p><p>Code Runner扩展的主要特点包括：‌</p><ul><li><strong>广泛的语言支持：‌</strong>支持包括C、‌C++、‌Java、‌JavaScript、‌PHP、‌Python、‌Ruby、‌Go、‌Lua、‌Groovy、‌PowerShell、‌TypeScript、‌Swift、‌Julia、‌Rust、‌Kotlin、‌Dart、‌Haskell等在内的多种流行编程语言，‌使得这个扩展对于使用多种语言的开发者来说非常有用。‌</li><li><strong>便捷的代码运行：‌</strong>可以直接从编辑器或文件资源管理器中运行代码，‌无需切换到终端或配置复杂的运行环境，‌提高了使用便捷性。‌</li><li><strong>自定义命令执行：‌</strong>允许用户根据需要配置和运行自定义命令，‌为不同的项目和工作流程提供灵活性。‌</li><li><strong>输出控制和展示：‌</strong>直观地在输出窗口中显示代码运行结果，‌方便调试和结果检查。‌</li><li><strong>支持REPL：‌</strong>支持REPL(读取-求值-打印循环)，‌可以提高生产力和效率。‌</li></ul><p>Code Runner扩展的开发者是韩骏，‌他是VS Code中文社区创始人，‌该扩展目前已经有了超过450万的下载量，‌并且在其GitHub项目页面上有详细的文档和社区支持。‌此外，‌Code Runner扩展还支持执行自定义命令，‌使得用户可以根据自己的需求进行灵活配置，‌进一步提高工作效率。‌</p><p><a href="https://github.com/formulahendry/vscode-code-runner">-&gt;GitHub仓库</a></p><hr><h1 id="美化篇"><a href="#美化篇" class="headerlink" title="美化篇"></a>美化篇</h1><h2 id="OSU-Mode-3"><a href="#OSU-Mode-3" class="headerlink" title="OSU Mode 3"></a>OSU Mode 3</h2><p><img src="https://s2.loli.net/2024/08/11/SiIz6Jodx5Fhybl.png" alt="OSU Mode 3"></p><p>这款扩展比较小众，是我在逛b站时偶然发现，启用后，在敲代码时，键入的字母及按键会俏皮的弹出，甚至右上角会显示连击次数，在达到一定次数后还可以弹出图片，这让枯燥的敲代码的过程变得十分有趣，虽然本质上意义不大，但还是挺有意思的。</p><p>我在使用的过程中只开启了按键的弹出，毕竟我认为小小花样可以调情，太花里胡哨就适得其反了。</p><p>字母大小、速度以及连击样式与图片都可以按自己的喜好调节，即使追溯起这个扩展的历史有些混乱，但作为使用者我也没有去考虑那么多……</p><p><a href="https://www.bilibili.com/video/BV1dR4y1n7tW/?spm_id_from=333.999.0.0&vd_source=db9e45951cf3a5f0d2714d5a33520bad">-&gt;bilibili相关教程</a></p><p><a href="https://github.com/ao-shen/vscode-osu-mode">-&gt;GitHub仓库</a></p><h2 id="One-Dark-Pro"><a href="#One-Dark-Pro" class="headerlink" title="One Dark Pro"></a>One Dark Pro</h2><p><img src="https://s2.loli.net/2024/08/11/m1XtvPOpD5ZL9dS.png" alt="One Dark Pro"></p><p><strong>它真的很火，因为它真的很不错！超级赞的素颜主题！</strong></p><p><code>One Dark Pro</code>是一款源自Atom的经典主题，‌现已成为VS Code中最受欢迎的主题插件之一。‌它的设计简洁而深邃，‌无论是在编码还是阅读代码时，‌都能为用户提供舒适的视觉体验。‌One Dark Pro主题基于Material Design理念打造，‌提供多种内置风格，‌包括默认、‌扁平、‌暗黑和复古等，‌以适应不同的工作环境和个人喜好。‌此外，‌它还支持自定义配色，‌用户可以通过设置<code>workbench.colorCustomizations</code>和<code>editor.tokenColorCustomizations</code>来个性化调整颜色方案。‌One Dark Pro的特色功能还包括与Markdown预览的完美融合，‌使得文档编写更加美观易读。‌对于喜欢使用斜体代码的开发者，‌One Dark Pro提供了可配置的斜体模式，‌只需在设置中进行调整即可。‌此外，‌为了提高Python开发者的体验，‌它特别兼容了Pylance扩展，‌允许用户定制语义高亮颜色。‌One Dark Pro适用于各种开发场景，‌无论你是前端工程师、‌后端开发者还是数据科学家，‌都可以在这款主题下高效地工作。‌尤其是在长时间编程的情况下，‌其柔和的色彩搭配有助于减轻视觉疲劳，‌保持良好的专注力。‌</p><p><a href="https://github.com/Binaryify/OneDark-Pro">-&gt;GitHub仓库</a></p><h2 id="Material-Icon-Theme"><a href="#Material-Icon-Theme" class="headerlink" title="Material Icon Theme"></a>Material Icon Theme</h2><p><img src="https://s2.loli.net/2024/08/11/cNhVk4swRKaLbmC.png" alt="Material Icon Theme"></p><p><strong>特别推荐！</strong></p><p><code>Material Icon Theme</code>无疑是一款让VScode界面焕然一新的必备神器，它不仅极大地提升了开发者的视觉体验，还通过细致入微的设计让代码库变得更加整洁、专业。</p><p>首先，Material Icon Theme以其精美的Material Design风格图标著称，这些图标被精心设计并应用到文件和文件夹上，使得开发者在浏览代码库时能够迅速识别出不同类型的文件。这种直观性不仅提高了工作效率，还减少了因寻找文件而浪费的时间。</p><p>其次，该扩展插件采用了SVG图形，这意味着图标在不同分辨率下都能保持极高的清晰度，无论是高分辨率的4K屏幕还是低分辨率的普通显示器，都能呈现出完美的视觉效果。此外，Material Icon Theme还支持自定义颜色、透明度和饱和度，让开发者可以根据个人喜好调整图标样式，打造个性化的开发环境。</p><p>更令人称赞的是，Material Icon Theme提供了一套完善的设置选项，允许开发者定制文件和文件夹的图标关联，甚至可以导入自己的SVG图标，实现真正的个性化图标设计。这种高度的可定制性使得Material Icon Theme能够满足不同开发者的需求，无论你是前端开发者、后端工程师，还是数据科学家，都能找到适合自己的图标配置。</p><p>在实用性方面，Material Icon Theme同样表现出色。它涵盖了多种编程语言、框架和通用文件类型的图标库，满足各类项目需求。同时，该插件还能与版本控制系统如Git紧密集成，显示文件的状态标记，如未跟踪、已修改和已暂存等，帮助开发者更好地管理代码变更。</p><p>最后，Material Icon Theme的易用性也是其一大亮点。通过VScode的命令面板或用户设置，开发者可以轻松完成图标配置，无需复杂的操作。这种简单而强大的功能使得Material Icon Theme成为VScode用户不可或缺的扩展插件之一。</p><p>综上所述，Material Icon Theme以其精美的图标设计、高度的可定制性、实用的功能以及简单易用的特点赢得了广泛的赞誉。如果你希望让你的VScode界面更具美感和实用性，那么这款插件绝对值得一试。</p><p><a href="https://github.com/material-extensions/vscode-material-icon-theme">-&gt;GitHub仓库</a></p><h2 id="background-cover"><a href="#background-cover" class="headerlink" title="background-cover"></a>background-cover</h2><p><img src="https://s2.loli.net/2024/08/11/RSNQoKestDjJiT7.png" alt="background-cover"></p><p><code>background-cover</code>是一个用于Visual Studio Code（‌VSCode）‌的插件，‌它允许用户替换VSCode界面的整体背景，‌而不仅仅是代码区的背景。‌这个插件提供了快捷的图形化配置界面，‌可以满足基本的配置需求，‌如设置图片路径、‌启用&#x2F;停用插件、‌背景透明度等功能。‌用户还可以通过图形界面快捷添加多张图片，‌并实现随机切换功能。‌此外，‌通过修改插件的配置文件，‌用户可以自定义背景样式，‌如调整图片大小、‌位置等，‌以实现个性化的界面背景设置。‌</p><p>该插件的原理是在VSCode加载、‌修改插件设置时，‌自动更新VSCode对应的CSS样式，‌以实现界面背景的更改。‌因此，‌用户可以通过找到插件中配置CSS样式的代码，‌并按照CSS的规则修改对应内容，‌来实现想要的效果。‌这包括调整背景图片的大小、‌位置以及背景颜色的设置等。‌</p><p>总的来说，‌background-cover插件为VSCode用户提供了一个方便的方式来个性化他们的开发环境，‌通过简单的图形化界面或通过修改配置文件来实现复杂的背景设置需求。‌</p><p>注：推荐，但静态壁纸还好，gif动图较占内存</p><p><a href="https://www.bilibili.com/video/BV1bs4y1w7fw/?spm_id_from=333.337.search-card.all.click&vd_source=db9e45951cf3a5f0d2714d5a33520bad">-&gt;bilibili教程</a></p><p><a href="https://github.com/AShujiao/vscode-background-cover">-&gt;GitHub仓库</a></p><hr><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>以上就是我精心挑选而且正在使用的一些VSCode插件，它们各具特色，功能强大，无论是在提升编码效率、增强代码质量，还是在美化编辑器、代码方面，都展现出了非凡的价值。我相信，随着你深入使用这些插件，它们将会成为你编程旅程中不可或缺的伙伴，助你在编码的世界里畅游无阻，探索无限可能。</p><p>当然，VSCode的插件生态如此丰富，我推荐的这些只是冰山一角。鼓励大家根据自己的实际需求和偏好，去发现更多适合自己的插件，不断优化自己的开发环境。记住，工欲善其事，必先利其器，一款好的开发工具加上高效的插件辅助，定能让你的编程之路更加顺畅，成就更加辉煌。</p><p>最后，感谢大家的阅读，希望这篇博客能为你带来一些启发和帮助。如果你有任何推荐的VSCode插件或者独特的使用心得，欢迎在评论区留言分享，让我们一起学习，共同进步！期待在未来的编程道路上，与更多的你相遇，共同书写属于我们的精彩篇章。</p><p>—end—</p>]]></content>
    
    
    <summary type="html">一些好用的插件</summary>
    
    
    
    
    <category term="VSCode" scheme="http://flashfish777.cn/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>Roefian的大冒险：初识面向对象!</title>
    <link href="http://flashfish777.cn/posts/961490cd.html"/>
    <id>http://flashfish777.cn/posts/961490cd.html</id>
    <published>2024-04-21T12:00:00.000Z</published>
    <updated>2024-08-20T12:52:39.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言——一些简单的尝试"><a href="#引言——一些简单的尝试" class="headerlink" title="引言——一些简单的尝试"></a>引言——一些简单的尝试</h1><h2 id="万年历"><a href="#万年历" class="headerlink" title="万年历"></a>万年历</h2><a class="btn-beautify outline pink larger" href="/pages/WanNianLi/"   title="源码"><i class="far fa-hand-point-right"></i><span>源码</span></a><p><img src="https://s2.loli.net/2024/08/12/nDgsW14aFojbQHz.png" alt="万年历"></p><div class="note info flat"><p><strong>图片展示功能有限，源码复制粘贴到编译器运行即可使用！</strong></p></div><p>该程序使用C++<strong>基本语法</strong>及一些<strong>字符串操作</strong>实现了判断闰年、判断某天为星期几、输出某年日历、输出某月日历四个功能。在代码实现中定义并实现了判断闰年、判断星期、输出日历等函数，在主函数中的主循环里做操作判断，分别调用这些函数来实现目标操作。（更多细节可以查看源码，这里不多做赘述）</p><p>‌在该程序中，我除对C语言的熟悉外，最大的收获是了解并使用了<strong>蔡勒公式</strong>来计算星期：<br><code>蔡勒（Zeller）公式</code>是一个用于计算星期的复杂公式，其推导过程涉及对历法规则（如‌闰年、月份天数等）的深入理解和数学运算。蔡勒公式基于‌格里高利历（公历），该历法在1582年进行了改革，废除了儒略历中的10天，并引入了更精确的闰年规则。在蔡勒公式中，为了简化计算，通常将1月和2月视为上一年的13月和14月。公式主要由几个部分组成，包括世纪数、年份、月份和日期，每个部分都通过特定的数学运算（如取整、乘法、加法等）与星期数相关联，<strong>最终，通过将所有部分相加并对7取模（即求余数），得到的结果即为所求日期的星期数（0代表星期日，1代表星期一，依此类推）</strong>。‌由于推导过程涉及大量数学细节和历法知识，这里不展开具体步骤。但可以通过查阅相关数学书籍或文献，了解更详细的推导过程。</p><h2 id="商城商品管理系统"><a href="#商城商品管理系统" class="headerlink" title="商城商品管理系统"></a>商城商品管理系统</h2><a class="btn-beautify outline red larger" href="/pages/ShopManager/"   title="源码"><i class="far fa-hand-point-right"></i><span>源码</span></a><p><img src="https://s2.loli.net/2024/08/12/71tOKb4EMUQSTWy.png" alt="商品管理系统"></p><div class="note info flat"><p><strong>图片展示功能有限，源码复制粘贴到编译器运行即可使用！</strong></p></div><p>该程序使用了C++的<code>Vector（容器）</code>动态数组，使用<strong>结构体Vector</strong>代替了常见的管理系统练习项目常用的<strong>结构体链表</strong>这种数据结构。除了Vector相关操作，我还掌握并使用了<code>重载运算符</code>、<code>迭代器</code>等相关知识。</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>C++中的<code>vector</code>是一个非常灵活且功能强大的序列容器，它能够存储具有相同类型的元素序列，并自动管理这些元素的内存。<code>vector</code>属于C++标准模板库（STL）的一部分，它提供了<strong>动态数组</strong>的功能，但与普通数组相比，<code>vector</code>具有更高的<strong>灵活性</strong>和<strong>安全性</strong>。</p><h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><ol><li><p><strong>动态数组</strong>：Vector可以动态地增长和缩小，以适应不同数量的元素。这意味着你不需要在编译时就知道数组的大小，也不需要在数组满时手动分配更大的数组并复制元素。</p></li><li><p><strong>自动内存管理</strong>：Vector自动管理其元素的内存分配和释放。当Vector被销毁时，其所有元素也会被自动销毁。这减少了内存泄漏的风险。</p></li><li><p><strong>随机访问</strong>：Vector支持随机访问其元素，即你可以通过索引直接访问任何位置的元素，类似于普通数组。这使得Vector在处理需要频繁访问元素的应用时非常高效。</p></li><li><p><strong>迭代器</strong>：Vector提供了迭代器，允许你遍历容器中的元素。迭代器提供了对容器中元素的间接访问，并可以递增以访问下一个元素。</p></li><li><p><strong>容量和大小</strong>：Vector有两个重要的属性：<code>size()</code>和<code>capacity()</code>。<code>size()</code>返回容器中元素的数量，而<code>capacity()</code>返回容器在不重新分配内存的情况下可以存储的元素数量。</p></li></ol><h4 id="选择Vector的原因"><a href="#选择Vector的原因" class="headerlink" title="选择Vector的原因"></a>选择Vector的原因</h4><p>我认为结构体Vector相对于结构体链表的优点主要包括以下几点：</p><ul><li><p><strong>高效的随机访问能力</strong>：‌Vector在内存中通常以数组的形式存储，‌这使其支持高效的随机访问。‌与链表相比，‌通过索引直接访问Vector中的元素速度更快，‌因为不需要从头开始遍历链表。‌</p></li><li><p><strong>线程安全性</strong>：‌Vector的所有方法都是线程安全的，‌这意味着在多线程环境中，‌对Vector的操作可以保证数据的一致性和完整性。‌相比之下，‌链表通常不提供线程安全保证，‌因此在多线程环境下使用时需要额外的同步机制。‌</p></li><li><p><strong>较低的空间消耗</strong>：‌虽然链表在空间使用上具有较好的灵活性，‌能够根据需要动态添加和删除节点，‌但在某些情况下，‌Vector可能具有较低的空间消耗。‌这是因为Vector在初始化时分配足够的内存空间，‌减少了频繁内存分配和释放的开销，‌这在处理大量数据时尤其重要。‌</p></li><li><p><strong>简洁方便的写法</strong>：最重要的一点是，无论是在定义调用或删除等任何操作中，Vector的写法总要比链表简单很多。</p></li></ul><h3 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h3><p>C++ 中的<code>运算符重载（Operator Overloading）</code>是一种特殊形式的函数重载，它允许程序员为已存在的运算符（如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>!=</code> 等）赋予新的意义，以便它们可以<strong>用于类的对象</strong>。通过运算符重载，可以使对象的使用更加直观和方便，类似于内置数据类型的操作。更多概念与使用可以查看这里-&gt;<a href="https://www.runoob.com/cplusplus/cpp-overloading.html">菜鸟教程</a></p><p>在本程序中，为商品结构体重定义<code>==</code>运算符，方便find函数查找。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p><code>迭代器</code>是一种用于遍历容器元素的对象，它提供了一种通用的访问容器元素的方式，无论容器的类型和数据结构如何。迭代器在C++标准库中占有重要地位，是<strong>连接容器和算法的重要桥梁</strong>。<code>迭代器(Iterator)</code>是<code>指针(pointer)</code>的泛化，它允许程序员用相同的方式处理不同的数据结构（容器）。每种容器类型都定义了自己的迭代器类型，这种类型支持迭代器的各种行为。迭代器提供了一种方法来顺序访问容器中的各个元素，同时不需要暴露容器的内部表示，这使得算法能够独立于容器的具体实现。</p><p>在程序中我广泛应用迭代器查找和获取元素信息，同时配合find函数（<span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">相关概念  </button><span class="hide-content">C++的find函数是定义在algorithm头文件中的一个通用算法，用于在给定范围内查找元素。它返回一个迭代器，指向查找到的元素的位置，如果没有找到，则返回结束迭代器（end迭代器）。</span></span>）与distance函数（<span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">相关概念  </button><span class="hide-content">C++的distance函数用于计算两个迭代器之间的距离。它接受两个迭代器作为参数，并返回它们之间的距离。</span></span>）使用，大大提高了效率。</p><h2 id="关于程序设计方法"><a href="#关于程序设计方法" class="headerlink" title="关于程序设计方法"></a>关于程序设计方法</h2><p>程序设计方法是指在进行软件开发过程中，<strong>按照一定的规范和策略来设计和实现计算机程序</strong>的方法论。它涵盖了从需求分析、系统设计、编码实现到测试调试等多个环节，是软件开发领域中的重要理论支撑。程序设计方法旨在通过科学、合理的方法论指导程序的设计和实现，以提高软件的质量和开发效率，同时降低后期维护成本。它使得软件开发过程更加规范化和可控，有助于开发出高效、可靠的计算机程序。</p><p>主要的程序设计方法有：结构化程序设计、面向对象程序设计（OOP）、函数式编程、响应式程序设计、并行程序设计、领域驱动设计（DDD）等。</p><h3 id="结构化程序设计"><a href="#结构化程序设计" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h3><p>在初次尝试自己实现小型功能的项目时，我其实在懵懵懂懂中使用的是简易的<code>结构化程序设计方法（Structured Programming）</code>，也称为面向过程（POP）的程序设计方法。这种方法最早由E.W.Dijkstra在1965年提出，是软件发展的一个重要里程碑。</p><p>结构化程序设计方法主张按功能来分析系统需求，其主要原则可概括为<strong>自顶向下</strong>、<strong>逐步求精</strong>、<strong>模块化</strong>等。它强调将复杂的程序设计任务分解成若干个简单、易于理解和实现的模块，每个模块完成一个特定的功能。</p><h4 id="主要特点-1"><a href="#主要特点-1" class="headerlink" title="主要特点"></a>主要特点</h4><ol><li><strong>模块化</strong>：将程序划分为若干个模块，每个模块完成一个相对独立的功能。这样做的好处是提高了程序的可读性、可维护性和可重用性。</li><li><strong>自顶向下</strong>：从程序的整体功能出发，逐步细化到各个子功能，直到每个子功能都足够简单，可以直接用编程语言实现。</li><li><strong>逐步求精</strong>：在自顶向下的过程中，不断对程序进行细化，确保每个步骤都清晰明确，易于实现。</li><li><strong>控制结构</strong>：结构化程序设计非常强调程序的控制结构，即程序的执行流程。它认为任何算法都可以由<code>顺序结构</code>、<code>选择结构</code>和<code>循环结构</code>这三种基本结构组成。</li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong>：</p><ul><li>结构清晰，易于理解和维护。</li><li>提高了程序的可重用性。</li><li>有利于团队协作和分工。</li></ul><p><strong>缺点</strong>：</p><ul><li>设计不够直观，与人类习惯思维不一致。</li><li>适应性差，可扩展性不强。当用户需求发生改变时，可能需要自顶而下地修改模块结构，维护成本较高。</li></ul><p>结构化程序设计方法是面向对象程序设计之前的一种重要程序设计方法，它在软件工程中发挥了重要作用。然而，随着软件技术的不断发展，面向对象程序设计方法逐渐成为了主流。</p><hr><h1 id="Roefian的大冒险"><a href="#Roefian的大冒险" class="headerlink" title="Roefian的大冒险"></a>Roefian的大冒险</h1><a class="btn-beautify outline purple larger" href="https://github.com/flashfish777/roefian-s-adventure"   title="GitHub仓库"><i class="far fa-hand-point-right"></i><span>GitHub仓库</span></a> <div class="note info flat"><p><strong>仓库中有源码及exe程序压缩包，下载即可运行</strong></p></div><p><img src="https://s2.loli.net/2024/08/12/4XFxCA2kJBoLGNH.png" alt="Boss"></p><p>在项目开发中，我选择了VS2022这款IDE、C++为编程语言以及EasyX图形库实现图形化界面。</p><h2 id="EasyX图形库"><a href="#EasyX图形库" class="headerlink" title="EasyX图形库"></a>EasyX图形库</h2><p><a href="https://easyx.cn/">EasyX图形库官方文档</a></p><h3 id="什么是图形库"><a href="#什么是图形库" class="headerlink" title="什么是图形库"></a>什么是图形库</h3><p><code>图形库（Graphics Library）</code>是一组用于<strong>图形处理</strong>的软件函数或类的集合，它们提供了<strong>绘制图形</strong>、<strong>处理图像</strong>、<strong>显示文本</strong>等功能的接口。图形库通常封装了底层的图形系统（如操作系统的图形接口或硬件的图形加速器）的复杂性，使得开发者可以更容易地在应用程序中实现图形界面和视觉效果。</p><p>图形库的主要作用包括：</p><ol><li><p><strong>简化图形开发</strong>：图形库提供了高级的图形处理功能，如绘图、图像处理、动画等，使得开发者无需深入了解底层的图形系统细节，就能实现复杂的图形效果。</p></li><li><p><strong>提高开发效率</strong>：通过使用图形库，开发者可以重用已有的图形处理函数和类，避免重复编写相同的代码，从而提高开发效率。</p></li><li><p><strong>跨平台兼容性</strong>：一些图形库被设计为跨平台的，即它们可以在不同的操作系统上运行，而无需对代码进行大量修改。这使得开发者可以编写一次代码，然后在多个平台上运行图形应用程序。</p></li><li><p><strong>性能优化</strong>：图形库通常会进行性能优化，以确保图形处理的高效性。它们可能会利用硬件加速功能（如GPU加速）来加快图形渲染速度，并提供对图形缓存、批处理等技术的支持。</p></li><li><p><strong>提供高级功能</strong>：除了基本的绘图功能外，图形库还可能提供一些高级功能，如文本渲染、图像处理（如缩放、旋转、裁剪等）、动画效果、用户交互（如鼠标和键盘事件处理）等。</p></li></ol><p>（简单来说就是让我们的代码运行不止于“小黑框”，而是拥有更漂亮的界面与更丰富的交互）</p><h3 id="为什么选择EasyX"><a href="#为什么选择EasyX" class="headerlink" title="为什么选择EasyX"></a>为什么选择EasyX</h3><p><code>EasyX</code>是一款基于C++语言开发的图形库，专为Windows平台设计，具有易于使用、功能强大等特点。基于C++语言开发，采用面向对象的编程方式，封装了Windows API中的GDI+接口。</p><ol><li><strong>简单易学</strong>：EasyX的API设计简单明了，无需掌握复杂的Win32或MFC开发技术，新手可以快速上手，制作出简单的图形界面和动画效果。</li><li><strong>功能全面</strong>：支持多种常用图形和文本操作，包括像素绘制、线条绘制、矩形绘制、圆形绘制、文字输出等功能，还可以播放音效和视频，支持鼠标键盘事件和定时器事件等高级功能。</li><li><strong>高效稳定</strong>：EasyX底层基于Windows API的GDI+接口实现，采用C++面向对象的设计方式，使得其运行高效稳定，能够充分利用计算机硬件资源，保证运行效果流畅。</li><li><strong>轻量级</strong>：EasyX是一个轻量级的图形库，不需要复杂的安装和配置过程，方便开发者快速集成和使用。</li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>（近四千五百行代码两周完成当时真是写麻了，甚至之后还加做了修改器……）</p><p><img src="https://s2.loli.net/2024/08/12/uWPrmYht4VfTjpa.jpg" alt="修改器"></p><p>游戏类型是横板2d闯关类型，有单、双人两种模式，内含八个关卡（包括一个隐藏关）、两个BOSS，玩家通过发射子弹攻击怪物，战胜一个关卡内全部怪物可获得补给并走进下一关，通过全部关卡即为通关，并按操作难度给出成就评价。</p><p>一些代码细节包括：</p><ul><li>每个游戏对象（Game Object）的封装</li><li>图片及音效素材的优化</li><li>游戏地图的链表实现及切换操作</li><li>子弹与怪物的生成与销毁（vector）</li><li>碰撞检测</li><li>单&#x2F;双人的模式</li><li>游戏UI与交互按钮的实现</li></ul><p>等等这些在这里先不做介绍，文章主要想写一些关于面向对象与对程序设计方法的浅谈（虽然前面写的确实过于冗杂了……）如有想了解细节可以通过研究代码以及评论或联系我等方式。</p><p>收获： </p><ul><li>熟悉并熟练应用了C++面向对象编程思想，熟悉了STL库的使用。 </li><li>应用了链表等数据结构与各种算法使程序更优化更简洁易懂。 </li><li>掌握了EasyX图形库的基本用法。 </li><li>了解了从抽象的代码到具象化的小游戏程序的过程。 </li><li>实现了简单的UI与交互按钮。</li></ul><p><strong>Roefian的大冒险小游戏的完成，实现了我“做游戏给自己玩”的梦想！虽然游戏本身很简陋，bug高级多，但能做出来我就已经很满足了！</strong></p><hr><h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在了解我使用C++结合EasyX图形库开发的小游戏之后，让我们对<code>面向对象程序设计（Object-Oriented Programming, OOP）</code>这一核心概念进行一番概览。面向对象程序设计是一种广泛使用的编程范式，<strong>它通过将现实世界中的事物抽象为“对象”来组织代码</strong>，这些对象之间通过消息传递进行交互，从而构建出复杂而灵活的软件系统。</p><h3 id="面向对象的核心概念"><a href="#面向对象的核心概念" class="headerlink" title="面向对象的核心概念"></a>面向对象的核心概念</h3><ol><li><p><strong>对象（Object）</strong>：<br>对象是面向对象编程中的基本单元，它封装了数据（属性）和操作这些数据的方法（行为）。每个对象都是某个类的实例，具有该类的所有属性和方法。</p></li><li><p><strong>类（Class）</strong>：<br>类是对一组具有相同属性和方法的对象的抽象描述。它定义了对象的蓝图，包括对象的属性（数据成员）和可以执行的操作（成员函数）。通过类，我们可以创建具有相似特性和行为的对象集合。</p></li><li><p><strong>封装（Encapsulation）</strong>：<br>封装是隐藏对象的属性和实现细节，仅对外公开接口（即方法）的过程。这有助于保护数据不被随意修改，同时简化了对象的使用方式，只需通过接口与对象交互即可。</p></li><li><p><strong>继承（Inheritance）</strong>：<br>继承允许我们定义一个类（子类或派生类）来继承另一个类（父类或基类）的属性和方法。子类可以拥有父类的所有特性，并可以添加新的特性或覆盖（重写）父类的某些方法。继承是实现代码复用的重要手段。</p></li><li><p><strong>多态（Polymorphism）</strong>：<br>多态允许我们以统一的方式处理不同类型的对象。在面向对象编程中，这通常通过接口（在C++中通过虚函数实现）来实现，使得子类对象可以替换父类对象的位置，而程序仍能正常运行，表现出不同的行为。</p></li></ol><h3 id="面向对象编程的优势"><a href="#面向对象编程的优势" class="headerlink" title="面向对象编程的优势"></a>面向对象编程的优势</h3><ul><li><strong>代码复用</strong>：通过继承，我们可以重用已有的代码，减少重复编写相同功能的代码。</li><li><strong>可维护性</strong>：封装使得每个对象都负责自己的数据和操作，降低了模块间的耦合度，使得系统更易于维护和扩展。</li><li><strong>灵活性</strong>：多态性使得程序能够灵活地处理不同类型的对象，提高了程序的扩展性和可重用性。</li><li><strong>易于理解</strong>：面向对象编程将现实世界中的事物抽象为对象，使得程序结构更加贴近人类思维方式，易于理解和设计。</li></ul><h3 id="在我的小游戏中的应用"><a href="#在我的小游戏中的应用" class="headerlink" title="在我的小游戏中的应用"></a>在我的小游戏中的应用</h3><p>在Roefian的大冒险小游戏中，我充分利用了面向对象编程的这些特性。例如，我定义了多个<strong>类</strong>来表示游戏中的不同元素，如玩家、敌人、子弹等。每个<strong>类</strong>都封装了相应的属性和方法，如位置、速度、绘制方法、移动方法等。通过继承怪物与子弹等的<strong>基类</strong>，我创建了不同类型的敌人及Boss，以及不同特征的子弹，它们共享一些基本的属性和方法，但又有各自独特的行为。此外，我还利用了多态性，在游戏的主循环中统一处理不同类型的对象，使得游戏逻辑更加清晰和灵活。</p><p>通过这个小游戏的开发，我深刻体会到了面向对象编程的强大和魅力，它不仅提高了我的编程效率，还让我对软件设计有了更深入的理解。</p><h2 id="面向对象程序设计的深入理解"><a href="#面向对象程序设计的深入理解" class="headerlink" title="面向对象程序设计的深入理解"></a>面向对象程序设计的深入理解</h2><h3 id="抽象与封装"><a href="#抽象与封装" class="headerlink" title="抽象与封装"></a>抽象与封装</h3><ul><li><p><strong>抽象</strong>：面向对象编程的核心之一是抽象。抽象意味着从复杂的现实世界中提取出最重要的特征，忽略掉不相关的细节。在编程中，我们通过定义类来抽象出具有共同属性和行为的一组对象。这种抽象不仅简化了问题，还使得代码更加通用和可复用。</p></li><li><p><strong>封装的进一步探讨</strong>：封装不仅仅是隐藏数据，它还涉及到如何<strong>安全地访问和修改这些数据</strong>。在C++中，我们通常使用<code>private</code>、<code>protected</code>和<code>public</code>关键字来控制成员的访问权限。<code>private</code>成员只能被类内部的成员函数访问，而<code>public</code>成员则对外部可见。<code>protected</code>成员在继承中扮演特殊角色，它们对派生类可见，但对外部不可见。</p></li></ul><h3 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h3><ul><li><p><strong>继承的层次与类型</strong>：除了基本的单继承外，C++还支持多重继承，即<strong>一个类可以继承自多个基类</strong>。然而，多重继承可能会引入复杂的菱形继承问题（Diamond Problem），因此在实际应用中需要谨慎使用。此外，还有虚继承的概念，它用于解决菱形继承中的二义性问题。</p></li><li><p><strong>组合</strong>：除了继承外，另一种实现代码复用的方式是组合（也称为聚合或包含）。组合是通过在类中包含其他类的对象作为成员来实现的。与继承不同，组合表示的是“has-a”关系，而不是“is-a”关系。组合更加灵活，因为它允许我们在<strong>运行时动态地改变对象的组合方式</strong>。</p></li></ul><h3 id="多态性的实现"><a href="#多态性的实现" class="headerlink" title="多态性的实现"></a>多态性的实现</h3><ul><li><p><strong>虚函数</strong>：在C++中，多态性主要通过虚函数实现。当一个基类的指针或引用指向派生类对象时，通过该指针或引用调用的虚函数将表现出派生类的行为。这是通过虚函数表（vtable）实现的，每个包含虚函数的类都有一个指向vtable的指针，vtable中存储了该类及其所有基类中虚函数的地址。</p></li><li><p><strong>纯虚函数与抽象类</strong>：如果一个类中含有至少一个纯虚函数（即只有声明没有实现的虚函数），则该类为抽象类。抽象类不能被实例化，但可以作为基类被其他类继承。纯虚函数用于在基类中定义一个接口，让派生类去实现具体的行为。</p></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>面向对象编程的一个高级应用是设计模式。设计模式是在软件工程中反复出现的问题的解决方案。它们不是代码本身，而是关于如何组织代码的指导原则。一些常见的面向对象设计模式包括：</p><ul><li><strong>工厂模式</strong>：用于创建对象而不将具体类的代码与客户端代码混合在一起。</li><li><strong>单例模式</strong>：确保一个类只有一个实例，并提供一个全局访问点。</li><li><strong>观察者模式</strong>：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</li></ul><h3 id="面向对象与游戏开发"><a href="#面向对象与游戏开发" class="headerlink" title="面向对象与游戏开发"></a>面向对象与游戏开发</h3><p>在游戏开发中，面向对象编程的优势尤为明显。通过将游戏世界中的每个实体（如角色、怪物、道具等）抽象为对象，并使用类来定义它们的属性和行为，我们可以构建出一个灵活且可扩展的游戏框架。此外，利用继承和多态性，我们可以轻松地实现不同类型的实体和它们之间的交互，从而增加游戏的多样性和可玩性。</p><p>比如游戏引擎 <strong>Unity</strong> 中的 <strong>C#</strong> 语言就是 <strong>面向对象的高级编程语言</strong> ，在Unity中，几乎所有的游戏元素都是通过<code>GameObject</code>来创建的。每个<code>GameObject</code>都可以附加多个<code>Component（组件）</code>，这些<code>Component</code>实际上就是类的<strong>实例</strong>，它们定义了<code>GameObject</code>的行为和属性。例如，一个角色<code>GameObject</code>可以附加<code>Rigidbody</code>组件来控制物理行为，附加<code>Animator</code>组件来控制动画等。在Unity中编写游戏逻辑时，通常会定义多个类来表示不同的游戏元素和逻辑模块。这些类之间通过继承、组合和聚合等关系相互关联，共同构成游戏的核心逻辑。</p><p>总之，面向对象编程是一种强大的编程范式，它为我们提供了一种更加自然和直观的方式来构建复杂的软件系统。通过深入理解面向对象的核心概念和设计原则，我们可以编写出更加高效、可维护和可扩展的代码。</p><h2 id="面向对象方法论"><a href="#面向对象方法论" class="headerlink" title="面向对象方法论"></a>面向对象方法论</h2><p><code>面向对象分析（OOA）</code>、<code>面向对象设计（OOD）</code>和<code>面向对象编程（OOP）</code>是软件工程中紧密相连且逐步深入的三个概念，它们共同构成了面向对象方法论的重要组成部分。</p><h3 id="面向对象分析（OOA）"><a href="#面向对象分析（OOA）" class="headerlink" title="面向对象分析（OOA）"></a>面向对象分析（OOA）</h3><p><strong>定义</strong>：<br>OOA是指通过对问题领域进行分析，识别出其中的实体、关系、行为等要素，并将其抽象为对象、类、继承等概念，以便更好地理解和描述问题。在OOA阶段，通常使用UML（统一建模语言）等工具来进行建模和描述。</p><p><strong>主要任务</strong>：</p><ul><li>确定对象和类：识别并定义系统中的关键对象和类。</li><li>确定结构：分析对象之间的关系，如继承、关联等。</li><li>确定属性和方法：定义对象的属性和操作这些属性的方法。</li></ul><p><strong>重要性</strong>：<br>OOA为后续的OOD和OOP阶段提供了基础，确保了对问题领域的深入理解和准确表达。</p><h3 id="面向对象设计（OOD）"><a href="#面向对象设计（OOD）" class="headerlink" title="面向对象设计（OOD）"></a>面向对象设计（OOD）</h3><p><strong>定义</strong>：<br>OOD是指在OOA的基础上，进一步考虑系统的结构和组织方式，确定类的属性、方法、接口等细节，并进行模块划分、关系建立等设计工作。OOD的目标是将问题领域的抽象模型转化为可执行的软件设计。</p><p><strong>主要任务</strong>：</p><ul><li>细化类和接口：为类和接口添加详细的属性和方法。</li><li>划分模块：将系统划分为多个模块，每个模块包含一组相关的类和接口。</li><li>设计交互：定义对象之间的交互方式和通信机制。</li></ul><p><strong>与OOA的关系</strong>：<br>OOD是对OOA结果的进一步细化和规范化，为OOP阶段提供了详细的设计蓝图。</p><h3 id="面向对象编程（OOP）"><a href="#面向对象编程（OOP）" class="headerlink" title="面向对象编程（OOP）"></a>面向对象编程（OOP）</h3><p><strong>定义</strong>：<br>OOP是指使用面向对象的思想和方法来实现软件系统。在OOP中，程序被组织为一组相互协作的对象，每个对象都有自己的状态和行为，并通过消息传递来进行交互。</p><p><strong>主要特点</strong>：</p><ul><li>封装：将对象的属性和方法绑定在一起，并限制外部对属性的直接访问。</li><li>继承：子类继承父类的属性和方法，实现代码重用和层次化组织。</li><li>多态：同一个操作在不同对象上表现出不同行为的能力。</li></ul><p><strong>与OOD的关系</strong>：<br>OOP是OOD的具体实现阶段，它按照OOD提供的设计蓝图，使用具体的编程语言来编写代码，实现软件系统。</p><h3 id="三者之间的关系"><a href="#三者之间的关系" class="headerlink" title="三者之间的关系"></a>三者之间的关系</h3><ul><li><strong>顺序关系</strong>：从OOA到OOD再到OOP，三者之间存在一定的顺序关系。首先进行面向对象的分析（OOA），然后基于分析结果进行面向对象的设计（OOD），最后根据设计进行面向对象的编程（OOP）。</li><li><strong>相互影响</strong>：虽然存在顺序关系，但三者之间并不是简单的线性关系，而是相互影响、相互支持的。OOA的结果会影响OOD的设计决策，而OOD的设计又会影响OOP的实现方式。同时，OOP的实践经验也可以反馈到OOA和OOD阶段，帮助改进和优化分析和设计过程。</li></ul><p>所以，面向对象分析、面向对象设计和面向对象程序设计是面向对象方法论中不可或缺的三个环节，它们共同推动了软件工程的发展和进步。</p><h2 id="面向对象程序设计的发展"><a href="#面向对象程序设计的发展" class="headerlink" title="面向对象程序设计的发展"></a>面向对象程序设计的发展</h2><p>面向对象程序设计的起源可以追溯到20世纪50年代末期，但其真正作为软件开发范式的主流思想则是在20世纪90年代以后。面向对象的思想是对结构化程序设计的一种继承和发展，它旨在改善结构化程序设计中的不足，使程序设计更加接近于人们看待真实世界的情况。</p><h3 id="关键里程碑"><a href="#关键里程碑" class="headerlink" title="关键里程碑"></a>关键里程碑</h3><ol><li><p><strong>ALGOL 60的封装尝试</strong>：</p><ul><li>50年代后期，在用FORTRAN语言编写大型程序时，常出现变量名在程序不同部分发生冲突的问题。为了解决这一问题，ALGOL语言的设计者在ALGOL 60中采用了以Begin……End为标识的程序块，使块内变量名是局部的，以避免它们与程序中块外的同名变量相冲突。这是编程语言中首次提供封装（保护）的尝试。</li></ul></li><li><p><strong>Simula语言的诞生</strong>：</p><ul><li>1960年代初期，Kristen Nygaard和Ole-Johan Dahl在挪威计算机中心工作时，为了满足系统模拟的需要，开始研发一种更加高抽象层面的编程语言。经过两年的努力，他们于1964年成功推出了Simula语言，这是人类历史上第一款面向对象的编程语言。在Simula中，类被称为process，属性被称为station，方法被称为customer。</li></ul></li><li><p><strong>Smalltalk语言的奠基</strong>：</p><ul><li>随后，Alan Kay结合前人的工作，开发出了Smalltalk语言。Smalltalk在系统设计中强调对象概念的统一，引入了对象、对象类、方法、实例等概念和术语，并采用了动态联编和单继承机制。Smalltalk被认为是真正的面向对象编程语言（OOP）的奠基者。</li></ul></li><li><p><strong>面向对象语言的蓬勃发展</strong>：</p><ul><li>从80年代起，基于以往提出的信息隐蔽和抽象数据类型等概念，以及由Modula2、Ada和Smalltalk等语言所奠定的基础，不同类型的面向对象语言（如Object-C、Eiffel、C++、Java、Object-Pascal、Python等）逐步发展和建立起来。这些语言各具特色，但都遵循面向对象的基本原则。</li></ul></li></ol><h3 id="面向对象程序设计的优点"><a href="#面向对象程序设计的优点" class="headerlink" title="面向对象程序设计的优点"></a>面向对象程序设计的优点</h3><p>与其他程序设计方法相比，面向对象程序设计具有以下显著优点：</p><ol><li><p><strong>符合人们习惯的思维方法</strong>：</p><ul><li>面向对象程序设计将现实世界中的事物抽象为对象，使得程序结构更加接近于人们的思维方式。这种方式便于分解大型的复杂多变的问题，使得软件开发者可以更方便地与问题提出者进行沟通和交流。</li></ul></li><li><p><strong>易于软件的维护和功能的增减</strong>：</p><ul><li>面向对象程序设计中的封装性和对象之间的松散组合，使得软件的修改和维护变得更加容易。当需要增加或修改软件功能时，只需要关注相关的对象和类，而不需要对整个系统进行全面的修改。</li></ul></li><li><p><strong>可重用性好</strong>：</p><ul><li>通过定义和实例化对象，可以在不同的项目中重复使用已经编写好的类。这种重用性不仅提高了软件开发的效率，还减少了代码中的冗余和错误。</li></ul></li><li><p><strong>可扩展性强</strong>：</p><ul><li>面向对象程序设计支持继承和多态等特性，使得代码更具扩展性。通过继承，可以创建新的类来扩展已有类的功能；通过多态，可以在运行时动态地选择不同的方法实现，提供更大的灵活性和可扩展性。</li></ul></li><li><p><strong>封装性提高了代码的安全性和可靠性</strong>：</p><ul><li>面向对象编程通过封装将数据和相关的方法组合在一起，形成类的实例。这样可以隐藏实现的细节，只暴露必要的接口给外部使用，从而提高了代码的安全性和可靠性。</li></ul></li></ol><p>因为这些原因，面向对象程序设计以其独特的优势在软件开发领域占据了重要地位，并成为了当今软件开发的主流范式之一。</p><hr><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>在软件开发的世界里，程序设计方法的多样性是其繁荣与创新的重要源泉。每一种程序设计方法，无论是结构化编程、面向对象编程、函数式编程，还是响应式编程、事件驱动编程、面向切面编程（AOP）等，都拥有其独特的优势与适用场景，而<strong>没有绝对的优与劣之分</strong>。关键在于，开发者需要根据具体项目的需求、团队的技能集、维护的便捷性、以及未来可扩展性等因素，灵活选择和运用最适合当前情况的程序设计方法。</p><p>结构化编程以其清晰的逻辑流程和模块化设计，特别适合处理那些<strong>流程控制较为明确</strong>、<strong>业务逻辑相对简单</strong>的应用场景。而面向对象编程则通过封装、继承和多态等特性，有效提升了代码的重用性、可维护性和可扩展性，尤其适合构建<strong>复杂</strong>、<strong>多变</strong>且<strong>需要长期维护</strong>的系统。函数式编程以其不可变性、纯函数和声明式编程模型，为<strong>并发编程</strong>和<strong>数据流处理</strong>等领域带来了新的思路和效率提升。</p><p>每一种方法都有其光芒四射的场合，也都有可能在某些情境下显得力不从心。因此，重要的是培养一种“<strong>以问题为中心</strong>”的思维模式，而不是盲目追求某种方法的“先进性”或“时髦性”。只有深刻理解项目需求，全面评估各种方法的利弊，才能在众多的选择中找到那把最合适的“钥匙”，打开通往高效、可靠软件开发之路的大门。最终，程序设计的成功与否，不在于方法本身，而在于我们如何智慧地运用这些方法，以解决实际问题并创造价值。</p><p>程序设计方法的不断完善和应用推动了软件开发行业的发展和进步。通过合理运用不同的程序设计方法，开发人员可以在保证软件质量的同时提高开发效率，实现更加高效、可靠的计算机程序。此外，随着新技术和新方法的不断涌现，程序设计方法也在不断演进和发展，以适应不断变化的软件开发需求。在未来，相信随着技术的不断进步和应用场景的不断拓展，程序设计方法也将继续演进和发展，为软件开发行业带来更多的创新和变革。</p><p>—end—</p>]]></content>
    
    
    <summary type="html">关于一些小项目以及对于程序设计方法的学习与理解...</summary>
    
    
    
    <category term="项目" scheme="http://flashfish777.cn/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="C++" scheme="http://flashfish777.cn/tags/C/"/>
    
    <category term="Easyx图形库" scheme="http://flashfish777.cn/tags/Easyx%E5%9B%BE%E5%BD%A2%E5%BA%93/"/>
    
    <category term="OOP" scheme="http://flashfish777.cn/tags/OOP/"/>
    
    <category term="项目" scheme="http://flashfish777.cn/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>C语言学习笔记</title>
    <link href="http://flashfish777.cn/posts/13675369.html"/>
    <id>http://flashfish777.cn/posts/13675369.html</id>
    <published>2024-03-08T13:30:04.000Z</published>
    <updated>2024-08-20T12:51:22.519Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p><strong>C语言知识点</strong></p></div><h1 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h1><p>打空格！！！</p><p>逗号后面要打空格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d %d&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运算符前后要打空格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环里的分号后面要打空格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小括号和花括号之间要打空格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双斜杠注释后面打空格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双斜杠和这句话中间有空格</span></span><br></pre></td></tr></table></figure><p>其他还有什么地方要打空格自己意会</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="C主框架"><a href="#C主框架" class="headerlink" title="C主框架"></a>C主框架</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*****************</span></span><br><span class="line"><span class="comment">    *****************/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code>函数，又称主函数，是程序执行的起点。在执行程序时，由系统调用主函数，最后返回，结束程序。主要代码要写在主函数里。</p><p>主函数的类型一般是<code>int</code>，最后由<code>return</code>返回<code>0</code>来结束运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*****************</span></span><br><span class="line"><span class="comment">    *****************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数也可由其他类型定义，如<code>void</code>、<code>signed</code>等，但一般不常见且在一些情况下可能报错。以上为以<code>void</code>做主函数头（无需返回值）。</p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><h3 id="C语言标准库"><a href="#C语言标准库" class="headerlink" title="C语言标准库"></a>C语言标准库</h3><p><code>stdio.h</code>是C语言标准库，提供了C语言最基本的语法以及一些函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数学函数库"><a href="#数学函数库" class="headerlink" title="数学函数库"></a>数学函数库</h3><p><code>math.h</code>里有大量关于数学操作的函数，可以用来更方便的解决问题。常用的有：</p><ul><li><p><code>abs()</code>    对整形数据取绝对值</p></li><li><p><code>fabs()</code>    对浮点型数据取绝对值</p></li><li><p><code>sqrt()</code>    对数据取平方根（<code>double</code>型）</p></li><li><p><code>pow(x, y)</code>    求x的y次幂（<code>double</code>型）</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incude<span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">-3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> c = <span class="number">12.5</span>;</span><br><span class="line">    <span class="type">float</span> d = <span class="number">-5.123</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %lf %f\n&quot;</span>, <span class="built_in">abs</span>(a), <span class="built_in">abs</span>(b), <span class="built_in">fabs</span>(c), <span class="built_in">fabs</span>(d));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> aa = <span class="built_in">sqrt</span>(a);</span><br><span class="line">    <span class="type">int</span> bb = <span class="built_in">pow</span>(b, <span class="number">3</span>); <span class="comment">// -3的3次方</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, aa, bb);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9 3 12.5 5.123</span><br><span class="line">3 -27</span><br></pre></td></tr></table></figure><h3 id="string库"><a href="#string库" class="headerlink" title="string库"></a>string库</h3><ul><li><p><code>string.h</code>中的函数主要用于对字符串进行操作,常用的函数有：</p></li><li><p><code>strlen()</code>    返回字符串的长度。</p></li><li><p><code>strcmp(x, y)</code>    比较字符串<code>x</code>和<code>y</code>，当<code>x &lt; y</code>，返回值小于<code>0</code>；当<code>x = y</code>，返回值等于<code>0</code>；当<code>x &gt; y</code>，返回值大于<code>0</code>。</p></li><li><p><code>strcpy(x, y)</code>    将<code>y</code>指向的字符复制到<code>x</code>中</p></li><li><p><code>strcat(x, y)</code>    将字符串<code>y</code>连接到<code>x</code>的尾部</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">6</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">6</span>] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">6</span>] = <span class="string">&quot;55555&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(a));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">strcmp</span>(a, b);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小于\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;等于\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大于\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(c, b);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcat</span>(a, c);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">小于</span><br><span class="line">HelloWorld</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li><p><code>//</code>    单行注释</p></li><li><p><code>/**/</code>    整段注释</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;Hello World&quot;);</span></span><br><span class="line">    <span class="comment">//printf(&quot;Hello World&quot;);</span></span><br><span class="line">    <span class="comment">//printf(&quot;Hello World&quot;);</span></span><br><span class="line">    <span class="comment">//printf(&quot;Hello World&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="define定义标识符"><a href="#define定义标识符" class="headerlink" title="#define定义标识符"></a>#define定义标识符</h2><p>C语言中可以使用<code>#define</code>来定义一个标识符来表示一个常量,或定义一些宏，定义的标识符,并不占用程序内存,在预编译阶段对程序代码进行文本替换。定义标识符的操作在主函数外面。</p><p>最常见的用法就是<code>#define</code>来定义一些常量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI = 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;圆周率 = %d&quot;</span>, PI);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="typedef-关键字定义"><a href="#typedef-关键字定义" class="headerlink" title="typedef 关键字定义"></a>typedef 关键字定义</h2><p>C语言允许用户使用 <code>typedef</code> 关键字来定义自己习惯的数据类型名称，<code>typedef</code> 的真正含义是给一个已经存在的类型名称起一个别名，注意是已经存在的数据类型，而非变量，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">LL a = <span class="number">12345678</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="定义和赋值"><a href="#定义和赋值" class="headerlink" title="定义和赋值"></a>定义和赋值</h2><p><strong>定义：</strong><code>数据类型</code>  <code>数据名</code> <code>;</code></p><p><strong>定义时赋初值：</strong><code>数据类型</code>  <code>数据名</code>  <code>赋值符号（=）</code>  <code>初值</code> <code>;</code></p><p><strong>同时定义多个：</strong><code>数据类型</code>  <code>数据名</code>  <code>,</code>  <code>数据名</code> <code>;</code></p><p><strong>注意！</strong>  定义时没有赋初值的话这个数据的值就是随机的，有需要时千万别忘了赋初值，没有需要时也赋初值也是一个很好的习惯。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">3.14</span>, d = <span class="number">2.2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %lf %lf&quot;</span>, a, b, c, d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 5 3.14 2.2</span><br></pre></td></tr></table></figure><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><p>在程序运行的过程中，可以改变值的变量称为变量。</p><p>程序运行过程中，不可以发生改变的量叫做常量。</p><p>一般定义的数据默认为变量，可以用<code>define</code>定义常量，也可以在定义时的数据类型前加上<code>const</code>使之成为常量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3</span>,<span class="number">1415926</span>;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><table><thead><tr><th></th><th align="left">类型</th><th>存储大小</th><th>值范围</th></tr></thead><tbody><tr><td><strong>char</strong></td><td align="left">字符型</td><td>1字节</td><td>-128 到 127</td></tr><tr><td><strong>short</strong></td><td align="left">短整型</td><td>2字节</td><td>-32,768 到 32,767</td></tr><tr><td><strong>int</strong></td><td align="left">整型</td><td>4字节</td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td><strong>long</strong></td><td align="left">长整型</td><td>4字节</td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td><strong>long long</strong></td><td align="left">长长整形</td><td>8字节</td><td></td></tr></tbody></table><h3 id="浮点型（实型）"><a href="#浮点型（实型）" class="headerlink" title="浮点型（实型）"></a>浮点型（实型）</h3><table><thead><tr><th></th><th>类型</th><th>存储大小</th><th>值范围</th><th>精度</th></tr></thead><tbody><tr><td><strong>float</strong></td><td>单精度浮点数</td><td>4字节</td><td>1.2E-38 到 3.4E+38</td><td>6 位有效位</td></tr><tr><td><strong>double</strong></td><td>双精度浮点数</td><td>8字节</td><td>2.3E-308 到 1.7E+308</td><td>15 位有效位</td></tr><tr><td><strong>long double</strong></td><td>长双精度浮点数</td><td>16字节</td><td>3.4E-4932 到 1.1E+4932</td><td>19位有效位</td></tr></tbody></table><h3 id="unsigned"><a href="#unsigned" class="headerlink" title="unsigned"></a>unsigned</h3><p>整型变量的值的范围包括负数到正数。 但是在实际应用中，有的数据的范围常常只有正值（如学号、年龄等），为了充分利用变量的值的范围，可以将变量定义为“无符号”类型。可以在类型符号前面加上修饰符 <code>unsigned</code> ，表示指定该变量是“无符号整数”类型。如果加上修饰符 <code>signed</code>或什么都不加，则是“有符号”类型。</p><p>有符号整型数据存储单元中最高位代表数值的符号，如果指定为无符号型，不能存放负数，如 -123 等。由于无符号整型变量不用符号位，所以可表示数值的范围是一般整型变量中的两倍。</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p><a href="https://blog.csdn.net/xiandang8023/article/details/126036564">内存分配-CSDN</a></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在进行运算时，不同类型的数据要转换成同一类型。</p><h3 id="自动类型转换（隐式类型转换）"><a href="#自动类型转换（隐式类型转换）" class="headerlink" title="自动类型转换（隐式类型转换）"></a>自动类型转换（隐式类型转换）</h3><ul><li><p><code>float</code>型数据自动转换成<code>double</code>型；</p></li><li><p><code>char</code>与<code>short</code>型数据自动转换成<code>int</code>型；</p></li><li><p><code>int</code>型与<code>double</code>型数据运算，直接将<code>int</code>型转换成<code>double</code>型</p></li><li><p><code>int</code>型与<code>unsigned</code>型数据、直接将<code>int</code>型转换成<code>unsigned</code>型；</p></li><li><p><code>int</code>型与<code>long</code>型数据，直接将<code>int</code>型转换成<code>long</code>型。</p><p>如此等等，总之是由低级向高级型转换。另外不要错误地理解为先将<code>char</code>型或<code>short</code>型转换成<code>int</code>型，再转换成<code>unsigned</code>型，再转换成<code>long</code>型，直至<code>double</code>型。</p></li></ul><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>强制类型转换的一般形式为：<code>（类型名）</code> <code>（表达式）</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">7</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="type">float</span> y1, y2;</span><br><span class="line"><span class="type">float</span> y1 = a / b; <span class="comment">// y1的值a/b为3.0</span></span><br><span class="line">y2 = (<span class="type">float</span>) (a / b); <span class="comment">// y2的值为3.5， float将a强制转换为实型，b也随之自动转换为实型</span></span><br></pre></td></tr></table></figure><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p>每个字符都对应着一个ASCII码：<a href="https://www.runoob.com/w3cnote/ascii.html">ASCII码表</a></p><p><strong>常用：</strong></p><p><code>0</code>-&gt;<code>48</code></p><p><code>9</code>-&gt;<code>57</code></p><p><code>A</code>-&gt;<code>65</code></p><p><code>Z</code>-&gt;<code>90</code></p><p><code>a</code>-&gt;<code>97</code></p><p><code>z</code>-&gt;<code>122</code></p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p><strong>十进制：</strong>默认数制</p><p> <strong>二进制：</strong>以<code>0B</code>或<code>0b</code>前缀表示，如<code>0b0101</code></p><p><strong>八进制：</strong>以<code>0</code>前缀表示，如<code>0123</code></p><p><strong>十六进制：</strong>以<code>0X</code>或<code>0x</code>前缀表示，如<code>0x1A</code></p><p><strong>vc6.0中整形后加<code>l</code>或<code>L</code>表示是<code>long</code>型，加<code>u</code>表示是<code>unsigned</code>型</strong></p><h1 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h1><p>在C语言中，程序的执行分为三种结构：顺序结构、选择结构（分支结构）和循环结构。</p><p>顺序结构：代码从上到下顺序执行，中间没有任何判断和跳转。</p><h2 id="变量输入输出"><a href="#变量输入输出" class="headerlink" title="变量输入输出"></a>变量输入输出</h2><p>在C语言中，输入和输出是通过库函数<code>stdio.h</code>中的<code>scanf()</code>和<code>printf()</code>函数来实现的。在输入与输出时，<code>printf()</code>函数与<code>scanf()</code>函数的格式字符串用于指定输入输出的格式。格式字符串中的格式说明符（如<code>%d</code>表示整数，<code>%f</code>表示浮点数）必须与后面参数的类型和数量相匹配。如果格式字符串与参数不匹配，可能会导致未定义的行为或输出错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">float</span> c;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> e;</span><br><span class="line">    <span class="type">char</span> f[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    %d 十进制有符号整数</span></span><br><span class="line"><span class="comment">%lld long long整数</span></span><br><span class="line"><span class="comment">%u 十进制无符号整数</span></span><br><span class="line"><span class="comment">%f 浮点数</span></span><br><span class="line"><span class="comment">%lf 双精度浮点数</span></span><br><span class="line"><span class="comment">%s 字符串</span></span><br><span class="line"><span class="comment">%c 单个字符</span></span><br><span class="line"><span class="comment">%p 指针的值</span></span><br><span class="line"><span class="comment">%e 指数形式的浮点数</span></span><br><span class="line"><span class="comment">%x,%X 无符号以十六进制表示的整数</span></span><br><span class="line"><span class="comment">%0 无符号以八进制表示的整数</span></span><br><span class="line"><span class="comment">%g 自动选择合适的表示法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c %d %f %lf %lld %s&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d, &amp;e, f); <span class="comment">// 输入时变量要加取地址符（&amp;），字符串不用，详见指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    %nd 表示输出n位整型数,不够n位右对齐</span></span><br><span class="line"><span class="comment">    %.nf 表示小数点后保留n位</span></span><br><span class="line"><span class="comment">%n.mf 表示输出场宽为n+m的浮点数，其中小数位为m,整数位为n,小数点占一位不够n+m位右对齐</span></span><br><span class="line"><span class="comment">%0nd 表示在输出一个小于n位的数值时,将在前面补0使其总宽度为n位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%8d%8d%8d\n&quot;</span>, b, b*<span class="number">10</span>, b*<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%8.2f%8.2f%8.2f\n&quot;</span>, c, c*<span class="number">10</span>, c*<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%08lld%08lld%08lld&quot;</span>, e, e*<span class="number">10</span>, e/<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输入：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a 25 3.456 12.3456 111 hello</span><br></pre></td></tr></table></figure><p><strong>输出如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      25     250    2500</span><br><span class="line">    3.46   34.56  345.60</span><br><span class="line">000001110000111000000011</span><br></pre></td></tr></table></figure><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>C语言中的表达式主要由运算符和操作数构成。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><strong>算术运算符</strong>：<code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code></li><li><strong>赋值运算符</strong>：C语言中的赋值运算符<code>=</code>用于将一个表达式的值赋给变量。此外，C语言还支持复合赋值运算符，如<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code> 等，这些运算符可以简化赋值和算术运算的组合。</li><li><strong>自增自减运算符</strong>：C语言中的自增<code>++</code>和自减 <code>--</code> 运算符用于将变量的值增加或减少1。这些运算符只能用于变量，不能用于常量或表达式。</li><li><strong>位运算符</strong>：<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>^</code>、<code>&amp;</code>、<code>|</code></li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>在C语言中，运算符的优先级决定了表达式中各个运算对象之间的计算顺序，即哪个部分先计算，哪个部分后计算。下面是C语言中常用的运算符优先级列表，从高到低排列：</p><ol><li>括号 ()</li><li>一元运算符：++ - - !</li><li>算术运算符：* &#x2F; %</li><li>算术运算符：+ -</li><li>关系运算符：&lt; &gt; &lt;&#x3D; &gt;&#x3D;</li><li>等价运算符：&#x3D;&#x3D; !&#x3D;</li><li>位运算符：&lt;&lt; &gt;&gt;</li><li>位运算符：&amp;</li><li>位运算符：^</li><li>位运算符：|</li><li>条件运算符 ?:</li><li>赋值运算符：&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</li><li>逗号运算符: ,</li></ol><p>需要注意的是，同一优先级的运算符按照结合性进行计算，大部分运算符遵循<strong>从左至右</strong>的结合性，只有<strong>单目运算符</strong>、<strong>条件运算符</strong>、<strong>赋值运算符</strong>遵循<strong>从右至左</strong>的结合性。</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>C语言中的语句可以分为以下几类：</p><ul><li><strong>表达式语句</strong>：由表达式加上分号<code>;</code>组成，用于计算表达式的值并执行副作用。</li><li><strong>函数调用语句</strong>：由函数名、实际参数加上分号<code>;</code>组成，用于调用函数。</li><li><strong>控制语句</strong>：用于控制程序的执行流程，包括条件判断、循环执行、转向等。</li><li><strong>复合语句</strong>：用花括号<code>&#123;&#125;</code>括起来的一条或多条语句，也称为块。</li><li><strong>空语句</strong>：只有分号<code>;</code>组成的语句，不执行任何操作的语句。</li></ul><h1 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h1><h2 id="if-else-if-else判断结构"><a href="#if-else-if-else判断结构" class="headerlink" title="if-else if- else判断结构"></a>if-else if- else判断结构</h2><h3 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)&#123;</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">    ……</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个if语句，如果表示条件的逻辑表达式的结果不是0，那么就执行后面跟着的这对大括号内的语句；否则就跳过不执行，继续下面的其他语句。</p><p><strong>但是if语句还有一种形式可以不用{}。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &gt; b)</span><br><span class="line">    a += b + <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>if语句这一行结束的时候并没有表示语句结束的”;”，而后面的赋值语句写在if的下一行，而且缩进了，在这一行结束的时候有一个分号。</p><p>表明这条赋值语句是if语句的一部分，if语句拥有和控制这条赋值语句，决定其是否被执行。</p><p>简单地说就是if(逻辑表达式)后要么跟上”{“，要么跟上语句，不能直接写分号。</p><p><strong>总结：</strong>有大括号的时候 条件满足的情况执行所有括号内语句，无大括号的时候 条件满足执行最近邻语句。</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>​<code>&lt;</code>  <code>&gt;=</code>  <code>&lt;</code>  <code>&lt;=</code> </p><p>​<code>!=</code>   用于测试“不相等”</p><p>​<code>==</code>   用于测试“相等”</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>​<code>&amp;&amp;</code>    </p><p>​逻辑与       理解为： 即 怎么  又 怎么       一假全假，全真为真</p><p>​<code>||</code>        </p><p>​逻辑或     理解为：   要么 怎么 要么 怎么      一真为真， 全假为假</p><p>​<code>！</code></p><p>​逻辑非     真取假  假取真</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;少年\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">18</span> &amp;&amp; age &lt; <span class="number">30</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;青年\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">30</span> &amp;&amp; age &lt; <span class="number">50</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;中年\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">50</span> &amp;&amp; age &lt; <span class="number">80</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;老年\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;老寿星\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch-case选择结构"><a href="#switch-case选择结构" class="headerlink" title="switch-case选择结构"></a>switch-case选择结构</h2><p><code>switch</code>语句也是一种分支语句。 常常用于多分支的情况。<code>else if</code> 语句也能实现多分支情况，但在某些情况下使用<code>else if</code>来实现，会使代码过于复杂。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(整型表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在一个 switch 中可以有任意数量的 case 语句。</span></span><br><span class="line">    <span class="keyword">case</span> 整形常量表达式:</span><br><span class="line">    语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch-case</code>语句一般搭配<code>break</code>和<code>default</code>使用</p><p>中断语句<code>break</code>是C语言中的关键字，用于跳出循环或<code>switch</code>语句的执行。<code>break</code>语句通常用于在满足某个条件时提前终止循环，或在<code>switch</code>语句中匹配到某个<code>case</code>后跳出。</p><p>当 <code>switch</code> 表达式的值并不匹配所有 <code>case</code> 标签的值时，这个 <code>default</code> 子句后面的语句就会执行，<code>switch</code> 语句可以有一个可选的 <code>default</code> <code>case</code>，出现在 <code>switch</code> 的结尾。<code>default</code> <code>case</code> 可用于在上面所有 <code>case</code> 都不为真时执行一个任务。<code>default</code> <code>case</code> 中的 <code>break</code> 语句不是必需的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;day);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (day)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期天\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注</strong>：C语言中的<code>switch</code>语句具有“穿透”性，这意味着如果在<code>switch case</code>中没有使用<code>break</code>语句，那么匹配的<code>case</code>之后的所有<code>case</code>都将被执行。</p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a ? b : c;</span><br></pre></td></tr></table></figure><p>意为若a成立，则执行b，否则执行c。相当于if-else中的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a)</span><br><span class="line">&#123;</span><br><span class="line">b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三目运算符有很多用法，如判断赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">x = a &gt; b ? a : b; <span class="comment">// x = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用三目运算符求出了a与b的最大值并赋给x，相较于</span></span><br><span class="line"><span class="comment">if (a &gt; b)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">x = a;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">x = b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">要简单。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如直接返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a * <span class="number">2</span> : b + a + b / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="布尔变量"><a href="#布尔变量" class="headerlink" title="布尔变量"></a>布尔变量</h2><p><strong>布尔类型</strong>是一种包含两种值的数据类型，即<code>0</code>和<code>1</code>。基本上，<code>bool</code>类型的值表示两种行为，即<code>true</code>或<code>false</code>。在这里，’<code>0&#39;</code>表示<code>false</code>值，而’<code>1</code>‘表示<code>true</code>值。</p><p><strong>在C中，<code>&#39;0&#39; </code>以<code>0</code>的形式存储，而其他整数以<code>1</code>的形式存储,即“非零即true”</strong></p><p>C语言标准库不自带<strong>bool</strong>类型，需要引用<code>stdbool.h</code>头文件或用<code>typedef</code>手动定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span> </span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span><span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="type">bool</span>;</span><br></pre></td></tr></table></figure><p>应用示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> x = <span class="literal">false</span>;  <span class="comment">// 变量初始化 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">true</span>) <span class="comment">// 条件语句</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x的值为真&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x的值为假&quot;</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x的值为假</span><br></pre></td></tr></table></figure><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><p>循环语句具有在某些条件满足的情况下，反复执行特定代码的功能。</p><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>语法形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h2><p>语法形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">语句;</span><br><span class="line">&#125; <span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure><p><code>do while</code> 循环是先直接进⼊循环体，执⾏循环语句，然后再执⾏ <code>while</code> 后的判断表达式，表达式为真，就会进⾏下⼀次，表达式为假，则不再继续循环。</p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>语法形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式1 ⽤于循环变量的初始化 ，表达式2 ⽤于循环结束条件的判断 ，表达式3 ⽤于循环变量的调整，三种表达式都可以省略，但分号不能省略。</p><p><code>for</code>循环和<code>while</code>循环可以相互转换。二者没有性能上的差别。实际开发中，根据具体结构的情况，选择哪个格式更合适、美观。</p><h2 id="break、continue"><a href="#break、continue" class="headerlink" title="break、continue"></a>break、continue</h2><p>在循环执行的过程中，如果某些状况发⽣的时候，需要提前终止循环，这是非常常见的现象。C语言中提供了 <code>break</code> 和 <code>continue</code> 两个关键字，就是应⽤到循环中的。</p><p><code>break</code> 的作用是用于永久的终止循环，只要 <code>break</code> 被执行，直接就会跳出循环，继续往后执行。</p><p><code>continue</code> 的作用是跳过本次循环 <code>continue</code> 后边的代码，在 <code>for</code>循环和 <code>while</code> 循环中有所差异的。</p><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>分支结构和循环结构在使用中都可以嵌套，像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Flag = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Flag) &#123;</span><br><span class="line">        <span class="type">int</span> Flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (Flag) &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> Flag = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            Flag++;</span><br><span class="line">            <span class="keyword">if</span> (Flag &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> Flag = <span class="number">0</span>; Flag &lt;= <span class="number">100</span>; ++Flag) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> Flag = <span class="number">0</span>; Flag &lt;= <span class="number">100</span>; ++Flag) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">static</span> <span class="type">int</span> Flag = <span class="number">-100</span>;</span><br><span class="line">                </span><br><span class="line">                Flag++;</span><br><span class="line">                <span class="keyword">if</span> (Flag &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> Flag = <span class="number">0</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (Flag) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Test 1\r\n&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Test 0\r\n&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong>函数</strong>是指将一组能完成一个功能或多个功能的语句放在一起的<strong>代码结构</strong>。在C语言程序中，至少会包含一个函数，即主函数<code>main()</code>。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><p>​库函数就是存放在函数库中的函数，具有明确的功能、入口调用参数和返回值。</p><p>​<strong>库函数必须知道的一个秘密就是：使用库函数，必须包含 #include 对应的头文件。</strong></p><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>​自定义函数和库函数一样，有函数名，返回值类型和函数参数。</p><p>​例：写一个函数可以找出两个整数中的最大值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (x &gt; y) ? (x) : (y);<span class="comment">//三目运算符：x大于y返回x，x小于y返回y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h2><p>一个在两个数中返回最大值的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (x &gt; y) ? (x) : (y);<span class="comment">//三目运算符：x大于y返回x，x小于y返回y</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> max = cmp(num1, num2);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;max = %d\n&quot;</span>, max);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 20</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max = 20</span><br></pre></td></tr></table></figure><p><strong>函数可以先声明后定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> max = cmp(num1, num2);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;max = %d\n&quot;</span>, max);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cmp(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (x &gt; y) ? (x) : (y);<span class="comment">//三目运算符：x大于y返回x，x小于y返回y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上的代码中，<code>int cmp(int x, int y);</code>先将函数声明，这样的语句叫做函数原型。</p><p>声明即告诉编译器有一个函数叫什么，参数是什么，返回类型是什么。但是具体是不是存在，函数声明决定不了。</p><p>创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</p><p>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。</p><h2 id="返回类型、函数名、形参、实参、返回"><a href="#返回类型、函数名、形参、实参、返回" class="headerlink" title="返回类型、函数名、形参、实参、返回"></a>返回类型、函数名、形参、实参、返回</h2><p>C 语言中的函数定义的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return_type <span class="title function_">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li><li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li><li><strong>参数：</strong>当函数被调用时，您向参数传递一个值，这个值被称为<strong>实际参数</strong>。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。<strong>形式参数</strong>是指函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才实例化（分配内存单元），所以叫形式参数。形式参数当函数调用完成之后就自动销毁了。因此形式参数只在函数中有效。</li><li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li></ul><h2 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h2><p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：</p><ul><li><p>在函数或块内部的<strong>局部</strong>变量</p></li><li><p>在所有函数外部的<strong>全局</strong>变量</p></li><li><p>在<strong>形式</strong>参数的函数参数定义中</p></li></ul><p>在某个函数或块的内部声明的变量称为<strong>局部变量</strong>。它们只能被该函数或该代码块内部的语句使用。<strong>局部变量</strong>在函数外部是不可知的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 实际初始化 */</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  c = a + b;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// a，b，c，sum都是main函数的局部变量</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; i ++ )</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">int</span> d;</span><br><span class="line">      d = i * <span class="number">2</span>;</span><br><span class="line">      </span><br><span class="line">      sum += d;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// i，d是for语句中的局部变量</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of a = %d, b = %d and c = %d\n&quot;</span>, a, b, c);</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;sum = %d&quot;</span>, sum);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全局变量</strong>是定义在主函数外部，通常是在程序的顶部。<strong>全局变量</strong>在整个程序生命周期内都是有效的，在任意的函数内部能访问<strong>全局变量</strong>。</p><p>全局变量可以被任何函数或语句访问。也就是说，全局变量在声明后整个程序中都是可用的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 全局变量声明 */</span></span><br><span class="line"><span class="type">int</span> g;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 实际初始化 */</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  g = a + b;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of a = %d, b = %d and g = %d\n&quot;</span>, a, b, g);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全局变量在定义时默认初值为0</strong></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><a href="https://www.runoob.com/cprogramming/c-recursion.html">递归-菜鸟驿站</a></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><strong>数组</strong>是一种<strong>数据结构</strong>，它可以存储一个固定大小的相同类型元素的<strong>顺序集合</strong>。数组中的元素可以通过索引访问，<strong>索引通常从0开始</strong>。</p><h2 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type arrayName [ arraySize ];</span><br></pre></td></tr></table></figure><p>这叫做一维数组。<code>arraySize</code> 必须是一个大于零的整数常量，<code>type</code> 可以是任意有效的 C 数据类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>]; <span class="comment">// 声明一个整型数组，其中包含5个元素，未初始化</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 声明一个整型数组，并初始化</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 声明并初始化一个整型数组</span></span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = arr[3]; // a = 4</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>可以使用循环语句对数组进行遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n[<span class="number">10</span>]; <span class="comment">/* n 是一个包含 10 个整数的数组 */</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化数组元素 */</span>         </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        n[i] = i + <span class="number">100</span>; <span class="comment">/* 设置元素 i 为 i + 100 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出数组中每个元素的值 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;n[%d] = %d\n&quot;</span>, j, n[j] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n[0] = 100</span><br><span class="line">n[1] = 101</span><br><span class="line">n[2] = 102</span><br><span class="line">n[3] = 103</span><br><span class="line">n[4] = 104</span><br><span class="line">n[5] = 105</span><br><span class="line">n[6] = 106</span><br><span class="line">n[7] = 107</span><br><span class="line">n[8] = 108</span><br><span class="line">n[9] = 109</span><br></pre></td></tr></table></figure><h2 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h2><p>数组长度可以使用 <code>sizeof</code> 运算符来获取数组的长度，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); <span class="comment">// 获取数组长度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组长度为: %d\n&quot;</span>, length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组长度为: 5</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>C 语言支持多维数组。多维数组声明的一般形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type name[size1][size2]...[sizeN];</span><br></pre></td></tr></table></figure><p>多维数组最简单的形式是<strong>二维数组</strong>。一个二维数组，在本质上，是一个一维数组的列表。下面是一个二维数组，包含 3 行和 4 列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p><strong>初始化二维数组</strong></p><p>多维数组可以通过在括号内为每行指定值来进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   <span class="comment">/*  初始化索引号为 0 的行 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   <span class="comment">/*  初始化索引号为 1 的行 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;   <span class="comment">/*  初始化索引号为 2 的行 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样也是一样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br></pre></td></tr></table></figure><p>二维数组可以用嵌套的两个循环来遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 一个带有 5 行 2 列的数组 */</span></span><br><span class="line">   <span class="type">int</span> a[<span class="number">5</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">2</span>,<span class="number">4</span>&#125;, &#123;<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">4</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">   <span class="type">int</span> i, j;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出数组中每个元素的值 */</span></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++ )</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d] = %d\n&quot;</span>, i,j, a[i][j] );</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a[0][0] = 0</span><br><span class="line">a[0][1] = 0</span><br><span class="line">a[1][0] = 1</span><br><span class="line">a[1][1] = 2</span><br><span class="line">a[2][0] = 2</span><br><span class="line">a[2][1] = 4</span><br><span class="line">a[3][0] = 3</span><br><span class="line">a[3][1] = 6</span><br><span class="line">a[4][0] = 4</span><br><span class="line">a[4][1] = 8</span><br></pre></td></tr></table></figure><h1 id="字符串（字符数组）"><a href="#字符串（字符数组）" class="headerlink" title="字符串（字符数组）"></a>字符串（字符数组）</h1><p>字符串实际上是使用空字符 <code>\0 </code>结尾的一维字符数组。因此，字符串的实际长度总要多一位，<code>\0</code> 是用于标记字符串的结束。在定义一个字符串时不需要把 <code>\0</code>字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 <code>\0</code> 放在字符串的末尾。</p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>在C语言中，转义字符是以反斜杠<code>\</code>开头，后跟一个字符。它用来表示非打印字符，比如换行<code>\n</code>以及其他一些特殊的字符。</p><p>以下是C语言中常用的转义字符的完整列表：</p><p><code>\\</code>：反斜杠<br><code>\&#39;</code>：单引号<br><code>\&quot;</code>：双引号<br><code>\?</code>：问号<br><code>\a</code>：警报（响铃）<br><code>\b</code>：退格<br><code>\f</code>：换页<br><code>\n</code>：换行<br><code>\r</code>：回车<br><code>\t</code>：制表符（水平制表）<br><code>\v</code>：垂直制表<br><code>\0</code>：空字符<br><code>\ooo</code>：八进制表示的字符（其中 ooo 是一个八进制数，范围为 0-377）<br><code>\xhh</code>：十六进制表示的字符（其中 hh 是一个十六进制数，范围为 00-FF）</p><h2 id="定义与赋值"><a href="#定义与赋值" class="headerlink" title="定义与赋值"></a>定义与赋值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> site[<span class="number">7</span>] = &#123;<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> site[] = <span class="string">&quot;RUNOOB&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>实际上，字符串就是char类型的数组，各种操作都与数组大同小异。</strong></p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>字符串用<code>%s</code>输入输出，且输入时不用加取地址符<code>&amp;</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">char</span> ch[<span class="number">11</span>] = &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">  <span class="type">char</span> ch2[<span class="number">11</span>] = <span class="string">&quot;javatpoint&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Char Array Value is: %s\n&quot;</span>, ch);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;String Literal Value is: %s\n&quot;</span>, ch2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Char Array Value is: javatpoint</span><br><span class="line">String Literal Value is: javatpoint</span><br></pre></td></tr></table></figure><p><strong>注</strong></p><ul><li><code>getchar()</code></li></ul><p>读取一个字符，包括任何字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> a = getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, getchar());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, a);</span><br><span class="line">    </span><br><span class="line">    reutnr <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcdefg</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">a</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>gets()</code></li></ul><p>读取整行输入，直至遇到换行符，然后把换行符，储存其余字符，并在这些字符的末尾添加一个空字符使其成为一个 C 字符串。</p><p>1.<code>gets()</code>函数不安全。<br>2.C11标准委员会已经将其废除，建议能不用尽量不用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    gets(str);  <span class="comment">// 从标准输入流中读取一行字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World！</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World！</span><br></pre></td></tr></table></figure><ul><li><code>%[^\n]</code></li></ul><p><code>%[^\n]</code>是一种输入方法，用到了正则表达式相关用法。它代表输入至换行符时停止。同样的，<code>%[^1]</code>表示输入到1停止，以此类推。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%[^1]&quot;</span>, str);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxxxxxxxxxxx1</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>（能理解多少就理解多少，知道地址与变量的关系就行）</p><p><a href="https://www.runoob.com/cprogramming/c-pointers.html">指针-菜鸟驿站</a></p><p><a href="https://blog.csdn.net/u012060033/article/details/127600005">指针-CSDN</a></p><h2 id="取地址符"><a href="#取地址符" class="headerlink" title="取地址符"></a>取地址符</h2><p>每一个变量都有一个内存位置，每一个内存位置都定义了可使用 <code>&amp;</code> 运算符访问的地址，它表示了在内存中的一个地址。</p><p>下面一个例子输出变量的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p;              <span class="comment">// 定义指针变量</span></span><br><span class="line">    p = &amp;var_runoob;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a 变量的地址： %p\n&quot;</span>, p);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a 变量的地址： 0x7ffeeaae08d8</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_41823495/article/details/133692629">指针与地址</a></p><h2 id="取内容符"><a href="#取内容符" class="headerlink" title="取内容符"></a>取内容符</h2><p>指针变量定义格式：存储类型 数据类型 指针变量名；</p><p><code>int *p</code>: 定义了一个指针变量p,指向的数据是int类型的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="type">char</span> c=<span class="string">&#x27;v&#x27;</span>;</span><br><span class="line"><span class="type">char</span> *q=&amp;c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>, p, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>,q,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,a,*p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c %c\n&quot;</span>,c,*q);</span><br></pre></td></tr></table></figure><p><strong>访问指针所指向空间的内容用取内容运算符<code>*</code></strong></p><p>那么p变量存放的就是a的地址，q变量存放的是c的地址。</p><p>符号<code>*</code>可以访问地址里面的内容。</p><h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><p>在 C 语言中，数组名表示数组的地址，即数组首元素的地址。当我们在声明和定义一个数组时，该数组名就代表着该数组的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br></pre></td></tr></table></figure><p>在这里，<code>myArray</code> 是数组名，它表示整数类型的数组，包含 5 个元素。<code>myArray</code> 也代表着数组的地址，即第一个元素的地址。</p><p>数组名本身是一个常量指针，意味着它的值是不能被改变的，一旦确定，就不能再指向其他地方。</p><p>我们可以使用&amp;运算符来获取数组的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;myArray[<span class="number">0</span>]; <span class="comment">// 或者直接写作 int *ptr = myArray;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>ptr</code> 指针变量被初始化为 <code>myArray</code> 的地址，即数组的第一个元素的地址。</p><p>需要注意的是，虽然数组名表示数组的地址，但在大多数情况下，数组名会自动转换为指向数组首元素的指针。这意味着我们可以直接将数组名用于指针运算，例如在函数传递参数或遍历数组时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]); <span class="comment">// 数组名arr被当作指针使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    printArray(myArray, <span class="number">5</span>); <span class="comment">// 将数组名传递给函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>printArray</code> 函数接受一个整数数组和数组大小作为参数，我们将 <code>myArray</code> 数组名传递给函数，函数内部可以像使用指针一样使用 <code>arr</code> 数组名。</p><h2 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h2><p><strong>传递指针给函数</strong></p><p>C 语言允许传递指针给函数，只需要简单地 <strong>声明函数参数为指针类型</strong> 即可。</p><p>下面的实例中，我们传递一个无符号的 long 型指针给函数，并在函数内改变这个值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">getSeconds</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *par)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> sec;</span><br><span class="line">   getSeconds( &amp;sec );</span><br><span class="line">   <span class="comment">/* 输出实际值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Number of seconds: %ld\n&quot;</span>, sec );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getSeconds</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *par)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 获取当前的秒数 */</span></span><br><span class="line">   *par = time( <span class="literal">NULL</span> );</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number of seconds :1294450468</span><br></pre></td></tr></table></figure><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体（<code>struct</code>）是一种构造类型，它可以将不同的数据类型组合在一起形成一个新的数据类型，这种新的数据类型就是结构体。 </p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>定义和声明结构体的同时创建变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; stu; <span class="comment">// 创建了一个名为stu的结构体变量</span></span><br></pre></td></tr></table></figure><p>先定义结构体，然后声明变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>;</span> <span class="comment">// 创建了一个名为stu的结构体变量</span></span><br></pre></td></tr></table></figure><p>使用typedef定义别名，然后创建变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; Student;</span><br><span class="line"> </span><br><span class="line">Student stu; <span class="comment">// 创建了一个名为stu的结构体变量</span></span><br></pre></td></tr></table></figure><p>在结构体内部不初始化成员，而是在创建结构体变量后初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; stu = &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>, <span class="number">90.5f</span>&#125;; <span class="comment">// 在定义变量的同时进行初始化</span></span><br></pre></td></tr></table></figure><h2 id="访问-1"><a href="#访问-1" class="headerlink" title="访问"></a>访问</h2><p>使用指针访问结构体成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span> =</span> &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>, <span class="number">90.5f</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p</span> =</span> &amp;stu;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (*p).name); <span class="comment">// 使用指针访问结构体成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p-&gt;name); <span class="comment">// 另一种访问结构体成员的方式</span></span><br></pre></td></tr></table></figure><p>在结构体数组中存储数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; stu[<span class="number">3</span>]; <span class="comment">// 创建了一个结构体数组，可以存储3个学生的信息</span></span><br></pre></td></tr></table></figure><p>使用结构体指针访问结构体数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; stu[<span class="number">3</span>], *p;</span><br><span class="line"> </span><br><span class="line">p = stu;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (p+<span class="number">1</span>)-&gt;name); <span class="comment">// 访问第二个学生的名字</span></span><br></pre></td></tr></table></figure><p>在结构体中使用结构体类型成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">birthday</span>;</span></span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span> =</span> &#123;<span class="string">&quot;Tom&quot;</span>, &#123;<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>&#125;, <span class="number">90.5f</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, stu.birthday.year); <span class="comment">// 访问学生的出生年份</span></span><br></pre></td></tr></table></figure><h2 id="链表-结构体指针"><a href="#链表-结构体指针" class="headerlink" title="链表-结构体指针"></a>链表-结构体指针</h2><p><a href="https://blog.csdn.net/Ruaaa_iiiiiiiii/article/details/129499703">结构体链表</a></p><p>—end—</p>]]></content>
    
    
    <summary type="html">在C语言的学习过程中记了一些概念性的笔记，即使网上有很多教程，不缺我这些拙劣的文字，但自己写下来的，往往更适合自己吧......</summary>
    
    
    
    <category term="C与算法" scheme="http://flashfish777.cn/categories/C%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C" scheme="http://flashfish777.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="http://flashfish777.cn/posts/d95d7e09.html"/>
    <id>http://flashfish777.cn/posts/d95d7e09.html</id>
    <published>2023-10-08T10:43:53.000Z</published>
    <updated>2024-08-20T03:56:02.967Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一天晚上，一个懵懵懂懂的电脑小白决心创建一个自己的博客网页，他找了很多教程，因为什么都不懂，这期间他也遇到了很多困难。但他没有放弃，失败了就删掉文件从头开始，哪里不懂就上网查，终于搞出了自己的第一个博客网站……</strong></p><h3 id="一、自我介绍"><a href="#一、自我介绍" class="headerlink" title="一、自我介绍"></a>一、自我介绍</h3><div class="note info flat"><p><strong>首先允许我郑重的以主人的身份入驻我的博客网站！</strong></p></div><p>想当高手.jpg<br>本人男性取向女，梦想是<mark class="hl-label blue">做游戏</mark> （做很棒很棒的游戏，让所有人都玩我的游戏！），性格<mark class="hl-label green">INFP</mark> ，乐观开朗，跟不熟的人有点腼腆，喜欢运动，会踢足球，会打羽毛球乒乓球台球，但是不厉害，喜欢交朋友，喜欢敲代码，学习新知识，喜欢打游戏，什么游戏都玩 但是都很菜，最喜欢的是<mark class="hl-label orange">吃糖</mark> 。<br>此时此刻我才是一名刚刚接触计算机与编程的大一学生，在开学之前苦战两个月c语言考进了学校的计科院学生团队，有很多厉害的学长学姐带我学习，带我走进这个神奇的世界，一步步实现自己的梦想。</p><h3 id="二、为什么是博客"><a href="#二、为什么是博客" class="headerlink" title="二、为什么是博客"></a>二、为什么是博客</h3><p>刚开始的时候，编程对我来说只是一个遥远而神秘的词汇。每当看到屏幕上那些密密麻麻的代码，我就像是一个站在高墙之外的旁观者，既好奇又敬畏。但随着时间的推移，我逐渐发现，编程不仅仅是一堆冷冰冰的字符和逻辑，它更是一种创造力和思维方式的展现。每一次编写代码，都是在构建一个属于自己的世界，那种从无到有的过程，让我感受到了前所未有的成就感和满足感。使我更加坚定了我的目标。<br>我眼中的博客，是大佬们记录和分享知识的圣地，记录了学习的点滴进步，分享遇到的挑战和解决方案，以及各种奇闻异事或趁手的工具。在这里我可以写下任何我想写的东西。<br><strong>作为程序员，我们每天都在进行无穷无尽知识输入却很少有机会能够输出。输出的重要性一是在于反思和总结，能让我更加清晰地认识到自己的不足和需要改进的地方，二是太多的知识无法消化便可以先记录下来，学习是一个在实践中不断碰壁的过程，三是一个人的思考不如大家的思考，我可以同他人一起交流我的观点与思路，可以让我结识更多多志同道合的朋友和前辈，他们的经验和建议都能让我受益匪浅。</strong><br>而且我相信，<strong>在撰写博客的过程中，我可以逐渐形成了自己的写作风格和思考方式。可以尝试用通俗易懂的语言解释复杂的技术问题，用生动的例子和贴切的比喻帮助读者更好地理解编程概念。这本身也是对我的表达能力的一种很好的锻炼。同时我也希望通过我的努力，能够让更多的人感受到编程的乐趣和魅力，从而激发他们对编程的兴趣和热情。</strong><br>我相信，知识的力量在于传播和共享。通过分享我的学习心得和项目经验，我不仅能够帮助到那些正在学习编程的朋友，还能够从他们的反馈和建议中汲取新的灵感和思路。这种双向的交流和学习，可以让我感受到智慧的碰撞和传承的力量。</p><p>另外，谁不想拥有一个可以DIY的属于自己的炫酷的网页呢……</p><h3 id="三、未来"><a href="#三、未来" class="headerlink" title="三、未来"></a>三、未来</h3><p>对未来，我充满了期待和憧憬。我希望能够继续深化我的编程技能，特别是在游戏开发领域，因为我始终相信，游戏是传递快乐和创意的最佳载体。我要通过一点一滴的积累来实现我的目标。<br>我也希望能够将我的博客打造成一个更专业、更全面、更有影响力的平台。我会发表很多很多的文章来记录我的成长之路。<br>我相信，只要我们保持对知识的渴望和对梦想的追求，就一定能够在编程的道路上不断前行、不断超越自我，实现自己的理想！</p><hr><p>刚开始是总是什么都做不好，我在这里记录一些链接，帮助我写出更漂亮的博客文章</p><p><a href="https://butterfly.js.org/">Butterfly</a></p><p><a href="https://butterfly.js.org/posts/dc584b87/#Front-matter">页面</a></p><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">标签外挂</a></p><hr><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Clear"><a href="#Clear" class="headerlink" title="Clear"></a>Clear</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clear</span><br></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>注:我的库上传依赖一个github密钥，30天期，别忘了！</p>]]></content>
    
    
    <summary type="html">一些想说的.......</summary>
    
    
    
    
  </entry>
  
</feed>
