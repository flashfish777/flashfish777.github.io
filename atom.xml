<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>flashfish777</title>
  
  <subtitle>千载白衣酒，一生青女霜</subtitle>
  <link href="http://www.flashfish777.cn/atom.xml" rel="self"/>
  
  <link href="http://www.flashfish777.cn/"/>
  <updated>2025-03-29T17:18:23.000Z</updated>
  <id>http://www.flashfish777.cn/</id>
  
  <author>
    <name>青女</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker笔记</title>
    <link href="http://www.flashfish777.cn/posts/5c266b64.html"/>
    <id>http://www.flashfish777.cn/posts/5c266b64.html</id>
    <published>2025-03-29T17:18:23.000Z</published>
    <updated>2025-03-29T17:18:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>有没有一种技术能够避免部署对服务器环境的依赖，减少复杂的部署流程呢？<br>答案是肯定的，这就是<strong>Docker</strong>技术。<br>即便对Linux不熟悉，你也能<strong>轻松部署各种常见软件、项目</strong>。</p><h2 id="Docker部署的基本流程"><a href="#Docker部署的基本流程" class="headerlink" title="Docker部署的基本流程"></a>Docker部署的基本流程</h2><p>我们以部署MySQL为例：</p><p>如果是利用传统方式部署MySQL，大概的步骤有：</p><ul><li>搜索并下载MySQL安装包</li><li>上传至Linux环境</li><li>编译和配置环境</li><li>安装</li></ul><p>而使用Docker安装，仅仅需要一步即可，在命令行输入下面的命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>这里下载的不是安装包，而是<strong>镜像。</strong>  镜像中不仅包含了MySQL本身，还包含了其运行所需要的环境、配置、系统级函数库。因此它在运行时就有自己独立的环境，就可以跨系统运行，也不需要手动再次配置环境了。这套独立运行的隔离环境我们称为<strong>容器</strong>。</p><p>Docker会根据命令中的镜像名称自动搜索并下载镜像，<strong>那么问题来了，它是去哪里搜索和下载镜像的呢？这些镜像又是谁制作的呢？</strong></p><p>Docker官方提供了一个专门管理、存储镜像的网站，并对外开放了镜像上传、下载的权利。Docker官方提供了一些基础镜像，然后各大软件公司又在基础镜像基础上，制作了自家软件的镜像，全部都存放在这个网站。这个网站就成了Docker镜像交流的社区：</p><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p>基本上我们常用的各种软件都能在这个网站上找到，我们甚至可以自己制作镜像上传上去。</p><p><strong>总结一下</strong>：<br>Docker本身包含一个后台服务，我们可以利用Docker命令告诉Docker服务，帮助我们快速部署指定的应用。Docker服务部署应用时，首先要去搜索并下载应用对应的镜像，然后根据镜像创建并允许容器，应用就部署完成了。</p><p>用一幅图标示如下：<br><img src="https://image.flashfish777.cn/img/post_27_1.jpg"></p><h2 id="解读部署MySQL的命令"><a href="#解读部署MySQL的命令" class="headerlink" title="解读部署MySQL的命令"></a>解读部署MySQL的命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>docker run -d</code> ：创建并运行一个容器，-d则是让容器以后台进程运行</li><li><code>--name mysql</code> : 给容器起个名字叫mysql，名字唯一，用于区分不同的容器</li><li><code>-p 3306:3306</code> : 设置端口映射。</li><li>容器是隔离环境，外界不可访问。但是可以将宿主机端口映射容器内到端口，当访问宿主机指定端口时，就是在访问容器内的端口了。</li><li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式： <code>-p</code> 宿主机端口:容器内端口，示例中就是将宿主机的3306映射到容器内的3306端口</li><li><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些环境参数（可以在docker官方网站查阅哪些环境参数是必须在下载时指定的）</li><li>格式：<code>-e KEY=VALUE</code>，<code>KEY</code> 和 <code>VALUE</code> 都由容器内进程决定</li><li>案例中，<code>TZ=Asia/Shanghai</code>是设置时区；<code>MYSQL_ROOT_PASSWORD=123</code>是设置MySQL默认密码</li><li><code>mysql</code> : 设置镜像名称，Docker会根据这个名字搜索并下载镜像</li><li>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</li><li>在未指定 <code>TAG</code> 的情况下，默认是最新版本，也就是 <code>mysql:latest</code></li></ul><hr><h1 id="Docker常见命令"><a href="#Docker常见命令" class="headerlink" title="Docker常见命令"></a>Docker常见命令</h1><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>说明</strong></th><th><strong>文档地址</strong></th></tr></thead><tbody><tr><td>docker pull</td><td>拉取镜像</td><td><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td>docker push</td><td>推送镜像到DockerRegistry</td><td><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td>docker images</td><td>查看本地镜像</td><td><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td>docker rmi</td><td>删除本地镜像</td><td><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td>docker run</td><td>创建并运行容器（不能重复创建）</td><td><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td>docker stop</td><td>停止指定容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td>docker start</td><td>启动指定容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td>docker restart</td><td>重新启动容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td>docker rm</td><td>删除指定容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td>docker ps</td><td>查看容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td>docker logs</td><td>查看容器运行日志</td><td><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td>docker exec</td><td>进入容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td>docker save</td><td>保存镜像到本地压缩文件</td><td><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td>docker load</td><td>加载本地压缩文件到镜像</td><td><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td>docker inspect</td><td>查看容器详细信息</td><td><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table><p>用一副图来表示这些命令的关系：<br><img src="https://image.flashfish777.cn/img/post_27_2.jpg"></p><h2 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h2><p>对于一些常用docker命令我们可以为其起一个简单的别名：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改/root/.bashrc文件</span></span><br><span class="line">vi /root/.bashrc</span><br><span class="line">内容如下：</span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br><span class="line"></span><br><span class="line">alias <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span></span><br><span class="line">alias <span class="built_in">cp</span>=<span class="string">&#x27;cp -i&#x27;</span></span><br><span class="line">alias <span class="built_in">mv</span>=<span class="string">&#x27;mv -i&#x27;</span></span><br><span class="line">alias dps=<span class="string">&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span></span><br><span class="line">alias dis=<span class="string">&#x27;docker images&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -<span class="type">f</span> /<span class="type">etc</span>/<span class="type">bashrc</span> ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>然后，执行命令使别名生效</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /root/.bashrc</span><br></pre></td></tr></table></figure><hr><h1 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h1><h2 id="镜像结构"><a href="#镜像结构" class="headerlink" title="镜像结构"></a>镜像结构</h2><p>镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为镜像中包含了程序运行需要的系统函数库、环境、配置、依赖。</p><p>因此，<strong>自定义镜像本质就是依次准备好程序运行的基础环境、依赖、应用本身、运行配置等文件，并且打包而成。</strong></p><p>要从0部署一个Java应用，大概流程是这样：</p><ul><li><p>准备一个linux服务（CentOS或者Ubuntu均可）</p></li><li><p>安装并配置JDK</p></li><li><p>上传Jar包</p></li><li><p>运行jar包</p></li></ul><p>那因此，我们打包镜像也是分成这么几步：</p><ul><li><p>准备Linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可）</p></li><li><p>安装并配置JDK</p></li><li><p>拷贝jar包</p></li><li><p>配置启动脚本</p></li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会<strong>单独打包并标记一个唯一id</strong>，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><p>例如，第一步中需要的Linux运行环境，通用性就很强，所以Docker官方就制作了这样的只包含Linux运行环境的镜像。我们在制作java镜像时，就无需重复制作，直接使用Docker官方提供的CentOS或Ubuntu镜像作为基础镜像。然后再搭建其它层即可，这样逐层搭建，最终整个Java项目的镜像结构如图所示：<br><img src="https://image.flashfish777.cn/img/post_27_3.jpg"></p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。</p><p>而这种记录镜像结构的文件就称为<strong>Dockerfile</strong>。</p><p>其中的语法比较多，比较常用的有：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>FROM</strong></td><td>指定基础镜像</td><td><code>FROM centos:6</code></td></tr><tr><td><strong>ENV</strong></td><td>设置环境变量，可在后面指令使用</td><td><code>ENV key value</code></td></tr><tr><td><strong>COPY</strong></td><td>拷贝本地文件到镜像的指定目录</td><td><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td><strong>RUN</strong></td><td>执行Linux的shell命令，一般是安装过程的命令</td><td><code>RUN yum install gcc</code></td></tr><tr><td><strong>EXPOSE</strong></td><td>指定容器运行时监听的端口，是给镜像使用者看的</td><td>EXPOSE 8080</td></tr><tr><td><strong>ENTRYPOINT</strong></td><td>镜像中应用的启动命令，容器运行时调用</td><td>ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>例如，要基于Ubuntu镜像来构建一个Java应用，其Dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录、容器内时区</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar </span></span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="comment"># 指定项目监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>可以发现这样的操作还是十分复杂且麻烦的，如果我们需要自定义多个JAVA应用的镜像，那么我们每次都需要写这样繁琐的DockerFile吗？</p><p>当然不是！！可以发现，对于不同的JAVA应用，却都需要Linux系统环境、JDK环境这两层，只有上面的3层不同（<strong>因为jar包不同</strong>），所以，就有人提供了基础的系统加JDK环境，我们在此基础上制作java镜像，就可以省去JDK的配置了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>当Dockerfile文件写好以后，就可以利用命令来构建镜像了。<br>我们以一个简单的JAVA应用的镜像构建为例：</p><p>dockerfile具体内容：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>然后，执行命令，构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/demo</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t docker-demo:1.0 .</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>如果 Dockerfile 文件没有命名为 <code>Dockerfile</code>，而是使用了其他名称（例如 <code>Dockerfile.dev</code> 或 <code>myapp.Dockerfile</code>），在构建镜像时，需要使用 <code>-f</code> 或 <code>--file</code> 参数来指定 Dockerfile 的路径。<br>假设你的 Dockerfile 文件名为 <code>Dockerfile.dev</code>，并且位于当前目录下，你可以使用以下命令构建镜像：<br><code>docker build -f Dockerfile.dev -t myapp:1.0 .</code><br>其中：</p><ul><li><code>-f Dockerfile.dev</code>：指定使用 <code>Dockerfile.dev</code> 作为 Dockerfile。</li><li><code>-t myapp:1.0</code>：将构建的镜像命名为 <code>myapp</code>，并打上标签 <code>1.0</code>。</li><li><code>.</code>：指定当前目录为构建上下文。</li></ul><hr><h1 id="数据卷挂载"><a href="#数据卷挂载" class="headerlink" title="数据卷挂载"></a>数据卷挂载</h1><h2 id="为什么需要数据卷挂载"><a href="#为什么需要数据卷挂载" class="headerlink" title="为什么需要数据卷挂载"></a>为什么需要数据卷挂载</h2><p>容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便。</p><ul><li><p>如果要升级MySQL版本，需要销毁旧容器，那么数据岂不是跟着被销毁了？</p></li><li><p>MySQL、Nginx容器运行后，如果我要修改其中的某些配置该怎么办？</p></li><li><p>我想要让Nginx代理我的静态资源怎么办？</p></li></ul><p>因此，容器提供程序的运行环境，但是<strong>程序运行产生的数据、程序运行依赖的配置都应该与容器解耦</strong>。</p><p><strong>此时我们就需要使用数据卷</strong></p><h2 id="什么是数据卷"><a href="#什么是数据卷" class="headerlink" title="什么是数据卷"></a>什么是数据卷</h2><p><strong>数据卷（volume）</strong> 是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机****目录</strong>之间映射的桥梁。</p><p>以Nginx为例，在Nginx中有两个关键的目录：</p><ul><li><p><code>html</code>：放置一些静态资源</p></li><li><p><code>conf</code>：放置配置文件</p></li></ul><p>如果要让Nginx代理我们的静态资源，最好是放到<code>html</code>目录；如果我们要修改Nginx的配置，最好是找到<code>conf</code>下的<code>nginx.conf</code>文件。</p><p>但遗憾的是，容器运行的Nginx所有的文件都在容器内部。所以我们必须利用数据卷将两个目录与宿主机目录关联，方便我们操作。如图：<br><img src="https://image.flashfish777.cn/img/post_27_4.jpg"></p><p>在上图中：</p><ul><li><p>我们创建了两个数据卷：<code>conf</code>、<code>html</code></p></li><li><p>Nginx容器内部的<code>conf</code>目录和<code>html</code>目录分别与两个数据卷关联。</p></li><li><p>而数据卷conf和html分别指向了宿主机的<code>/var/lib/docker/volumes/conf/_data</code>目录和<code>/var/lib/docker/volumes/html/_data</code>目录</p></li></ul><p>这样以来，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机的<code>conf</code>和<code>html</code>目录关联起来，我们称为<strong>挂载</strong>。此时，我们操作宿主机的<code>/var/lib/docker/volumes/html/_data</code>就是在操作容器内的<code>/usr/share/nginx/html/_data</code>目录。只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了（<strong>也就是容器内的目录和宿主机的目录双向绑定</strong>）</p><p><strong>需要注意的是：</strong><br><code>var/lib/docker/volumes/</code> 是 Docker 默认存储<strong>命名数据卷</strong> 的目录。</p><ul><li><p>当你使用 <code>docker volume create</code> 命令创建一个命名数据卷时，Docker 会在 <code>/var/lib/docker/volumes/</code> 目录下为该卷创建一个子目录。</p></li><li><p>例如，创建一个名为 <code>my-volume</code> 的数据卷：<br>  <code>docker volume create my-volume</code><br>  这个卷的实际数据会存储在 <code>/var/lib/docker/volumes/my-volume/_data/</code> 目录下。</p></li></ul><h2 id="数据卷命令"><a href="#数据卷命令" class="headerlink" title="数据卷命令"></a>数据卷命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>说明</strong></th><th><strong>文档地址</strong></th></tr></thead><tbody><tr><td>docker volume create</td><td>创建数据卷</td><td><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td>docker volume ls</td><td>查看所有数据卷</td><td><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td>docker volume rm</td><td>删除指定数据卷</td><td><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td>docker volume inspect</td><td>查看某个数据卷的详情</td><td><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td>docker volume prune</td><td>清除数据卷</td><td><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table><hr><h1 id="本地数据卷挂载"><a href="#本地数据卷挂载" class="headerlink" title="本地数据卷挂载"></a>本地数据卷挂载</h1><p>由于路径过长，且匿名数据卷对应的路径为docker帮我们随机生成的路径名，因此对mysql升级时，当卸载掉旧的容器，重新生成新的容器时，就会造成数据卷中的信息丢失（<strong>Docker会为新的容器随机创建一个新的匿名数据卷</strong>）。<strong>因此，我们就需要使用本地数据卷，将容器目录与宿主机指定目录挂载。</strong></p><h2 id="挂载本地目录或文件"><a href="#挂载本地目录或文件" class="headerlink" title="挂载本地目录或文件"></a>挂载本地目录或文件</h2><p>挂载语法与数据卷类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="comment"># 挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br></pre></td></tr></table></figure><hr><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p><strong>容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接会失败。</strong></p><p>因此我们就需要使用docker自定义网络的功能，当容器接入到我们自定义的网络中时，我们可以不通过容器的ip地址，而是通过容器名直接访问到对应的容器。</p><h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><p>常见命令有：</p><table><thead><tr><th><strong>命令</strong></th><th><strong>说明</strong></th><th><strong>文档地址</strong></th></tr></thead><tbody><tr><td>docker network create</td><td>创建一个网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td></tr><tr><td>docker network ls</td><td>查看所有网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td></tr><tr><td>docker network rm</td><td>删除指定网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td></tr><tr><td>docker network prune</td><td>清除未使用的网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td></tr><tr><td>docker network connect</td><td>使指定容器连接加入某网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td></tr><tr><td>docker network disconnect</td><td>使指定容器连接离开某网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td></tr><tr><td>docker network inspect</td><td>查看网络详细信息</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td></tr></tbody></table><hr><h1 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker compose"></a>Docker compose</h1><h2 id="为什么会使用到DockerCompose"><a href="#为什么会使用到DockerCompose" class="headerlink" title="为什么会使用到DockerCompose"></a>为什么会使用到DockerCompose</h2><p>可以看到，我们部署一个简单的java项目，其中包含3个容器：</p><ul><li>MySQL</li><li>Nginx</li><li>Java项目</li></ul><p>而稍微复杂的项目，其中还会有各种各样的其它中间件，需要部署的东西远不止3个。如果还像之前那样手动的逐一部署，就太麻烦了。</p><p>而Docker Compose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>。<strong>它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器。</strong></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><code>docker-compose</code> 文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于 <code>service</code> 就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数非常相似。</p><p>我们可以比对着<code>docker run</code>的语法来看<code>DockerCompose</code>的语法：<br>用docker run部署MySQL的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network hmall</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>用<code>docker-compose.yml</code>文件来定义，就是这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">new:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure><p>对比如下：</p><table><thead><tr><th><strong>docker run 参数</strong></th><th><strong>docker compose 指令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>–name</td><td>container_name</td><td>容器名称</td></tr><tr><td>-p</td><td>ports</td><td>端口映射</td></tr><tr><td>-e</td><td>environment</td><td>环境变量</td></tr><tr><td>-v</td><td>volumes</td><td>数据卷配置</td></tr><tr><td>–network</td><td>networks</td><td>网络</td></tr></tbody></table><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose [OPTIONS] [COMMAND]</span><br></pre></td></tr></table></figure><p>其中，OPTIONS和COMMAND都是可选参数，比较常见的有：</p><table><thead><tr><th><strong>类型</strong></th><th><strong>参数或指令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Options</td><td></td><td></td></tr><tr><td></td><td>-f</td><td>指定compose文件的路径和名称</td></tr><tr><td></td><td>-p</td><td>指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td></tr><tr><td>Commands</td><td></td><td></td></tr><tr><td></td><td>up</td><td>创建并启动所有service容器</td></tr><tr><td></td><td>down</td><td>停止并移除所有容器、网络</td></tr><tr><td></td><td>ps</td><td>列出所有启动的容器</td></tr><tr><td></td><td>logs</td><td>查看指定容器的日志</td></tr><tr><td></td><td>stop</td><td>停止容器</td></tr><tr><td></td><td>start</td><td>启动容器</td></tr><tr><td></td><td>restart</td><td>重启容器</td></tr><tr><td></td><td>top</td><td>查看运行的进程</td></tr><tr><td></td><td>exec</td><td>在指定的运行中容器中执行命令</td></tr></tbody></table><p>—end—</p>]]></content>
    
    
    <summary type="html">一篇关于 Docker 的入门与实践笔记，简单记录了一些容器化技术的核心概念和基础操作...</summary>
    
    
    
    <category term="笔记" scheme="http://www.flashfish777.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Docker" scheme="http://www.flashfish777.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Lua学习笔记</title>
    <link href="http://www.flashfish777.cn/posts/9285b404.html"/>
    <id>http://www.flashfish777.cn/posts/9285b404.html</id>
    <published>2025-01-20T15:00:00.000Z</published>
    <updated>2025-01-20T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger info flat"><p><strong>酝酿中…</strong></p></div>]]></content>
    
    
    <summary type="html">记录一下学习Lua的笔记...</summary>
    
    
    
    <category term="笔记" scheme="http://www.flashfish777.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Lua" scheme="http://www.flashfish777.cn/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>微派冬令营面试</title>
    <link href="http://www.flashfish777.cn/posts/174932e5.html"/>
    <id>http://www.flashfish777.cn/posts/174932e5.html</id>
    <published>2024-12-30T19:00:00.000Z</published>
    <updated>2024-12-30T19:00:00.000Z</updated>
    
    
    <summary type="html">学长推荐了微派冬令营，就去投了简历，一开始没有想过简历能过，可谁知道第一次面试的我就经历了四轮面试...</summary>
    
    
    
    <category term="面经" scheme="http://www.flashfish777.cn/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="http://www.flashfish777.cn/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>SQL语法简记</title>
    <link href="http://www.flashfish777.cn/posts/7c005a55.html"/>
    <id>http://www.flashfish777.cn/posts/7c005a55.html</id>
    <published>2024-12-26T16:00:00.000Z</published>
    <updated>2024-12-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p><strong>记的是MySQL的语法，但是应该大差不差</strong></p></div><h1 id="数据库的规范化"><a href="#数据库的规范化" class="headerlink" title="数据库的规范化"></a>数据库的规范化</h1><h2 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h2><p><strong>第一范式是指数据库的每一列都是不可分割的基本数据项</strong>，而下面这样的就存在可分割的情况：</p><ul><li>学生（姓名，电话号码）</li></ul><p>电话号码实际上包括了<code>家用座机电话</code>和<code>移动电话</code>，因此它可以被拆分为：</p><ul><li>学生（姓名，座机号码，手机号码）</li></ul><p><strong>满足第一范式是关系型数据库最基本的要求！</strong></p><h2 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h2><p><strong>第二范式要求表中必须存在主键，且其他的属性必须完全依赖于主键</strong>，比如：</p><ul><li>学生（学号，姓名，性别）</li></ul><p>学号是每个学生的唯一标识，每个学生都有着不同的学号，因此此表中存在一个主键，并且每个学生的所有属性都依赖于学号，学号发生改变就代表学生发生改变，姓名和性别都会因此发生改变，所有此表满足第二范式。</p><h2 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h2><p><strong>在第二范式的基础上，要求一个数据库表中不包含已在其他表中已包含的非主属性信息，也就是说，非主键列必须直接依赖于主键，不能依赖于其他非主键列</strong></p><ul><li>学生借书情况（借阅编号，学生学号，书籍编号，书籍名称，书籍作者）</li></ul><p>实际上书籍编号依赖于借阅编号，而书籍名称和书籍作者依赖于书籍编号，因此存在传递依赖的情况，我们可以将书籍信息进行单独拆分为另一张表：</p><ul><li>学生借书情况（借阅编号，学生学号，书籍编号）</li><li>书籍（书籍编号，书籍名称，书籍作者）</li></ul><p>这样就消除了传递依赖，从而满足第三范式。</p><h2 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h2><p>BCNF作为第三范式的补充，假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：</p><p>(仓库ID, 存储物品ID) →(管理员ID, 数量)</p><p>(管理员ID, 存储物品ID) → (仓库ID, 数量)</p><p>所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：</p><p>(仓库ID) → (管理员ID)</p><p>(管理员ID) → (仓库ID)</p><p>即存在关键字段决定关键字段的情况，如果修改管理员ID，那么就必须逐一进行修改，所以其不符合BCNF范式。<br>也就是出现了 管理员ID 和 仓库ID 都能够确定一个仓库 即 出现了<strong>两个唯一值</strong>相互确定。</p><hr><h1 id="数据库定义语言（DDL）"><a href="#数据库定义语言（DDL）" class="headerlink" title="数据库定义语言（DDL）"></a>数据库定义语言（DDL）</h1><p><strong>写命令时 要大写就都大写 小写就都小写</strong></p><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><ol><li>创建一个数据库：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database 数据库名</span><br></pre></td></tr></table></figure><p>为了能够支持中文，我们在创建时可以设定编码格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 数据库名称 <span class="keyword">DEFAULT</span> CHARSET utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span><br></pre></td></tr></table></figure><p><code>IF NOT EXISTS</code>表示 只有当<strong>指定的数据库名</strong>不存在时才创建<strong>对应的数据库</strong></p><ol start="2"><li>删除一个数据库：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database 数据库名</span><br></pre></td></tr></table></figure><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><p><strong>[]里的内容代表可以省略</strong></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>（1）以下的数据类型用于字符串存储：</strong></p><ul><li>char(n)可以存储任意字符串，但是是固定长度为n，如果插入的长度小于定义长度时，则用空格填充。</li><li>varchar(n)也可以存储任意数量字符串，长度不固定，但不能超过n，不会用空格填充。</li></ul><p><strong>（2）以下数据类型用于存储数字：</strong></p><ul><li>smallint用于存储小的整数，范围在 (-32768，32767)</li><li>int用于存储一般的整数，范围在 (-2147483648，2147483647)</li><li>bigint用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807)</li><li>float用于存储单精度小数</li><li>double用于存储双精度的小数</li></ul><p><strong>（3）以下数据类型用于存储时间：</strong></p><ul><li>date存储日期</li><li>time存储时间</li><li>year存储年份</li><li>datetime用于混合存储日期+时间</li></ul><h3 id="列级约束条件"><a href="#列级约束条件" class="headerlink" title="列级约束条件"></a>列级约束条件</h3><p><strong>一个列可以有多个约束</strong></p><p>列级约束有六种：主键<code>Primary key</code>、外键<code>foreign key</code> 、唯一 <code>unique</code>、检查 <code>check</code>（CHECK约束用于在数据库中对表的数据进行验证和限制。它允许你定义一个条件，该条件必须在插入或更新数据时满足才能成功执行操作。） 、默认<code>default</code> 、非空&#x2F;空值 <code>not null/ null</code></p><h3 id="表级约束条件"><a href="#表级约束条件" class="headerlink" title="表级约束条件"></a>表级约束条件</h3><p>表级约束有四种：主键、外键、唯一、检查</p><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(列名 数据类型[列级约束条件],</span><br><span class="line">             列名 数据类型[列级约束条件],</span><br><span class="line">             ...</span><br><span class="line">             [,表级约束条件])</span><br></pre></td></tr></table></figure><p>如果需要在创建的时候 添加外键，下面是一个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> Orders (</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_CustomerID] <span class="keyword">FOREIGN KEY</span> (CustomerID) <span class="keyword">REFERENCES</span> Customers (CustomerID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在这个例子中，创建了一个名为”Orders”的表，它有三个列：OrderID、CustomerID和OrderDate。然后，通过FOREIGN KEY约束，将CustomerID列设置为外键，参照了另一个名为”Customers”的表中的CustomerID列作为主键。<br>通过定义外键约束，我们可以确保在”Orders”表中的CustomerID列中的值必须存在于”Customers”表的CustomerID列中，从而维护了表之间的关系完整性。</p><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 表名 <span class="comment">/*添加列*/</span>[<span class="keyword">ADD</span> 新列名 数据类型[列级约束条件]]</span><br><span class="line">                <span class="comment">/*删除列*/</span>[<span class="keyword">DROP</span> <span class="keyword">COLUMN</span> 列名[restrict<span class="operator">|</span>cascade]]</span><br><span class="line">                <span class="comment">/*修改列*/</span>[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> 列名 新数据类型]</span><br></pre></td></tr></table></figure><p>我们可以通过 <code>ADD</code> 来添加一个新的列，通过 <code>DROP</code> 来删除一个列，不过我们可以添加restrict或cascade，默认是restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除，而cascade会强制连带引用此列的约束、视图一起删除。还可以通过 <code>ALTER</code> 来修改此列的属性。</p><h3 id="表创建后-对列追加约束"><a href="#表创建后-对列追加约束" class="headerlink" title="表创建后 对列追加约束"></a>表创建后 对列追加约束</h3><p>你也可以在创建表之后，使用ALTER TABLE语句来添加约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> Employees</span><br><span class="line">MODIFY ID <span class="type">INT</span> <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span>;</span><br></pre></td></tr></table></figure><p>这个语句会修改”Employees”表，使得”ID”列不能有NULL值，并且所有的值必须是唯一的。</p><h3 id="表创建后-对列追加外键约束"><a href="#表创建后-对列追加外键约束" class="headerlink" title="表创建后 对列追加外键约束"></a>表创建后 对列追加外键约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> Orders (</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 添加外键约束</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> Orders</span><br><span class="line"><span class="keyword">ADD CONSTRAINT</span> FK_CustomerID <span class="keyword">FOREIGN KEY</span> (CustomerID) <span class="keyword">REFERENCES</span> Customers (CustomerID);</span><br></pre></td></tr></table></figure><h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><p>注意：并非所有的数据库系统都支持RENAME TABLE语句例如MySQL支持</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> <span class="operator">&lt;</span>old_table_name<span class="operator">&gt;</span> <span class="keyword">TO</span> <span class="operator">&lt;</span>new_table_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="删除外键约束"><a href="#删除外键约束" class="headerlink" title="删除外键约束"></a>删除外键约束</h3><p>首先使用DESCRIBE语句查看表的结构，确定要删除外键约束的表和列名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> table_name;</span><br></pre></td></tr></table></figure><p>（将table_name替换为实际的表名）</p><p>使用ALTER TABLE语句和DROP FOREIGN KEY子句删除外键约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">FOREIGN KEY</span> constraint_name;</span><br></pre></td></tr></table></figure><p>（将table_name替换为实际的表名，constraint_name替换为实际的外键约束名称）。</p><hr><h1 id="数据库操纵语言（DML）"><a href="#数据库操纵语言（DML）" class="headerlink" title="数据库操纵语言（DML）"></a>数据库操纵语言（DML）</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>, 值<span class="number">2</span>, 值<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名(列名<span class="number">1</span>, 列名<span class="number">2</span>) <span class="keyword">VALUES</span>(值<span class="number">1</span>, 值<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>我们也可以一次性向数据库中插入多条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名(列名<span class="number">1</span>, 列名<span class="number">2</span>) <span class="keyword">VALUES</span>(值<span class="number">1</span>, 值<span class="number">2</span>), (值<span class="number">1</span>, 值<span class="number">2</span>), (值<span class="number">1</span>, 值<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>我们可以通过<code>update</code>语句来更新表中的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 列名<span class="operator">=</span>值,... <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure><p>注意，SQL语句中的等于判断是<code>=</code></p><p><strong>警告：如果忘记添加<code>WHERE</code>字句来限定条件，将使得整个表中此列的所有数据都被修改！</strong></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>我们可以通过使用<code>delete</code>来删除表中的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名</span><br></pre></td></tr></table></figure><p><strong>不加条件限制会把表中数据全部删除</strong></p><p>通过这种方式，将删除表中全部数据，我们也可以使用<code>where</code>来添加条件，只删除指定的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure><hr><h1 id="数据库查询语言（DQL）"><a href="#数据库查询语言（DQL）" class="headerlink" title="数据库查询语言（DQL）"></a>数据库查询语言（DQL）</h1><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><h3 id="单表查询-1"><a href="#单表查询-1" class="headerlink" title="单表查询"></a>单表查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 指定查询某一列数据</span></span><br><span class="line"><span class="keyword">SELECT</span> 列名[,列名] <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">-- 会以别名显示此列</span></span><br><span class="line"><span class="keyword">SELECT</span> 列名 别名 <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">-- 查询所有的列数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">-- 只查询不重复的值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 列名 <span class="keyword">FROM</span> 表名</span><br></pre></td></tr></table></figure><p>我们也可以添加<code>where</code>字句来限定查询目标：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure><p><strong>常用查询条件</strong>：</p><ul><li>一般的比较运算符，包括<code>=、&gt;、&lt;、&gt;=、&lt;=、!=</code>等。</li><li>是否在集合中：<code>in</code>、<code>not in</code></li><li>字符模糊匹配：<code>like</code>，<code>not like</code></li><li>多重条件连接查询：<code>and</code>、<code>or</code>、<code>not</code></li><li>空值和非空值：<code>is null</code>、<code>is not null</code><br>模糊查询举例：</li></ul><ol><li>匹配以特定字符开头的值：<br> 示例：<code>SELECT * FROM 表名 WHERE 列名 LIKE &#39;abc%&#39;;</code><br> 这将返回以”abc”开头的所有值，如”abc123”、”abcdef”等。</li><li>匹配以特定字符结尾的值：<br> 示例：<code>SELECT * FROM 表名 WHERE 列名 LIKE &#39;%xyz&#39;;</code><br> 这将返回以”xyz”结尾的所有值，如”abcxyz”、”123xyz”等。</li><li>匹配包含特定字符的值：<br> 示例：<code>SELECT * FROM 表名 WHERE 列名 LIKE &#39;%def%&#39;;</code><br> 这将返回包含”def”的所有值，如”abcdef”、”defghi”等。</li><li>匹配任意单个字符：<br> 示例：<code>SELECT * FROM 表名 WHERE 列名 LIKE &#39;_bc&#39;;</code><br> 这将返回第一个字符为任意字符，后面跟着”bc”的值，如”abc”、”1bc”等。</li><li>匹配指定数量的任意字符：<br> 示例：<code>SELECT * FROM 表名 WHERE 列名 LIKE &#39;a__&#39;;</code><br> 这将返回以”a”开头，后面跟着任意两个字符的值，如”abc”、”axy”等。</li><li>使用<strong>IN</strong>条件：<br> 假设您有一个名为”users”的表，其中包含一个名为”country”的列。您想要查询所有来自”美国”和”英国”的用户。您可以使用IN条件来实现这个查询：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> country <span class="keyword">IN</span> (<span class="string">&#x27;美国&#x27;</span>, <span class="string">&#x27;英国&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="7"><li>使用<strong>NOT IN</strong>条件：<br> 假设您有一个名为”products”的表，其中包含一个名为”category”的列。您想要查询不属于”电子产品”和”家居用品”类别的产品。您可以使用NOT IN条件来实现这个查询：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> category <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;电子产品&#x27;</span>, <span class="string">&#x27;家居用品&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p>我们可以通过order by来将查询结果进行排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名 <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><p>使用ASC表示升序排序，使用DESC表示降序排序，默认为升序。</p><p>我们也可以可以同时添加多个排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名<span class="number">1</span> <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>, 列名<span class="number">2</span> <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><p>这样会先按照列名1进行排序，每组列名1相同的数据再按照列名2排序。</p><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>聚集函数一般用作统计，包括：</p><ul><li><code>count([distinct]*)</code>统计所有的行数（distinct表示去重再统计，下同）</li><li><code>count([distinct]列名)</code>统计某列的值总和</li><li><code>sum([distinct]列名)</code>求一列的和（注意必须是数字类型的）</li><li><code>avg([distinct]列名)</code>求一列的平均值（注意必须是数字类型）</li><li><code>max([distinct]列名)</code>求一列的最大值</li><li><code>min([distinct]列名)</code>求一列的最小值</li></ul><p>一般聚集函数是这样使用的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> 列名) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 </span><br></pre></td></tr></table></figure><p>当你使用 <code>COUNT(*)</code> 时，它会计算表中的所有行，无论列值是否为NULL。这包括了所有的记录，无论它们的列值是否为空。<br>换句话说，<code>COUNT(*)</code> 会返回表中的总行数，而不仅仅是那些至少有一列非NULL值的行数<br>如果你想要计算至少有一列非NULL值的行数，你需要指定那一列，像这样：<code>COUNT(列名)</code>。这样，只有当指定列的值非NULL时，那一行才会被计数。</p><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p>通过使用<code>group by</code>来对查询结果进行分组，它需要结合聚合函数一起使用， 聚合函数会对组中的数据进行计算统计：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">sum</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 列名</span><br></pre></td></tr></table></figure><p>我们还可以添加<code>having</code>来限制分组条件：<br><code>HAVING</code>子句主要是用来对聚合函数（如<code>COUNT</code>, <code>SUM</code>, <code>AVG</code>, <code>MAX</code>, <code>MIN</code>等）的结果进行过滤或条件判断。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">sum</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 列名 <span class="keyword">HAVING</span> 约束条件</span><br></pre></td></tr></table></figure><p><strong>分组的依据：在分组查询中，具有相同值的数据会被分到同一组中</strong></p><p><code>group by</code>就是把<strong>一列</strong>通过<strong>某个条件</strong>分成不同的部分进行<strong>聚合函数</strong>计算</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>我们可以逐页获取数据，而不是一次性获取全部数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 LIMIT 起始位置,数量</span><br></pre></td></tr></table></figure><hr><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询"></a>多表查询</h3><p>多表查询是同时查询的两个或两个以上的表，多表查询会提通过连接转换为单表查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span>, 表<span class="number">2</span></span><br></pre></td></tr></table></figure><p>直接这样查询会得到两张表的笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span>, 表<span class="number">2</span> <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure><p>这样，只会从笛卡尔积的结果中得到满足条件的数据。<br><strong>注意： 如果两个表中都带有此属性，需要添加表名前缀来指明是哪一个表的数据。</strong></p><p>以下是一个示例，假设您有两个表： <code>employee</code> 和 <code>departments</code> ，它们都具有一个名为”name”的属性。您想要查询每个员工所属的部门名称以及员工的姓名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.name <span class="keyword">AS</span> employee_name, departments.name <span class="keyword">AS</span> department_name</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们使用AS关键字为每个属性指定别名。<code>employees.name``被重命名为employee_name</code>，<code>departments.name</code>被重命名为<code>department_name</code>。这样，我们可以明确地引用每个属性，并避免冲突。</p><h3 id="自身连接查询"><a href="#自身连接查询" class="headerlink" title="自身连接查询"></a>自身连接查询</h3><p>自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 别名<span class="number">1</span>, 表名 别名<span class="number">2</span></span><br></pre></td></tr></table></figure><p>其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。</p><p>以下是别名的其他应用场景：</p><ol><li>列别名：可以为查询结果中的列指定一个更具描述性的名称。<br> 示例：<code>SELECT 列名 AS 别名 FROM 表名;</code><br> 例如，可以使用别名将”salary”列的名称更改为”工资”：<br> <code>SELECT salary AS 工资 FROM employees;</code></li><li>表别名：可以为查询中的表指定一个简短的别名，以减少重复输入。<br> 示例：<code>SELECT 列名 FROM 表名 AS 别名;</code><br> 例如，可以使用别名将”employees”表的名称更改为”e”：</li></ol><h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><p>外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 左表名 <span class="operator">&lt;</span>连接方式<span class="operator">&gt;</span> 右表名 <span class="keyword">ON</span> 连接条件;</span><br></pre></td></tr></table></figure><ul><li>通过使用<code>inner join</code>进行内连接，只会返回两个表满足条件的交集部分：</li><li>通过使用<code>left join</code>进行左连接，不仅会返回两个表满足条件的交集部分，也会返回左边表中的全部数据，而在右表中缺失的数据会使用<code>null</code>来代替（右连接<code>right join</code>同理，只是反过来而已，这里就不再介绍了）</li><li>我们还可以将三张表（甚至更多外连接到一起）</li></ul><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>我们可以将查询的结果作为另一个查询的条件，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名<span class="number">1</span> <span class="operator">=</span> (<span class="keyword">SELECT</span> 列名<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件)</span><br></pre></td></tr></table></figure><p>也就是 查询到了 列1 和 列2 相等部分的 重合的数据</p><p><strong>使用嵌套查询进行子查询</strong>：<br>假设您有一个名为”orders”的表，其中包含订单信息，包括订单号（order_id）和订单金额（amount）。您想要查询所有订单金额大于平均订单金额的订单。您可以使用嵌套查询来实现这个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id, amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(amount) <span class="keyword">FROM</span> orders);</span><br></pre></td></tr></table></figure><p>在上述示例中，内部查询<code>(SELECT AVG(amount) FROM orders)</code>计算了订单金额的平均值，并将其用于外部查询的筛选条件。</p><p><strong>使用嵌套查询进行连接查询</strong>：<br>假设您有两个表：”customers”和”orders”，其中”customers”表包含客户信息，”orders”表包含订单信息。您想要查询每个客户的订单数量。您可以使用嵌套查询和连接查询来实现这个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.customer_id, c.customer_name, (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> customer_id <span class="operator">=</span> c.customer_id) <span class="keyword">AS</span> order_count</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c;</span><br></pre></td></tr></table></figure><p>在上述示例中，内部查询<code>(SELECT COUNT(*) FROM orders WHERE customer_id = c.customer_id)</code>计算了每个客户的订单数量，并将其作为外部查询的一个列。</p><hr><h1 id="数据库控制语言（DCL）"><a href="#数据库控制语言（DCL）" class="headerlink" title="数据库控制语言（DCL）"></a>数据库控制语言（DCL）</h1><h2 id="创建用户："><a href="#创建用户：" class="headerlink" title="创建用户："></a>创建用户：</h2><p>在MySQL中，你可以使用以下语法来创建一个用户并为其设置密码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;username&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这个命令将创建一个名为 ‘username’ 的用户，并将其密码设置为 ‘password’。</p><p>如果你希望用户能够从任何主机连接到MySQL服务器，可以将 <code>&#39;localhost&#39;</code> 替换为 <code>&#39;%&#39;</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure><p>我们也可以在创建时不设置密码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> 用户名;</span><br></pre></td></tr></table></figure><h2 id="登陆用户"><a href="#登陆用户" class="headerlink" title="登陆用户"></a>登陆用户</h2><p>首先需要添加一个环境变量，然后我们通过cmd去登陆mysql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">login <span class="operator">-</span>u 用户名 <span class="operator">-</span>p</span><br></pre></td></tr></table></figure><p>输入密码后即可登陆此用户</p><h2 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h2><p>我们可以通过使用<code>grant</code>来为一个数据库用户进行授权：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">all</span> [权限<span class="number">1</span>,权限<span class="number">2.</span>..(列<span class="number">1</span>,...)] <span class="keyword">on</span> 数据库.表 <span class="keyword">to</span> 用户 [<span class="keyword">with</span> <span class="keyword">grant</span> option]</span><br></pre></td></tr></table></figure><p>其中all代表授予所有权限，当数据库和表为<code>*</code>，代表为所有的数据库和表都授权。如果在最后添加了<code>with grant option</code>，那么被授权的用户还能将已获得的授权继续授权给其他用户。</p><p>授予权限的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privileges <span class="keyword">ON</span> database.table <span class="keyword">TO</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;host&#x27;</span>;</span><br></pre></td></tr></table></figure><p>其中，’privileges’是你要授予的权限，可以是单个权限或多个权限的组合，用逗号分隔。’database.table’指定了你要授予权限的数据库和表。‘username‘@’host’指定了你要授予权限的用户和主机。</p><p>例如，如果要将SELECT和INSERT权限授予用户’john’，并且限制他只能在数据库’exampledb’中的表’table1’上执行这些操作，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> exampledb.table1 <span class="keyword">TO</span> <span class="string">&#x27;john&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li>ALL PRIVILEGES：授予用户对指定数据库或表的所有权限，包括 <code>SELECT</code> 、 <code>INSERT</code> 、 <code>UPDATE</code> 、 <code>DELETE</code> 、 <code>CREATE</code> 、 <code>DROP</code> 等。</li><li><code>SELECT</code>：授予用户对指定表的SELECT权限，允许其查询表中的数据。</li><li><code>INSERT</code>：授予用户对指定表的INSERT权限，允许其向表中插入新的数据。</li><li><code>UPDATE</code>：授予用户对指定表的UPDATE权限，允许其修改表中已有的数据。</li><li><code>DELETE</code>：授予用户对指定表的DELETE权限，允许其删除表中的数据。</li><li><code>CREATE</code>：授予用户创建新表、数据库或索引的权限。</li><li><code>DROP</code>：授予用户删除表、数据库或索引的权限。</li><li><code>ALTER</code>：授予用户修改表结构的权限，包括添加、修改和删除表的列。</li><li><code>GRANT OPTION</code>：授予用户将自己拥有的权限授予其他用户的权限。</li></ol><p>我们可以使用<code>revoke</code>来收回一个权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">all</span> [权限<span class="number">1</span>,权限<span class="number">2.</span>..(列<span class="number">1</span>,...)] <span class="keyword">on</span> 数据库.表 <span class="keyword">from</span> 用户</span><br></pre></td></tr></table></figure><hr><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><h3 id="创建单列索引"><a href="#创建单列索引" class="headerlink" title="创建单列索引"></a>创建单列索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (column_name);</span><br></pre></td></tr></table></figure><h3 id="创建多列索引"><a href="#创建多列索引" class="headerlink" title="创建多列索引"></a>创建多列索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (column1, column2, ...);</span><br></pre></td></tr></table></figure><h3 id="创建唯一索引"><a href="#创建唯一索引" class="headerlink" title="创建唯一索引"></a>创建唯一索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name <span class="keyword">ON</span> table_name (column_name);</span><br></pre></td></tr></table></figure><h3 id="创建全文索引"><a href="#创建全文索引" class="headerlink" title="创建全文索引"></a>创建全文索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX index_name <span class="keyword">ON</span> table_name (column_name);</span><br></pre></td></tr></table></figure><h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h2><h3 id="查看表的索引"><a href="#查看表的索引" class="headerlink" title="查看表的索引"></a>查看表的索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="查看索引的定义"><a href="#查看索引的定义" class="headerlink" title="查看索引的定义"></a>查看索引的定义</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE TABLE</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><h4 id="删除表的索引"><a href="#删除表的索引" class="headerlink" title="删除表的索引"></a>删除表的索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure><h4 id="删除表的所有索引"><a href="#删除表的所有索引" class="headerlink" title="删除表的所有索引"></a>删除表的所有索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> table_name <span class="keyword">DROP</span> INDEX <span class="keyword">ALL</span>;</span><br></pre></td></tr></table></figure><p>请注意，创建索引可以提高查询效率，但也会增加插入、更新和删除操作的开销。因此，在创建索引时需要权衡查询性能和修改性能之间的平衡。</p><p><strong>无论是否使用索引，最终都能查询到相应的内容</strong>。索引只是一种优化技术，<strong>它可以加快查询的速度，但并不影响查询结果的准确性</strong>。</p><p>在没有索引的情况下，数据库会对整个表进行全表扫描，逐行比对查询条件，最终找到符合条件的数据。这种方式可以保证查询结果的准确性，但在大型表或者有大量数据的情况下，查询可能会较慢。</p><p>而使用索引后，数据库可以利用索引的数据结构，直接定位到符合查询条件的数据行，避免了全表扫描的开销，从而提高了查询的速度。索引可以加快查询的效率，但不会改变查询结果。</p><p><strong>需要注意的是</strong>，索引的创建和维护也会带来一定的开销，特别是在频繁进行插入、更新和删除操作的情况下。因此，在设计数据库时，需要根据具体的查询需求和数据特点，选择合适的列创建索引，以获得最佳的查询性能。</p><hr><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图本质就是一个查询的结果，不过我们每次都可以通过打开视图来按照我们想要的样子查看数据。既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。</p><h2 id="如何创建视图"><a href="#如何创建视图" class="headerlink" title="如何创建视图"></a>如何创建视图</h2><p>我们可以通过<code>create view</code>来创建视图;</p><p><strong>我们可以把 创建出的视图 理解为是对原表部分列的引用 因此当我们对某个可修改的视图进行修改时 原表对应的部分也会被修改</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称(列名) <span class="keyword">as</span> 子查询语句 [<span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION];</span><br></pre></td></tr></table></figure><p>（<code>WITH CHECK OPTION</code>是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用<code>select</code>语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。）</p><h2 id="视图需要遵守的规则"><a href="#视图需要遵守的规则" class="headerlink" title="视图需要遵守的规则"></a>视图需要遵守的规则</h2><ul><li><p>若视图是<strong>由两个以上基本表导出的</strong>，则此视图<strong>不允许更新</strong>。</p></li><li><p>若视图的字段<strong>来自字段表达式或常数</strong>，则<strong>不允许</strong>对此视图执行INSERT和UPDATE操作，<strong>但允许</strong>执行DELETE操作。</p></li><li><p>若视图的字段来自<strong>集函数</strong>，则此视图<strong>不允许更新</strong>。</p></li><li><p>若视图定义中含有<strong>GROUP BY子句</strong>，则此视图<strong>不允许更新</strong>。</p></li><li><p>若视图定义中含有<strong>DISTINCT短语</strong>，则此视图<strong>不允许更新</strong>。</p></li><li><p>若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC：<br>  <code>CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade &gt; (SELECT AVG(Grade) FROM SC);</code> 　　<br>  导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。</p></li><li><p>一个不允许更新的视图上定义的视图也不允许更新</p></li></ul><h3 id="如何删除一个视图："><a href="#如何删除一个视图：" class="headerlink" title="如何删除一个视图："></a>如何删除一个视图：</h3><p>通过<code>drop</code>来删除一个视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> apptest</span><br></pre></td></tr></table></figure><hr><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的SQL语句来完成，这些数据库操作语句就可以构成一个事务！只有Innodb引擎支持事务</p><p>我们通过以下例子来探究以下事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;   #开始事务</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span>;  #回滚事务</span><br><span class="line"><span class="keyword">savepoint</span> 回滚点;  #添加回滚点</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> 回滚点; #回滚到指定回滚点</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>; #提交事务</span><br><span class="line"><span class="comment">-- 一旦提交，就无法再进行回滚了！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>如果事务中的所有操作都执行成功，可以使用<code>COMMIT</code>提交事务，将结果永久保存到数据库中。</li><li>如果事务中的任何操作失败或出现错误，可以使用<code>ROLLBACK</code>回滚事务，将所有操作都撤销到事务开始之前的状态。</li></ul><hr><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器就像其名字一样，在某种条件下会自动触发，在<code>select</code>&#x2F;<code>update</code>&#x2F;<code>delete</code>时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。</p><ul><li><code>insert</code>操作时，新的内容会被插入到new表中；</li><li>在<code>delete</code>操作时，旧的内容会被移到old表中，我们仍可在old表中拿到被删除的数据；</li><li>在<code>update</code>操作时，旧的内容会被移到old表中，新的内容会出现在new表中。</li></ul><h2 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">&#123;BEFORE <span class="operator">|</span> AFTER&#125; &#123;<span class="keyword">INSERT</span> <span class="operator">|</span> <span class="keyword">UPDATE</span> <span class="operator">|</span> <span class="keyword">DELETE</span>&#125; <span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">   </span><br><span class="line"># 触发器的操作逻辑</span><br><span class="line">   </span><br></pre></td></tr></table></figure><h2 id="修改触发器"><a href="#修改触发器" class="headerlink" title="修改触发器"></a>修改触发器</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">&#123;BEFORE <span class="operator">|</span> AFTER&#125; &#123;<span class="keyword">INSERT</span> <span class="operator">|</span> <span class="keyword">UPDATE</span> <span class="operator">|</span> <span class="keyword">DELETE</span>&#125; <span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">   </span><br><span class="line"># 修改后的触发器的操作逻辑</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>触发器的操作逻辑：是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</p><h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [IF <span class="keyword">EXISTS</span>] trigger_name;</span><br></pre></td></tr></table></figure><h2 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS</span><br></pre></td></tr></table></figure><p>—end—</p>]]></content>
    
    
    <summary type="html">学了下MySQL的语法，简单记了些笔记...</summary>
    
    
    
    <category term="笔记" scheme="http://www.flashfish777.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据库" scheme="http://www.flashfish777.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java语法简记</title>
    <link href="http://www.flashfish777.cn/posts/a57fb7e2.html"/>
    <id>http://www.flashfish777.cn/posts/a57fb7e2.html</id>
    <published>2024-12-25T16:00:00.000Z</published>
    <updated>2024-12-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>笔记较为简单，主要记录了一些Java与C#某些地方的相似与区别，适合简单浏览速通，不细致不深入。</strong></p><p><img src="https://image.flashfish777.cn/img/post_23_1.jpg"></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// final定义常量</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在Java中，整数类型包括以下几个：</p><table><thead><tr><th>类型</th><th>大小</th><th>范围</th></tr></thead><tbody><tr><td>byte 字节型</td><td>8个bit，也就是1个字节</td><td>-128~+127</td></tr><tr><td>short 短整形</td><td>16个bit，也就是2个字节</td><td>-32768~+32767</td></tr><tr><td>int 整形</td><td>32个bit，也就是4个字节</td><td>-2147483648 ~ +2147483647</td></tr><tr><td>long 长整形（+L&#x2F;l）</td><td>64个bit，也就是8个字节</td><td>9223372036854775808 ~ +9223372036854775807</td></tr><tr><td>float 单精度浮点型（+F&#x2F;f）</td><td>32个bit，也就是4个字节</td><td></td></tr><tr><td>double 双精度浮点型</td><td>64个bit，也就是8个字节</td><td></td></tr><tr><td>char 字符型</td><td>16个bit，也就是2字节，它不带符号</td><td>0 ~ 65535</td></tr><tr><td>boolen 布尔类型</td><td></td><td>true，false</td></tr></tbody></table><h2 id="隐式类型转换：小转大，大不转小"><a href="#隐式类型转换：小转大，大不转小" class="headerlink" title="隐式类型转换：小转大，大不转小"></a>隐式类型转换：小转大，大不转小</h2><h2 id="强转与C一样：（数据类型）变量"><a href="#强转与C一样：（数据类型）变量" class="headerlink" title="强转与C一样：（数据类型）变量"></a>强转与C一样：（数据类型）变量</h2><h2 id="字符串支持“-”拼接"><a href="#字符串支持“-”拼接" class="headerlink" title="字符串支持“+”拼接"></a>字符串支持“+”拼接</h2><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>相同名称的方法可以定义多次，传入不同类型的参数和返回类型，在使用时会自动匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sum</span><span class="params">(String a, String b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XX.sum(<span class="number">1.5</span>, <span class="number">2.2</span>); <span class="comment">// 使用时会自动匹配方法</span></span><br><span class="line">XX.sum(<span class="number">6</span>, <span class="number">9</span>);</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    Person()&#123;    <span class="comment">//构造方法不需要指定返回值，并且方法名称与类名相同</span></span><br><span class="line">        name = <span class="string">&quot;小明&quot;</span>;   <span class="comment">//构造方法会在对象创建时执行，我们可以将各种需要初始化的操作都在这里进行处理</span></span><br><span class="line">        age = <span class="number">18</span>;</span><br><span class="line">        sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不写构造方法就会有一个默认的什么也没有的构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法可以重构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="type">int</span> age, String sex)&#123;   <span class="comment">//跟普通方法是一样的</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Person()&#123;</span><br><span class="line">        name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法会在new的时候自动执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();   <span class="comment">//这里的new Person()其实就是在调用无参构造方法</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小红&quot;</span>, <span class="number">15</span>, <span class="string">&quot;女&quot;</span>); <span class="comment">// 这里使用有参的构造方法</span></span><br><span class="line">    System.out.println(p.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h2><p>一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。在静态方法中，无法获取成员变量的值，但是静态方法可以访问到静态变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line">    <span class="keyword">static</span> String info;    <span class="comment">//这里我们定义一个info静态变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包-namespace"><a href="#包-namespace" class="headerlink" title="包 &#x3D; namespace"></a>包 &#x3D; namespace</h2><p>packa，import</p><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><table><thead><tr><th></th><th>当前类</th><th>同一个包下的类</th><th>不同包下的子类</th><th>不同包下的类</th></tr></thead><tbody><tr><td>public</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>protected</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>默认</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>private</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table><h2 id="继承：extends"><a href="#继承：extends" class="headerlink" title="继承：extends"></a>继承：extends</h2><p>（如果父类没有使用默认构造函数，子类需要调用super父类构造方法（super代表这个子类的父类））</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;    <span class="comment">//因为学生职业已经确定，所以说学生直接填写就可以了</span></span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;学生&quot;</span>);   <span class="comment">//使用super代表父类，父类的构造方法就是super()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的名字是 &quot;</span>+name+<span class="string">&quot;，我在学习！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断一个对象是什么类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(person <span class="keyword">instanceof</span> Student) &#123;   <span class="comment">//我们可以使用instanceof关键字来对类型进行判断</span></span><br><span class="line">        System.out.println(<span class="string">&quot;对象是 Student 类型的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(person <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象是 Person 类型的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>注意，方法的重写不同于之前的方法重载，不要搞混了，方法的重载是为某个方法提供更多种类，而方法的重写是覆盖原有的方法实现，比如我们现在不希望使用Object类中提供的equals方法，那么我们就可以将其重写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//重写方法可以添加 @Override 注解，有关注解我们会在最后一章进行介绍，这个注解默认情况下可以省略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;   <span class="comment">//重写方法要求与父类的定义完全一致</span></span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//如果传入的对象为null，那肯定不相等</span></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person) &#123;     <span class="comment">//只有是当前类型的对象，才能进行比较，要是都不是这个类型还比什么</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) obj;   <span class="comment">//先转换为当前类型，接着我们对三个属性挨个进行比较</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(person.name) &amp;&amp;    <span class="comment">//字符串内容的比较，不能使用==，必须使用equals方法</span></span><br><span class="line">                    <span class="built_in">this</span>.age == person.age &amp;&amp;       <span class="comment">//基本类型的比较跟之前一样，直接==</span></span><br><span class="line">                    <span class="built_in">this</span>.sex.equals(person.sex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;   <span class="comment">//通过添加abstract关键字，表示这个类是一个抽象类</span></span><br><span class="line">    <span class="keyword">protected</span> String name;   <span class="comment">//大体内容其实普通类差不多</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">protected</span> String sex;</span><br><span class="line">    <span class="keyword">protected</span> String profession;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, String sex, String profession)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.profession = profession;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span>;   <span class="comment">//抽象类中可以具有抽象方法，也就是说这个方法只有定义，没有方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类的子类必须要实现抽象类中所有抽象方法，除非抽象类的子类也是抽象类。</p><p>抽象类无法直接实例化。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>interface定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Study</span> &#123;    <span class="comment">//使用interface表示这是一个接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>;    <span class="comment">//接口中只能定义访问权限为public抽象方法，其中public和abstract关键字可以省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>implements实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Study</span> &#123;   <span class="comment">//使用implements关键字来实现接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;学生&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;    <span class="comment">//实现接口时，同样需要将接口中所有的抽象方法全部实现</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我会学习！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口可以多继承</strong></p><p><strong>接口可以设置默认实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;   <span class="comment">//使用default关键字为接口中的方法添加默认实现</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我是默认实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口可以继承自其他接口</strong></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举类也可以添加成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    RUNNING(<span class="string">&quot;睡觉&quot;</span>), STUDY(<span class="string">&quot;学习&quot;</span>), SLEEP(<span class="string">&quot;睡觉&quot;</span>);   <span class="comment">//无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;    <span class="comment">//枚举的成员变量</span></span><br><span class="line">    Status(String name)&#123;    <span class="comment">//覆盖原有构造方法（默认private，只能内部使用！）</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;   <span class="comment">//获取封装的成员变量</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包装类与特殊包装类"><a href="#包装类与特殊包装类" class="headerlink" title="包装类与特殊包装类"></a>包装类与特殊包装类</h2><p><code>BigInteger</code> ， 超大整数类型，没有限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> BigInteger.valueOf(Long.MAX_VALUE);    <span class="comment">//表示Long的最大值，轻轻松松</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BigDecimal</code> ， 更高精度浮点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">i</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">10</span>);</span><br><span class="line">    i = i.divide(BigDecimal.valueOf(<span class="number">3</span>), <span class="number">100</span>, RoundingMode.CEILING);</span><br><span class="line">      <span class="comment">//计算10/3的结果，精确到小数点后100位</span></span><br><span class="line">      <span class="comment">//RoundingMode是舍入模式，就是精确到最后一位时，该怎么处理，这里CEILING表示向上取整</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h2><p>定义函数参数时加三个‘.’</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String... strings)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用时可以传任意数量的实参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    person.test(<span class="string">&quot;1！&quot;</span>, <span class="string">&quot;5！&quot;</span>, <span class="string">&quot;哥们在这跟你说唱&quot;</span>); <span class="comment">//这里我们可以自由传入任意数量的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时strings为数组</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>如果我们仅仅是想要判断两个字符串的内容是否相同，不要使用<code>==</code>，String类重载了equals方法用于判断和比较内容是否相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    System.out.println(str1.equals(str2));   <span class="comment">//字符串的内容比较，一定要用equals</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>这个类型是专门用于构造字符串的，我们可以使用它来对字符串进行拼接、裁剪等操作，它就像一个字符串编辑器，弥补了字符串不能修改的不足：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();   <span class="comment">//一开始创建时，内部什么都没有</span></span><br><span class="line">    builder.append(<span class="string">&quot;AAA&quot;</span>);   <span class="comment">//我们可以使用append方法来讲字符串拼接到后面</span></span><br><span class="line">    builder.append(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">    System.out.println(builder.toString());   <span class="comment">//当我们字符串编辑完成之后，就可以使用toString转换为字符串了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuilder类的编辑操作也非常多，这里就不一一列出了。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span>&lt;T&gt; &#123;   <span class="comment">//泛型类需要使用&lt;&gt;，我们需要在里面添加1 - N个类型变量</span></span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    T value;   <span class="comment">//T会根据使用时提供的类型自动变成对应类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, T value)</span> &#123;   </span><br><span class="line">    <span class="comment">//这里T可以是任何类型，但是一旦确定，那么就不能修改了</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要让某个变量支持引用确定了任意类型的泛型，那么可以使用 <code>?</code> 通配符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Test&lt;?&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;Integer&gt;();</span><br><span class="line">    test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;String&gt;();</span><br><span class="line">      <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> test.value;    </span><br><span class="line">      <span class="comment">//但是注意，如果使用通配符，那么由于类型不确定，所以说具体类型同样会变成Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型只能确定为一个引用类型，基本类型是不支持的</strong></p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> test(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">test</span><span class="params">(T t)</span>&#123;   <span class="comment">//在返回值类型前添加&lt;&gt;并填写泛型变量表示这个是一个泛型方法</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;   <span class="comment">//设定类型参数上界，必须是Number或是Number的子类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>缓冲字节流：</p><ul><li><code>BufferedInputStream</code>:<br>要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)))&#123;   <span class="comment">//传入FileInputStream</span></span><br><span class="line">        System.out.println((<span class="type">char</span>) bufferedInputStream.read());   </span><br><span class="line">        <span class="comment">//操作和原来的流是一样的</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BufferedInputStream</code><strong>操作和原来的<code>FileInputStream</code>流是一样的</strong></p><ul><li><code>BufferedOutputStream</code>:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)))&#123;</span><br><span class="line">        outputStream.write(<span class="string">&quot;lbwnb&quot;</span>.getBytes());</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程的实现方式：</p><h3 id="继承Thread类："><a href="#继承Thread类：" class="headerlink" title="继承Thread类："></a>继承Thread类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t03</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;线程03&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//开启线程</span></span><br><span class="line">        t01.run();</span><br><span class="line">        t02.run();</span><br><span class="line">        t03.run();</span><br><span class="line">        <span class="comment">// 不会启动线程，不会分配新的分支栈。（这种方式就是单线程。）</span></span><br><span class="line">        <span class="comment">// start()方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码任务完成之后，瞬间就结束了。</span></span><br><span class="line">        <span class="comment">// 这段代码的任务只是为了开启一个新的栈空间，只要新的栈空间开出来，start()方法就结束了。线程就启动成功了。</span></span><br><span class="line">        <span class="comment">// 启动成功的线程会自动调用run方法，并且run方法在分支栈的栈底部（压栈）。</span></span><br><span class="line">        <span class="comment">// run方法在分支栈的栈底部，main方法在主栈的栈底部。run和main是平级的。</span></span><br><span class="line">        t01.start();</span><br><span class="line">        t02.start();</span><br><span class="line">        t03.start();</span><br><span class="line">        <span class="comment">//设置线程名（补救的设置线程名的方式）</span></span><br><span class="line">        t01.setName(<span class="string">&quot;线程01&quot;</span>);</span><br><span class="line">        t02.setName(<span class="string">&quot;线程02&quot;</span>);</span><br><span class="line">        <span class="comment">//设置主线程名称</span></span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Thread.currentThread() 获取当前正在执行线程的对象</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//run方法是每个线程运行过程中都必须执行的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Runnable接口："><a href="#实现Runnable接口：" class="headerlink" title="实现Runnable接口："></a>实现Runnable接口：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">myRun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();<span class="comment">//将一个任务提取出来，让多个线程共同去执行</span></span><br><span class="line">        <span class="comment">//封装线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRun, <span class="string">&quot;线程01&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRun, <span class="string">&quot;线程02&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t03</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRun, <span class="string">&quot;线程03&quot;</span>);</span><br><span class="line">        <span class="comment">//开启线程</span></span><br><span class="line">        t01.start();</span><br><span class="line">        t02.start();</span><br><span class="line">        t03.start();</span><br><span class="line">        <span class="comment">//通过匿名内部类的方式创建线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="comment">//可以使用lambda表达式简化</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;线程04&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义线程类，实现Runnable接口</span></span><br><span class="line"><span class="comment">//这并不是一个线程类，是一个可运行的类，它还不是一个线程。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="线程锁和线程同步"><a href="#线程锁和线程同步" class="headerlink" title="线程锁和线程同步"></a>线程锁和线程同步</h3><p>synchronized关键字也可以作用于方法上，调用此方法时也会获取锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) add();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) add();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);  <span class="comment">//主线程停止1秒，保证两个线程执行完成</span></span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解-特性"><a href="#注解-特性" class="headerlink" title="注解 &#x3D; 特性"></a>注解 &#x3D; 特性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span> <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123; </span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—end—</p>]]></content>
    
    
    <summary type="html">大概速通了下Java的语法，感觉和C#很像，简单记了些笔记...</summary>
    
    
    
    <category term="笔记" scheme="http://www.flashfish777.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://www.flashfish777.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java大作业-车辆租赁系统</title>
    <link href="http://www.flashfish777.cn/posts/b15d19f.html"/>
    <id>http://www.flashfish777.cn/posts/b15d19f.html</id>
    <published>2024-12-23T16:00:00.000Z</published>
    <updated>2024-12-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这学期在学校上了一学期<strong>面向对象程序设计</strong>和<strong>数据库原理及应用</strong>的课程（虽然但是其实是自己学的上课根本不可能听），做了一学期的实验后，也是最终迎来了Java和数据库的大作业。</p><p>这两门课的大作业其实差不多，Java的是用Java设计一个系统，拓展是可以用到数据库；数据库的是创建一个数据库，拓展是用一种语言结合数据库实现一个系统。所以我就当成一项做了。</p><p>其实大多数课程我是不那么认真的。Java是因为我感觉和C#很像，所以学起来其实很轻松，数据库的话以后会用到我就也认真学了，虽然学校教的是微软的SQL Server我学的是MySQL。</p><p>这个作业我做的十分认真（其实大多数情况都是找现成的或者直接丢给AI来写），甚至前前后后改了三版。我就当练习面向对象的思想和原则以及设计模式来做的了，所以有哪里我觉得抽象的不好或者哪里耦合比较高我都会去绞尽脑汁改很多遍。</p><p><a href="https://github.com/flashfish777/VehicleManager-Java">GitHub项目地址</a></p><hr><h1 id="项目实现"><a href="#项目实现" class="headerlink" title="项目实现"></a>项目实现</h1><p>ps:从没想过有一天我会结合我的实验报告来写文章…</p><p><img src="https://image.flashfish777.cn/img/post_22_2.png" alt="功能结构图"></p><p><img src="https://image.flashfish777.cn/img/post_22_3.png" alt="代码结构图"></p><p>系统的第一版确定了基本代码结构。我选择了<strong>单例模式</strong>作为主要的设计模式，因为前不久才刚刚学到，正好巩固一下，加深一下对它的理解，而且也比较符合系统需求。</p><p>图中 <code>Managers</code> 文件夹中的类都是单例，我让它们每个类负责自己的事情：</p><ul><li><p><code>SqlManager</code> 中封装了使用JDBC通过Java代码链接数据库并执行SQL语句的方法，如从数据库中获取车辆、获取用户、获取租借记录、写入数据、删除表等。<br>  <img src="https://image.flashfish777.cn/img/post_22_1.png"></p></li><li><p><code>DataManager</code> 中封装了车辆表、用户表、租借表的List列表，并提供公共方法通过 <code>SqlManager</code> 从数据库中获取各表，使以下三种 <code>Manager</code> 在初始化时可以获取各自的数据表。同时SqlManager还提供私有方法将各表存到数据库中。</p></li><li><p><code>VehicleManager</code> 是车辆类的管理类，其中封装了添加、修改、删除等对车辆列表的操作。</p></li><li><p><code>RentManager</code> 是租借管理类，负责提供营业额及对租借记录的管理。</p></li><li><p><code>UsersManager</code> 是用户管理类，负责账户账号的登录、添加、删除，系统的进入等。</p></li></ul><p>在第一版中， <code>DataManager</code> 是不存在的。用户对于数据的管理是直接通过车辆、租借、用户的Manager调用SqlManager中的方法来直接对数据库进行增删查改的。在第一版完成之后，我发现<strong>系统对数据库的操作过于频繁</strong>：查询一次车辆就要查询一次数据库，获取某个信息要查询一次数据库，添加、删除、修改等都要查询数据库。<br>这样不仅<strong>降低了程序的效率，还造成了代码的冗余</strong>，于是我想到使用集合框架，在程序开始时查询一次数据库，将所有如车辆、用户、租借的信息存储到集合框架中，在程序运行过程中只需要从集合框架中查询、添加、修改信息，最后在程序结束时或是需要的地方再将这些数据统一存回数据库，对数据库的操作只需要两次，同时使增删查改等操作更加简单，大大提升了程序的效率。于是便有了 <code>DataManager</code> 。</p><p>后来，我发现这种方法固然方便快捷，但这降低了程序的容错率，调取与存储数据只在程序的开始与结束进行，一旦程序异常退出，数据就会出现异常，而且程序存在很多的隐患，很多的非法输入可能会导致程序报错。</p><p>为了解决以上问题，我先是从程序的隐患下手，我发现大多数容易出错的地方都在输入上。例如需要 <code>Int</code> 时输入字符就会报错等。所以我加工出了 <code>IO</code> 类代替普通的 <code>Scanner</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">IO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**输出 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">_Speak</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**输入Int */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">_ReadInt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> input.nextInt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            _Speak(<span class="string">&quot;输入错误！请重新输入：&quot;</span>);</span><br><span class="line">            input.nextLine();</span><br><span class="line">            <span class="keyword">return</span> _ReadInt();</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**输入String */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">_ReadStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> input.next();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            _Speak(<span class="string">&quot;输入错误！请重新输入：&quot;</span>);</span><br><span class="line">            input.nextLine();</span><br><span class="line">            <span class="keyword">return</span> _ReadStr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**输入Float */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">_ReadFloat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> input.nextFloat();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            _Speak(<span class="string">&quot;输入错误！请重新输入：&quot;</span>);</span><br><span class="line">            input.nextLine();</span><br><span class="line">            <span class="keyword">return</span> _ReadFloat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>IO</code> 类中对 <code>Input</code> 操作进行包装，使用异常处理，如果监测到异常就通过递归调用重新执行输入方法，这样既<strong>减少了事故触发的可能</strong>，也<strong>避免了在系统中到处添加异常处理的麻烦</strong>。</p><p>接下来，我开始着手于数据的存储与调用。既然两次太少，那多调几次就行了呗！我用<strong>多线程</strong>不就好了嘛！</p><p>于是我将 <code>DataManager</code> 继承 <code>Runnable</code> 类，将数据的存储写在 <code>run()</code> 方法中调用，这样就实现了新开辟一个线程去异步存储数据，避免了数据过大存储时会卡顿，然后在关键的地方适当多次启动线程存储数据就好啦。</p><p>对于Vehicle车辆和User用户的封装这里就不过多解释了，感兴趣的可以直接去项目仓库下载源码。这里放下程序入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Managers.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 初始化数据库</span></span><br><span class="line">        SqlManager.Init();</span><br><span class="line">        <span class="comment">// 初始化数据管理器</span></span><br><span class="line">        DataManager.Init();</span><br><span class="line">        <span class="comment">// 初始化车辆管理器</span></span><br><span class="line">        VehicleManager.Init();</span><br><span class="line">        <span class="comment">// 初始化租借管理器</span></span><br><span class="line">        RentManager.Init();</span><br><span class="line">        <span class="comment">// 初始化用户管理器</span></span><br><span class="line">        UsersManager.Init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 登录</span></span><br><span class="line">        UsersManager.Instance.Login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.flashfish777.cn/img/post_22_4.png" alt="url类关系图"><br>（类关系图很乱其实也看不清，V2源码文件夹里有这张图片）</p><p>到第二版系统就已经非常完善了，第三版是为了适应数据库的大作业，在前两版的开发中我对数据库的造诣不是很深，都是乱开的表乱存的。在第三版中，我<strong>优化了数据库之间的关系，也使用了更高级的存储与查询方式</strong>，使系统更加完美。</p><hr><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>通过这次车辆租赁系统的开发实践，我深刻体会到了理论知识与实际应用相结合的重要性。从最初简单的功能实现，到不断优化架构设计，再到最终完善数据库关系，整个过程让我收获颇丰。</p><p>在技术层面，我巩固了以下知识点：</p><ol><li>单例模式在实际项目中的合理应用</li><li>集合框架作为内存缓存提升系统性能</li><li>多线程异步处理耗时操作</li><li>输入输出的安全封装</li><li>数据库设计与优化技巧</li></ol><p>更重要的是，这次项目让我对软件开发的工程化思维有了更深的理解。从发现问题（如频繁数据库操作导致性能问题），到分析问题（找出性能瓶颈），再到解决问题（引入DataManager作为缓存层），这个过程培养了我的系统思考能力和工程实践能力。</p><p>这个项目不仅是一次课程作业，更是我编程成长路上的重要里程碑。希望未来能继续在实践中学习，在学习中进步。</p><p>—end—</p>]]></content>
    
    
    <summary type="html">学校的面向对象程序设计课程的大作业，使用Java语言与MySQL数据库设计的车辆租赁系统，收获颇多...</summary>
    
    
    
    <category term="项目" scheme="http://www.flashfish777.cn/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="非游戏" scheme="http://www.flashfish777.cn/categories/%E9%A1%B9%E7%9B%AE/%E9%9D%9E%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="Java" scheme="http://www.flashfish777.cn/tags/Java/"/>
    
    <category term="OOP" scheme="http://www.flashfish777.cn/tags/OOP/"/>
    
    <category term="数据库" scheme="http://www.flashfish777.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>VSCode插件推荐2</title>
    <link href="http://www.flashfish777.cn/posts/20a54dfa.html"/>
    <id>http://www.flashfish777.cn/posts/20a54dfa.html</id>
    <published>2024-12-15T20:00:00.000Z</published>
    <updated>2024-12-15T20:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>众所可能不周知，经过了很长时间的磨合，我已经变成了<mark class="hl-label blue">VSCode</mark>的形状。<br>这玩意儿用起来实在是太爽，<strong>轻量级</strong>、<strong>速度快</strong>，<strong>插件多到爆炸</strong>，想干什么都能找到对应的工具。而且界面还特别清爽，<strong>主题随便换</strong>，实在不满意甚至能DIY，想怎么折腾就怎么折腾，完全符合我的审美。<br>拿我自己来说，作为一名计算机专业的大学牲，我有无数的专业课需要实操，<code>Cpp</code>、<code>Java</code>、<code>Python</code>、<code>Web前端</code>、<code>数据库</code>、<code>计网</code>，除此之外，我自己还在学习<code>C#</code>。虽然对我来说都不难，但多的让人头大。<br>很多人学<code>Cpp</code>时下载<code>DevC++</code>、<code>Clion</code>，学<code>Java</code>时下载<code>IDEA</code>，学<code>Python</code>时又下<code>PyCharm</code>，学数据库时又下<code>SqlServer</code>、下<code>navicat</code>，学前端时又下<code>WebStorm</code>，想写<code>C#</code>还要下<code>Visual Studio</code>。先不说运行时的效率，就光这些“大块头”就要把存储空间占满了，动辄十几几十个G，没一个省油的灯，况且对于我们学习学校的课程来说，完全用不到这么专业的IDE。<br>我从大学刚刚开始就接触了VSCode，之后也一直在用（中途用过一次VS2022，每次打开都要把我的内存占满，最后直接卸载了）。学习C语言和算法时我安装C&#x2F;Cpp的插件，学Java时我安装Java语言的插件，学数据库时我安装数据库插件用VSCode连接数据库，学习使用git时我用VSCode的终端就能打开bash，还能通过插件连接github储存库进行一键式的版本管理，什么东西都是即安即用，最多配个环境。<br>有同学要问了老师老师你安这么多插件VSCode不也会超负荷的吗？当然不会。VSCode独特的配置文件可以将不同配置文件中的插件与设置隔离起来，哪个文件夹用哪个配置文件，就会加载对应的插件，完全不用担心插件太多太杂。</p><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1em421j7wZ&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><p><img src="https://image.flashfish777.cn/img/post_21_1.jpg" alt="配置文件"></p><p>总之，真的十分推荐VSCode！这次将再次推荐一些好用的插件 -&gt;&gt;&gt;</p><hr><h1 id="功能篇"><a href="#功能篇" class="headerlink" title="功能篇"></a>功能篇</h1><h2 id="any-rule"><a href="#any-rule" class="headerlink" title="any-rule"></a>any-rule</h2><p>你要的“正则”都在这！</p><p><img src="https://image.flashfish777.cn/img/post_21_2.jpg" alt="any-rule"></p><p><strong>Any-rule</strong> 是一款正则表达式插件，旨在帮助开发者快速生成和使用正则表达式。它内置了大量常用的正则表达式模板，覆盖了多种常见场景，如匹配邮箱、URL、手机号等。</p><p><strong>主要功能</strong></p><ol><li><strong>常用正则表达式模板</strong>：<ul><li>提供丰富的正则表达式模板，涵盖邮箱、URL、IP地址、手机号、身份证号等常见需求。</li></ul></li><li><strong>快速生成正则表达式</strong>：<ul><li>通过快捷键或命令面板，快速生成所需的正则表达式。</li></ul></li><li><strong>自定义正则表达式</strong>：<ul><li>支持自定义正则表达式模板，满足个性化需求。</li></ul></li><li><strong>实时测试</strong>：<ul><li>提供实时测试功能，可在编辑器中直接测试正则表达式的匹配效果。</li></ul></li></ol><p><strong>使用方法</strong></p><ol><li><strong>通过命令面板</strong>：<ul><li>打开命令面板（快捷键 <code>Ctrl+Shift+P</code>）。    </li><li>输入 “Any-rule” 并选择相应模板。</li></ul></li><li><strong>通过快捷键</strong>：<ul><li>使用快捷键 <code>Ctrl+Alt+R</code> 打开 Any-rule 菜单，选择所需正则表达式。</li></ul></li><li><strong>自定义模板</strong>：<ul><li>在设置中配置自定义正则表达式模板。</li></ul></li></ol><p>Any-rule 插件简化了正则表达式的生成和使用，适合需要频繁处理正则表达式的开发者。通过内置模板和自定义功能，能显著提升开发效率。</p><h2 id="var-translate-en"><a href="#var-translate-en" class="headerlink" title="var-translate-en"></a>var-translate-en</h2><p>中文一键翻译为英文并转换成驼峰命名,提效神器🚀</p><p><img src="https://image.flashfish777.cn/img/post_21_3.jpg" alt="var-translate-en"></p><p><strong>Var-Translate-EN</strong> 是一款变量命名辅助工具 + 翻译工具，主要用于将中文变量名翻译为英文，且支持中英互译，帮助开发者编写更规范的代码并解决不认识的生词。它特别适合在需要中英互相转换的场景中使用，比如处理英文注释或中文命名的遗留代码。</p><p><strong>主要功能</strong></p><ol><li><strong>中文变量名翻译</strong>：<ul><li>将中文变量名自动翻译为英文，支持驼峰命名、下划线命名等多种格式。</li></ul></li><li><strong>多种命名风格</strong>：<ul><li>支持多种命名风格，如驼峰式（camelCase）、下划线式（snake_case）、常量式（UPPER_CASE）等。</li></ul></li><li><strong>批量翻译</strong>：<ul><li>支持批量翻译选中的多个变量名，提升效率。</li></ul></li><li><strong>自定义词典</strong>：<ul><li>允许用户添加自定义翻译词典，满足特定领域或项目的需求。</li></ul></li><li><strong>实时预览</strong>：<ul><li>在翻译时提供实时预览功能，方便开发者确认翻译结果。</li></ul></li></ol><p><strong>使用方法</strong></p><ol><li><strong>选中变量名</strong>：<ul><li>在代码中选中需要翻译的中文变量名。</li></ul></li><li><strong>调用插件</strong>：<ul><li>右键点击选中的变量名，选择 <strong>Var-Translate-EN</strong> 选项。</li><li>或者使用快捷键（默认快捷键为 <code>Ctrl+Alt+T</code>）。</li></ul></li><li><strong>选择命名风格</strong>：<ul><li>在弹出的选项中选择所需的命名风格（如驼峰式、下划线式等）。</li></ul></li><li><strong>确认翻译</strong>：<ul><li>插件会自动将中文变量名翻译为英文，并替换到代码中。</li></ul></li></ol><p><strong>自定义词典</strong></p><ol><li>打开 VSCode 设置（<code>Ctrl+,</code>）。</li><li>搜索 “Var-Translate-EN”。</li><li>在配置中添加自定义词典，例如：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;var-translate-en.customDictionary&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;用户名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;accountName&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;订单编号&quot;</span><span class="punctuation">:</span> <span class="string">&quot;orderId&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Todo-Tree"><a href="#Todo-Tree" class="headerlink" title="Todo Tree"></a>Todo Tree</h2><p>方便的查找与修改TODO、BUG、TEST等指令</p><p><img src="https://image.flashfish777.cn/img/post_21_4.jpg" alt="Todo Tree"></p><p><strong>Todo Tree</strong> 是一款任务管理插件，用于快速查找和整理代码中的注释标签（如 <code>TODO</code>、<code>FIXME</code> 等）。它能够将散落在代码中的任务注释集中展示在一个树形结构中，方便开发者管理和跟踪任务进度。</p><p><strong>主要功能</strong></p><ol><li><strong>注释标签高亮</strong>：<ul><li>自动高亮代码中的注释标签（如 <code>TODO</code>、<code>FIXME</code>、<code>NOTE</code> 等）。</li></ul></li><li><strong>任务树形结构</strong>：<ul><li>将代码中的所有任务注释以树形结构展示在侧边栏中，方便查看和管理。</li></ul></li><li><strong>快速跳转</strong>：<ul><li>点击树形结构中的任务，可以快速跳转到对应的代码位置。</li></ul></li><li><strong>自定义标签</strong>：<ul><li>支持自定义注释标签，满足不同项目的需求。</li></ul></li><li><strong>过滤和搜索</strong>：<ul><li>支持按标签、文件路径等条件过滤任务，快速定位目标。</li></ul></li><li><strong>多工作区支持</strong>：<ul><li>支持同时管理多个工作区中的任务注释。</li></ul></li></ol><p><strong>使用方法</strong></p><ol><li><strong>查看任务树</strong>：<ul><li>安装插件后，左侧活动栏会显示一个树形图标，点击即可打开 Todo Tree 面板。</li></ul></li><li><strong>添加注释标签</strong>：<ul><li>在代码中添加注释标签，例如：</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// TODO: 优化性能</span><br><span class="line">// FIXME: 修复空指针异常</span><br><span class="line">// NOTE: 需要进一步测试</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>高亮显示</strong>：<ul><li>插件会自动高亮这些注释标签，并在 Todo Tree 面板中展示。</li></ul></li><li><strong>快速跳转</strong>：<ul><li>点击 Todo Tree 面板中的任务，可以直接跳转到对应的代码位置。</li></ul></li><li><strong>自定义标签</strong>：<ul><li>在设置中配置自定义标签，例如：</li></ul></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;todo-tree.general.tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;TODO&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;FIXME&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;NOTE&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;CUSTOM&quot;</span></span><br><span class="line"><span class="punctuation">]</span>   </span><br></pre></td></tr></table></figure><ol start="6"><li><strong>过滤任务</strong>：<ul><li>在 Todo Tree 面板的搜索框中输入关键字，可以按标签、文件路径等条件过滤任务。</li></ul></li></ol><p><strong>Todo Tree</strong> 是一款非常实用的任务管理插件，特别适合需要跟踪和管理代码中任务注释的开发者。它通过树形结构集中展示任务，支持自定义标签和高亮颜色，能够显著提升代码维护效率。如果你经常使用 <code>TODO</code>、<code>FIXME</code> 等注释标签，这款插件会是一个很好的助手。</p><h2 id="数据库天团："><a href="#数据库天团：" class="headerlink" title="数据库天团："></a>数据库天团：</h2><p><strong>vscode-database &amp; Prettier SQL VSCode &amp; MySQL</strong></p><p><img src="https://image.flashfish777.cn/img/post_21_5.jpg" alt="database"></p><p>当你看到别人用他们的IDEA、VS轻松地连接到数据库并随意操作也不用羡慕！VSCode也有独特的数据库插件：</p><h3 id="vscode-database"><a href="#vscode-database" class="headerlink" title="vscode-database"></a>vscode-database</h3><p><strong>vscode-database</strong> 是一款数据库管理插件，支持直接在 <code>VSCode</code> 中连接、查询和管理多种数据库（如 <code>MySQL</code>、<code>PostgreSQL</code>、<code>SQLite</code>、<code>Redis</code> 等）。它集成了数据库连接、SQL 查询、数据编辑、表结构管理等功能，适合开发者在编写代码的同时直接操作数据库。</p><p><strong>主要功能</strong></p><ol><li><strong>多数据库支持</strong>：<ul><li>支持多种常见数据库，包括 <code>MySQL</code>、<code>PostgreSQL</code>、<code>SQLite</code>、<code>Redis</code>、<code>MongoDB</code> 等。</li></ul></li><li><strong>数据库连接管理</strong>：<ul><li>提供直观的界面管理数据库连接，支持保存连接配置。</li></ul></li><li><strong>SQL 查询与执行</strong>：<ul><li>支持编写和执行 SQL 查询，并查看查询结果。</li></ul></li><li><strong>数据编辑</strong>：<ul><li>可以直接在插件中编辑数据库表中的数据。</li></ul></li><li><strong>表结构管理</strong>：<ul><li>支持查看和修改表结构（如添加、删除、修改字段）。</li></ul></li><li><strong>查询历史</strong>：<ul><li>自动保存 SQL 查询历史，方便快速复用。</li></ul></li><li><strong>数据导出</strong>：<ul><li>支持将查询结果导出为 CSV、JSON 等格式。</li></ul></li><li><strong>智能提示</strong>：<ul><li>提供 SQL 语法高亮和智能提示，提升编写效率。</li></ul></li></ol><h3 id="Prettier-SQL-VSCode"><a href="#Prettier-SQL-VSCode" class="headerlink" title="Prettier SQL VSCode"></a>Prettier SQL VSCode</h3><p><strong>Prettier SQL</strong> 是一款 SQL 语言格式化工具，基于 <a href="https://prettier.io/">Prettier</a> 生态开发。它专注于对 SQL 代码进行自动格式化，帮助开发者保持代码风格的一致性，提升代码的可读性和维护性。</p><p><strong>主要功能</strong></p><ol><li><strong>SQL 代码格式化</strong>：<ul><li>自动格式化 SQL 代码，支持常见的 SQL 语法（如 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等）。</li></ul></li><li><strong>支持多种 SQL 方言</strong>：<ul><li>支持多种 SQL 方言，包括 MySQL、PostgreSQL、SQL Server、SQLite 等。</li></ul></li><li><strong>与 Prettier 集成</strong>：<ul><li>作为 Prettier 的插件，可以与 Prettier 的其他功能（如 JavaScript、TypeScript 格式化）无缝集成。</li></ul></li><li><strong>配置文件支持</strong>：<ul><li>支持通过 <code>.prettierrc</code> 配置文件自定义格式化规则。</li></ul></li><li><strong>快捷键格式化</strong>：<ul><li>支持通过快捷键快速格式化 SQL 代码。</li></ul></li><li><strong>保存时自动格式化</strong>：<ul><li>支持在保存文件时自动格式化 SQL 代码。</li></ul></li></ol><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p><strong>MySQL</strong> 插件是一款数据库管理工具，专门用于连接、查询和管理 MySQL 数据库。它提供了直观的界面和强大的功能，使开发者能够直接在 VSCode 中操作数据库，而无需切换到其他数据库管理工具。</p><p><strong>主要功能</strong></p><ol><li><strong>数据库连接管理</strong>：<ul><li>支持连接本地或远程的 MySQL 数据库。</li><li>支持多数据库连接配置。</li></ul></li><li><strong>SQL 查询与执行</strong>：<ul><li>提供 SQL 编辑器，支持语法高亮、自动补全和代码格式化。</li><li>可以直接在 VSCode 中编写和执行 SQL 查询。</li></ul></li><li><strong>数据表管理</strong>：<ul><li>查看和编辑数据库中的表结构。</li><li>支持表数据的增删改查（CRUD）操作。</li></ul></li><li><strong>查询结果展示</strong>：<ul><li>以表格形式展示查询结果，支持排序、筛选和导出数据。</li></ul></li><li><strong>数据库对象浏览</strong>：<ul><li>浏览数据库中的表、视图、存储过程、函数等对象。</li></ul></li><li><strong>事务支持</strong>：<ul><li>支持事务操作，可以提交或回滚事务。</li></ul></li><li><strong>导出与导入</strong>：<ul><li>支持将查询结果或表数据导出为 CSV、JSON 等格式。</li><li>支持导入外部数据到数据库中。</li></ul></li></ol><p><img src="https://image.flashfish777.cn/img/post_21_6.jpg" alt="MySQL"></p><p>当然，不止<code>MySQL</code>，如果你用到如<code>Redis</code>、<code>MogoDB</code>等其他数据库，也可以下载对应的插件使用。</p><p><img src="https://image.flashfish777.cn/img/post_21_7.jpg" alt="数据库天团"></p><hr><h1 id="美化篇"><a href="#美化篇" class="headerlink" title="美化篇"></a>美化篇</h1><h2 id="Ayu"><a href="#Ayu" class="headerlink" title="Ayu"></a>Ayu</h2><p>巨好看的深色主题</p><p><img src="https://image.flashfish777.cn/img/post_21_8.jpg" alt="Ayu"></p><p><strong>Ayu</strong> 是一款非常受欢迎的代码编辑器主题插件，以其简洁、现代的设计风格和舒适的视觉体验而闻名。Ayu 提供了多种配色方案（如亮色、暗色和幻影色），适合不同开发者的审美偏好和工作环境。<br>（ps：个人觉得<code>Ayu Dark</code>最好看！）</p><h2 id="Gradient-Theme"><a href="#Gradient-Theme" class="headerlink" title="Gradient Theme"></a>Gradient Theme</h2><p>无敌好看的渐变代码主题</p><p><img src="https://image.flashfish777.cn/img/post_21_9.jpg" alt="Gradient Theme"></p><p><strong>Gradient Theme</strong> 是一款主题插件，以其渐变色设计和现代风格著称。它为代码编辑器提供了独特的视觉体验，通过柔和的渐变色背景和精心设计的语法高亮，使代码更加美观且易于阅读。<br><strong>Gradient Theme</strong> 的渐变色真的超级好看！是我现在仍在用的一款主题，每一种风格都很漂亮，还可以自定义渐变色！使用后别忘了在命令中心打开 <code>Gradient Theme: Enable Gradient</code> 配置！不然不会显示渐变哦。</p><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1EWtjezEYn&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><h2 id="vscode-teriri-custom-style"><a href="#vscode-teriri-custom-style" class="headerlink" title="vscode-teriri-custom-style"></a>vscode-teriri-custom-style</h2><p>不计效率地为 vscode 添加样式与动画</p><p><img src="https://image.flashfish777.cn/img/post_21_10.jpg" alt="vscode-teriri-custom-style"></p><p><a href="https://github.com/TeR1R1/vscode-teriri-custom-style">-&gt; GitHub仓库</a></p><p><strong>重头戏来了！</strong><br>超级超级棒，超级推荐的一个项目！如果你不局限于主题、背景、特效插件这样的美化，想让你的VSCode变得更加 下炫酷， <code>vscode-teriri-custom-style</code> 可以做到这些！</p><p><code>vscode-teriri-custom-style</code> 是一个为VSCode开发的的自定义样式项目，为开发者提供个性化的编辑器界面和代码高亮方案。该项目通过自定义 CSS 和配置文件，允许用户根据自己的喜好调整 VSCode 的外观和功能，从而提升开发体验。</p><p>非线性移动动画与进入动画、毛玻璃与圆角效果、高亮动画、发光字体、光标动画、炫酷的RGB光效、提示窗口动画、资源管理器动画……各种炫酷的效果随意添加，只需要安装 CSS 加载器，例如 <code>Apc Customize UI++</code> 插件, <code>Custom CSS and JS Loader</code> 等，能加载 CSS 文件就行。</p><p><img src="https://image.flashfish777.cn/img/post_21_11.jpg" alt="Custom CSS and JS Loader"></p><p>安装好插件后将项目中对应的 CSS 文件导入即可。具体的教程与演示在项目仓库中写的很详细，感兴趣的朋友可以自行查看。</p><p>当然，<code>vscode-teriri-custom-style</code> 只是项目作者自行研究的动画效果合辑。只要通过 CSS 加载器插件加载需要的 CSS 文件就可以通过 CSS 做到更多的效果。</p><hr><h1 id="JetBrains-Rider"><a href="#JetBrains-Rider" class="headerlink" title="JetBrains Rider"></a>JetBrains Rider</h1><p>就在前段时间，公认的全球最受喜爱，最佳游戏开发IDE <code>JetBrains Rider</code> 对非商业用途的用户开放了免费使用，这无疑是一个超级大的好消息。众所周知 <code>JetBrains</code> 家的IDE无论是 <code>IDEA</code> 、 <code>PyCharm</code> 、 <code>CLion</code> 、 <code>WebStorm</code> 等都受到了广泛开发者的喜爱，虽然并没有用过 <code>JetBrains</code> 的产品，但我相信好评是有目共睹的，于是在了解了 <code>Rider</code> 非商业化免费之后，我也立马下载下来体验了一番。</p><p><strong>Rider</strong> 是由 JetBrains 开发的一款跨平台集成开发环境（IDE），专为 <code>.NET</code>、<code>C#</code> 和 <code>Unity</code> 开发而设计。它基于 <code>IntelliJ</code> 平台和 <code>ReSharper</code> 技术，提供了强大的代码编辑、调试和重构功能，支持多种 <code>.NET</code> 项目类型，包括 <code>.NET Framework</code>、<code>.NET Core</code>、<code>Mono</code> 和 <code>Unity</code> 项目。</p><h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><ol><li><strong>跨平台支持</strong>：<ul><li>Rider 支持 <code>Windows</code>、<code>macOS</code> 和 <code>Linux</code> 操作系统，开发者可以在不同平台上无缝切换。</li></ul></li><li><strong>强大的代码编辑功能</strong>：<ul><li>提供语法高亮、代码自动补全、实时错误检测和代码重构功能，帮助开发者高效编写代码。</li><li>支持超过 2200 种实时代码检查，并提供快速修复建议。。</li></ul></li><li><strong>Unity 开发支持</strong>：<ul><li>作为一个游戏开发者，Rider 对 Unity 的支持让我印象深刻。它能够直接识别 Unity 项目中的脚本，并提供智能提示和调试功能。</li><li>在 Unity 中编写 C# 脚本时，Rider 的代码补全和重构功能极大地提升了开发效率。此外，它还支持 Unity 的 API 文档快速查看，方便随时查阅。</li></ul></li><li><strong>调试与测试</strong>：<ul><li>Rider 内置的调试器非常强大，支持断点、变量监视、表达式评估等功能。调试 Unity 项目时，它能够与 Unity 编辑器无缝衔接，实时查看游戏状态。</li></ul></li><li><strong>丰富的插件生态系统</strong>：<ul><li>支持多种插件扩展，包括 Git 版本控制、数据库工具、AI工具等等。</li></ul></li></ol><p>一开始我还觉得编辑器可能对我的开发影响不大，毕竟我已经习惯了用 VSCode 做任何事情。可是用了一段时间 Rider 我才发现它的专业性确实要更加更加强大，无论是代码补全还是对Unity的完美支持都完全秒杀 VSCode 插件的组合式开发环境，更别说 Rider还能完美的支持Unity Shader 的语法了。<br>相比之下 VSCode 倒像是可以支持各种语言环境的文本编辑器，它的涉猎广泛，但不够深入。 Rider 相比之下至少在 Unity 开发上更加专业。况且 Rider 也有插件系统不是嘛。<br>所以我觉得我应该重新对待 VSCode ，我不能再过度的依赖它。对于我来说，Unity 开发是我的主要工作，所以我选择使用 Rider 。在学习其他语言或进行其他不需要我涉猎很深的工作时 VSCode 可能仍是最好的选择。</p><h2 id="配置推荐"><a href="#配置推荐" class="headerlink" title="配置推荐"></a>配置推荐</h2><p>在 Rider 的使用上我或许不是很熟练与专业，但我可以给出我的一些建议。<br>首先快捷键配置我选择 VSCode 的，毕竟用习惯了。主题我选择用 <code>VSCode Theme</code> 插件，代码字体选用 <code>Consolas</code> ，哪里不像 VSCode 我用着都很别扭哈哈哈。</p><p><img src="https://image.flashfish777.cn/img/post_21_12.jpg"></p><p>提示级别是这样的，因为我觉得尽管正确的命名与拼写是必要的，但总会有一些特殊情况，编辑器一直提示的话我会觉得很烦，至于规范化的事情自己注意就好了。还有性能检查也是我觉得很棒的一个功能，它可以提示你那些方法或操作的开销比较大或其他，在开发时很有参考意义。</p><p>至于其他不错的功能就一起探索吧！</p><hr><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>以上就是我的一些推荐和想说的话，希望能为你带来帮助。如果你有任何推荐的VSCode插件或者独特的使用心得，欢迎在评论区留言分享，让我们一起学习，共同进步！期待在未来的编程道路上，与更多的你相遇，共同书写属于我们的精彩篇章。</p><p>—end—</p>]]></content>
    
    
    <summary type="html">再次推荐一些好用的VSCode插件 + 浅谈Rider...</summary>
    
    
    
    <category term="推荐" scheme="http://www.flashfish777.cn/categories/%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="VSCode" scheme="http://www.flashfish777.cn/tags/VSCode/"/>
    
    <category term="Rider" scheme="http://www.flashfish777.cn/tags/Rider/"/>
    
  </entry>
  
  <entry>
    <title>Unity插件之Localization</title>
    <link href="http://www.flashfish777.cn/posts/f35bbb42.html"/>
    <id>http://www.flashfish777.cn/posts/f35bbb42.html</id>
    <published>2024-12-12T19:00:00.000Z</published>
    <updated>2024-12-12T19:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>考虑到 <code>Unity Crazy Web 2024 GameJam</code> 是外国的比赛，所以我们将多语言添加到了项目的开发计划中。在进行多语言的配置时，就少不了一些好用的插件的支持，就比如 <code>Unity Localization</code> 这款本地化插件。在进行了了解、学习与使用后，它的方便快捷、功能强大为我留下了深刻的印象，所以我第一时间就将这款插件的推荐写了出来，有本地化需求的小伙伴一定能有所收获！</p><hr><h1 id="Unity-Localization-插件介绍"><a href="#Unity-Localization-插件介绍" class="headerlink" title="Unity Localization 插件介绍"></a>Unity Localization 插件介绍</h1><p><code>Unity Localization</code> 是 Unity 官方推出的本地化解决方案，它提供了一个系统化的方法来管理游戏或应用的多语言内容。这个插件从 Unity 2019.3 开始作为预览包提供，并在 Unity 2021.2 中成为正式功能。</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ol><li><p><strong>文本本地化</strong>：</p><ul><li>支持多种语言的文本翻译</li><li>提供智能字符串查找和替换功能</li><li>支持文本参数化（如动态插入变量）</li></ul></li><li><p><strong>资源本地化</strong>：</p><ul><li>支持本地化纹理、音频、预制体等资产</li><li>不同语言可以使用不同的资源版本</li></ul></li><li><p><strong>字体管理</strong>：</p><ul><li>自动为不同语言切换合适的字体</li><li>支持回退字体设置</li></ul></li><li><p><strong>Pluralization（复数形式处理）</strong>：</p><ul><li>支持不同语言的复数规则</li><li>根据数量自动选择正确的文本形式</li></ul></li></ol><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><ol><li><p><strong>Localization Tables（本地化表）</strong>：</p><ul><li>以电子表格形式组织翻译内容</li><li>支持 CSV 格式导入导出</li><li>包含键值对结构（Key-Value）</li></ul></li><li><p><strong>Localized String</strong>：</p><ul><li>特殊数据类型，表示可本地化的字符串</li><li>可以绑定到 UI 文本元素</li></ul></li><li><p><strong>Locale（区域设置）</strong>：</p><ul><li>表示特定语言和区域设置</li><li>包含语言代码、书写方向等信息</li></ul></li><li><p><strong>Localization Settings</strong>：</p><ul><li>全局本地化设置</li><li>管理可用语言和默认语言</li></ul></li></ol><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li><p><strong>安装与设置</strong>：</p><ul><li>通过 Package Manager 安装 Localization 包</li><li>创建 Localization Settings 资源</li></ul></li><li><p><strong>添加语言</strong>：</p><ul><li>创建或导入 Locale 资产</li><li>设置默认语言和备用语言</li></ul></li><li><p><strong>创建翻译表</strong>：</p><ul><li>新建字符串表或资产表</li><li>添加翻译键和对应语言的文本</li></ul></li><li><p><strong>实现本地化</strong>：</p><ul><li>在场景中使用 LocalizedString 或 LocalizedAsset</li><li>或通过代码访问本地化内容</li></ul></li><li><p><strong>运行时语言切换</strong>：</p><ul><li>通过代码更改 Selected Locale</li><li>所有本地化内容会自动更新</li></ul></li></ol><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取本地化字符串</span></span><br><span class="line"><span class="keyword">var</span> localizedString = <span class="keyword">new</span> LocalizedString(<span class="string">&quot;MyTable&quot;</span>, <span class="string">&quot;Greeting&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> translatedText = localizedString.GetLocalizedString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态参数</span></span><br><span class="line"><span class="keyword">var</span> stringWithParams = <span class="keyword">new</span> LocalizedString(<span class="string">&quot;MyTable&quot;</span>, <span class="string">&quot;WelcomeMessage&quot;</span>);</span><br><span class="line">stringWithParams.Arguments = <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; playerName &#125;;</span><br><span class="line"><span class="built_in">string</span> message = stringWithParams.GetLocalizedString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换语言</span></span><br><span class="line">LocalizationSettings.SelectedLocale = LocalizationSettings.AvailableLocales.Locales[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h2 id="优势特点"><a href="#优势特点" class="headerlink" title="优势特点"></a>优势特点</h2><ol><li><strong>官方支持</strong>：Unity 官方维护，与引擎深度集成</li><li><strong>非破坏性工作流</strong>：不会修改原始资源</li><li><strong>动态更新</strong>：语言切换时无需重新加载场景</li><li><strong>扩展性强</strong>：支持自定义本地化提供程序</li><li><strong>编辑器友好</strong>：提供专用编辑器窗口和工具</li></ol><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>多语言游戏或应用开发</li><li>需要频繁更新翻译内容的项目</li><li>大型项目需要团队协作管理本地化</li><li>需要动态切换语言而不重启的应用</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>需要 Unity 2019.3 或更高版本</li><li>对于非常简单的项目可能显得过于复杂</li><li>学习曲线相对陡峭，特别是对于复杂用例</li><li>需要合理规划键命名和表格结构以保持可维护性</li></ol><hr><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p><a href="https://developer.unity.cn/projects/653e4464edbc2a001f1c7101">Unity官网教程</a><br><a href="https://blog.csdn.net/zhangay1998/article/details/134940651">本文参考教程</a></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在 <code>Package Manager</code> 安装插件之后，打开菜单栏 <code>Edit -&gt; Project Settings -&gt; Localization -&gt; Create</code> ，找到Localization，点击Create创建，并选择一个文件目录进行文件保存。<br><img src="https://image.flashfish777.cn/img/post_20_1.jpg"></p><p>点击 <code>Locale Generator</code> 搜索 <code>zh</code> 和 <code>en</code> 添加中英文配置，第一次添加时会让我们选择一个文件夹目录保存。<br><img src="https://image.flashfish777.cn/img/post_20_2.jpg"></p><p><code>Locale Generator</code> 哟用于添加或移除语言，每添加一种语言也会生成对应的配置文件，然后可以修改默认语言为中文，如图：<br><img src="https://image.flashfish777.cn/img/post_20_3.jpg"></p><h3 id="添加多语言映射"><a href="#添加多语言映射" class="headerlink" title="添加多语言映射"></a>添加多语言映射</h3><p>打开菜单栏 <code>Window -&gt; Asset Management -&gt; Localization Tables</code> ,点击 <code>New Table Collectiont</code> 创建表格。<br>该表格用于建立不同资源之间的对应关系，一个ky对应多个语言的资源，可以选择创建文本表或者资源表。<br>这里我们选择文本表(String Table Collection)使用，写好表名后点击Create就可以创建了，然后选择一个路径目录进行保存。<br><img src="https://image.flashfish777.cn/img/post_20_4.jpg"></p><p>此时在 <code>Localization Table</code> 中添加多语言文本即可，配置内容主要是 <code>Key</code> 和对应多种语言的文本。<br>可通过 <code>Window -&gt; Asset Manager -&gt; Localization Tables</code> 打开该窗口。<br><img src="https://image.flashfish777.cn/img/post_20_5.jpg"></p><p>实际项目中不一定将多语言内容全写在一个配置表中，不同的文本内容也可以通过创建多个配置表进行填写，让不同的模块自己管理文本内容也是一个不错的选择。</p><p>此时在场景中添加一个文本组件 <code>Text</code> ，然后在该组件右侧菜单处点击 <code>Localize</code>  ，会自动添加一个 <code>Localization String Event</code> 组件。也可以手动添加 <code>Localization String Event</code> 组件。<br><img src="https://image.flashfish777.cn/img/post_20_6.jpg"></p><p>此时在该组件中的 <code>String Reference</code> 参数中选择之前配置的多语言文本配置表中的 <code>Key</code> 即可完成多语言的配置。<br><img src="https://image.flashfish777.cn/img/post_20_7.png"></p><p>通过脚本控制语言的切换，测试代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Localization.Settings;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LanguageManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchChineseButton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        LocalizationSettings.SelectedLocale = LocalizationSettings.AvailableLocales.Locales[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchEnglishButton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        LocalizationSettings.SelectedLocale = LocalizationSettings.AvailableLocales.Locales[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引值为 Localization 的配置项中的多语言的顺序，如下方第一个语言为中文则索引为0.<br><img src="https://image.flashfish777.cn/img/post_20_8.png"></p><p>将脚本挂载到场景中，并在场景中添加两个Button分别绑定切换中英文的方法即可。<br><img src="https://image.flashfish777.cn/img/post_20_9.gif"></p><p>这样就完成多语言的配置与使用啦，像动态文本、资源多语言、映射表Excel等就先不多介绍了，有需要可以看上面的参考教程链接。</p><hr><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p><code>Unity Localization</code> 插件为开发者提供了强大的工具来处理游戏本地化的复杂性，特别适合中大型项目或需要支持多种语言和地区的产品。希望能够对有本地化需求的小伙伴带来帮助。那么这次插件的分享就到这里啦，欢迎在评论区讨论你的见解与推荐！</p><p>—end—</p>]]></content>
    
    
    <summary type="html">推荐一种好用的本地化语言插件...</summary>
    
    
    
    <category term="推荐" scheme="http://www.flashfish777.cn/categories/%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="游戏开发" scheme="http://www.flashfish777.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="Unity插件" scheme="http://www.flashfish777.cn/tags/Unity%E6%8F%92%E4%BB%B6/"/>
    
    <category term="本地化" scheme="http://www.flashfish777.cn/tags/%E6%9C%AC%E5%9C%B0%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Unity Crazy Web GameJam 2024</title>
    <link href="http://www.flashfish777.cn/posts/76f0264f.html"/>
    <id>http://www.flashfish777.cn/posts/76f0264f.html</id>
    <published>2024-12-10T12:00:00.000Z</published>
    <updated>2024-12-10T12:00:00.000Z</updated>
    
    
    <summary type="html">第二次参加GameJam，当上了主程，完整的完成并提交了作品，和大家一起交流学到了很多东西，非常完美的一次经历...</summary>
    
    
    
    <category term="项目" scheme="http://www.flashfish777.cn/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="游戏" scheme="http://www.flashfish777.cn/categories/%E9%A1%B9%E7%9B%AE/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="GameJam" scheme="http://www.flashfish777.cn/categories/%E9%A1%B9%E7%9B%AE/%E6%B8%B8%E6%88%8F/GameJam/"/>
    
    
    <category term="GameJam" scheme="http://www.flashfish777.cn/tags/GameJam/"/>
    
    <category term="游戏开发" scheme="http://www.flashfish777.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="Unity" scheme="http://www.flashfish777.cn/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity插件之QuickOutline与shader</title>
    <link href="http://www.flashfish777.cn/posts/2255085f.html"/>
    <id>http://www.flashfish777.cn/posts/2255085f.html</id>
    <published>2024-11-25T19:00:00.000Z</published>
    <updated>2025-04-02T03:05:11.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 在Unity开发的游戏和虚拟现实应用中，为了提升用户体验和交互性，我们常常需要对某些物体进行高亮处理，以引导玩家注意或选择特定的目标。然而，Unity引擎本身并未内置这类高亮功能。<br> 在众多第三方插件中， <code>QuickOutline</code> 以其简洁易用且功能强大的特点脱颖而出。通过多次实践验证，我发现 <code>QuickOutline</code> 不仅能够高效地实现物体高亮的需求，而且其简易性使得初学者也能快速上手。<br>  <code>QuickOutLine</code> 高亮插件也是我在TapTap的项目过程中了解到的，觉得很好用，故写此篇推荐。</p><hr><h1 id="QuickOutLine"><a href="#QuickOutLine" class="headerlink" title="QuickOutLine"></a>QuickOutLine</h1><p>首先来介绍一下 QuikOutLine插件。</p><p>Unity 的 <strong>Quick Outline</strong> 是一个轻量级插件，用于快速为 3D 物体添加 <strong>描边（Outline）</strong> 效果。它通常用于高亮选中物体、交互提示或特殊视觉效果。</p><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ul><li><strong>快速描边</strong>：无需编写 Shader，直接通过组件为物体添加描边。</li><li><strong>可定制参数</strong>：<ul><li>描边颜色（<code>Outline Color</code>）</li><li>描边宽度（<code>Outline Width</code>）</li><li>描边模式（基于屏幕空间或几何体膨胀）</li></ul></li><li><strong>性能优化</strong>：适合移动端和低配设备（相比一些后处理方案更轻量）。</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><a href="https://www.bilibili.com/opus/970519672427380743">参考文章链接</a></p><p>导入 <code>QuickOutLine</code> 插件之后，在使用时，为需要添加的物体添加 <code>outline</code> 组件即可。</p><p><img src="https://image.flashfish777.cn/img/post_18_4.jpg" alt="导入"><br><img src="https://image.flashfish777.cn/img/post_18_5.jpg" alt="使用"></p><p>（注！<strong>此处可以挂载到所需高亮物体的总物体上，只需要该物体下的子物体中有MaterRenderer组件即可!挂载了Quick Outline插件的组件的模型，都要开启Read&#x2F;Write Enabled。</strong>）</p><h2 id="功能特性详解"><a href="#功能特性详解" class="headerlink" title="功能特性详解"></a>功能特性详解</h2><p><img src="https://image.flashfish777.cn/img/post_18_6.jpg" alt="属性"></p><p><code>Outline Mode</code>： 高亮方式<br><img src="https://image.flashfish777.cn/img/post_18_7.jpg" alt="Outline Mode"></p><p><code>Outline Color</code>：高亮颜色<br><code>Outline Width</code>：高亮线的宽度(0-10)<br><code>Precompute Outline</code>：用于控制是否在编辑器阶段预先计算物体的轮廓数据。当启用预计算时，轮廓的计算会在编辑器中进行，并将结果与物体一起序列化存储；而当禁用预计算时，轮廓计算则会在运行时的方法中执行。</p><hr><h1 id="简单Shader实现"><a href="#简单Shader实现" class="headerlink" title="简单Shader实现"></a>简单Shader实现</h1><p>那么有同学问：“煮波煮波有没有不使用插件的方法呢？”，有的兄弟有的，简单的 <code>Unity Shader</code> 就能实现描边效果，以下是我使用过的小例子：</p><p>首先我们在Unity资源目录中选择一个位置（建议 <code>/Assests/Shader/</code> 文件夹）,新建一个 <code>outline.shader</code> 文件，这是一个 <code>Unity Shader</code> 文件。然后将以下代码粘贴到shader文件中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;shader2D/outline&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex(<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _lineWidth(<span class="string">&quot;lineWidth&quot;</span>,Range(<span class="number">0</span>,<span class="number">10</span>)) = <span class="number">1</span></span><br><span class="line">        _lineColor(<span class="string">&quot;lineColor&quot;</span>,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ---------------------------【子着色器】---------------------------</span></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 渲染队列采用 透明</span></span><br><span class="line">        Tags</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="comment">//顶点着色器输入结构体</span></span><br><span class="line">            <span class="keyword">struct</span> VertexInput</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顶点着色器输出结构体</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">VertexOutput</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">               float2 uv : TEXCOORD0;</span><br><span class="line">               float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ---------------------------【顶点着色器】---------------------------</span></span><br><span class="line">            VertexOutput <span class="title function_">vert</span><span class="params">(VertexInput v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                VertexOutput o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_TexelSize;</span><br><span class="line">            <span class="type">float</span> _lineWidth;</span><br><span class="line">            float4 _lineColor;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ---------------------------【片元着色器】---------------------------</span></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(VertexOutput i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 采样周围4个点</span></span><br><span class="line">                float2 up_uv = i.uv + float2(<span class="number">0</span>,<span class="number">1</span>) * _lineWidth * _MainTex_TexelSize.xy;</span><br><span class="line">                float2 down_uv = i.uv + float2(<span class="number">0</span>,<span class="number">-1</span>) * _lineWidth * _MainTex_TexelSize.xy;</span><br><span class="line">                float2 left_uv = i.uv + float2(<span class="number">-1</span>,<span class="number">0</span>) * _lineWidth * _MainTex_TexelSize.xy;</span><br><span class="line">                float2 right_uv = i.uv + float2(<span class="number">1</span>,<span class="number">0</span>) * _lineWidth * _MainTex_TexelSize.xy;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果有一个点透明度为0 说明是边缘</span></span><br><span class="line">                <span class="type">float</span> w = tex2D(_MainTex,up_uv).a * tex2D(_MainTex,down_uv).a * tex2D(_MainTex,left_uv).a * tex2D(_MainTex,right_uv).a;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// if(w == 0)</span></span><br><span class="line">                <span class="comment">// &#123;</span></span><br><span class="line">                <span class="comment">//     col.rgb = _lineColor;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">// 和原图做插值</span></span><br><span class="line"></span><br><span class="line">                col.rgb = lerp(_lineColor,col.rgb,w);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的shader就写好啦，它的核心思路是检测纹理的边缘（Alpha 接近 0 的区域），并用指定的颜色（<code>_lineColor</code>）进行描边。</p><p><strong>包含的Properties（属性）：</strong></p><ul><li><code>_MainTex</code>：主纹理（如 Sprite 图片）。</li><li><code>_lineWidth</code>：描边宽度（0~10）。</li><li><code>_lineColor</code>：描边颜色（默认白色）。</li></ul><p>接下来，我们需要为该shader创建材质。<br>新建一个材质（<code>Material</code>），然后将材质的shader选为 <code>shader2D/outline</code> 。</p><p><img src="https://image.flashfish777.cn/img/post_18_1.jpg" alt="材质配置"></p><p>创建完成后在需要的地方将材质挂载到目标的 <code>Image</code> 组件的 <code>Material</code> 上。<br>例如我想让我的卡牌拥有鼠标进入就显示描边的效果，我就控制代码，在使用预制体生成卡牌的时候将 <code>outline</code> 材质挂载到预制体下的 <code>bg</code> 的 <code>Image</code> 组件上。</p><p><img src="https://image.flashfish777.cn/img/post_18_2.jpg" alt="卡牌预制体"></p><p>相关代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置bg背景Image的Material</span></span><br><span class="line">transform.Find(<span class="string">&quot;bg&quot;</span>).GetComponent&lt;Image&gt;().material = Instantiate(Resources.Load&lt;Material&gt;(<span class="string">&quot;Mats/outline&quot;</span>));</span><br></pre></td></tr></table></figure><p>到这步就已经万事具备啦，现在只需要写下你需要的代码逻辑，比如我这里就是使用 <code>SetColor</code> 与 <code>SetFloat</code> 在鼠标进入时显示黄色描边，并设置描边宽度为10，鼠标离开后让描边消失：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鼠标进入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerEnter</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    transform.Find(<span class="string">&quot;bg&quot;</span>).GetComponent&lt;Image&gt;().material.SetColor(<span class="string">&quot;_lineColor&quot;</span>, Color.yellow);</span><br><span class="line">    transform.Find(<span class="string">&quot;bg&quot;</span>).GetComponent&lt;Image&gt;().material.SetFloat(<span class="string">&quot;_lineWidth&quot;</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标离开</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerExit</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    transform.Find(<span class="string">&quot;bg&quot;</span>).GetComponent&lt;Image&gt;().material.SetColor(<span class="string">&quot;_lineColor&quot;</span>, Color.black);</span><br><span class="line">    transform.Find(<span class="string">&quot;bg&quot;</span>).GetComponent&lt;Image&gt;().material.SetFloat(<span class="string">&quot;_lineWidth&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：<br><img src="https://image.flashfish777.cn/img/post_18_3.gif"></p><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>QuickOutLine插件的分享就到这里啦，欢迎在评论区讨论你的见解与推荐！</p><p>—end—</p>]]></content>
    
    
    <summary type="html">推荐一种好用的鼠标悬停高亮插件并使用shader简单实现一种这样的效果...</summary>
    
    
    
    <category term="推荐" scheme="http://www.flashfish777.cn/categories/%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="游戏开发" scheme="http://www.flashfish777.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="Unity插件" scheme="http://www.flashfish777.cn/tags/Unity%E6%8F%92%E4%BB%B6/"/>
    
    <category term="Shader" scheme="http://www.flashfish777.cn/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>Unity插件之DOTween</title>
    <link href="http://www.flashfish777.cn/posts/9e0ed965.html"/>
    <id>http://www.flashfish777.cn/posts/9e0ed965.html</id>
    <published>2024-11-21T19:00:00.000Z</published>
    <updated>2024-11-21T19:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在边做比赛项目边学习的过程中，我不仅了解到<strong>设计模式</strong>那般优雅的解决方案，还了解了另一种精致的工具——Unity的插件。像我们最常用的 <code>TMPro</code> 就是Unity插件的一种。Unity众多的插件不光可以节省我们的开发时间，还可以为我们提供出乎意料的神秘技能，本文将推荐一款好用的动画插件——<strong>DOTween</strong>。</p><hr><h1 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h1><h2 id="DOTween-概述"><a href="#DOTween-概述" class="headerlink" title="DOTween 概述"></a>DOTween 概述</h2><p><code>DOTween</code> 是 Unity 中最受欢迎的补间动画(<code>Tweening</code>)插件之一，它提供了一个高效、灵活且易于使用的动画系统。作为 <code>HOTween</code> 的继承者，<code>DOTween</code> 在性能、功能和易用性方面都有显著提升。</p><h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><ul><li>零分配内存操作（Zero-allocation）</li><li>高度优化的代码结构</li><li>比 Unity 原生动画系统更高效</li></ul><h3 id="丰富的功能集"><a href="#丰富的功能集" class="headerlink" title="丰富的功能集"></a>丰富的功能集</h3><ul><li>支持 <code>Transform</code>、<code>Material</code>、<code>Camera</code>、<code>UI</code> 等多种对象动画</li><li>路径动画功能</li><li>序列动画系统</li><li>回调函数支持</li><li>物理模拟动画</li></ul><h3 id="3-简洁的-API-设计"><a href="#3-简洁的-API-设计" class="headerlink" title="3. 简洁的 API 设计"></a>3. 简洁的 API 设计</h3><ul><li>链式调用语法</li><li>直观的命名规则</li><li>丰富的扩展方法</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="安装与设置"><a href="#安装与设置" class="headerlink" title="安装与设置"></a>安装与设置</h3><p>通过 <code>Unity Asset Store</code> 或 <code>GitHub</code> 获取 <code>DOTween</code>，导入后需初始化：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> DG.Tweening;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化DOTween（自动完成）</span></span><br><span class="line">    DOTween.Init(autoKillMode, useSafeMode, logBehaviour);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本补间动画"><a href="#基本补间动画" class="headerlink" title="基本补间动画"></a>基本补间动画</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动物体</span></span><br><span class="line">transform.DOMove(<span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), <span class="number">1f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩放物体</span></span><br><span class="line">transform.DOScale(<span class="keyword">new</span> Vector3(<span class="number">1.5f</span>, <span class="number">1.5f</span>, <span class="number">1.5f</span>), <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旋转物体</span></span><br><span class="line">transform.DORotate(<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">90</span>, <span class="number">0</span>), <span class="number">1f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 颜色渐变</span></span><br><span class="line">material.DOColor(Color.red, <span class="number">1f</span>);</span><br></pre></td></tr></table></figure><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transform.DOMoveX(<span class="number">5</span>, <span class="number">1f</span>)</span><br><span class="line">         .SetEase(Ease.OutBounce)</span><br><span class="line">         .OnComplete(() =&gt; Debug.Log(<span class="string">&quot;移动完成!&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="动画序列（Sequences）"><a href="#动画序列（Sequences）" class="headerlink" title="动画序列（Sequences）"></a>动画序列（Sequences）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sequence mySequence = DOTween.Sequence();</span><br><span class="line">mySequence.Append(transform.DOMoveX(<span class="number">5</span>, <span class="number">1f</span>));</span><br><span class="line">mySequence.AppendInterval(<span class="number">0.5f</span>);</span><br><span class="line">mySequence.Append(transform.DOScale(<span class="number">2</span>, <span class="number">0.5f</span>));</span><br><span class="line">mySequence.Play();</span><br></pre></td></tr></table></figure><h3 id="路径动画"><a href="#路径动画" class="headerlink" title="路径动画"></a>路径动画</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector3[] path = <span class="keyword">new</span> Vector3[] &#123; <span class="comment">/* 路径点 */</span> &#125;;</span><br><span class="line">transform.DOPath(path, <span class="number">5f</span>, PathType.CatmullRom)</span><br><span class="line">         .SetLookAt(<span class="number">0.01f</span>);</span><br></pre></td></tr></table></figure><h3 id="回调系统"><a href="#回调系统" class="headerlink" title="回调系统"></a>回调系统</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transform.DOMoveX(<span class="number">5</span>, <span class="number">1f</span>)</span><br><span class="line">         .OnStart(() =&gt; Debug.Log(<span class="string">&quot;动画开始&quot;</span>))</span><br><span class="line">         .OnUpdate(() =&gt; Debug.Log(<span class="string">&quot;动画进行中&quot;</span>))</span><br><span class="line">         .OnComplete(() =&gt; Debug.Log(<span class="string">&quot;动画完成&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="动画控制"><a href="#动画控制" class="headerlink" title="动画控制"></a>动画控制</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Tween myTween = transform.DOMoveX(<span class="number">5</span>, <span class="number">1f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂停/继续</span></span><br><span class="line">myTween.Pause();</span><br><span class="line">myTween.Play();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重设动画</span></span><br><span class="line">myTween.Rewind();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成动画</span></span><br><span class="line">myTween.Complete();</span><br></pre></td></tr></table></figure><h2 id="UI-动画支持"><a href="#UI-动画支持" class="headerlink" title="UI 动画支持"></a>UI 动画支持</h2><p><code>DOTween</code> 对 Unity UI 有特别优化：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文本动画</span></span><br><span class="line">text.DOText(<span class="string">&quot;新文本&quot;</span>, <span class="number">1f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 颜色渐变</span></span><br><span class="line">image.DOColor(Color.blue, <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 淡入淡出</span></span><br><span class="line">canvasGroup.DOFade(<span class="number">0</span>, <span class="number">1f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// UI 元素移动</span></span><br><span class="line">rectTransform.DOAnchorPos(<span class="keyword">new</span> Vector2(<span class="number">100</span>, <span class="number">100</span>), <span class="number">1f</span>);</span><br></pre></td></tr></table></figure><h2 id="性能优化技巧"><a href="#性能优化技巧" class="headerlink" title="性能优化技巧"></a>性能优化技巧</h2><ol><li><strong>对象池</strong>：<code>DOTween</code> 自动管理补间对象池</li><li><strong>重用补间</strong>：避免频繁创建新补间</li><li><strong>批量控制</strong>：使用 <code>DOTween.To()</code> 批量处理</li><li><strong>合理设置 Update 类型</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myTween.SetUpdate(UpdateType.Normal); <span class="comment">// 默认</span></span><br><span class="line">myTween.SetUpdate(UpdateType.Late);  <span class="comment">// LateUpdate</span></span><br><span class="line">myTween.SetUpdate(UpdateType.Fixed); <span class="comment">// FixedUpdate</span></span><br><span class="line">myTween.SetUpdate(<span class="literal">true</span>); <span class="comment">// 使用独立时间不受Time.timeScale影响</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol><li><p><strong>使用静态扩展方法</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOTween.To(() =&gt; myValue, x =&gt; myValue = x, <span class="number">10</span>, <span class="number">1f</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>组合动画</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.DOMoveX(<span class="number">5</span>, <span class="number">1f</span>).Join(transform.DORotate(<span class="keyword">new</span> Vector3(<span class="number">0</span>,<span class="number">180</span>,<span class="number">0</span>), <span class="number">1f</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>自定义缓动函数</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myTween.SetEase(Ease.InOutQuad);</span><br><span class="line"><span class="comment">// 或使用动画曲线</span></span><br><span class="line">myTween.SetEase(myAnimationCurve);</span><br></pre></td></tr></table></figure></li><li><p><strong>性能监控</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DOTween.SetTweensCapacity(<span class="number">200</span>, <span class="number">50</span>); <span class="comment">// 设置最大补间数</span></span><br><span class="line">Debug.Log(DOTween.TotalPlayingTweens); <span class="comment">// 监控当前补间数</span></span><br></pre></td></tr></table></figure></li></ol><p><code>DOTween</code> 的强大之处在于它的灵活性和高性能，掌握这些功能可以显著提升 Unity 项目的动画效果和开发效率。</p><p>文章只列出了 <code>DOTWeen</code> 大致的函数调用，想了解具体函数的调用规则与细节，或者对插件感兴趣可以访问 <a href="https://dotween.demigiant.com/">DOTween官网</a></p><hr><h1 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h1><p>因为这段时间一直在写2D游戏，所以用在UI上比较多，下面分享一些我的用法：</p><h2 id="卡牌动画"><a href="#卡牌动画" class="headerlink" title="卡牌动画"></a>卡牌动画</h2><p>在TapTap的GameJam上做的卡牌之光游戏的卡牌效果就用到了DOTween，包括鼠标进入与离开的反馈、抽牌和使用的动画等。因为动画逻辑写的比较杂，就不放代码了。</p><h2 id="按钮效果"><a href="#按钮效果" class="headerlink" title="按钮效果"></a>按钮效果</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerClick</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 缩小按钮</span></span><br><span class="line">    transform.DOScale(<span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * <span class="number">0.9f</span>, <span class="number">0.1f</span>)</span><br><span class="line">        .OnComplete(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 播放音效</span></span><br><span class="line">            AudioManager.Instance.PlayEffect();</span><br><span class="line">            <span class="comment">// 恢复按钮大小</span></span><br><span class="line">            transform.DOScale(<span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="number">0.1f</span>)</span><br><span class="line">            .OnComplete(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                onClick?.Invoke(gameObject, eventData);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得UI的EventTrigger吗？ <a class="btn-beautify green larger" href="/posts/e1d7977f.html#UI%E7%9A%84%E6%9E%84%E5%BB%BA" title="UI的构建"><i class="far fa-hand-point-right"></i><span>UI的构建</span></a><br>在鼠标点击方法中，我在执行事件函数之前添加了缩小和恢复两段动画，就实现了弹性的按钮啦。</p><p><img src="https://image.flashfish777.cn/img/post_17_3.gif" alt="按钮效果"></p><h2 id="Tips提示"><a href="#Tips提示" class="headerlink" title="Tips提示"></a>Tips提示</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowTip</span>(<span class="params"><span class="built_in">string</span> msg, Color color, System.Action callback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GameObject obj = Instantiate(Resources.Load(<span class="string">&quot;UI/Tips&quot;</span>), canvasTf) <span class="keyword">as</span> GameObject;</span><br><span class="line">    Text text = obj.transform.Find(<span class="string">&quot;bg/Text&quot;</span>).GetComponent&lt;Text&gt;();</span><br><span class="line">    text.color = color;</span><br><span class="line">    text.text = msg;</span><br><span class="line">    Tween scale1 = obj.transform.Find(<span class="string">&quot;bg&quot;</span>).DOScaleY(<span class="number">1</span>, <span class="number">0.4f</span>);</span><br><span class="line">    Tween scale2 = obj.transform.Find(<span class="string">&quot;bg&quot;</span>).DOScaleY(<span class="number">0</span>, <span class="number">0.4f</span>);</span><br><span class="line"></span><br><span class="line">    Sequence seq = DOTween.Sequence();</span><br><span class="line">    seq.Append(scale1);</span><br><span class="line">    seq.AppendInterval(<span class="number">0.5f</span>);</span><br><span class="line">    seq.Append(scale2);</span><br><span class="line">    seq.AppendCallback(<span class="built_in">delegate</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    MonoBehaviour.Destroy(obj, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我让一张图片生成时渐渐变宽，就形成了Tips效果。</p><p><img src="https://image.flashfish777.cn/img/post_17_2.gif" alt="Tips"></p><h2 id="翻页效果"><a href="#翻页效果" class="headerlink" title="翻页效果"></a>翻页效果</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 翻页动画（左）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FilpPageEffectLeft</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    transform.Find(<span class="string">&quot;bgmask&quot;</span>).gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    transform.SetAsLastSibling();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向左位移</span></span><br><span class="line">    ((RectTransform)transform).DOAnchorPosX(-Screen.width, <span class="number">1f</span>)</span><br><span class="line">        .SetEase(Ease.InOutQuad)</span><br><span class="line">        .OnComplete(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Close();</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过改变上一级UI的关闭动画实现了翻页效果。</p><p><img src="https://image.flashfish777.cn/img/post_17_1.gif" alt="翻页效果"></p><p>我用了几天的时间闲的没事做了一个抽奖玩法的手机小游戏，将这一系列动画效果集成在了这个小游戏中，使UI”活蹦乱跳”，我将连接放在这里了啦：<br><a href="https://github.com/flashfish777/GambleSimulator">GitHub仓库 -&gt; 读博模拟器</a><br>感兴趣可以体验一下。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>在Unity开发中，强大的插件生态能极大提升开发效率与游戏表现。<strong>DOTween</strong>作为动画系统的标杆，以它简洁的API、卓越的性能和丰富的功能，让复杂的动画效果变得触手可及。无论是UI交互、角色动作还是场景过渡，DOTween都能轻松胜任，成为开发者工具箱中不可或缺的利器。</p><p>当然，Unity的插件宇宙远不止于此。Unity众多的插件如同游戏开发的”加速器”，帮助开发者将创意快速转化为现实。但切记：<strong>插件是工具而非依赖</strong>，合理选择、适度使用才是关键。理解底层原理，结合项目需求，才能让插件真正发挥价值。</p><p>希望本文的推荐能为你的Unity开发之旅提供灵感。如果你有其他优秀的插件推荐，或对DOTween的使用有独到见解，欢迎在评论区分享交流！</p><p>—end—</p>]]></content>
    
    
    <summary type="html">推荐一种好用的Unity简单动画插件...</summary>
    
    
    
    <category term="推荐" scheme="http://www.flashfish777.cn/categories/%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="游戏开发" scheme="http://www.flashfish777.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="Unity插件" scheme="http://www.flashfish777.cn/tags/Unity%E6%8F%92%E4%BB%B6/"/>
    
    <category term="动画" scheme="http://www.flashfish777.cn/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>Unity日记：UGUI与单例模式</title>
    <link href="http://www.flashfish777.cn/posts/e1d7977f.html"/>
    <id>http://www.flashfish777.cn/posts/e1d7977f.html</id>
    <published>2024-11-20T20:00:00.000Z</published>
    <updated>2024-11-20T20:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>那段时间为了 GameJam 项目的开发，我到处学习一些Demo与教学，学到了很多我看一万种理论视频也学不来的知识，其中最令我收益匪浅的就是一个Up主的教程中，他对于UI系统的管理。</p><p>他没有麻烦地将需要的UI全部拖进场景中，而是使用了一个 <code>UIManager</code> 脚本去管理一堆 <code>UIBase</code> 的子类，并在需要的时候生成预制体。</p><p>我惊叹于竟然可以将对于UI的管理完全封装到一个类中，然后这个类只提供一个静态成员来存储这个类本身！这种方法既减免了很多对象被实例化的性能占用，更让UI的管理变得简单轻松——你只需要在任何需要的地方调用这个静态成员，就能使用 <code>UIMnager</code> 中的所有方法。</p><p>了解过之后才知道，这种巧妙的方法有很多，它们是<strong>面向对象的设计模式</strong>，而我了解到的这种叫做<strong>单例模式</strong>。</p><hr><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h2><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><p><strong>设计模式（Design Pattern）</strong> 是软件设计中针对常见问题的可重用解决方案。它们不是可以直接转化为代码的完整设计，而是解决特定问题的模板或指导方针，是众多软件工程师经过长期实践总结出来的最佳实践方案。</p><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><p>设计模式通常分为三大类：</p><h4 id="创建型模式（5种）"><a href="#创建型模式（5种）" class="headerlink" title="创建型模式（5种）"></a>创建型模式（5种）</h4><ul><li>单例模式（Singleton）</li><li>工厂方法模式（Factory Method）</li><li>抽象工厂模式（Abstract Factory）</li><li>建造者模式（Builder）</li><li>原型模式（Prototype）</li></ul><h4 id="结构型模式（7种）"><a href="#结构型模式（7种）" class="headerlink" title="结构型模式（7种）"></a>结构型模式（7种）</h4><ul><li>适配器模式（Adapter）</li><li>装饰器模式（Decorator）</li><li>代理模式（Proxy）</li><li>外观模式（Facade）</li><li>桥接模式（Bridge）</li><li>组合模式（Composite）</li><li>享元模式（Flyweight）</li></ul><h4 id="行为型模式（11种）"><a href="#行为型模式（11种）" class="headerlink" title="行为型模式（11种）"></a>行为型模式（11种）</h4><ul><li>策略模式（Strategy）</li><li>模板方法模式（Template Method）</li><li>观察者模式（Observer）</li><li>迭代器模式（Iterator）</li><li>责任链模式（Chain of Responsibility）</li><li>命令模式（Command）</li><li>备忘录模式（Memento）</li><li>状态模式（State）</li><li>访问者模式（Visitor）</li><li>中介者模式（Mediator）</li><li>解释器模式（Interpreter）</li></ul><h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><ol><li><strong>开闭原则</strong>：对扩展开放，对修改关闭</li><li><strong>单一职责原则</strong>：一个类只负责一个功能领域</li><li><strong>里氏替换原则</strong>：子类必须能够替换其父类</li><li><strong>依赖倒置原则</strong>：依赖于抽象而非具体实现</li><li><strong>接口隔离原则</strong>：使用多个专用接口而非一个总接口</li><li><strong>迪米特法则</strong>：最少知识原则，降低耦合度</li></ol><h3 id="设计模式的意义"><a href="#设计模式的意义" class="headerlink" title="设计模式的意义"></a>设计模式的意义</h3><p>设计模式的核心目的是<strong>提高软件的可维护性、可扩展性和复用性</strong>，同时保证代码的灵活性和可靠性。<br>简单来说，设计模式的目标可以从以下几个维度理解：</p><ul><li><strong>解决常见设计问题，避免重复造轮子</strong></li><li><strong>提升代码的可维护性</strong></li><li><strong>增强可扩展性</strong></li><li><strong>促进团队协作</strong></li><li><strong>优化性能与资源管理</strong></li><li><strong>平衡灵活性与复杂度</strong></li><li><strong>传承最佳实践</strong></li></ul><h2 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h3><p>单例模式确保一个类只有一个实例，并提供一个全局访问点。这种模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>当类只能有一个实例且客户可以从一个众所周知的访问点访问它时</li><li>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时</li><li>需要严格控制全局变量的场景</li><li>频繁创建和销毁的对象</li><li>重量级对象，需要共享的资源（如数据库连接池、线程池、配置对象等）</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="饿汉式（线程安全）"><a href="#饿汉式（线程安全）" class="headerlink" title="饿汉式（线程安全）"></a>饿汉式（线程安全）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> instance; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>类加载时就初始化，浪费内存</li><li>没有加锁，执行效率高</li><li>线程安全</li></ul><h4 id="懒汉式（非线程安全）"><a href="#懒汉式（非线程安全）" class="headerlink" title="懒汉式（非线程安全）"></a>懒汉式（非线程安全）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>懒加载，内存利用率高</li><li>线程不安全</li><li>不推荐使用</li></ul><h4 id="懒汉式（线程安全）"><a href="#懒汉式（线程安全）" class="headerlink" title="懒汉式（线程安全）"></a>懒汉式（线程安全）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> lockObj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (lockObj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>懒加载</li><li>线程安全</li><li>效率低（每次获取实例都要同步）</li></ul><h4 id="双重检查锁（DCL）"><a href="#双重检查锁（DCL）" class="headerlink" title="双重检查锁（DCL）"></a>双重检查锁（DCL）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> lockObj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">lock</span> (lockObj)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>懒加载</li><li>线程安全</li><li>效率较高（只有第一次创建时需要同步）</li></ul><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类（C# 中称为嵌套类）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SingletonHolder</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> SingletonHolder.Instance; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>懒加载（只有调用getInstance时才会加载SingletonHolder类）</li><li>线程安全</li><li>效率高</li><li>推荐使用</li></ul><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 显式静态构造函数告诉编译器不要标记为beforefieldinit</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 业务方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>简洁</li><li>自动支持序列化机制</li><li>绝对防止多次实例化</li></ul><h3 id="单例模式的优缺点"><a href="#单例模式的优缺点" class="headerlink" title="单例模式的优缺点"></a>单例模式的优缺点</h3><p><strong>优点</strong>：</p><ul><li>提供了对唯一实例的受控访问</li><li>节约系统资源（避免频繁创建和销毁对象）</li><li>允许可变数目的实例（可以通过设计扩展）</li></ul><p><strong>缺点</strong>：</p><ul><li>没有抽象层，难以扩展</li><li>职责过重，在一定程度上违背了”单一职责原则”</li><li>不适用于变化的对象</li><li>滥用单例会导致代码耦合度高，难以测试</li></ul><h3 id="单例模式的注意事项"><a href="#单例模式的注意事项" class="headerlink" title="单例模式的注意事项"></a>单例模式的注意事项</h3><ol><li><strong>线程安全</strong>：多线程环境下要确保只创建一个实例</li><li><strong>序列化问题</strong>：如果单例类使用了Serializable特性，反序列化时会创建新实例</li><li><strong>反射攻击</strong>：通过反射可以调用私有构造器创建新实例</li><li><strong>类加载器问题</strong>：不同的类加载器可能会创建多个实例</li><li><strong>内存泄漏</strong>：长时间不用的单例对象可能导致内存泄漏</li></ol><h2 id="设计模式与单例模式的实践建议"><a href="#设计模式与单例模式的实践建议" class="headerlink" title="设计模式与单例模式的实践建议"></a>设计模式与单例模式的实践建议</h2><ol><li><strong>不要过度使用单例模式</strong>：单例模式本质上是全局变量，过度使用会导致代码难以维护和测试</li><li><strong>考虑依赖注入</strong>：对于需要单例的对象，可以考虑使用依赖注入框架（如Spring）来管理</li><li><strong>优先选择枚举实现</strong>：枚举实现简单且能防止反射和序列化问题</li><li><strong>注意生命周期管理</strong>：明确单例对象的创建和销毁时机</li><li><strong>考虑替代方案</strong>：对于某些场景，静态工具类可能是更好的选择</li></ol><hr><h1 id="Unity-UI的管理"><a href="#Unity-UI的管理" class="headerlink" title="Unity UI的管理"></a>Unity UI的管理</h1><p>在我的项目中，我融汇并使用了这种设计模式。尽管可能并不是很完美与规范，但还是为我的开发带来了不少的便捷与优化。</p><h2 id="UI的构建"><a href="#UI的构建" class="headerlink" title="UI的构建"></a>UI的构建</h2><p><strong>UIBase: UI基类</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> UI基类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIBase</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UIEventTrigger <span class="title">Register</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Transform tf = transform.Find(name);</span><br><span class="line">        <span class="keyword">return</span> UIEventTrigger.Get(tf.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 显示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Hide</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭（销毁）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Close</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIManager.Instance.CloseUI(gameObject.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UIEventTrigger: UI事件类</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> UI事件</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIEventTrigger</span> : <span class="title">MonoBehaviour</span>, <span class="title">IPointerClickHandler</span>, <span class="title">IPointerEnterHandler</span>, <span class="title">IPointerExitHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Action&lt;GameObject, PointerEventData&gt; onClick; <span class="comment">// 鼠标点击</span></span><br><span class="line">    <span class="keyword">public</span> Action&lt;GameObject, PointerEventData&gt; onEnter; <span class="comment">// 鼠标进入</span></span><br><span class="line">    <span class="keyword">public</span> Action&lt;GameObject, PointerEventData&gt; onExit; <span class="comment">// 鼠标离开</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UIEventTrigger <span class="title">Get</span>(<span class="params">GameObject obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIEventTrigger trigger = obj.GetComponent&lt;UIEventTrigger&gt;();</span><br><span class="line">        <span class="keyword">if</span> (trigger == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            trigger = obj.AddComponent&lt;UIEventTrigger&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> trigger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerClick</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 执行事件</span></span><br><span class="line">        onClick?.Invoke(gameObject, eventData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerEnter</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        onEnter?.Invoke(gameObject, eventData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerExit</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        onExit?.Invoke(gameObject, eventData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 UIBase 中，我封装了包括打开关闭与UI事件的基本逻辑。然后将UI事件扩展成一个类，在改类中使用 <code>Action</code> 事件来存储UI被触发时的逻辑，并实现了需要的鼠标事件接口，在对应的鼠标事件函数中调用对应的UI事件，扩展了UI的事件多样性。</p><h2 id="UI的管理"><a href="#UI的管理" class="headerlink" title="UI的管理"></a>UI的管理</h2><p><strong>UIManager: 管理UI的单例类</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> UI管理器</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UIManager Instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Transform canvasTf; <span class="comment">// 画布的变换组件</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UIBase&gt; uiList; <span class="comment">// 存储加载过的界面的集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不对外开方构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UIManager</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态初始化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实例化对象</span></span><br><span class="line">        Instance = <span class="keyword">this</span>();</span><br><span class="line">        <span class="comment">// 找世界中的画布</span></span><br><span class="line">        canvasTf = GameObject.Find(<span class="string">&quot;Canvas&quot;</span>).transform;</span><br><span class="line">        <span class="comment">// 初始化集合</span></span><br><span class="line">        uiList = <span class="keyword">new</span> List&lt;UIBase&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 显示UI</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UIBase <span class="title">ShowUI</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> uiName</span>) <span class="keyword">where</span> T : UIBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIBase ui = Find(uiName);</span><br><span class="line">        <span class="keyword">if</span> (ui == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 集合中没有就需要从其他地方（如 Resources/UI 文件夹中）加载</span></span><br><span class="line">            GameObject obj = Instantiate(Resources.Load(<span class="string">&quot;UI/&quot;</span> + uiName), canvasTf) <span class="keyword">as</span> GameObject;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 改名字</span></span><br><span class="line">            obj.name = uiName;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加需要的脚本</span></span><br><span class="line">            ui = obj.AddComponent&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加到集合进行存储</span></span><br><span class="line">            uiList.Add(ui);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 显示</span></span><br><span class="line">            ui.Show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ui;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏UI</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HideUI</span>(<span class="params"><span class="built_in">string</span> uiName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIBase ui = Find(uiName);</span><br><span class="line">        <span class="keyword">if</span> (ui != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ui.Hide();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭所有界面</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CloseAllUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = uiList.Count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(uiList[i].gameObject);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uiList.Clear(); <span class="comment">// 清空集合</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭某个界面</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CloseUI</span>(<span class="params"><span class="built_in">string</span> uiName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIBase ui = Find(uiName);</span><br><span class="line">        <span class="keyword">if</span> (ui != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            uiList.Remove(ui);</span><br><span class="line">            Destroy(ui.gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从集合中找到名字对应的界面脚本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UIBase <span class="title">Find</span>(<span class="params"><span class="built_in">string</span> uiName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> t <span class="keyword">in</span> uiList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.name == uiName)</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得某个界面的脚本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetUI</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> uiName</span>) <span class="keyword">where</span> T : UIBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIBase ui = Find(uiName);</span><br><span class="line">        <span class="keyword">if</span> (ui != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ui.GetComponent&lt;T&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在UIManager中，我提供了一个公共的 <code>Instance</code> 属性作为“窗口”，使得所有脚本都可以调用 <code>UIManager</code> 的方法，然后关闭构造函数，提供一个静态的初始化函数，使Instance只能通过初始化函数实例化自身。最后再加上对UI进行管理的相关方法，一个专业的管理者就诞生了。</p><h2 id="UI的实例"><a href="#UI的实例" class="headerlink" title="UI的实例"></a>UI的实例</h2><p>再之后，分别写出需要的UI实例类，继承UIBase，使它们获得UI的基本逻辑，如：<br><strong>LoginUI: 登录界面</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 登录界面</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoginUI</span> : <span class="title">UIBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 开始游戏</span></span><br><span class="line">        Register(<span class="string">&quot;start&quot;</span>).onClick = onStartGameBtn;</span><br><span class="line">        <span class="comment">// 设置</span></span><br><span class="line">        Register(<span class="string">&quot;settings&quot;</span>).onClick = onSettingsBtn;</span><br><span class="line">        <span class="comment">// 退出游戏</span></span><br><span class="line">        Register(<span class="string">&quot;quit&quot;</span>).onClick = onQuitBtn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onStartGameBtn</span>(<span class="params">GameObject @<span class="built_in">object</span>, PointerEventData data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 开始游戏的逻辑，</span></span><br><span class="line">        <span class="comment">// 如加载场景、调用UI</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// UIManager将预制体实例化到场景中</span></span><br><span class="line">        UIManager.Instance.ShowUI&lt;GameUI&gt;(<span class="string">&quot;GameUI&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Close(); <span class="comment">// 关闭LoginUI</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onSettingsBtn</span>(<span class="params">GameObject @<span class="built_in">object</span>, PointerEventData data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIManager.Instance.ShowUI&lt;SettingsUI&gt;(<span class="string">&quot;SettingsUI&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onQuitBtn</span>(<span class="params">GameObject @<span class="built_in">object</span>, PointerEventData data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">        UnityEditor.EditorApplication.isPlaying = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        Application.Quit();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SettingsUI: 设置界面</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 设置UI</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SettingsUI</span> : <span class="title">UIBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        Register(<span class="string">&quot;close&quot;</span>).onClick = onCloseBtn;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回主菜单</span></span><br><span class="line">        Register(<span class="string">&quot;backTOmenu&quot;</span>).onClick = onBackBtn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onCloseBtn</span>(<span class="params">GameObject @<span class="built_in">object</span>, PointerEventData data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onBackBtn</span>(<span class="params">GameObject @<span class="built_in">object</span>, PointerEventData data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Close();</span><br><span class="line"></span><br><span class="line">        UIManager.Instance.ShowUI&lt;LoginUI&gt;(<span class="string">&quot;LoginUI&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在具体的UI类中，需要根据UI的功能在最开始（Awake）的时候将对应的函数事件添加到相应的UI事件中。还记得吗？注册函数 <code>Register</code> 返回的是 <code>UIEventTrigger</code> 类。这时，我们在对UI进行操作时，便会调用对应的函数事件，执行UI的逻辑了。<br>同时，我们可以在例子中的具体UI事件中看到对于 <code>UIManager</code> 的调用，轻松的管理了UI界面的生成。</p><p><strong>注意</strong>：<code>UIManager</code> 生成UI的方法是在资源文件中寻找相应名称的UI预制体，并将对应的脚本挂载到预制体上，所以，ShowUI&lt; <code>T</code> &gt;( <code>&quot;&quot;</code> ) 的两个参数一定不能写错。</p><hr><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>单例模式是一种简单却强大的设计模式，它确保一个类只有一个实例，并提供了全局访问点。无论是管理配置信息、数据库连接，还是共享资源，单例模式都能帮助我们避免不必要的资源浪费，同时保证数据的一致性。</p><p>设计模式的世界远不止于此。除了单例模式，还有更多巧妙的设计模式，它们各自解决特定场景下的问题，让代码更具扩展性和可维护性。</p><p>设计模式的核心思想是“解决问题”，而非“套用规则”。希望本文能帮助你理解单例模式的精髓，并在实际开发中灵活运用。如果你对其他设计模式感兴趣，或者有更多想法与疑问，欢迎在评论区交流讨论！</p><p>—end—</p>]]></content>
    
    
    <summary type="html">在项目开发过程中对于UI的管理与设计模式有了很多新的认识与思考...</summary>
    
    
    
    <category term="知识分享" scheme="http://www.flashfish777.cn/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="游戏开发" scheme="http://www.flashfish777.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="Unity" scheme="http://www.flashfish777.cn/tags/Unity/"/>
    
    <category term="C#" scheme="http://www.flashfish777.cn/tags/C/"/>
    
    <category term="OOP" scheme="http://www.flashfish777.cn/tags/OOP/"/>
    
    <category term="设计模式" scheme="http://www.flashfish777.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>《青年谓世辞》的故事</title>
    <link href="http://www.flashfish777.cn/posts/8c9cff07.html"/>
    <id>http://www.flashfish777.cn/posts/8c9cff07.html</id>
    <published>2024-11-16T18:43:53.000Z</published>
    <updated>2024-11-16T18:43:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h1><p><strong>回忆的开始</strong></p><p>没事翻看相册的时候偶然翻到这张图片：</p><p><img src="https://image.flashfish777.cn/img/post_15_1.jpg"></p><p>这是一张高考前二模的时候我的作文的阅卷图片，当时得了52分，在全校数一数二。<br>这张图片模模糊糊的，却勾起了我很多回忆。</p><p>高中的时候很喜欢古诗文，现在也是，这种浓缩的、有情感、有韵律的文字，我觉得美极了。当时不仅背过很多很多的古诗文，也经常写一些诗词拿来消遣。<br>那时候正是最紧张的复习阶段，可是越到这个时候我越是学不进去，那时候晚自习根本写不进去作业，除了偷偷看小说，写一写诗词便成了唯一的乐趣。可以写日常的生活、无聊的复习、同学的黑历史很多很多。<br>然后说语文。我的语文成绩一直是个谜。六科里面我唯一一点东西都不学的就是语文。别人学六科，我学五科。这可是高三啊，可和大学不一样，有一科一点不学真的不敢想。可是我就是这样的，而且最神奇的是，我的语文成绩还一直都是第一第二（我是真的不学啊）。但因为我不学习跟语文老师闹得很僵，因为我上课从不会听讲，作业也不写。高三的时候有一次语文老师让我们上课写作文，我不但不写还拿出化学作业来写，导致他直接大发雷霆，抢走了我的化学作业，我也没服软（因为我觉得真没什么好服软的，经过我长时间的不学语文分数却一直这么高导致我真的不想再把时间浪费在做那些作业上，再提升也提升不了多少（那时候基本上模拟都是125&#x2F;150，对于语文来说已经很高了），不如多提升一下其他科目），我又抢回来了，老师就说再也不管我，还说我以后要是交作业我就是🐶，我俩就开始冷战了。结局就是以后的考试语文还是第一第二，高考也没掉链子。我不知道老师一直都是怎么想，我后面也再没揣测过，我觉得后悔和对老师有意见都不是什么好事.</p><p>好了回归正题，有一次我发现写这种偏文言的作文得的分会高很多，可能是显得比较有文采，虽然也都是照猫画虎，写的当然不是真正的文言文。于是我就开始都写这种文章，每次也都是拿很高很高的分，甚至我高考也是写的这种。<br>我写过很多很多的诗、词和这种文章，但记录下来的只有这个应该。虽然对于我自己来说肯定是觉得每篇都很好，但我总是记得有一篇特别特别好，可是应该找不到了，我记得是高考完扔掉了，不是这篇。今天突然翻到了，就想对照着照片和记忆把文章拷下来，虽然图片有的字都看不清，但毕竟是自己写的，也能记起个大概。</p><h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><details class="toggle" ><summary class="toggle-button" style="">青年谓世辞</summary><div class="toggle-content"><pre><code>青年谓世辞</code></pre><p>明时而立，新世而属。致学不艰，勤业不苦。时开放之局，今世界一浦。年方青壮，生于黄土。遗世而生 ，志存鸿鹄。世界生我，问我以何志而锄；我谓世界，答之以变之为笃。</p><p>立心于天地，立命于生民。继绝学于往圣，开太平于万世。大国汤汤，其韵绵长。吾辈青年，与国无疆。观察世界，志在四方。融入世界，敢拼敢当。影响世界，遗世留香。当以此志，扬帆远航！</p><p>观察世界，志以修身。睹古今之兴变，明智理之遗存。视当今之格局，立长志以修身。观世之所需兮，先吾辈乎立志。代长梦以快马兮，莫负时之韶韶；觑困拘于迩达兮，莫畏路之迢迢！渺长征之天路兮，见军未有色挠。明长志以立世兮，终行吾之所道。观世之遗蕴兮，品其意之可昭。下远洋以寻陆，治乱世于明条。开疆拓土，以谓创造。吾辈青年，立世之礁，观世之蕴，行己之道。</p><p>融入世界，以勤志心；为梦为志，以奋志体。欲成志以容世兮，当吾辈乎勤坚。非梦桃之桃梦兮，梦荣光之一取。忍疼痛之锥骨兮，终跪地而旗举。添鞍辔于梦骏兮，虽万险而莫惧！以若所坚，求若所欲。困坚毅于金石兮，虽殒身而不恤！行坚而睹己，省前日而回已。学日新以时习兮，自孔夫而谈起；成吾辈之身修兮，虽千年而未已！行此之坚毅兮，问以何而身修？欲融志于世界，行冬夏而春秋。</p><p>影响世界，当任以己。己欲立乎立人，己欲达乎达人。夫吾立之地，实为吾疆。吾心所向，乃国显彰。吾德如阳，则邦生光；吾志若玉，其道弥昌；吾怀明德，天下同芳。君可见也，芳龄村官返家乡，排难渡险致富地；君可见也，埋名隐姓黄土里，家国利剑扶摇起；君可见也，敢问吾书为何读，一人一志国崛起。泱泱华夏，名仕四地；大千世界，志士四起。影响世界，当需由己！行己之道，坚己之意。颤举世之格局，终因吾而已矣。</p><p>世界育我，我心明德。吾辈青年，应以我则。世界问我，我谓其说：吾辈青年，当立当歌！一苇以航，修身立德行志；振翅以翔，观世融世惊世。吾辈青年，当以此仿。知深洋谷，德曜星芒。为梦为志，当奋当狂。前承千古，后亦流芳！</p></div></details><p>（copy下来感觉好少啊哈哈）</p><p>我还把文章喂给了AI，让他解析以下，我感觉还不错。</p><details class="toggle" ><summary class="toggle-button" style="">AI翻译及解析</summary><div class="toggle-content"><p>以下是逐段翻译与解析，确保覆盖全文每个段落：</p><hr><p><strong>青年谓世辞</strong></p><p><em><strong>原文第一段</strong></em></p><p><strong>明时而立，新世而属。致学不艰，勤业不苦。时开放之局，今世界一浦。年方青壮，生于黄土。遗世而生 ，志存鸿鹄。世界生我，问我以何志而锄；我谓世界，答之以变之为笃。</strong></p><p><strong>翻译：</strong><br>青年向世界宣言：<br>我们生在开明的时代，属于崭新的世界。求学不再艰难，奋斗不再痛苦。面对开放的格局，世界已连成一片。正值青春年华，扎根于祖国大地，虽身处平凡却心怀超越的鸿鹄之志。世界问我们“以何种志向耕耘人生”，我们回答：“改变世界是永恒的信念！”</p><p><strong>解析：</strong></p><ul><li><p><strong>核心意象</strong>：以“明时”“新世”强调时代特征，“黄土”象征中华大地，“鸿鹄”喻远大志向。</p></li><li><p><strong>问答结构</strong>：通过“世界问我—我答世界”的对话，点明青年使命。</p></li><li><p><strong>语言特色</strong>：“锄”字双关，既指耕耘土地，又喻人生奋斗。</p></li></ul><hr><p><em><strong>原文第二段</strong></em></p><p><strong>立心于天地，立命于生民。继绝学于往圣，开太平于万世。大国汤汤，其韵绵长。吾辈青年，与国无疆。观察世界，志在四方。融入世界，敢拼敢当。影响世界，遗世留香。当以此志，扬帆远航！</strong></p><p><strong>翻译：</strong><br>（此段为总纲，后文展开部分已拆分解析，此处保留完整翻译）<br>我们立志于天地，献身于人民。传承先贤的智慧，开创万世的太平。大国气象恢宏，文明生生不息。我们青年与祖国共成长，永无止境。观察世界，胸怀天下；融入世界，勇于担当；影响世界，留下不朽印记。带着这样的志向，启程远航！</p><p><strong>解析：</strong></p><ul><li><p><strong>思想源流</strong>：化用张载“横渠四句”（为天地立心，为生民立命，为往圣继绝学，为万世开太平），体现儒家担当。</p></li><li><p><strong>结构功能</strong>：总领全文，提出“观察-融入-影响”三重境界。</p></li></ul><hr><p><em><strong>原文第三段（观察世界部分）</strong></em></p><p><strong>观察世界，志以修身。睹古今之兴变，明智理之遗存。视当今之格局，立长志以修身。观世之所需兮，先吾辈乎立志。代长梦以快马兮，莫负时之韶韶；觑困拘于迩达兮，莫畏路之迢迢！</strong></p><p><strong>翻译：</strong><br>观察世界，以志向修身。看古今兴衰变迁，明悟智慧传承；观当今世界格局，树立长远志向。根据时代需要，青年首先要确立理想。以快马追逐长远梦想，不辜负美好青春；莫被眼前利益束缚，别畏惧路途遥远！</p><p><strong>解析：</strong></p><ul><li><p><strong>方法论</strong>：提出“观察-明理-立志”的修身路径。</p></li><li><p><strong>警示对照</strong>：“迩达”（眼前成就）与“迢迢”（长远目标）形成对比。</p></li></ul><hr><p><em><strong>原文第三段（观察世界例证）</strong></em></p><p><strong>渺长征之天路兮，见军未有色挠。明长志以立世兮，终行吾之所道。观世之遗蕴兮，品其意之可昭。下远洋以寻陆，治乱世于明条。开疆拓土，以谓创造。吾辈青年，立世之礁，观世之蕴，行己之道。</strong></p><p><strong>翻译：</strong><br>遥望长征险途，先烈面不改色；坚定远大志向，终将走自己的道路。观察文明积淀，领悟其中深意。如同航海家探索新大陆，像改革家重建秩序。开拓创新，这才是真正的创造。我们这一代青年，如礁石屹立于世，观察世界的深意，践行自己的道路。</p><p><strong>解析：</strong></p><ul><li><p><strong>历史回响</strong>：以长征精神激励当代，实现精神谱系传承。</p></li><li><p><strong>历史事件</strong>：“下远洋”指郑和航海。</p></li><li><p><strong>重新定义</strong>：将“开疆拓土”从地理概念转化为创新维度。</p></li><li><p><strong>象征</strong>：“礁石”象征坚定，突出青年在时代中的锚定作用。</p></li></ul><hr><p><em><strong>原文第四段（融入世界核心论述和例证）</strong></em></p><p><strong>融入世界，以勤志心；为梦为志，以奋志体。欲成志以容世兮，当吾辈乎勤坚。非梦桃之桃梦兮，梦荣光之一取。忍疼痛之锥骨兮，终跪地而旗举。</strong>  </p><p><strong>翻译：</strong><br>融入世界，追逐梦想，需以勤奋坚定心志与行动。若想实现理想、立足世间，我们必须勤勉坚韧。徐梦桃的梦想并不是虚幻的空想（<em>“桃梦”指不切实际的幻想</em>），而是真正的荣耀。即便忍受锥心刺骨的痛苦，最终举起胜利的旗帜！</p><p><strong>解析：</strong></p><ul><li><p><strong>引用真人真事</strong>：用徐梦桃在奥运会的故事来论证勤奋与梦想</p></li><li><p><strong>目标导向</strong>：强调“荣光”需通过实际奋斗获取。</p></li></ul><hr><p><em><strong>原文第四段（融入世界方法论）</strong></em></p><p><strong>添鞍辔于梦骏兮，虽万险而莫惧！以若所坚，求若所欲。困坚毅于金石兮，虽殒身而不恤！行坚而睹己，省前日而回已。学日新以时习兮，自孔夫而谈起；成吾辈之身修兮，虽千年而未已！行此之坚毅兮，问以何而身修？欲融志于世界，行冬夏而春秋。</strong>  </p><p><strong>翻译：</strong><br>为梦想的骏马备好鞍辔，纵使万般艰险也绝不退缩！以这样的坚定，追求这样的理想。将毅力熔铸成金石般的意志，哪怕牺牲生命也毫不迟疑！行动中审视自我，反思过往修正自身。学习要日日常新、时时践行，这是从孔子时代便传承的真理；我们修身养性的追求，纵使千年也不会停息！践行这样的坚毅时，如何修身？要将志向融入世界，历经四季轮回。</p><p><strong>解析：</strong></p><ul><li><p><strong>生死观</strong>：“殒身不恤”化用林觉民《与妻书》，彰显献身精神。</p></li><li><p><strong>古今贯通</strong>：将《论语》“学而时习之”与当代“终身学习”理念结合。</p></li><li><p><strong>时间维度</strong>：通过“千年”强调修身的永恒性，破除急功近利思维，“冬夏春秋”喻指长期坚持，不惧时间考验。</p></li></ul><hr><p><em><strong>原文第五段（影响世界总论）</strong></em></p><p><strong>影响世界，当任以己。己欲立乎立人，己欲达乎达人。夫吾立之地，实为吾疆。吾心所向，乃国显彰。吾德如阳，则邦生光；吾志若玉，其道弥昌；吾怀明德，天下同芳。</strong><br><strong>翻译：</strong><br>影响世界，需从自身担当开始。自己要立身立业，也要助他人立身立业；自己追求通达，也要助他人通达。我们站立的地方，就是责任的疆土；我们心志所指的方向，便是国家的荣光。若我们的德行如太阳般光辉，国家便充满光明；若我们的志向如美玉般高洁，民族复兴之路将更加通畅；若我们心怀美德，天下将共享芬芳。</p><p><strong>解析：</strong></p><ul><li><p><strong>儒家伦理</strong>：直接引用《论语》“己欲立而立人”，强调推己及人的担当。</p></li><li><p><strong>化用名句</strong>：化用崔卫平《光明与黑暗》中的名句“你所站立的地方，正是你的中国；你怎么样，中国便怎么样；你是什么，中国便是什么；你有光明，中国便不黑暗”。</p></li><li><p><strong>因果关系</strong>：个人品德直接决定国家命运，体现“修身→治国”的传统逻辑。</p></li></ul><hr><p><em><strong>原文第五段（影响世界现实例证）</strong></em></p><p><strong>君可见也，芳龄村官返家乡，排难渡险致富地；君可见也，埋名隐姓黄土里，家国利剑扶摇起；君可见也，敢问吾书为何读，一人一志国崛起。</strong>  </p><p><strong>翻译：</strong><br>你看！年轻村官返回家乡，攻坚克难带领乡亲致富；你看！隐姓埋名的奉献者扎根荒漠，铸就护国重器直上云霄；你看！万千学子追问“为何而读书”，用个人志向推动国家崛起。</p><p><strong>解析：</strong></p><ul><li><p><strong>现实映射</strong>：</p><ul><li><p>“芳龄村官”指向黄文秀等扶贫干部；</p></li><li><p>“埋名隐姓”对应邓稼先等“两弹一星”元勋；</p></li><li><p>“书为何读”化用周恩来“为中华之崛起而读书”。</p></li></ul></li><li><p><strong>镜头语言</strong>：三个“君可见也”如电影蒙太奇，展现不同领域的青年担当。</p></li></ul><hr><p><em><strong>原文第五段（影响世界总结）</strong></em></p><p><strong>泱泱华夏，名仕四地；大千世界，志士四起。影响世界，当需由己！行己之道，坚己之意。颤举世之格局，终因吾而已矣。</strong>  </p><p><strong>翻译：</strong><br>华夏大地英才辈出，世界各处志士云集。改变世界必须从自身做起！坚持自己的道路，坚定自己的信念。撼动世界格局的力量，终将因我们而诞生！</p><p><strong>解析：</strong></p><ul><li><p><strong>空间拓展</strong>：从“华夏”到“大千世界”，构建人类命运共同体视角。</p></li><li><p><strong>动词炼字</strong>：“颤”字既含“震撼”之力，又带“改变”之渐进性，精准表达量变到质变的过程。</p></li></ul><hr><p><em><strong>原文结尾段（全文升华）</strong></em></p><p><strong>世界育我，我心明德。吾辈青年，应以我则。世界问我，我谓其说：吾辈青年，当立当歌！一苇以航，修身立德行志；振翅以翔，观世融世惊世。吾辈青年，当以此仿。知深洋谷，德曜星芒。为梦为志，当奋当狂。前承千古，后亦流芳！</strong>  </p><p><strong>翻译：</strong><br>世界培育我们，我们心怀光明德行。新时代青年应以自身为准则，回应世界的叩问：我们必将顶天立地，高歌前行！像芦苇般坚韧远航，修身立德践行理想；如雄鹰振翅高飞，观察世界、融入时代、震撼寰宇！青年们应当以此为榜样，让学识比大洋和峡谷还深，让德行如星辰光芒般闪耀。为梦想与志向，就应这般行动！继承千古文明，开创万世流芳！</p><p><strong>解析：</strong></p><ul><li><p><strong>文化符号</strong>：</p><ul><li><p>“一苇以航”出自《诗经·卫风·河广》“谁谓河广？一苇杭之”，喻微小而坚韧的力量；</p></li><li><p>“振翅以翔”呼应《庄子·逍遥游》鲲鹏意象，象征超越性追求。</p></li></ul></li><li><p><strong>时空对话</strong>：“前承千古”与“后亦流芳”形成历史纵深感，将青年置于文明传承者位置。</p></li><li><p><strong>动词体系</strong>：“观-融-惊”三字浓缩全文三大篇章，与开篇“观察-融入-影响”形成闭环。</p></li></ul><hr></div></details><p>真是每一句都说出了我写时想说的！ </p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>现在想来高中的真的满是回忆啊，真的是最美好的时光，可惜已经回不去了，不可惜的是高中时候的好朋友都还在。祝所有人都事事顺心、不留遗憾。</p><p>—end—</p>]]></content>
    
    
    <summary type="html">一篇作文和一些想说的...</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>TapTap聚光灯GameJam</title>
    <link href="http://www.flashfish777.cn/posts/249f88d5.html"/>
    <id>http://www.flashfish777.cn/posts/249f88d5.html</id>
    <published>2024-11-15T12:00:00.000Z</published>
    <updated>2024-11-15T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger info flat"><p><strong>酝酿中</strong></p></div><p>—end—</p>]]></content>
    
    
    <summary type="html">第一次参加GameJam，虽然因为一些原因遗憾没能提交作品，但还是学到了很多...</summary>
    
    
    
    <category term="项目" scheme="http://www.flashfish777.cn/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="游戏" scheme="http://www.flashfish777.cn/categories/%E9%A1%B9%E7%9B%AE/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="GameJam" scheme="http://www.flashfish777.cn/categories/%E9%A1%B9%E7%9B%AE/%E6%B8%B8%E6%88%8F/GameJam/"/>
    
    
    <category term="GameJam" scheme="http://www.flashfish777.cn/tags/GameJam/"/>
    
    <category term="游戏开发" scheme="http://www.flashfish777.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="Unity" scheme="http://www.flashfish777.cn/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Inno Setup 安装包制作教程</title>
    <link href="http://www.flashfish777.cn/posts/54db36cb.html"/>
    <id>http://www.flashfish777.cn/posts/54db36cb.html</id>
    <published>2024-10-30T21:00:00.000Z</published>
    <updated>2024-10-30T21:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1> Inno Setup 打包教程 </h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对计算机相对熟悉之后，我们发现大部分应用都是一整个文件，里面可能会有 <code>exe</code> 可执行文件及其他素材文件、库文件、依赖等等。比如我的 LecSnake ，windows平台打包之后是一个这样的文件夹：</p><p><img src="https://image.flashfish777.cn/img/post_13_1.jpg" alt="&#x2F;LecSnake&#x2F;"></p><p>以后我们可能还会做更多的游戏以及其他的项目。那么我们想发给朋友玩的时候难道只能压缩成压缩包然后发给别人解压吗？<br>我们一般在网上下载东西时都是下载安装程序。再通过安装程序将应用文件夹下载至磁盘中。那么我们自己的应用是否也可以打包成 方便 快捷 高级 的安装程序呢？<br>本文将介绍 <code>Inno Setup</code> 及使用 <code>Inno Setup</code> 快捷方便的将应用文件夹打包成安装程序的方法。</p><h1 id="Inno-Setup"><a href="#Inno-Setup" class="headerlink" title="Inno Setup"></a>Inno Setup</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Inno Setup</code> 是一个免费的 Windows 安装程序制作工具，具有以下特点：</p><ul><li>小巧高效（单EXE即可运行）</li><li>支持所有现代Windows版本</li><li>内置多语言支持</li><li>支持脚本扩展功能</li></ul><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>访问 <a href="http://www.jrsoftware.org/isdl.php">官方下载页面</a> 下载最新版本（当前推荐版本：6.4.2）</p><p><img src="https://image.flashfish777.cn/img/post_13_2.jpg" alt="download"></p><p>下面那个 <code>Netherlands</code> 要快一些。</p><h3 id="安装选项"><a href="#安装选项" class="headerlink" title="安装选项"></a>安装选项</h3><p>建议：</p><ul><li>记得安到D盘哦</li><li>剩下全部默认就可以了</li></ul><h2 id="基础打包步骤"><a href="#基础打包步骤" class="headerlink" title="基础打包步骤"></a>基础打包步骤</h2><h3 id="使用脚本向导创建基础脚本"><a href="#使用脚本向导创建基础脚本" class="headerlink" title="使用脚本向导创建基础脚本"></a>使用脚本向导创建基础脚本</h3><p>（推荐）</p><p>通过开始菜单或桌面快捷方式启动 <code>Inno Setup Compiler</code> ，打开之后会有一个 <code>Welcome</code> 窗口:</p><p><img src="https://image.flashfish777.cn/img/post_13_3.png" alt="welcome"></p><p>选择 “<code>Create a new script using the Script Wizard</code>“，点击 <code>OK</code> 。</p><p>也可以通过主程序左上角 <code>File/New</code> 来创建一个新的脚本文件向导。</p><p><code>Inno Setup</code> 的运行原理简单来说就是通过一组脚本规则来创建对应的安装程序，脚本规则中主要包括安装路径、文件夹位置、应用程序配置、语言等等规则，我们要做的就是配置好这些规则，然后运行脚本文件生成安装程序。同时还可以将脚本文件保存下来，打包具有相似配置的应用时直接使用即可。</p><p>接下来直接点击 <code>Next</code> 来到 <code>Application Information</code> (应用信息)界面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Application name : Myproject // 此处填写最终生成的应用名称，及 Myproject.exe</span><br><span class="line">Application version : 1.0 // 此处填写应用的版本</span><br><span class="line">Application publisher : yourname // 发布者信息，什么都可以，非必要</span><br><span class="line">Application website : // 网站网址，非必要</span><br><span class="line"></span><br><span class="line">-&gt; Next</span><br></pre></td></tr></table></figure><p>来到 <code>Application Folder</code> ，这里设定安装完成后的文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Application destination base folder : 默认安装路径，不用动，也可以自定义</span><br><span class="line">Application folder Name : 生成的文件夹名称</span><br><span class="line">允许用户更改安装路径一般为true</span><br><span class="line">第四个不用管</span><br><span class="line"></span><br><span class="line">-&gt; Next</span><br></pre></td></tr></table></figure><p>来到 <code>Application Files</code> ，设定源文件：</p><p><img src="https://image.flashfish777.cn/img/post_13_4.jpg" alt="Application Files"></p><p>点击 <code>Browse</code> 选择要打包应用的可执行文件 (<code>exe</code>)，然后在下方点击 <code>Add folder</code> 将应用文件夹全部添加上去即可 Next 。</p><p>下一步 <code>Application File Association</code> 不需要，勾掉（<code>false</code>）就可以了。</p><p>下一步 <code>Application Shortcuts</code> 默认。</p><p>下一步 <code>Application Documentation</code> 跳过。</p><p>下一步 <code>Setup Install Mode</code> 默认。</p><p>下一步 <code>Application Registry Keys And Values</code> 跳过。</p><p>下一步语言选择英语即可。</p><p>下一步 <code>Compiler Settings</code> 配置安装包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Custom compiler output folder: // 运行脚本文件后安装包生成的目录</span><br><span class="line">Compiler output base file name: LecSnake_Setup // 安装包名称</span><br><span class="line">Custom Setup icon file: // 安装包icon文件，非必要</span><br><span class="line">Setup password: // 安装密码，非必要</span><br><span class="line"></span><br><span class="line">-&gt; Next</span><br></pre></td></tr></table></figure><p>下一步 <code>Inno Setup Preprocessor</code> 保持默认即可。</p><p>点击 Finish 后即可看到生成的脚本文件，在自动弹出的弹窗点击“是”将开始执行脚本，或者在主程序左上角 <code>Run/Run</code> 随时执行脚本文件。等待一段时间执行完成后，在之前填写的 <code>Custom compiler output folder</code> 目录中即可找到安装程序。随后你可以选择保存脚本文件等待下一次的使用。</p><p>BiliBili教程-&gt;</p><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1MZQ8YTEeg&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><hr><h3 id="直接配置脚本文件"><a href="#直接配置脚本文件" class="headerlink" title="直接配置脚本文件"></a>直接配置脚本文件</h3><p>如果你已经了解了创建安装程序的基本规则，并相对熟悉了脚本文件的大致配置你可以直接修改脚本文件来配置规则，这样不仅自由度更高也更加方便修改。</p><p>以下展示大致脚本代码介绍与步骤：</p><h4 id="填写基本信息"><a href="#填写基本信息" class="headerlink" title="填写基本信息"></a>填写基本信息</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Setup]</span><br><span class="line">AppName=My Application</span><br><span class="line">AppVersion=<span class="number">1.0</span></span><br><span class="line">DefaultDirName=<span class="comment">&#123;pf&#125;</span>\MyApp</span><br><span class="line">DefaultGroupName=MyApp</span><br><span class="line">OutputDir=userdocs:Inno Setup Examples Output</span><br></pre></td></tr></table></figure><h4 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h4><p>在脚本的<code>[Files]</code>段添加：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Files]</span><br><span class="line">Source: &quot;C:\MyApp\*&quot;; DestDir: &quot;<span class="comment">&#123;app&#125;</span>&quot;; Flags: ignoreversion recursesubdirs</span><br></pre></td></tr></table></figure><h4 id="创建开始菜单项"><a href="#创建开始菜单项" class="headerlink" title="创建开始菜单项"></a>创建开始菜单项</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Icons]</span><br><span class="line"><span class="keyword">Name</span>: &quot;<span class="comment">&#123;group&#125;</span>\My <span class="keyword">Program</span>&quot;; Filename: &quot;<span class="comment">&#123;app&#125;</span>\MyApp.exe&quot;</span><br></pre></td></tr></table></figure><h4 id="编译脚本"><a href="#编译脚本" class="headerlink" title="编译脚本"></a>编译脚本</h4><p>点击工具栏的”Compile”按钮（或按F9），生成的安装包默认在<code>Output</code>目录</p><h3 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h3><h4 id="添加卸载程序"><a href="#添加卸载程序" class="headerlink" title="添加卸载程序"></a>添加卸载程序</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Setup]</span><br><span class="line">Uninstallable=yes</span><br><span class="line">UninstallFilesDir=<span class="comment">&#123;app&#125;</span>\uninstall</span><br><span class="line"></span><br><span class="line">[UninstallDelete]</span><br><span class="line"><span class="keyword">Type</span>: files; <span class="keyword">Name</span>: &quot;<span class="comment">&#123;app&#125;</span>\config.ini&quot;</span><br></pre></td></tr></table></figure><h4 id="注册表操作"><a href="#注册表操作" class="headerlink" title="注册表操作"></a>注册表操作</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Registry]</span><br><span class="line">Root: HKLM; Subkey: &quot;Software\MyApp&quot;; ValueType: <span class="keyword">string</span>; ValueName: &quot;InstallPath&quot;; ValueData: &quot;<span class="comment">&#123;app&#125;</span>&quot;</span><br></pre></td></tr></table></figure><h4 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Languages]</span><br><span class="line"><span class="keyword">Name</span>: &quot;english&quot;; MessagesFile: &quot;compiler:<span class="keyword">Default</span>.isl&quot;</span><br><span class="line"><span class="keyword">Name</span>: &quot;chinesesimplified&quot;; MessagesFile: &quot;compiler:Languages\ChineseSimplified.isl&quot;</span><br></pre></td></tr></table></figure><h4 id="自定义安装页面"><a href="#自定义安装页面" class="headerlink" title="自定义安装页面"></a>自定义安装页面</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Code]</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">InitializeWizard</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="comment">// 创建自定义页面示例</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>BiliBili:更美化的安装程序 -&gt; </p><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1jQ4y1o7zX&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>好啦，现在你不仅可以将应用程序打包成安装包，更方便的分享给朋友下载，还可以打包出更好看、更高级的安装程序。相信 <code>Inno Setup</code> 会为你带来帮助，我以后也会分享更多有趣、有用的东西，谢谢观看！</p><p>—end—</p>]]></content>
    
    
    <summary type="html">分享一下通过Inno Setup软件将应用文件打包成安装程序的方法...</summary>
    
    
    
    <category term="推荐" scheme="http://www.flashfish777.cn/categories/%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="安装包" scheme="http://www.flashfish777.cn/tags/%E5%AE%89%E8%A3%85%E5%8C%85/"/>
    
    <category term="InnoSetup" scheme="http://www.flashfish777.cn/tags/InnoSetup/"/>
    
  </entry>
  
  <entry>
    <title>Unity进阶学习笔记</title>
    <link href="http://www.flashfish777.cn/posts/bdafbbe3.html"/>
    <id>http://www.flashfish777.cn/posts/bdafbbe3.html</id>
    <published>2024-10-20T15:00:00.000Z</published>
    <updated>2024-10-20T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger info flat"><p><strong>别急。</strong></p></div><p>—end—</p>]]></content>
    
    
    <summary type="html">记了一些Unity引擎相对深入一点的功能与用法，相对基础的东西并没有过多赘述...</summary>
    
    
    
    <category term="笔记" scheme="http://www.flashfish777.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Unity" scheme="http://www.flashfish777.cn/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>LecSnake - 3d贪吃蛇</title>
    <link href="http://www.flashfish777.cn/posts/5a49393d.html"/>
    <id>http://www.flashfish777.cn/posts/5a49393d.html</id>
    <published>2024-10-15T12:00:00.000Z</published>
    <updated>2024-12-30T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个Unity新手的3D贪吃蛇开发历程"><a href="#一个Unity新手的3D贪吃蛇开发历程" class="headerlink" title="一个Unity新手的3D贪吃蛇开发历程"></a>一个Unity新手的3D贪吃蛇开发历程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚好放寒假的时候，在大致进行了系统的Unity与C#的学习之后，我觉得我是时候做出一款游戏出来了。尽管之前跟随网上的教程完成过一两个简单的小项目，可那时候毕竟只能算是照猫画虎，学习了这么多知识之后也有必要通过一些项目来把这些知识巩固在脑海中，所以我就打算从头开始，自己做一款小游戏，不管是怎样的，至少先做出来再说吧！<br>我打算从相对简单的开始，不能急于求成。于是我打算做一种3D的贪吃蛇小游戏。因为我认为我这个项目的目的不是做的有多精美，多好玩，而是加强我的基本程序能力、熟练的使用unity编辑器的基础功能，在我需要的时候我能自己学会用什么、点什么、在哪里写些什么，而不是像最初稀里糊涂的跟着教程有样学样。<br>我打算在一个大场景中生成各种障碍物和食物，让贪吃蛇在场景中吃到食物来增加身体长度。在经过一段时间的研究与学习，经历了很多困难的解决与想法的改变后，最终我如愿完成了<strong>LecSnake（我们是卷王）-3D贪吃蛇小游戏</strong>。<br>在这个项目中，我不再是教程的模仿者，而是真正成为了系统的设计者。每一个技术决策背后，都是对Unity编辑器的深入探索和C#编程思维的锤炼。</p><p><img src="https://image.flashfish777.cn/img/post_11_1.jpg" alt="Login"></p><p><img src="https://image.flashfish777.cn/img/post_11_2.jpg" alt="游戏截图"></p><p><a href="https://github.com/flashfish777/LecSnake">项目链接</a></p><hr><h2 id="开发历程"><a href="#开发历程" class="headerlink" title="开发历程"></a>开发历程</h2><h3 id="🐍-贪吃蛇的进化"><a href="#🐍-贪吃蛇的进化" class="headerlink" title="🐍 贪吃蛇的进化"></a>🐍 贪吃蛇的进化</h3><p><strong>第一阶段：物理系统</strong>  </p><p>理想：</p><ul><li>用Rigidbody实现头部运动控制</li><li>通过Joint连接身体部件</li><li>期待呈现自然的物理摆动效果</li></ul><p>现实：</p><ul><li>刚体的摩擦力和重力导致速度不稳定</li><li>多节身体相互碰撞产生”卡顿链式反应”</li><li>惯性作用使转弯时身体完全失控</li></ul><p>一开始，我用刚体圆球来代表蛇的身体，用<code>WASD</code>控制蛇头的前后左右移动，然后用<code>Joint</code>组件来连接身体与身体，需要增加长度时，就在蛇尾部生成一个body球，然后连接到最后。我本想以此模拟顺滑的物理效果，可我发现并非如此。我发现刚体是有摩擦力和重力的，随着身体越来越多移动会越来越困难，这导致速度不平均。于是我花了很长时间磨合摩擦力与重力的数值，想通过调节数值来解决这个问题，最后我发现即使不使用重力不使用摩擦力都不能解决这个问题，于是我又将蛇头的移动方式从按下按键施加力变为简单的每帧改变坐标，我甚至锁定了所有身体的y轴使它们不再接触地面，但即使解决了速度问题依然还有其他问题，例如身体总会不规则的旋转，用线连接的身体也会有惯性导致蛇的身体乱动，而且最终也并没有很好的实现转弯时平滑的物理效果。所以我放弃了使用刚体来模拟物理效果，再次经过了一段时间的探索后，我找到了足够实现我需求的理想方法：</p><p><strong>第二阶段：返璞归真的坐标追踪法</strong>  </p><p>经过两周的反复试验，终于找到优雅的解决方案：</p><ul><li>改用立方体消除不规则旋转</li><li>创建历史坐标队列记录头部轨迹</li><li>身体部件按固定间隔跟随对应坐标</li></ul><p>我将球形身体改为方形，这样连起来更美观且能解决很多问题，然后在蛇的移动上，我使用了一个<code>historyPosition</code>列表存储蛇头走过的位置，然后将身体的坐标逐帧改为对应的坐标，而蛇头则是自动向前，由<code>AD</code>键控制左转和右转，空格加速。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 向前移动</span></span><br><span class="line">    transform.position += transform.forward * moveSpeed * Time.deltaTime;</span><br><span class="line">    <span class="comment">// 加速</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKey(KeyCode.Space))</span><br><span class="line">    &#123;</span><br><span class="line">        moveSpeed = <span class="number">40</span>;</span><br><span class="line">        bodySpeed = <span class="number">40</span>;</span><br><span class="line">        fastCount += Time.deltaTime;</span><br><span class="line">        <span class="keyword">if</span> (fastCount &gt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (score &gt; <span class="number">0</span>) score--;</span><br><span class="line">            fastCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        moveSpeed = <span class="number">20</span>;</span><br><span class="line">        bodySpeed = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方向操控</span></span><br><span class="line">    <span class="built_in">float</span> steerDirection = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">    transform.Rotate(Vector3.up * steerDirection * steerSpeed * Time.deltaTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存位置移动史</span></span><br><span class="line">    positionHistory.Insert(<span class="number">0</span>, transform.position);</span><br><span class="line">    <span class="keyword">while</span> (positionHistory.Count &gt; bodyList.Count * Gap)</span><br><span class="line">        positionHistory.RemoveAt(positionHistory.Count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动身体</span></span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> body <span class="keyword">in</span> bodyList)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 point = positionHistory[Mathf.Clamp(index * Gap, <span class="number">0</span>, positionHistory.Count - <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让贪吃蛇的身体沿头部轨迹运动</span></span><br><span class="line">        Vector3 moveDirection = point - body.transform.position;</span><br><span class="line">        body.transform.position += moveDirection * bodySpeed * Time.deltaTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让身体朝向头部移动的方向</span></span><br><span class="line">        body.transform.LookAt(point);</span><br><span class="line"></span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方案不仅实现了顺滑的蛇体运动，更让我深刻理解了<strong>数据驱动</strong>的设计哲学。当放弃对物理引擎的执念后，问题反而迎刃而解。<br>这样就实现了贪吃蛇的平滑移动了。这是我认为最耗脑筋的一个点，也是用了最长时间的一个点。</p><hr><h3 id="🍎-食物与障碍物"><a href="#🍎-食物与障碍物" class="headerlink" title="🍎 食物与障碍物"></a>🍎 食物与障碍物</h3><p>老实说这个地方没什么好讲的，当时做的时候也是简单完成，唯一值得思考的点就是在随机生成的时候要考虑到重叠生成，比如一个食物生成到一个树（障碍物）里面去了，于是我还思考了一下，考虑将场景分成很多格子来生成物体，随机格子的位置即可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (num &lt; <span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> x = Random.Range(<span class="number">1</span>, <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">int</span> z = Random.Range(<span class="number">1</span>, <span class="number">32</span>);</span><br><span class="line">    Quaternion spawnRotation = Quaternion.Euler(<span class="number">0</span>, Random.Range(<span class="number">0</span>, <span class="number">360</span>), <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!map[z, x])</span><br><span class="line">    &#123;</span><br><span class="line">        map[z, x] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        x = x &lt;= <span class="number">16</span> ? ((x - <span class="number">17</span>) * <span class="number">2</span> + <span class="number">1</span>) : ((x - <span class="number">16</span>) * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">        z = z &lt;= <span class="number">16</span> ? ((<span class="number">17</span> - z) * <span class="number">2</span> - <span class="number">1</span>) : ((<span class="number">16</span> - z) * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Vector3 spawnPosition = <span class="keyword">new</span> Vector3(x * <span class="number">25</span>, <span class="number">0.5f</span>, z * <span class="number">25</span>);</span><br><span class="line">        Instantiate(Treelist[<span class="number">0</span>], spawnPosition, spawnRotation);</span><br><span class="line"></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用后才发现按这样生成出来的位置都太有规律性了，有时候太整齐不是什么好事。如果贪吃蛇只能四向移动的话这样的生成方法明显更优。</p><p>在贪吃蛇碰到食物或障碍物后会将该物体销毁并执行对应的加分减分操作，然后再在场景一个一个随机位置生成一个对应物体使之不会越来越少。但后来我发现，其实可以在碰到物体时直接随机更改一下物体的坐标就可以了，而不用销毁再生成，省去了不必要的步骤与消费。</p><hr><h3 id="🗺️-小地图的实现"><a href="#🗺️-小地图的实现" class="headerlink" title="🗺️ 小地图的实现"></a>🗺️ 小地图的实现</h3><p>之后我想到在左上角放一个缩略地图的功能，可以更方便玩家查看附近的情况。具体步骤在之前的文章介绍过：<br> <a class="btn-beautify green larger" href="/posts/bf08e6b6.html" title="Unity日记：小地图"><i class="far fa-hand-point-right"></i><span>Unity日记：小地图</span></a></p><p>这个功能的实现，让我对Unity的多摄像机协作有了更深理解。</p><hr><h3 id="⚙️-暂停与设置"><a href="#⚙️-暂停与设置" class="headerlink" title="⚙️ 暂停与设置"></a>⚙️ 暂停与设置</h3><p>我添加了暂停按钮，通过<code>Time.timeScale</code>调整游戏的时间状态，并添加了一些选项设置。通过调节摄像机与音频给玩家带来不同的体验。</p><p><img src="https://image.flashfish777.cn/img/post_11_3.jpg" alt="暂停的设置界面"></p><p>这个模块的开发，让我体会到<strong>系统隔离</strong>的重要性。</p><hr><h3 id="🔄-主界面场景切换"><a href="#🔄-主界面场景切换" class="headerlink" title="🔄 主界面场景切换"></a>🔄 主界面场景切换</h3><p>做到这里主要的功能基本就完成了，最后我想给游戏添加一个开始界面与背景，于是便在游戏启动时默认播放一个描述背景故事的视频，点击可以跳过，随后便进入开始界面。<br><img src="https://image.flashfish777.cn/img/post_11_1.jpg" alt="开始界面"></p><p>我将它放在了一个独立的场景里，在场景中房里几颗树木烘托氛围。当玩家点击开始后就会跳转到游戏的主场景了。关于场景切换，在之前的文章亦有记载：</p><a class="btn-beautify red larger" href="/posts/fdbe57b8.html#%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD" title="Unity日记：场景切换与并发编程-异步加载"><i class="far fa-hand-point-right"></i><span>Unity日记：场景切换与并发编程-异步加载</span></a><p>在这个过程中，我真正理解了游戏状态管理的艺术。</p><hr><h3 id="💾-存档系统"><a href="#💾-存档系统" class="headerlink" title="💾 存档系统"></a>💾 存档系统</h3><p>在最后的最后，一款能让人玩下去的游戏一定离不开存档，于是我了解并学习了有关数据持久化的相关知识，并为我的贪吃蛇游戏添加了存档。存档实现的详情见以下文章：</p><a class="btn-beautify yellow larger" href="/posts/posts/a985624f.html#%E7%A4%BA%E4%BE%8B-1" title="Unity日记：存档系统-JSON-示例"><i class="far fa-hand-point-right"></i><span>Unity日记：存档系统-JSON-示例</span></a><p>我存储了食物和障碍物的坐标列表、<code>historyPosition</code>列表以及得分等数据简单实现了贪吃蛇游戏的存档系统。</p><p>2024年12月续：值得一提的是，我在面试微派的时候，面试官曾问我有没有想过不存食物和障碍物的坐标且仍能实现存档，当时我还云里雾里，知道面试官提了随机数种子的概念，我才想到可以用相同的随机数种子，生成的随机坐标就是和上一次一样的坐标了，障碍物和食物也会在原先的位置，这样只需要存以下种子，就依然可以实现存档。妙哉！</p><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个项目最宝贵的收获，是让我建立起<strong>独立解决问题</strong>的自信。当看到自己构思的系统通过自己的努力真正运转起来时，那种喜悦远超复制十个教程项目。期待在下一个项目中挑战更复杂的游戏程序设计，相信我的程序水平会越来越成熟！</p><p>—end—</p>]]></content>
    
    
    <summary type="html">使用Unity引擎开发的一个以Lec为背景的3d贪吃蛇小游戏，是我在暑假期间完全独立探索出的第一款Unity小游戏...</summary>
    
    
    
    <category term="项目" scheme="http://www.flashfish777.cn/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="游戏" scheme="http://www.flashfish777.cn/categories/%E9%A1%B9%E7%9B%AE/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="Unity" scheme="http://www.flashfish777.cn/categories/%E9%A1%B9%E7%9B%AE/%E6%B8%B8%E6%88%8F/Unity/"/>
    
    
    <category term="游戏开发" scheme="http://www.flashfish777.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="Unity" scheme="http://www.flashfish777.cn/tags/Unity/"/>
    
    <category term="C#" scheme="http://www.flashfish777.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#学习笔记</title>
    <link href="http://www.flashfish777.cn/posts/9526375f.html"/>
    <id>http://www.flashfish777.cn/posts/9526375f.html</id>
    <published>2024-10-12T15:00:00.000Z</published>
    <updated>2024-10-12T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p><strong>CSharp知识点</strong></p></div><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><table><thead><tr><th align="left">类型</th><th align="left">描述</th><th align="left">范围</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">bool</td><td align="left">布尔值</td><td align="left">True 或 False</td><td align="left">False</td></tr><tr><td align="left">byte</td><td align="left">8 位无符号整数</td><td align="left">0 到 255</td><td align="left">0</td></tr><tr><td align="left">char</td><td align="left">16 位 Unicode 字符</td><td align="left">U +0000 到 U +ffff</td><td align="left">‘\0’</td></tr><tr><td align="left">decimal</td><td align="left">128 位精确的十进制值，28-29 有效位数</td><td align="left">(-7.9 x 1028 到 7.9 x 1028) &#x2F; 100 到 28</td><td align="left">0.0M</td></tr><tr><td align="left">double</td><td align="left">64 位双精度浮点型</td><td align="left">(+&#x2F;-)5.0 x 10-324 到 (+&#x2F;-)1.7 x 10308</td><td align="left">0.0D</td></tr><tr><td align="left">float</td><td align="left">32 位单精度浮点型</td><td align="left">-3.4 x 1038 到 + 3.4 x 1038</td><td align="left">0.0F</td></tr><tr><td align="left">int</td><td align="left">32 位有符号整数类型</td><td align="left">-2,147,483,648 到 2,147,483,647</td><td align="left">0</td></tr><tr><td align="left">long</td><td align="left">64 位有符号整数类型</td><td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td><td align="left">0L</td></tr><tr><td align="left">sbyte</td><td align="left">8 位有符号整数类型</td><td align="left">-128 到 127</td><td align="left">0</td></tr><tr><td align="left">short</td><td align="left">16 位有符号整数类型</td><td align="left">-32,768 到 32,767</td><td align="left">0</td></tr><tr><td align="left">uint</td><td align="left">32 位无符号整数类型</td><td align="left">0 到 4,294,967,295</td><td align="left">0</td></tr><tr><td align="left">ulong</td><td align="left">64 位无符号整数类型</td><td align="left">0 到 18,446,744,073,709,551,615</td><td align="left">0</td></tr><tr><td align="left">ushort</td><td align="left">16 位无符号整数类型</td><td align="left">0 到 65,535</td><td align="left">0</td></tr></tbody></table><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。</p><p>换句话说，它们指的是一个内存位置。使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是由一个变量改变的，其他变量会自动反映这种值的变化。<strong>内置的</strong> 引用类型有：<strong>object</strong>、<strong>dynamic</strong> 和 <strong>string</strong>。</p><h3 id="对象（Object）类型"><a href="#对象（Object）类型" class="headerlink" title="对象（Object）类型"></a>对象（Object）类型</h3><p><strong>对象（Object）类型</strong> 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 <code>System.Object</code> 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。</p><p>当一个值类型转换为对象类型时，则被称为 <strong>装箱</strong>；另一方面，当一个对象类型转换为值类型时，则被称为 <strong>拆箱</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> obj;</span><br><span class="line">obj = <span class="number">100</span>; <span class="comment">// 这是装箱</span></span><br></pre></td></tr></table></figure><h3 id="动态（Dynamic）类型"><a href="#动态（Dynamic）类型" class="headerlink" title="动态（Dynamic）类型"></a>动态（Dynamic）类型</h3><p>您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。</p><p>声明动态类型的语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> &lt;variable_name&gt; = <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> d = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。</p><h3 id="字符串（String）类型"><a href="#字符串（String）类型" class="headerlink" title="字符串（String）类型"></a>字符串（String）类型</h3><p><strong>字符串（String）类型</strong> 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：引号和 @引号。</p><p>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;runoob.com&quot;</span>;</span><br></pre></td></tr></table></figure><p>一个 @引号字符串：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">@&quot;runoob.com&quot;</span>;</span><br></pre></td></tr></table></figure><p>C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\）当作普通字符对待，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">@&quot;C:\Windows&quot;</span>;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;C:\\Windows&quot;</span>;</span><br></pre></td></tr></table></figure><p>@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">@&quot;&lt;script type=&quot;&quot;text/javascript&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;!--</span></span><br><span class="line"><span class="string">    --&gt;</span></span><br><span class="line"><span class="string">&lt;/script&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>用户自定义引用类型有：class（类）、interface（接口） 或 delegate（委托）。我们将在以后的章节中讨论这些类型。</p><h2 id="指针类型（不安全代码）"><a href="#指针类型（不安全代码）" class="headerlink" title="指针类型（不安全代码）"></a>指针类型（不安全代码）</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。</p><p>声明指针类型的语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type* identifier;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span>* cptr;</span><br><span class="line"><span class="built_in">int</span>* p1, p2, p3;</span><br><span class="line"><span class="built_in">int</span>*[] p4; <span class="comment">// p4是 指针的数组 而不是 数组的指针</span></span><br><span class="line"><span class="keyword">void</span>* p5; <span class="comment">// 指向未知类型的指针</span></span><br><span class="line"><span class="built_in">int</span>** p6; <span class="comment">// 指针的指针</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>当一个代码块使用 <strong>unsafe</strong> 修饰符标记时，C# 允许在函数中使用指针变量。<strong>不安全代码</strong>或非托管代码是指使用了<strong>指针</strong>变量的代码块</p><p>您可以使用 <strong>ToString()</strong> 方法检索存储在指针变量所引用位置的数据。下面的实例演示了这点：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UnsafeCodeApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">unsafe</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> <span class="keyword">var</span> = <span class="number">20</span>;</span><br><span class="line">                <span class="built_in">int</span>* p = &amp;<span class="keyword">var</span>;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Data is: &#123;0&#125; &quot;</span> , <span class="keyword">var</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Data is: &#123;0&#125; &quot;</span> , p-&gt;ToString());</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Address is: &#123;0&#125; &quot;</span> , (<span class="built_in">int</span>)p);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Data is: 20</span><br><span class="line">Data is: 20</span><br><span class="line">Address is: 77128984</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>为了编译不安全代码，您必须切换到命令行编译器指定 <strong>&#x2F;unsafe</strong> 命令行。</p><p>例如，为了编译包含不安全代码的名为 prog1.cs 的程序，需在命令行中输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csc /unsafe prog1.cs</span><br></pre></td></tr></table></figure><hr><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul><li>在namespace语句块中声明枚举（常用）</li><li>在class、struct语句块中也可以声明枚举</li><li><strong>枚举不能在函数语句块中声明！</strong></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Enum_practise</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">enum</span> Day &#123;</span><br><span class="line">        Sun,</span><br><span class="line">        Mon,</span><br><span class="line">        Tue,</span><br><span class="line">        Wed,</span><br><span class="line">        Thu,</span><br><span class="line">        Fri,</span><br><span class="line">        Sat</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnumTest</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Day today = Day.Sun;</span><br><span class="line">            <span class="keyword">switch</span> (today)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> Day.Sun:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期日&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Mon:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期一&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Tue:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期二&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Wed:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期三&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Thu:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;V我50&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Fri:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期五&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Sat:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期六&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量类型可以是所有变量类型</span></span><br><span class="line"><span class="built_in">int</span>[] arr1;</span><br><span class="line"><span class="built_in">int</span>[] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">int</span>[] arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] arr4 = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] arr5 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[,] arr;</span><br><span class="line"><span class="built_in">int</span>[,] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">int</span>[,] arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>, <span class="number">3</span>] &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                              &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">                              &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">int</span>[,] arr4 = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                              &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">                              &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">int</span>[,] arr5 = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">                &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><h2 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h2><p><strong>真正的数组的数组。与二维数组的区别：每个一维数组的长度可以不一样。</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[][] arr;</span><br><span class="line"><span class="built_in">int</span>[][] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][];</span><br><span class="line"><span class="built_in">int</span>[][] arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][] &#123; <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                              <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">5</span> &#125;,</span><br><span class="line">                              <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">6</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">int</span>[][] arr4 = <span class="keyword">new</span> <span class="built_in">int</span>[][] &#123; <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                              <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">5</span> &#125;,</span><br><span class="line">                              <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">6</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">int</span>[][] arr5 = &#123; <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                 <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">5</span> &#125;,</span><br><span class="line">                 <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">6</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h1><h2 id="ref-和-out"><a href="#ref-和-out" class="headerlink" title="ref 和 out"></a>ref 和 out</h2><h3 id="按引用传递参数（ref）"><a href="#按引用传递参数（ref）" class="headerlink" title="按引用传递参数（ref）"></a>按引用传递参数（ref）</h3><p>引用参数是一个对变量的<strong>内存位置的引用</strong>。当按引用传递参数时，与值参数不同的是，它不会为这些参数创建一个新的存储位置。引用参数表示与提供给方法的实际参数具有相同的内存位置。</p><p>在 C# 中，使用 <strong>ref</strong> 关键字声明引用参数。下面的实例演示了这点：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> x, <span class="keyword">ref</span> <span class="built_in">int</span> y</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">int</span> temp;</span><br><span class="line"></span><br><span class="line">         temp = x; <span class="comment">/* 保存 x 的值 */</span></span><br><span class="line">         x = y;    <span class="comment">/* 把 y 赋值给 x */</span></span><br><span class="line">         y = temp; <span class="comment">/* 把 temp 赋值给 y */</span></span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         NumberManipulator n = <span class="keyword">new</span> NumberManipulator();</span><br><span class="line">         <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">         <span class="built_in">int</span> a = <span class="number">100</span>;</span><br><span class="line">         <span class="built_in">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在交换之前，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在交换之前，b 的值： &#123;0&#125;&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 调用函数来交换值 */</span></span><br><span class="line">         n.swap(<span class="keyword">ref</span> a, <span class="keyword">ref</span> b);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在交换之后，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在交换之后，b 的值： &#123;0&#125;&quot;</span>, b);</span><br><span class="line"> </span><br><span class="line">         Console.ReadLine();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在交换之前，a 的值：100</span><br><span class="line">在交换之前，b 的值：200</span><br><span class="line">在交换之后，a 的值：200</span><br><span class="line">在交换之后，b 的值：100</span><br></pre></td></tr></table></figure><p>结果表明，<em>swap</em> 函数内的值改变了，且这个改变可以在 <em>Main</em> 函数中反映出来。</p><h3 id="按输出传递参数（out）"><a href="#按输出传递参数（out）" class="headerlink" title="按输出传递参数（out）"></a>按输出传递参数（out）</h3><p>return 语句可用于只从函数中返回一个值。但是，可以使用 <strong>输出参数</strong> 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。</p><p>下面的实例演示了这点：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> x </span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">int</span> temp = <span class="number">5</span>;</span><br><span class="line">         x = temp;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         NumberManipulator n = <span class="keyword">new</span> NumberManipulator();</span><br><span class="line">         <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">         <span class="built_in">int</span> a = <span class="number">100</span>;</span><br><span class="line">         </span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在方法调用之前，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">/* 调用函数来获取值 */</span></span><br><span class="line">         n.getValue(<span class="keyword">out</span> a);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在方法调用之后，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在方法调用之前，a 的值： 100</span><br><span class="line">在方法调用之后，a 的值： 5</span><br></pre></td></tr></table></figure><p>提供给输出参数的变量不需要赋值。当需要从一个参数没有指定初始值的方法中返回值时，输出参数特别有用。请看下面的实例，来理解这一点：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValues</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> x, <span class="keyword">out</span> <span class="built_in">int</span> y </span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;请输入第一个值： &quot;</span>);</span><br><span class="line">          x = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;请输入第二个值： &quot;</span>);</span><br><span class="line">          y = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         NumberManipulator n = <span class="keyword">new</span> NumberManipulator();</span><br><span class="line">         <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">         <span class="built_in">int</span> a , b;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">/* 调用函数来获取值 */</span></span><br><span class="line">         n.getValues(<span class="keyword">out</span> a, <span class="keyword">out</span> b);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在方法调用之后，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在方法调用之后，b 的值： &#123;0&#125;&quot;</span>, b);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果（取决于用户输入）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请输入第一个值：</span><br><span class="line">7</span><br><span class="line">请输入第二个值：</span><br><span class="line">8</span><br><span class="line">在方法调用之后，a 的值： 7</span><br><span class="line">在方法调用之后，b 的值： 8</span><br></pre></td></tr></table></figure><h3 id="ref-和-out的区别"><a href="#ref-和-out的区别" class="headerlink" title="ref 和 out的区别"></a>ref 和 out的区别</h3><ul><li>ref 传入的变量必须初始化，out 不用 （买票上车）</li><li>out 传入的变量必须在内部赋值，ref 不用 （买票下车）</li></ul><h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><p>变长参数允许在调用方法时传入不定长度的参数。变长参数是一个语法糖，本质上还是基于数组的实现</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>使用 params 关键字可以指定被params修饰的参数在传参时数目可变：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseParams</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">object</span>[] list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(list[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>调用方式主要有三种，第一种是传一个数组，第二种是传n个参数，第三种是不传入参数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UseParams(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="string">&quot;test&quot;</span>&#125;); <span class="comment">// 传入数组</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UseParams(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">// 传入多个参数</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UseParams(); <span class="comment">// 不传参</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>params关键字后面必为数组</li><li>数组类型可以是任意的类型</li><li>函数参数可以有别的参数和params关键字修饰的参数</li><li>函数参数中只能最多出现一个params关键字并且一定是在最后一组参数，前面可以有n个其他参数</li></ul><h2 id="命名实参"><a href="#命名实参" class="headerlink" title="命名实参"></a>命名实参</h2><p>通过命名实参，你可以为形参指定实参，方法是将实参与该形参的名称匹配，而不是与形参在形参列表中的位置匹配。有了命名实参，将不再需要将实参的顺序与所调用方法的形参列表中的形参顺序相匹配。 每个形参的实参都可按形参名称进行指定。 例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintOrderDetails(<span class="string">&quot;Gift Shop&quot;</span>, <span class="number">31</span>, <span class="string">&quot;Red Mug&quot;</span>);</span><br><span class="line"><span class="comment">// 卖家姓名、订单号和产品名称</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用命名实参调用</span></span><br><span class="line">PrintOrderDetails(orderNum: <span class="number">31</span>, productName: <span class="string">&quot;Red Mug&quot;</span>, sellerName: <span class="string">&quot;Gift Shop&quot;</span>);</span><br><span class="line">PrintOrderDetails(productName: <span class="string">&quot;Red Mug&quot;</span>, sellerName: <span class="string">&quot;Gift Shop&quot;</span>, orderNum: <span class="number">31</span>);</span><br></pre></td></tr></table></figure><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>有<strong>参数默认值</strong>的参数，一般称为可选参数。当调用函数时可以不传入该参数，不传就会使用默认值作为参数的值。</p><p>例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExampleMethod</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">required</span>, <span class="built_in">string</span> optionalstr = <span class="string">&quot;default string&quot;</span>, <span class="built_in">int</span> optionalint = <span class="number">10</span></span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line">anExample.ExampleMethod(<span class="number">3</span>); <span class="comment">// 后两个参数为默认值</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li><p>支持多参数默认值，每个参数都可以有默认值</p></li><li><p>如果要混用，可选参数必须写在普通参数后面</p></li><li><p>默认值必须是以下类型的表达式之一：</p><ul><li>常量表达式</li><li><code>new ValType() </code>形式的表达式，其中 <code>ValType</code> 是值类型，例如 <code>enum</code> 或 <code>struct</code></li><li><code>default(ValType)</code> 形式的表达式，其中 <code>ValType</code> 是值类型</li></ul></li><li><p>如果调用方为一系列可选形参中的任意一个形参提供了实参，则它必须为前面的所有可选形参提供实参，实参列表中不支持使用逗号分隔的间隔，如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//anExample.ExampleMethod(3, ,4);</span></span><br></pre></td></tr></table></figure><p>如果想要选择性提供实参，可以使用命名实参来实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anExample.ExampleMethod(<span class="number">3</span>, optionalint: <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>重载允许在<strong>同一作用域内定义多个同名函数</strong>，但这些函数<strong>必须在参数类型、个数或顺序上存在区别</strong>，以便编译器可以根据传递给函数的参数来确定调用哪个函数。在C#中，函数的重载是通过函数签名（函数名称和参数类型、数目以及顺序）来确定的，并不包括返回类型。可以定义相同函数名的函数，只要它们的参数有所不同即可。如果有多个函数符合调用条件，则编译器会选择最匹配的函数。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>命名一组功能相似的函数，减少函数名的数量，避免命名空间的污染</li><li>提升代码复用性与可读性</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ClassOverload CO = <span class="keyword">new</span> ClassOverload();</span><br><span class="line">        CO.GetInfo();</span><br><span class="line">        CO.GetInfo(<span class="number">2</span>);</span><br><span class="line">        CO.GetInfo(<span class="string">&quot;我是第3个重载方法&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        CO.GetInfo(<span class="number">2</span>, <span class="string">&quot;我是第4个重载方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ClassOverload</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是第1个重载方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo</span>(<span class="params"><span class="built_in">int</span> Num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;我是第<span class="subst">&#123;Num&#125;</span>个重载方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo</span>(<span class="params"><span class="built_in">string</span> Name, <span class="built_in">int</span> Num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Name&#125;</span>我有<span class="subst">&#123;Num&#125;</span>个参数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo</span>(<span class="params"><span class="built_in">int</span> Num, <span class="built_in">string</span> Name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Name&#125;</span>我有<span class="subst">&#123;Num&#125;</span>个参数,我的参数顺序与第3个方法不同&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol><li><p>在使用重载时只能通过不同的参数样式</p></li><li><p>不能通过访问权限、返回类型进行重新加载</p></li><li><p>方法的数目不会对重新加载造成影响</p></li><li><p>对于继承来说，如果某一方法在父类中是访问权限是private，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果</p></li><li><p>接口不能重载</p></li></ol><hr><h1 id="结构体（与类的区别）"><a href="#结构体（与类的区别）" class="headerlink" title="结构体（与类的区别）"></a>结构体（与类的区别）</h1><p>结构体提供了一种轻量级的数据类型，适用于表示简单的数据结构，具有较好的性能特性和值语义。</p><p><strong>与类的区别</strong></p><p>类和结构体在设计和使用时有不同的考虑因素，类适合表示复杂的对象和行为，支持继承和多态性，而结构体则更适合表示轻量级数据和值类型，以提高性能并避免引用的管理开销。</p><p>类和结构体有以下几个基本的不同点：</p><p><strong>数据类型：</strong></p><ul><li><strong>结构体是值类型（Value Type）：</strong> 结构体是值类型，它们在栈上分配内存，而不是在堆上。当将结构体实例传递给方法或赋值给另一个变量时，将复制整个结构体的内容。</li><li><strong>类是引用类型（Reference Type）：</strong> 类是引用类型，它们在堆上分配内存。当将类实例传递给方法或赋值给另一个变量时，实际上是传递引用（内存地址）而不是整个对象的副本。</li></ul><p><strong>变量：</strong></p><ul><li>结构体中声明的变量不能直接初始化。</li><li>类可以在声明时对变量初始化。</li></ul><p><strong>继承和多态性：</strong></p><ul><li><strong>结构体不能继承：</strong> 结构体不能继承其他结构体或类，也不能作为其他结构体或类的基类。结构体成员不能指定为 abstract、virtual 或 protected。</li><li><strong>类支持继承：</strong> 类支持继承和多态性，可以通过派生新类来扩展现有类的功能。</li></ul><p><strong>默认构造函数：</strong></p><ul><li><strong>结构体不能有无参数的构造函数、不能定义析构函数：</strong> 结构体不能包含无参数的构造函数。每个结构体都必须有至少一个有参数的构造函数。不能定义析构函数。</li><li><strong>类可以有无参数的构造函数：</strong> 类可以包含无参数的构造函数，如果没有提供构造函数，系统会提供默认的无参数构造函数。</li></ul><p><strong>实例：</strong></p><ul><li>类必须使用 New 操作符才能被实例化。</li><li>结构体可以不使用 New 操作符即可被实例化。如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。</li></ul><p><strong>赋值行为：</strong></p><ul><li>类型为类的变量在赋值时存储的是引用，因此两个变量指向同一个对象。</li><li>结构体变量在赋值时会复制整个结构，因此每个变量都有自己的独立副本。</li></ul><p><strong>传递方式：</strong></p><ul><li>类型为类的对象在方法调用时通过引用传递，这意味着在方法中对对象所做的更改会影响到原始对象。</li><li>结构体对象通常通过值传递，这意味着传递的是结构体的副本，而不是原始结构体对象本身。因此，在方法中对结构体所做的更改不会影响到原始对象。</li></ul><p><strong>可空性：</strong></p><ul><li><strong>结构体是值类型，不能直接设置为 null：</strong> 因为 <strong>null</strong> 是引用类型的默认值，而不是值类型的默认值。如果你需要表示结构体变量的缺失或无效状态，可以使用 <code>Nullable&lt;T&gt;</code> 或称为 <strong>T?</strong> 的可空类型。</li><li><strong>类默认可为null：</strong> 类的实例默认可以为 <code>null</code>，因为它们是引用类型。</li></ul><p><strong>性能和内存分配：</strong></p><ul><li><strong>结构体通常更轻量：</strong> 由于结构体是值类型且在栈上分配内存，它们通常比类更轻量，适用于简单的数据表示。</li><li><strong>类可能有更多开销：</strong> 由于类是引用类型，可能涉及更多的内存开销和管理。</li></ul><hr><h1 id="面向对象理论"><a href="#面向对象理论" class="headerlink" title="面向对象理论"></a>面向对象理论</h1><h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><p><strong>类中一般包含：</strong></p><ul><li>特征——成员变量</li><li>行为——成员方法</li><li>保护特征——成员属性</li><li>构造函数和析构函数</li><li>索引器</li><li>运算符重载</li><li>静态成员</li></ul><p><strong>对象</strong>是类创建出来的，相当于申明一个指定类的变量，类创建对象的过程一般称为实例化对象，类对象都是引用类型的。</p><p><strong>实例化</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p;</span><br><span class="line">Person p2 = <span class="literal">null</span>; <span class="comment">// 与上面相同，没有分配堆内存，栈中为null</span></span><br><span class="line">Person p3 = <span class="keyword">new</span> Person(); <span class="comment">// 分配了堆内存</span></span><br></pre></td></tr></table></figure><h4 id="成员变量和访问修饰符"><a href="#成员变量和访问修饰符" class="headerlink" title="成员变量和访问修饰符"></a>成员变量和访问修饰符</h4><p><strong>成员变量基本规则</strong></p><ul><li>申明在类语句块中</li><li>用来描述对象的特征</li><li>可以是任意变量类型</li><li>数量不作限制</li><li>可以初始化</li><li>是否赋值根据需求来定</li></ul><p><strong>访问修饰符</strong></p><table><thead><tr><th></th><th>当前类</th><th>当前程序集下的类</th><th>其他程序集下的子类</th><th>其他程序集下的类</th></tr></thead><tbody><tr><td>public</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>protected</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>internal（默认）</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>private</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table><p><code>protected internal</code>: 成员可以由当前程序集或子类中的代码访问。</p><p><code>private protected</code>: 成员可以在其定义的类及子类中被访问，但仅当这些子类在同一个程序集中时。</p><p><strong>注意：</strong> 如果没有指定，则使用默认的访问标识符。类的默认访问标识符是 <strong>internal</strong>，成员的默认访问标识符是 <strong>private</strong>。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><strong>基本概念：</strong> 类的 <strong>构造函数</strong> 是类的一个特殊的成员函数，当创建类的新对象时执行。在实例化对象时，会调用的用于初始化的函数。</p><p><strong>写法：</strong> </p><ul><li><strong>构造函数的名称与类的名称完全相同</strong>，它没有任何返回类型。</li><li><strong>默认的构造函数</strong>没有任何参数。但是如果你需要一个带有参数的构造函数可以有参数，这种构造函数叫做<strong>参数化构造函数</strong>。</li><li>没有特殊需求时一般都是public的</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>构造函数可以被重载</li><li><code>this</code>关键字代表当前调用该函数的对象自己，数据类型为当前对象</li><li>如果不自己实现无参构造函数而实现了有参构造函数，会失去默认的无参构造</li></ul><p><strong>特殊写法：</strong></p><p>可以通过 <code>:</code> 运算符重用其他构造函数代码，例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Manager</span> : <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span>(<span class="params"><span class="built_in">int</span> annualSalary</span>) : <span class="title">base</span>(<span class="params">annualSalary</span>) <span class="comment">// 使用基类构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Add further instructions here.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">int</span> weeklySalary, <span class="built_in">int</span> numberOfWeeks</span>) : <span class="title">this</span>(<span class="params">weeklySalary * numberOfWeeks</span>) <span class="comment">// 使用当前类其他构造函数</span></span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做时，当使用此构造函数，函数会先调用 <code>:</code> 之后的构造函数，再执行当前构造函数的代码。</p><h4 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h4><p>主构造函数是 C# 12 中的一项新功能，可用于直接在构造函数参数列表中定义和初始化属性。此功能消除了对重复代码的需要，并使代码更加简洁和可读。</p><p><strong>概念：</strong> 主构造函数是一种简洁的语法，用于声明一个构造函数，其参数在类型的主体中的任何位置都可用。</p><p><strong>注意：</strong> 主构造函数的参数在整个类定义的范围内，因此可以使用它们来初始化属性、字段或其他成员。但是，默认情况下，它们不会存储为字段或属性，除非您显式将它们分配给一个字段或属性。它们也不能作为 或 访问，因为它们不是类的成员。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">string</span> firstName, <span class="built_in">string</span> lastName, DateTime hireDate, <span class="built_in">decimal</span> salary</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; = firstName;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; = lastName;  </span><br><span class="line">    <span class="keyword">public</span> DateTime HireDate &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; = hireDate;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Salary &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; = salary;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码等效于以下没有主构造函数的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> DateTime HireDate &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Salary &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">string</span> firstName, <span class="built_in">string</span> lastName, DateTime hireDate, <span class="built_in">decimal</span> salary</span>)</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        FirstName = firstName;  </span><br><span class="line">        LastName = lastName;  </span><br><span class="line">        HireDate = hireDate;  </span><br><span class="line">        Salary = salary;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特殊写法：</strong> 使用主构造参数时仍可使用 <code>this</code> 或 <code>base</code> 关键字，使用特殊写法调用其他构造函数。</p><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p><strong>基本概念：</strong> 类的 <strong>析构函数</strong> 是类的一个特殊的成员函数，当类的对象超出范围时执行。当引用类型的堆内存被回收时，会调用该函数</p><p><strong>写法</strong>： 析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。</p><p><strong>注意：</strong></p><ul><li>析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载</li><li>对于需要手动管理内存的语言（比如c++），需要在析构函数中做一些内存回收处理，但是c#中存在自动垃圾回收机制GC，所以几乎不会这怎么使用析构函数，除非你想在某一个对象被垃圾回收时，做一些特殊处理</li><li>在Unity开发中析构函数几乎不会使用，所以该知识点只做了解即可</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Person() &#123;&#125; <span class="comment">// 析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="垃圾回收机制（GC）"><a href="#垃圾回收机制（GC）" class="headerlink" title="垃圾回收机制（GC）"></a>垃圾回收机制（GC）</h4><p><strong>概念：</strong></p><p>在编写程序时，会产生很多的数据 比如:int string 变量，这些数据都存储在内存里，如果不合理的管理他们，就会内存溢出导致程序崩溃。C#内置了自动垃圾回收GC，在编写代码时可以不需要担心内存溢出的问题 变量失去引用后 GC会帮我们自动回收，但不包括数据流，和一些数据库的连接，这就需要我们手动的释放资源</p><p><strong>垃圾回收</strong>，英文简写<strong>GC</strong>（<code>Garbage Collector</code>）。垃圾回收的过程是在遍历堆（Heap）上动态分配的所有对象，通过识别它们是否被引用来确定哪些对象是垃圾，哪些对象仍要被使用。所谓的垃圾就是没有被任何变量、对象引用的内容，垃圾就需要被回收释放。</p><p>垃圾回收有很多种算法，比如引用计数（Reference Counting）、标记清除（Mark Sweep）、标记整理（Mark Compact）、复制整合（Copy Collection）等。</p><p><strong>机制：</strong></p><p>代的概念：代是垃圾回收机制使用的一种算法（分代算法），新分配的对象都会被配置在弟0代内存中，每次分配都可能会进行垃圾回收以释放内存（0代内存满时），大对象总被认为是第二代内存，不会对大对象进行搬迁压缩，目的是减少性能损耗，85000字节（83kb）以上的对象为大对象。</p><p>过程：垃圾回收共分3代，每次创建对象的时候 都是在第0代分配内存，并且每一代都配有初始内存空间。假设现在程序已经跑了一段时间了，而第0代分配的空间已经满了，<strong>这时候就会进行垃圾回收，把失去引用的对象释放</strong>，此时未使用完的对象将进入到第1代。垃圾回收后，第0代就已经空了，后面创建的对象就会重新放入第0代，以此类推。0代满后，又会重新垃圾回收，还在使用的对象又会放入第1代，此后运行一段时间 1代也已经满了，而0代还在使用的对象也会移动到1代，这时候已经不够放了，又会进行垃圾回收，1代的将移动到2代，0代的将移动到1代（即1代进行垃圾回收时0代也会同时进行垃圾回收），以此类推。假如代数都满了，但对象都还在使用，并没有回收多少，这时GC就会自动的把初始内存给扩大，比如原来2MB扩大到4MB，还不够使用的情况下内存就满了，就会抛出异常。</p><p>**注意：**GC只负责堆内存的垃圾回收，引用类型都是存在堆中的，所以它们的分配和释放都通过垃圾回收机制来管理。栈上的内存是由系统自动管理的，值类型是在栈中分配内存的，它们有自己的生命周期，不用对他们进行管理，会自动分配和释放。</p><p><strong>手动执行垃圾回收：</strong></p><p>垃圾回收一般情况下是自动执行，如果想要手动执行垃圾回收，需要调动此行代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GC.Collect();</span><br></pre></td></tr></table></figure><p>一般情况下不会频繁进行垃圾回收，因为垃圾回收过程比较复杂耗时，可能会造成程序卡顿，通常在Loading界面时顺便进行一次垃圾回收。</p><h4 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h4><p><strong>概念：</strong></p><p>用于保护成员变量，为成员变量的获取和赋值添加逻辑处理。解决访问修饰符的局限性。属性可以让成员变量在外部只能获取不能修改或者只能修改不能获取。</p><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符  属性类型  属性名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span>&#123;&#125; <span class="comment">//get需要返回值，没有返回值就会报错</span></span><br><span class="line">    <span class="keyword">set</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 可以在设置之前添加一些逻辑规则</span></span><br><span class="line">            <span class="comment">// 实现加密等操作</span></span><br><span class="line">            name = <span class="keyword">value</span>; </span><br><span class="line">            <span class="comment">// value关键字，表示外部传入的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 可以在返回之前添加一些逻辑规则</span></span><br><span class="line">            <span class="comment">// 实现解密等操作</span></span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">            <span class="comment">// 这个属性可以获取内容</span></span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">p.Name = <span class="string">&quot;LiMing&quot;</span>; <span class="comment">// &#x27;=&#x27; 默认调用set</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(p.Name); <span class="comment">// 直接使用默认调用get</span></span><br></pre></td></tr></table></figure><p><strong>成员属性中get和set前可以加访问修饰符：</strong> 默认不加会使用属性声明时的权限，加的访问修饰符要低于属性的访问权限，不能让set和get的访问权限都低于属性权限。</p><p><strong>自动属性</strong><br>类似于自动的成员变量，set和get会自动生成成员变量将他们包裹起来。</p><p>作用：外部能得不能改的特征，如果类中有一个特征是只希望外部能得不能改的，又没有什么特殊处理，就可以直接使用自动属性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> Height</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//没有在set,get中写逻辑的需求或者想法</span></span><br><span class="line">    <span class="keyword">get</span>;</span><br><span class="line">    <span class="keyword">set</span>;</span><br><span class="line">    <span class="comment">//可以添加访问修饰符</span></span><br><span class="line">    <span class="comment">//如：private set;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> Sex &#123; <span class="keyword">set</span>; <span class="keyword">get</span>; &#125; = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h4><p><strong>概念：</strong> 索引器允许通过类实例的索引来访问该类的实例成员。它的声明类似于属性，但具有参数。通常情况下，索引器用于允许类的实例像数组一样通过索引进行访问。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Person[] friends;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Person <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> friends[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// value代表传入的值</span></span><br><span class="line">            friends[index] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">p[<span class="number">0</span>] = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>索引器支持多维索引</li><li>C#允许对索引器进行重载</li><li>索引器可以具有多个参数，但每个参数的类型必须唯一</li><li>索引器的参数可以是值类型或引用类型</li><li>可以根据需要只声明 get 或 set 访问器，但至少必须实现其中一个</li></ul><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p><strong>概念：</strong></p><p>静态关键字：<code>static</code>，用static修饰的成员变量，方法，属性等称为静态成员。静态成员可以直接用类名点出来使用。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//静态成员变量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">float</span> PI=<span class="number">3.1415926f</span>;</span><br><span class="line">   <span class="comment">//成员变量</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> testInt=<span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//静态成员方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">CalcCircle</span>(<span class="params"><span class="built_in">float</span> r</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> PI*r*r;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//成员方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">     Console.WriteLine(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(Test.PI);</span><br><span class="line">Console.WriteLine（Test.CalcCircle(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p><strong>原理：</strong></p><p>为什么可以点出来使用：静态成员会有一片静态存储空间，与程序同生共死，一般不参与垃圾回收机制（除非静态引用变量定义为Null,才会参与垃圾回收）</p><p>程序不是无中生有的，我们要使用对象，变量，函数都是要在内存中分配内存空间，在程序中产生一个抽象的对象。</p><p>静态成员的特点：程序开始运行时就分配内存空间，所以我们可以直接使用。静态成员与程序同生共死，只要使用了它，直到程序结束才会被释放，一个静态成员有唯一的小房间，静态成员就有了唯一性。</p><p><strong>注意：</strong></p><ul><li>静态函数不能使用非静态成员，非静态函数可以使用静态成员</li><li>const常量和静态变量都可以通过类名点出来使用，但const常量必须初始化，不能修改，static没有这个规则，static可以修饰很多。const常量一定是写在访问修饰符后面，而static没有这个要求。</li></ul><h4 id="静态类和静态构造函数"><a href="#静态类和静态构造函数" class="headerlink" title="静态类和静态构造函数"></a>静态类和静态构造函数</h4><p><strong>静态类：</strong> 用<code>static</code>关键字修饰的类称作静态类，静态类只能包含静态成员且不能被实例化。例如<strong>Console</strong>就是一个静态类。</p><p><strong>作用：</strong> 将常用的静态成员写在静态类中，方便使用。静态类不能被实例化，更能体现工具类的唯一性。</p><p><strong>静态构造函数：</strong> 用<code>static</code>关键字修饰的构造函数为静态构造函数，静态类和普通类都可以有静态构造函数。静态构造函数不能使用访问修饰符、不能有参数且只会自动调用一次。</p><p><strong>作用：</strong> 静态构造函数用于初始化静态变量。</p><p>静态构造函数不可继承、不可被直接调用，当创建类实例或引用任何静态成员之前，静态构造函数被自动执行，并且只执行一次。</p><h4 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h4><p><strong>概念：</strong> 为现有的非静态变量类型添加新方法。</p><p><strong>作用：</strong></p><ul><li>提升程序拓展性</li><li>不需要在对象中重新写方法</li><li>不需要继承来添加方法</li><li>为别人封装的类型写额外的方法</li></ul><p><strong>特点：</strong></p><ul><li>一定是写在静态类中</li><li>一定是个静态函数</li><li>第一个参数为拓展目标</li><li>第一个参数用this修饰</li></ul><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 返回值 函数名(<span class="keyword">this</span> 拓展类名 参数名, 参数类型 参数名, 参数类型 参数名, ...)</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为int拓展了一个成员方法</span></span><br><span class="line">    <span class="comment">//成员方法是需要实例化对象后才能使用的</span></span><br><span class="line">    <span class="comment">//value代表使用该方法的实例化对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpeakValue</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拓展的方法的逻辑</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;为int的拓展方法&quot;</span> + <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpeakStringInfo</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> str, <span class="built_in">string</span> str2, <span class="built_in">string</span> str3</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;为string拓展的方法&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;调用方法的对象&quot;</span> + str);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;传的参数&quot;</span> + str2 + str3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun2</span>(<span class="params"><span class="keyword">this</span> Test t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是为Test类拓展的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是自带的成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">i.SpeakValue();</span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;000&quot;</span>;</span><br><span class="line">str.SpeakStringInfo(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line">t.Fun2();</span><br></pre></td></tr></table></figure><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p><strong>概念：</strong> 让自定义类和结构体能够使用运算符。</p><p><strong>关键字：</strong> <code>operator</code></p><p><strong>特点：</strong></p><ul><li>一定是一个公共的静态方法</li><li>返回值写在operator前</li><li>逻辑处理自定义</li></ul><p><strong>作用：</strong> 让自定义类和结构体对象可以进行运算。</p><p><strong>注意：</strong></p><ul><li><p>二元运算符需要成对实现</p><ul><li><p><code>==</code>（相等）对应 <code>!=</code>（不等）</p></li><li><p><code>&gt;</code>（大于）对应 <code>&lt;</code>（小于）</p></li><li><p><code>&gt;=</code>（大于等于）对应 <code>&lt;=</code>（小于等于）</p></li></ul></li><li><p>一个符号可以多个重载</p></li><li><p>不能使用 ref 和 out </p></li><li><p>参数列表至少要有一个当前类（或结构体）类型的参数</p></li></ul><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回类型 <span class="keyword">operator</span> 运算符( 参数列表 )</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> x;</span><br><span class="line">    <span class="built_in">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span>+(Point p1, Point p2)</span><br><span class="line">    &#123;</span><br><span class="line">        Point p = <span class="keyword">new</span> Point();</span><br><span class="line">        p.x = p1.x + p2.x;</span><br><span class="line">        p.y = p1.y + p2.y;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point();</span><br><span class="line">p.x = <span class="number">1</span>;</span><br><span class="line">p.y = <span class="number">1</span>;</span><br><span class="line">Point p2 = <span class="keyword">new</span> Point();</span><br><span class="line">p2.x = <span class="number">2</span>;</span><br><span class="line">p2.y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">Point p3 = p + p2;</span><br></pre></td></tr></table></figure><h4 id="内部类和分部类"><a href="#内部类和分部类" class="headerlink" title="内部类和分部类"></a>内部类和分部类</h4><p><strong>内部类：</strong> 在一个类中声明的类。</p><p><strong>特点：</strong> 使用时要用包裹者点出自己。</p><p><strong>作用：</strong> 亲密关系的变现 。</p><p><strong>注意：</strong> 访问修饰符作用很大。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> Body body;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Body</span></span><br><span class="line">    &#123;</span><br><span class="line">        Arm leftArm;</span><br><span class="line">        Arm rightArm;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">class</span> <span class="title">Arm</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person.Body body = <span class="keyword">new</span> Person.Body();</span><br></pre></td></tr></table></figure><p><strong>分部类：</strong> 把一个类分成几部分声明（关键字：<code>partial</code>）。</p><p><strong>作用：</strong> 增加程序的拓展性。</p><p><strong>注意：</strong></p><ul><li>分部类可以写在不同的脚本文件中</li><li>分部类的访问修饰符要一致</li><li>分部类中不能有重复成员</li></ul><p><strong>分部方法：</strong> 将方法的声明和实现分离（局限性大，了解即可）。</p><p><strong>特点：</strong></p><ul><li>不能加访问修饰符，默认私有</li><li>只能在分部类中声明</li><li>返回值只能是void</li><li>可以有参数但不能用 out 关键字</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> number;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"><span class="built_in">int</span> speed</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetHeight</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"><span class="built_in">int</span> speed</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承的基本原则"><a href="#继承的基本原则" class="headerlink" title="继承的基本原则"></a>继承的基本原则</h4><p><strong>基本概念：</strong> 当一个类A继承一个类B时，类A将会继承类B的所有成员，A类将拥有B类的所有特征和行为。被继承的类称为父类、基类、超类，继承的类称为子类、派生类。子类可以有自己的特征和行为。</p><p><strong>特点：</strong></p><ul><li>单根性：子类只能有一个父类（单继承）</li><li>传递性：子类可以间接继承父类的父类</li></ul><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 : 被继承的类名</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同名成员：</strong> 在子类中出现与父类同名的成员，默认将父类的成员覆盖，也可以使用<code>new</code>关键字表示覆盖，但极其不建议使用同名成员。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">new</span> <span class="built_in">string</span> name;</span><br></pre></td></tr></table></figure><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><p>里氏替换原则是面向对象七大原则中最重要的原则</p><p><strong>基本概念：</strong> 任何父类出现的地方，子类都可替代。</p><p><strong>重点：</strong> 语法表现——父类容器装子类对象，因为子类对象包含了父类的所有内容。</p><p><strong>作用：</strong> 方便进行对象存储和管理。</p><p><strong>基本实现：</strong> 用父类容器装载子类对象</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Monster</span> : <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Boss</span> : <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">GameObject player = <span class="keyword">new</span> Player();</span><br><span class="line">GameObject[] objects = <span class="keyword">new</span> GameObject[] &#123; <span class="keyword">new</span> Player(), <span class="keyword">new</span> Monster(), <span class="keyword">new</span> Boss() &#125;;</span><br></pre></td></tr></table></figure><p><strong>is 和 as 关键字：</strong></p><ol><li><p><code>is</code>：判断一个类对象是否是指定类对象，返回值为<code>bool</code>，是为真，不是为假</p></li><li><p><code>as</code>：将一个对象转换为指定类对象，返回值为指定类型对象，成功返回指定类型对象，失败返回<code>null</code></p></li><li><p>基本语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 书接上回</span></span><br><span class="line"><span class="keyword">if</span> (player <span class="keyword">is</span> Player)</span><br><span class="line">&#123;</span><br><span class="line">    Player p = player <span class="keyword">as</span> Player;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注：不能用子类容器装父类对象</strong></p><h4 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h4><p><strong>特点：</strong> 当声明一个子类对象时，先执行父类的构造函数，再执行子类的构造函数。</p><p><strong>注意：</strong> 父类的无参构造很重要。子类可以通过base关键字代表父类，调用父类构造。</p><p><strong>继承中构造函数的执行顺序：</strong> 父类的父类的构造 -&gt; 父类构造 -&gt; 子类构造。子类实例化时，默认自动调用的是父类的无参构造，所以如果父类的无参构造被顶掉，会出错。</p><p><strong>通过base调用指定的父类构造：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Son</span> : <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span>(<span class="params"><span class="built_in">int</span> i</span>) : <span class="title">base</span>(<span class="params">i</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="万物之父和装箱拆箱"><a href="#万物之父和装箱拆箱" class="headerlink" title="万物之父和装箱拆箱"></a>万物之父和装箱拆箱</h4><p><strong>万物之父：</strong> <code>object</code> 是所有类型的基类，它是一个类（引用类型）。</p><p><strong>作用：</strong> 可以利用里氏替换原则，用 <code>object</code> 容器装所有对象。可以用来表示不确定类型，作为函数参数类型。</p><p><strong>装箱拆箱：</strong></p><ul><li>装箱：把值类型用引用类型存储（栈内存会迁移到堆内存中）</li><li>拆箱：把引用类型存储的值取出来（堆内存会迁移到栈内存中）</li><li>好处：不确定类型时可以方便参数的存储和传递</li><li>坏处：存在内存迁移，增加性能消耗</li></ul><h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><p><strong>概念：</strong> 密封类是使用 <code>sealed</code> 密封关键字修饰的类。密封类无法被继承。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Son</span> : <span class="title">Father</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p><strong>作用：</strong> 在面向对象程序设计中，密封类的主要作用就是不允许最底层子类被继承，可以保证程序的规范性，安全性。</p><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="Vob"><a href="#Vob" class="headerlink" title="Vob"></a>Vob</h4><p><strong>多态的概念：</strong> 多态按字面的意思就是“多种状态”，让继承同一父类的子类们 在执行相同方法时有不同的表现（状态）。</p><p><strong>多态的实现：</strong></p><ul><li>编译时多态——函数重载</li><li>运行时多态：Vob、抽象函数、接口</li></ul><p><strong>Vob：</strong></p><ul><li>v： <code>virtual</code>（虚函数）</li><li>o： <code>override</code> （重写）</li><li>b： <code>base</code> （父类）</li><li>（n）： <code>new</code> （覆盖）</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GameObject</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//虚函数 可以被子类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;游戏对象进行攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//重写虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//base的作用</span></span><br><span class="line">        <span class="comment">//代表父类 可以通过base来保留父类的行为</span></span><br><span class="line">        <span class="keyword">base</span>.Atk();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;玩家对象进行攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Monster</span> : <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monster</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;怪物对象进行攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要目的：</strong> 同一父类的对象 执行相同行为（方法）有不同的表现。</p><p><strong>解决的问题：</strong> 让同一个对象有唯一行为的特征。</p><h4 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h4><p><strong>概念：</strong> 被抽象关键字 <code>abstract</code> 修饰的类为抽象类，方法称为抽象方法。</p><p><strong>特点：</strong></p><ul><li>抽象类不能被实例化，但仍可以使用里氏替换原则装它的子类</li><li>抽象方法只能在抽象类中声明，抽象方法没有方法体且不能是私有的</li><li>继承抽象类必须重写其抽象方法</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The dog barks.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The cat meows.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p><strong>概念：</strong> 接口是行为的抽象规范，它也是一种自定义类型。关键字： <code>interface</code> 。</p><p><strong>接口声明的规范：</strong></p><ol><li>不能包含成员变量</li><li>只能包含方法、属性、索引器、事件</li><li>成员不能被实现</li><li>成员不能是私有的，但可以不写访问修饰符，默认是公共的</li><li>接口不能继承类，但可以继承另一个接口</li></ol><p><strong>接口的使用规范：</strong></p><ol><li>类可以继承多个接口</li><li>类继承接口后，必须实现接口中所有成员</li></ol><p><strong>特点：</strong></p><ol><li>和类的声明类似</li><li>接口只能用来继承，不能被实例化，但可以作为容器存储对象（里氏替换原则）</li><li>接口名称通常以大写字母 “I” 开头，表示接口（Interface）的含义，然后跟随具体的接口名称</li></ol><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;攻击&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IExampleInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Method1</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method2</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IExampleInterface2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method4</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IExampleInterfaceSon</span> : <span class="title">IExampleInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Method3</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Book</span> : <span class="title">GameObject</span>, <span class="title">IExampleInterfaceSon</span>, <span class="title">IExampleInterface2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method2</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method3</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method4</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显式实现接口：</strong></p><p>当一个类继承多个接口，但接口中存在同名方法时，可以使用显式实现接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Atk</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ISuperAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Atk</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">IAtk</span>, <span class="title">ISuperAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> IAtk.Atk() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> ISuperAtk.Atk() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong> 显式实现接口不能写访问修饰符。</p><h4 id="密封方法"><a href="#密封方法" class="headerlink" title="密封方法"></a>密封方法</h4><p><strong>概念：</strong> 密封方法是使用 <code>sealed</code> 密封关键字修饰的重写方法，让虚方法或抽象方法在之后不能再被重写。</p><p><strong>特点：</strong> 和 <code>override</code> 一起出现。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="面向对象七大原则"><a href="#面向对象七大原则" class="headerlink" title="面向对象七大原则"></a>面向对象七大原则</h2><h3 id="开闭原则OCP"><a href="#开闭原则OCP" class="headerlink" title="开闭原则OCP"></a>开闭原则OCP</h3><p>开闭原则是设计原则基础的基础，是面向对象的核心原则，其它原则均围绕开闭原则进行展开。 </p><p><strong>开闭原则指的是一个软件实体应对对扩展开放，对修改关闭(Software entities should be open for extension, but closed for modification)。</strong> 这个原则是说在设计一个模块的时候，应对使这个模块可以在不被修改的前提下被扩展，换言之，应对可以不必修改源代码的情况下改变这个模块的行为。 </p><p><strong>满足开闭原则的软件系统的优越性：</strong> </p><ul><li><p>通过扩展已有的软件系统，可以提供新的行为，以满足对软件的新需求，使变化中的软件系统有一定的适应性和灵活性</p></li><li><p>已有的软件模块，特别是最重要的抽象层模块不能再修改，这就使变化中的软件系统有一定的稳定性和延续性</p></li></ul><p><strong>实现开闭原则的关键：</strong></p><p>抽象化是解决问题的关键，在面向对象的编程语言里，可以给系统定义出一套相对较为固定的抽象设计，此设计允许无穷无尽的行为在实现层被实现。在语言里，可以给出一个或多个抽象类或者接口，规定出所有的具体类必须提供的方法的特征作为系统设计的抽象层。这个抽象层预见了所有的可扩展性，因此，在任何扩展情况下都不会改变。这就使得系统的抽象不需要修改，从而满足了开闭原则的第二条，对修改关闭。 </p><p>同时，由于从抽象层导出一个或多个新的具体类可以改变系统的行为，因此系统的设计对扩展是开放的，这就满足了开闭原则的第一条。 </p><p><strong>对可变性的封装原则：</strong> </p><p><strong>把变化的东西封装起来，把不变的抽象出来。</strong> 这是对开闭原则的另外一种描述，它讲的是找到一个系统的可变因素，将之封装起来。该原则意味着两点: </p><ul><li><p>一种可变性不应当散落在代码的很多角落，而应当封装到一个对象里面。继承应当被看做是封装变化的方法，而不应该被认为是一种从一般对象生成特殊对象的方法</p></li><li><p>一种可变性不应当与另外一种可变性混合在一起。这意味着一般的继承层次不会超过两层</p></li></ul><h3 id="里氏替换原则LSP"><a href="#里氏替换原则LSP" class="headerlink" title="里氏替换原则LSP"></a>里氏替换原则LSP</h3><p>任何基类可以出现的地方，子类一定可以出现。<strong>即父类存在的地方，子类是可以替换的。</strong> 替换后行为不变，结果会变化。调用子类行为。 子类和父类必须有相同行为才能完全地实现替换。 </p><p>实现开闭原则的关键是抽象化，而里氏代换原则中的基类和子类的继承关系正是抽象化的具体体现，所以里氏代换原则是对实现抽象化的具体步骤的规范。违反里氏代换原则一个最经典的例子便是把正方形设计成长方形的子类。</p><h3 id="依赖倒置原则DIP"><a href="#依赖倒置原则DIP" class="headerlink" title="依赖倒置原则DIP"></a>依赖倒置原则DIP</h3><p><strong>要依赖于抽象，不要依赖于实现。</strong> 说的白一点就是要依赖于抽象类和接口不要依赖具体类，具体类也就是我们可以用new关键字实例化的类。依赖倒转原则是实现开闭原则的一个手段。</p><h3 id="单一职责原则SRP（体现高内聚）"><a href="#单一职责原则SRP（体现高内聚）" class="headerlink" title="单一职责原则SRP（体现高内聚）"></a>单一职责原则SRP（体现高内聚）</h3><p><strong>每一个类应该专注于做一件事情。</strong></p><h3 id="接口隔离原则ISP"><a href="#接口隔离原则ISP" class="headerlink" title="接口隔离原则ISP"></a>接口隔离原则ISP</h3><p><strong>应当为客户端提供尽可能小的单独接口，而不要提供大的总接口。</strong> 暴露行为让后面的实现类知道的越少越好。</p><h3 id="迪米特法则（体现松偶合）"><a href="#迪米特法则（体现松偶合）" class="headerlink" title="迪米特法则（体现松偶合）"></a>迪米特法则（体现松偶合）</h3><p><strong>又叫最少知识原则，一个对象对另一个对象知道的越少越好，即一个软件实体应当尽可能少的与其他实体发生相互作用。</strong></p><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p><strong>要尽量使用合成&#x2F;聚合达到复用，而不是继承关系达到复用的目的。尽量少用继承。</strong> 就如我们前面说的，如果为了复用，便使用继承的方式将两个不相干的类联系在一起，这样的方式是违反合成&#x2F;聚合复用原则的，更进一步的后果那便是违反里氏代换原则。合成&#x2F;聚合复用和里氏代换原则相辅相成，合成&#x2F;聚合复用原则要求我们在复用时首先考虑合成&#x2F;聚合关系，而里氏代换原则是要求我们在使用继承时，必须满足一定的条件。 </p><p><strong>原则：一个类中有另一个类的对象。</strong></p><hr><h2 id="面向对象设计模式"><a href="#面向对象设计模式" class="headerlink" title="面向对象设计模式"></a>面向对象设计模式</h2><p><a href="https://blog.csdn.net/JSANXWT/article/details/126479362">面向对象设计的23种设计模式</a></p><hr><h2 id="面向对象相关"><a href="#面向对象相关" class="headerlink" title="面向对象相关"></a>面向对象相关</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>命名空间是用来组织和重用代码的，就像是一个工具包，类就像是一件一件的工具，都是声明在命名空间中的。命名空间的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。</p><p><strong>定义：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">namespace_name</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>命名空间可以分开声明且可以嵌套：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyGame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyGame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">UI</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">TestUI</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">Image</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">TestImage</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同一命名空间下不能含有同名类，不同命名空间下可以含有同名类：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Run</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Move</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Fly</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Move</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>1.使用 <code>using</code> 关键字引用其他命名空间使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MyGame; <span class="comment">// 只如此引用仍要通过指明出处才能引用该命名空间下的命名空间的类</span></span><br><span class="line"><span class="keyword">using</span> MyGame.UI; <span class="comment">// 如此引用只能使用UI命名空间的类，可以与MyGame同时引用</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Now</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameObject gameobject = <span class="keyword">new</span> GameObject();</span><br><span class="line">        Player player = <span class="keyword">new</span> Player();</span><br><span class="line">        TestUI testUI = <span class="keyword">new</span> TestUI();</span><br><span class="line">        </span><br><span class="line">        MyGame.Image.TestImage testImage = <span class="keyword">new</span> MyGame.Image.TestImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.指明出处使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Now</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.Console.WriteLine(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        MyGame.GameObject gameObject = <span class="keyword">new</span> MyGame.GameObject();</span><br><span class="line">        MyGame.Player player = <span class="keyword">new</span> MyGame.Player();</span><br><span class="line">        MyGame.Image.TestImage testImage = <span class="keyword">new</span> MyGame.Image.TestImage();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同名类只能通过指明出处使用</span></span><br><span class="line">        Run.Move move1 = <span class="keyword">new</span> Run.Move();</span><br><span class="line">        Fly.Move move2 = <span class="keyword">new</span> Fly.Move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（引用命名空间后也可指明出处使用）</p><p><strong>注：命名空间中的类默认为 internal 。</strong></p><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><h4 id="object中的静态方法"><a href="#object中的静态方法" class="headerlink" title="object中的静态方法"></a>object中的静态方法</h4><p><strong>静态方法 <code>Equals</code> ：</strong></p><p>判断两个对象是否相等。最终的判断权交给左侧对象的 Equals 成员方法，不管值类型还是引用类型都会按照左侧对象的 Equals 成员方法的规则来进行比较。</p><p><strong>静态方法 <code>ReferenceEquals</code> ：</strong></p><p>比较两个对象是否是相同的引用，主要是用来比较引用类型的对象，值类型对象返回值始终是 false 。</p><h4 id="object中的成员方法"><a href="#object中的成员方法" class="headerlink" title="object中的成员方法"></a>object中的成员方法</h4><p><strong>普通方法 <code>GetType</code> ：</strong></p><p>该方法的主要作用是获取对象运行时的类型 Type ，通过 Type 结合反射相关知识点可以做很多关于对象的操作。该方法在反射相关知识点中是非常重要的方法。</p><p><strong>普通方法 <code>MemberwiseClone</code>  ：</strong></p><p>该方法用于获取对象的浅拷贝对象，意思就是会返回一个新的对象，但是新对象中的引用变量会和老对象中的一致。</p><h4 id="object中的虚方法"><a href="#object中的虚方法" class="headerlink" title="object中的虚方法"></a>object中的虚方法</h4><p><strong>虚方法 <code>Equals</code> ：</strong></p><p>默认实现还是比较两者是否为同一个引用，即相当于 <code>ReferenceEquals</code> 。但是微软在所有类型值的基类 <code>System.ValueType</code> 中重写了该方法，用来比较值相等。我们也可以重写该方法，定义自己的比较规则。</p><p><strong>虚方法 <code>GetHashCode</code> ：</strong></p><p>该方法时获取对象的哈希码（一种通过算法算出的，表示对象的唯一编码，不同对象的哈希码有可能一样，具体值根据哈希算法决定），我们可以通过重写该函数来自己定义对象的哈希码算法，正常情况下，基本不用。</p><p><strong>虚方法 <code>ToString</code> ：</strong></p><p>该方法用于返回当前对象代表的字符串，我们可以重写它定义我们自己的对象转字符串规则，该方法非常常用。当我们调用打印方法时，默认使用的就是对象的 <code>ToString</code> 方法后打印出来的内容。</p><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>, <span class="number">1</span>, <span class="number">3333</span>);</span><br><span class="line">Console.Write(str);</span><br><span class="line"><span class="comment">// 输出 13333</span></span><br></pre></td></tr></table></figure><h4 id="正向查找字符位置"><a href="#正向查找字符位置" class="headerlink" title="正向查找字符位置"></a>正向查找字符位置</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> index = str.IndexOf(<span class="string">&quot;好&quot;</span>); <span class="comment">// 找不到返回-1</span></span><br><span class="line">Console.Write(index);</span><br><span class="line"><span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><h4 id="反向查找指定字符串位置"><a href="#反向查找指定字符串位置" class="headerlink" title="反向查找指定字符串位置"></a>反向查找指定字符串位置</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> index = str.LastIndexOf(<span class="string">&quot;哈哈&quot;</span>); <span class="comment">// 找不到返回-1</span></span><br><span class="line">Console.Write(index);</span><br><span class="line"><span class="comment">// 输出 4</span></span><br></pre></td></tr></table></figure><h4 id="移除指定位置后的字符（包括指定位置）"><a href="#移除指定位置后的字符（包括指定位置）" class="headerlink" title="移除指定位置后的字符（包括指定位置）"></a>移除指定位置后的字符（包括指定位置）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Remove(<span class="number">3</span>); <span class="comment">// 只会返回新字符串，不会修改原字符串</span></span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 你好哈</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Remove(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">// 第二个参数决定移除的字符个数</span></span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 你好哈哈哈</span></span><br></pre></td></tr></table></figure><h4 id="替换指定字符串"><a href="#替换指定字符串" class="headerlink" title="替换指定字符串"></a>替换指定字符串</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Replace(<span class="string">&quot;哈哈&quot;</span>, <span class="string">&quot;嘻嘻&quot;</span>);</span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 你好嘻嘻哈哈</span></span><br></pre></td></tr></table></figure><h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;jhsdgfhsdgfs&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.ToUpper(); <span class="comment">// 转大写</span></span><br><span class="line">newstr = str.ToLower(); <span class="comment">// 转小写</span></span><br></pre></td></tr></table></figure><h4 id="字符串截取（包含指定位置）"><a href="#字符串截取（包含指定位置）" class="headerlink" title="字符串截取（包含指定位置）"></a>字符串截取（包含指定位置）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Substring(<span class="number">2</span>); <span class="comment">// 截取从指定位置开始之后的字符串</span></span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 哈哈哈哈</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Substring(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 第二个参数表示截取指定个数</span></span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 哈哈</span></span><br></pre></td></tr></table></figure><h4 id="字符串切割"><a href="#字符串切割" class="headerlink" title="字符串切割"></a>字符串切割</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;1,2,3,4,5,6,7,8&quot;</span>;</span><br><span class="line"><span class="built_in">string</span>[] strs = str.Split(<span class="string">&#x27;,&#x27;</span>); <span class="comment">// 以逗号切割</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; strs.Length; i ++)</span><br><span class="line">    Console.Write(strs[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">// 输出 1 2 3 4 5 6 7 8</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p><code>string</code> 是特殊的引用，每次重新赋值或者拼接时会分配新的内存空间，如果一个字符串经常改变会非常浪费空间。</p><p><code>StringBuilder</code> 是c#提供的一个用于处理字符串的公共类，主要解决的问题是：直接修改字符串而不创建新的对象，需要频繁修改和拼接的字符串可以使用它，可以提升性能。</p><p><strong>注意使用时需要引用命名空间</strong></p><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;12213123123&quot;</span>, <span class="number">50</span>); <span class="comment">// 初始化与指定容量（可选）</span></span><br><span class="line"><span class="comment">// StringBuilder始终会有空余容量，超过会自动扩容，每次自动扩容容量翻一倍</span></span><br><span class="line">Console.WriteLine(str.Capacity); <span class="comment">// 获取容量</span></span><br><span class="line">Console.WriteLine(str.Length); <span class="comment">// 获取字符串长度</span></span><br></pre></td></tr></table></figure><p><strong>方法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加</span></span><br><span class="line">str.Append(<span class="string">&quot;8888&quot;</span>); <span class="comment">// 加到字符串末尾</span></span><br><span class="line">str.AppendFormat(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>, <span class="number">444</span>, <span class="number">666</span>); <span class="comment">// 通过拼接的形式添加</span></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">str.Insert(<span class="number">0</span>, <span class="string">&quot;2784356&quot;</span>); <span class="comment">// 插入位置 插入内容</span></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">str.Remove(<span class="number">0</span>, <span class="number">10</span>); <span class="comment">// 起始位置 删除个数</span></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">str.Clear();</span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="comment">// str[1] 直接索引</span></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 直接修改</span></span><br><span class="line"><span class="comment">// 替换</span></span><br><span class="line">str.Replace(<span class="string">&quot;34&quot;</span>, <span class="string">&quot;283645&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>StringBuilder</code> 的所有方法执行后都会直接修改原字符串，不需要重新定义。</p><hr><h1 id="数据结构类"><a href="#数据结构类" class="headerlink" title="数据结构类"></a>数据结构类</h1><h2 id="ArrayList类（可变数组）"><a href="#ArrayList类（可变数组）" class="headerlink" title="ArrayList类（可变数组）"></a>ArrayList类（可变数组）</h2><p><strong>概念：</strong> <code>ArrayList</code> 本质是一个 <code>object</code>类型的数组，实现了很多方法。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引用命名空间 System.Collections</span></span><br><span class="line">ArrayList array = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个增加</span></span><br><span class="line">array.Add(<span class="number">1</span>);</span><br><span class="line">array.Add(<span class="string">&quot;3424&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量增加（把另一个List容器里面的内容全部加到后面）</span></span><br><span class="line">array.AddRange(array2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">array.Insert(<span class="number">1</span>, <span class="string">&quot;12345&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.Remove(<span class="string">&quot;ghfjk&quot;</span>); <span class="comment">// 删除第一个指定元素</span></span><br><span class="line">array.RemoveAt(<span class="number">0</span>); <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">array.Clear(); <span class="comment">// 清空</span></span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到指定位置的元素</span></span><br><span class="line">Console.WriteLine(array[<span class="number">0</span>]); <span class="comment">// 直接读取下标</span></span><br><span class="line"><span class="comment">// 查看元素是否存在</span></span><br><span class="line">array.Contains(<span class="string">&quot;123&quot;</span>); <span class="comment">// 返回bool类型，有就返回true，没有返回false</span></span><br><span class="line"><span class="comment">// 正向查找元素位置</span></span><br><span class="line"><span class="built_in">int</span> index = array.IndexOf(<span class="string">&quot;gfh&quot;</span>); <span class="comment">// 返回元素下标，没有返回-1</span></span><br><span class="line"><span class="comment">// 反向查找元素位置</span></span><br><span class="line">index = array.LastIndexOf(<span class="string">&quot;111&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">0</span>] = <span class="string">&quot;3334&quot;</span>; <span class="comment">// 直接修改</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>装箱拆箱：</strong></p><p><code>ArrayList</code> 本质上是一个可以自动扩容的 <code>object</code> 数组，当往其中进行值类型存储时就是在装箱，当值类型对象取出来转换使用时就是在拆箱，所以 <code>ArrayList</code> 尽量少用，有更好的数据容器。</p><p><strong>注：</strong> <code>ArrayList</code> 同样具有容量，原理和作用与 <code>StringBuilder</code> 相同。</p><h2 id="Stack类（栈）"><a href="#Stack类（栈）" class="headerlink" title="Stack类（栈）"></a>Stack类（栈）</h2><p><strong>概念：</strong> <code>Stack</code> 的本质也是 <code>object</code> 数组，封装了栈的存储规则，栈是一种先进后出的数据结构。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引用命名空间 System.Collections</span></span><br><span class="line">stack stack = <span class="keyword">new</span> Stack();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压栈</span></span><br><span class="line">stack.Push(<span class="number">0</span>);</span><br><span class="line">stack.Push(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>取出</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弹栈</span></span><br><span class="line"><span class="built_in">object</span> v = stack.Pop();</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈无法查看指定位置的元素，只能查看栈顶的内容</span></span><br><span class="line">v = stack.Peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看元素是否存在于栈中</span></span><br><span class="line">stack.Contains(<span class="string">&quot;123&quot;</span>); <span class="comment">// true / false</span></span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈无法改变其中的元素，只能压和弹，实在要改，只有清空</span></span><br><span class="line">stack.Clear();</span><br></pre></td></tr></table></figure></li></ul><h2 id="Queue类（队列）"><a href="#Queue类（队列）" class="headerlink" title="Queue类（队列）"></a>Queue类（队列）</h2><p><strong>概念：</strong> <code>Queue</code> 的本质也是 <code>object</code> 数组，封装了队列的存储规则，队列是一种先进先出的数据结构。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引用命名空间 System.Collections</span></span><br><span class="line">Queue queue = <span class="keyword">new</span> Queue();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.Enqueue(<span class="number">1</span>);</span><br><span class="line">queue.Enqueue(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>取出</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> v = queue.Dequeue();</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看队列头部元素</span></span><br><span class="line">v = queue.Peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看元素是否在队列中</span></span><br><span class="line">queue.Contains(<span class="string">&quot;123&quot;</span>); <span class="comment">// true / false</span></span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列无法改变其中的元素，只能进和出，实在要改，只有清空</span></span><br><span class="line">queue.Clear();</span><br></pre></td></tr></table></figure></li></ul><h2 id="Hashtable类（哈希表）"><a href="#Hashtable类（哈希表）" class="headerlink" title="Hashtable类（哈希表）"></a>Hashtable类（哈希表）</h2><p><strong>概念：</strong> <code>Hashtable</code> （又称散列表）是基于键的哈希代码组织起来的键值对集合，它的主要作用是提高数据查询的效率，使用键来访问集合中的元素。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引用命名空间 System.Collections</span></span><br><span class="line">Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：不能出现相同键</span></span><br><span class="line">hashtable.Add(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">hashtable.Add(<span class="number">2</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">hashtable.Add(<span class="string">&quot;123&quot;</span>, <span class="number">2</span>); <span class="comment">// 第一个参数是key</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接通过键删除</span></span><br><span class="line">hashtable.Remove(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">hashtable.Clear();</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过键查找值 找不到会返回空</span></span><br><span class="line">Console.WriteLine(hashtable[<span class="string">&quot;key&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看是否存在</span></span><br><span class="line"><span class="comment">// 根据键检测</span></span><br><span class="line">hashtable.Contains(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">hashtable.ContainsKey(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="comment">// 根据值检测</span></span><br><span class="line">hashtable.Contains.ContainsValue(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能改键对应的内容，无法修改键</span></span><br><span class="line">hashtable[<span class="string">&quot;123&quot;</span>] = <span class="number">100.5f</span>;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型-1"><a href="#泛型-1" class="headerlink" title="泛型"></a>泛型</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>泛型实现了类型参数化，达到代码重用的目的，通过类型参数化来实现同一份代码上操作多种类型。</p><p>泛型相当于类型占位符，定义类或方法时使用替代符代表变量类型，当真正使用类或者方法时再具体指定类型。</p><h3 id="泛型类和接口"><a href="#泛型类和接口" class="headerlink" title="泛型类和接口"></a>泛型类和接口</h3><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestClass1</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestClass1</span> &#123; &#125; </span><br><span class="line"><span class="comment">// 泛型属于类名的一部分，即使它们名字相同，如果泛型不同（是否引用泛型、泛型引用个数），它们也不是同一个类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ITest</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型占位字母可以有多个，用逗号分开</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestClass2</span>&lt;<span class="title">T</span>, <span class="title">E</span>, <span class="title">M</span>, <span class="title">XXX</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T value1;</span><br><span class="line">    <span class="keyword">public</span> E value2;</span><br><span class="line">    <span class="keyword">public</span> XXX value3;</span><br><span class="line">    <span class="keyword">public</span> M value4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TestClass1&lt;<span class="built_in">int</span>&gt; t1 = <span class="keyword">new</span> TestClass1&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">t1.<span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line">TestClass1&lt;<span class="built_in">string</span>&gt; t2 = <span class="keyword">new</span> TestClass1&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">t2.<span class="keyword">value</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line">TestClass2&lt;<span class="built_in">int</span>, <span class="built_in">string</span>, <span class="built_in">float</span>, <span class="built_in">bool</span>&gt; t3 = <span class="keyword">new</span> TestClass2&lt;<span class="built_in">int</span>, <span class="built_in">string</span>, <span class="built_in">float</span>, <span class="built_in">bool</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>继承：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承时实现指定</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span> : <span class="title">ITest</span>&lt;<span class="title">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p><strong>普通类中的泛型方法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun1</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span> &#123; <span class="comment">/* 函数逻辑 */</span> &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 泛型可以有多个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun2</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt;()</span></span><br><span class="line">    &#123;</span><br><span class="line">        T t = <span class="literal">default</span>(T);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 可以用泛型类型做一些逻辑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 泛型作返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">TestFun3</span>&lt;<span class="title">T</span>&gt;()</span></span><br><span class="line">    &#123;</span><br><span class="line">        T Value;</span><br><span class="line">        <span class="keyword">return</span> Value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Test1 t1 = <span class="keyword">new</span> Test2();</span><br><span class="line"></span><br><span class="line">t1.TestFun1&lt;<span class="built_in">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">t1.TestFun1&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;12321312&quot;</span>);</span><br><span class="line"></span><br><span class="line">t1.TestFun2&lt;<span class="built_in">bool</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = t1.TestFun3&lt;<span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>泛型类中的泛型方法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T Value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这种不是泛型方法，T是类的泛型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">T t</span>)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这种才算泛型方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">E</span>&gt;(<span class="params">E e</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test2&lt;<span class="built_in">int</span>&gt; t2 = <span class="keyword">new</span> Test2&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">t2.TestFun&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;123213&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h3><ul><li>不同类型对象的相同逻辑处理就可以用泛型</li><li>使用泛型可以一定程度上避免装箱拆箱</li></ul><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><h3 id="什么是泛型约束"><a href="#什么是泛型约束" class="headerlink" title="什么是泛型约束"></a>什么是泛型约束</h3><p><strong>概念：</strong> 让泛型的类型有一定的限制。</p><p><strong>关键字：</strong> <code>where</code></p><p><strong>泛型约束一共有6种：</strong></p><ol><li>值类型： <code>where 泛型字母 : struct</code></li><li>引用类型： <code>where 泛型字母 : class</code></li><li>存在无参公共构造函数： <code>where 泛型字母 : new()</code></li><li>某个类本身或其派生类： <code>where 泛型字母 : 类名</code></li><li>某个接口的派生类型： <code>where 泛型字母 : 接口名</code></li><li>另一个泛型类型本身或者派生类型： <code>where 泛型字母 : 另一个泛型字母</code></li></ol><h3 id="约束的组合使用"><a href="#约束的组合使用" class="headerlink" title="约束的组合使用"></a>约束的组合使用</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span>, <span class="title">new</span>() &#123; &#125;</span><br><span class="line"><span class="comment">// 可以通过逗号组合使用</span></span><br></pre></td></tr></table></figure><h3 id="多个泛型有约束"><a href="#多个泛型有约束" class="headerlink" title="多个泛型有约束"></a>多个泛型有约束</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>, <span class="title">M</span>, <span class="title">E</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span>, <span class="title">new</span>() <span class="keyword">where</span> <span class="title">M</span> : <span class="title">new</span>() <span class="keyword">where</span> <span class="title">E</span> : <span class="title">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="泛型数据结构类"><a href="#泛型数据结构类" class="headerlink" title="泛型数据结构类"></a>泛型数据结构类</h1><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p><strong>概念：</strong> <code>List</code> 本质是一个可变类型的泛型数组，实现了很多方法。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入命名空间 System.Collections.Generic</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.Add(<span class="number">1</span>); <span class="comment">// 单加</span></span><br><span class="line">list.AddRange(list2); <span class="comment">// 批量加</span></span><br><span class="line">list.Insert(<span class="number">0</span>, <span class="number">999</span>); <span class="comment">// 插入</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.Remove(<span class="number">1</span>); <span class="comment">// 删除指定元素</span></span><br><span class="line">list.RemoveAt(<span class="number">0</span>); <span class="comment">// 删除指定位置元素</span></span><br><span class="line">list.Clear(); <span class="comment">// 清空</span></span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list[0] // 直接通过下标查找指定位置元素</span></span><br><span class="line">list.Contains(<span class="number">1</span>); <span class="comment">// 查看元素是否存在</span></span><br><span class="line">list.IndexOf(<span class="number">2</span>); <span class="comment">// 正向查找元素位置</span></span><br><span class="line">list.LastIndexOf(<span class="number">2</span>); <span class="comment">// 反向查找元素位置</span></span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list[<span class="number">0</span>] = <span class="number">99</span>; <span class="comment">// 直接修改</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>List排序</strong></p><ul><li><p>List自带的排序方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">list.Sort(); <span class="comment">// 默认升序</span></span><br></pre></td></tr></table></figure></li><li><p>自定义类的排序</p><p>继承并实现 <code>ICompareble</code> 接口或 <code>ICompareble&lt;T&gt;</code> 接口中的 <code>CompareTo</code> 方法，自定义排序规则，再使用 <code>Sort</code> 方法。</p></li><li><p>通过委托函数进行排序</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Fun</span>(<span class="params">自定义类名 a, 自定义类名 b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 传入的两个对象为列表中的两个对象</span></span><br><span class="line">    <span class="comment">// 进行两两比较</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现排序规则（返回值规则与CompareTo一样）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.Sort(Fun); <span class="comment">// 将排序函数传入Sort执行</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h2><p><strong>概念：</strong> 可以将 <code>Dictionary</code> 理解为拥有泛型的 <code>Hashtable</code> ，它也是基于键的哈希代码组织起来的键值对，键值对类型从 <code>object</code> 变为了可以自己制定的泛型。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入命名空间 System.Collections.Generic</span></span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意不能出现相同键</span></span><br><span class="line">dictionary.Add();</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能通过键删除</span></span><br><span class="line">dictionary.Remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">dictionary.Clear();</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dictionary[4] // 通过键查看值，找不到会返回空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看是否存在</span></span><br><span class="line"><span class="comment">// 根据键检测</span></span><br><span class="line">dictionary.ContainsKey(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 根据值检测</span></span><br><span class="line">dictionary.ContainsValue(<span class="string">&quot;23874&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary[<span class="number">1</span>] = <span class="string">&quot;555&quot;</span>; <span class="comment">// 直接修改</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="LinkedList（链表）"><a href="#LinkedList（链表）" class="headerlink" title="LinkedList（链表）"></a>LinkedList（链表）</h2><p><strong>概念：</strong>  <code>LinkedList</code> 本质是一个可变类型的泛型双向链表</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入命名空间 System.Collections.Generic</span></span><br><span class="line">LinkedList&lt;<span class="built_in">int</span>&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表尾部添加元素</span></span><br><span class="line">linkedList.AddLast(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 在链表头部添加元素</span></span><br><span class="line">linkedList.AddFirst(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 在某一个节点之后添加一个节点</span></span><br><span class="line">linkedList.AddAfter(node, <span class="number">15</span>);</span><br><span class="line"><span class="comment">// 在某一个节点之前添加一个节点</span></span><br><span class="line">linkedList.AddBefore(node, <span class="number">20</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除头节点</span></span><br><span class="line">linkedList.RemoveFirst();</span><br><span class="line"><span class="comment">// 移除尾节点</span></span><br><span class="line">linkedList.RemoveLast();</span><br><span class="line"><span class="comment">// 移除指定元素（不是指定位置的元素）</span></span><br><span class="line">linkedList.Remove(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">linkedList.Clear();</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头节点</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; first = linkedList.First;</span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; last = linkedList.Last;</span><br><span class="line"><span class="comment">// 找到指定值的节点,找不到返回空</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; node = linkedList.Find(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 判断是否存在</span></span><br><span class="line">linkedList.Contains(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先得到节点，再修改值</span></span><br><span class="line">node.Value = <span class="number">8</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="泛型栈和队列"><a href="#泛型栈和队列" class="headerlink" title="泛型栈和队列"></a>泛型栈和队列</h2><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入命名空间 System.Collections.Generic</span></span><br><span class="line"><span class="comment">// 名称不变，加上泛型即可</span></span><br><span class="line">Stack&lt;<span class="built_in">int</span>&gt; stack = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">Queue&lt;<span class="built_in">string</span>&gt; queue = <span class="keyword">new</span> Queue&lt;<span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>使用上与普通栈和队列基本没有区别。</strong></p><hr><h1 id="委托和事件"><a href="#委托和事件" class="headerlink" title="委托和事件"></a>委托和事件</h1><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><strong>委托是函数的容器。</strong> 可以理解为表示函数的变量类型，用来存储和传递函数。委托的本质是一个类，用来定义函数的类型（返回值和参数的类型），不同的函数必须对应和各自“格式”一致的委托。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><strong>关键字：</strong> <code>delegate</code></p><p><strong>语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="built_in">delegate</span> 返回值 委托名(参数列表);</span><br></pre></td></tr></table></figure><p><strong>可以声明在namespace和class语句块中，更多的写在namespace中，访问修饰符默认为public。</strong></p><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyFun1</span>()</span>; <span class="comment">// 声明了一个可以用来存储无参无返回值的函数的容器</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyFun2</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span>()</span> &#123; &#125; <span class="comment">// 无参无返回</span></span><br><span class="line"></span><br><span class="line">MyFun1 f1 = <span class="keyword">new</span> MyFun(Fun); <span class="comment">//装载Fun函数</span></span><br><span class="line">MyFun1 f2 = Fun; <span class="comment">// 另一种实现方法</span></span><br><span class="line"></span><br><span class="line">f1.Invoke(); <span class="comment">// 调用委托</span></span><br><span class="line">f2(); <span class="comment">// 另一种调用方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Fun2</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123; <span class="keyword">return</span> x; &#125; <span class="comment">// 有参有返回</span></span><br><span class="line"></span><br><span class="line">MyFun2 ff1 = Fun2;</span><br><span class="line">ff1(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>委托常用在：</p><ul><li>作为类的成员</li><li>作为函数的参数</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MyFun1 fun1;</span><br><span class="line">    <span class="keyword">public</span> MyFun2 fun2;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">MyFun1 fun1, MyFun2 Fun2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        fun1();</span><br><span class="line">        fun2(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多播委托（存储多个函数）"><a href="#多播委托（存储多个函数）" class="headerlink" title="多播委托（存储多个函数）"></a>多播委托（存储多个函数）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyFun1 f1 = Fun;</span><br><span class="line"></span><br><span class="line">f1 += Fun; <span class="comment">// 存了两个Fun函数</span></span><br><span class="line">f1 += Funa;</span><br><span class="line">f1 += Funb; <span class="comment">// 存储多个函数</span></span><br><span class="line"></span><br><span class="line">f1(); <span class="comment">// 调用委托时全部执行（按添加顺序）</span></span><br><span class="line"></span><br><span class="line">f1 -= FUn; <span class="comment">// 从f1委托中移除Fun函数</span></span><br><span class="line"></span><br><span class="line">f1 = <span class="literal">null</span>; <span class="comment">// 相当于清空委托 </span></span><br></pre></td></tr></table></figure><h3 id="系统定义好的委托"><a href="#系统定义好的委托" class="headerlink" title="系统定义好的委托"></a>系统定义好的委托</h3><p>使用系统自带委托，需要引用 <code>System</code> 命名空间。</p><p><strong>Action</strong></p><p>一个无参无返回的委托。</p><p><strong>Func&lt;out&gt;</strong></p><p>可以指定返回值类型的泛型委托。</p><p><strong>Action&lt;in…&gt;</strong></p><p>可以传n个参数的委托，系统提供了1到16个参数的委托。</p><p><strong>Func&lt;in…, out&gt;</strong></p><p>可以传n个参数的有返回值的委托，系统也提供了1到16个参数的写法。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>事件是一种特殊的变量类型。事件是基于委托的存在，是委托的安全包裹，让委托的使用更有安全性。</p><h3 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h3><p>委托怎么用，事件就怎么用。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">event</span> 委托类型 时间名;</span><br></pre></td></tr></table></figure><p><strong>与委托的区别：</strong></p><ul><li>事件只能作为成员存在于类和接口以及结构体中</li><li>事件不能在类的外部赋值</li><li>事件不能在类的外部调用</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 委托成员变量</span></span><br><span class="line">    <span class="keyword">public</span> Action myFun;</span><br><span class="line">    <span class="comment">// 事件成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action myEvent;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 事件的使用与委托一样</span></span><br><span class="line">        myFun = TestFun;</span><br><span class="line">        myFun += TestFun;</span><br><span class="line">        myFun();</span><br><span class="line">        myFun.Invoke();</span><br><span class="line">        </span><br><span class="line">        myEvent = TestFun;</span><br><span class="line">        myEvent += TestFun;</span><br><span class="line">        myEvent();</span><br><span class="line">        myEvent.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托可以在外部赋值</span></span><br><span class="line">t.myFun = <span class="literal">null</span>;</span><br><span class="line">t.myFun = TestFun;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件不能在外部赋值，但可以添加和移除记录的函数</span></span><br><span class="line"><span class="comment">// t.myEvent = TestFun;</span></span><br><span class="line">t.myEvent += TestFun;</span><br><span class="line">t.myEvent -= TestFun;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托可以在外部调用，事件不能在外面调用</span></span><br><span class="line">t.myFun();</span><br></pre></td></tr></table></figure><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ol><li>防止外部随意置空委托</li><li>防止外部随意调用委托</li><li>事件相当于对委托进行了一次封装，让其更加安全</li></ol><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>匿名函数，就是没有名字的函数。匿名函数的使用主要是配合委托和事件进行使用，脱离委托和事件一般不会用到匿名函数。</p><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delegate</span> (参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 函数逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h3><p>在函数中传递委托参数时和委托或事件赋值时使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Action a = <span class="built_in">delegate</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我是匿名函数&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">a += <span class="built_in">delegate</span> () &#123; <span class="comment">/* 函数逻辑 */</span> &#125;;</span><br><span class="line"></span><br><span class="line">Action&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; b = <span class="built_in">delegate</span> (<span class="built_in">int</span> x, <span class="built_in">string</span> str) &#123; <span class="comment">/* 函数逻辑 */</span> &#125;; <span class="comment">// 有参</span></span><br><span class="line"></span><br><span class="line">Func&lt;<span class="built_in">string</span>&gt; c = <span class="built_in">delegate</span> () &#123; <span class="keyword">return</span> <span class="string">&quot;123&quot;</span> &#125;; <span class="comment">// 有返回</span></span><br></pre></td></tr></table></figure><p>作为函数参数传递或作为函数返回值使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Action action;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 作为参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun1</span>(<span class="params"><span class="built_in">int</span> a, Action fun</span>)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 作为返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">Fun2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">delegate</span> () &#123;</span><br><span class="line">            <span class="comment">// 函数逻辑</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数传递</span></span><br><span class="line">t.Fun1(<span class="number">20</span>, <span class="built_in">delegate</span> () &#123;</span><br><span class="line">    <span class="comment">// 函数逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line">Action ac = t.Fun2(); <span class="comment">// 存起来</span></span><br><span class="line">t.Fun2()(); <span class="comment">// 直接调用</span></span><br></pre></td></tr></table></figure><h3 id="匿名函数的缺点"><a href="#匿名函数的缺点" class="headerlink" title="匿名函数的缺点"></a>匿名函数的缺点</h3><p>因为没有名字，所以添加到委托或事件中后不记录无法单独移除。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p>lambda表达式可以理解为匿名函数的简写，它除了写法不同外，使用上和匿名函数一模一样，都是配合委托或事件使用的。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用-6"><a href="#使用-6" class="headerlink" title="使用"></a>使用</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Action a = () =&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line">Action&lt;<span class="built_in">int</span>&gt; b = (<span class="built_in">int</span> x) =&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>参数类型也可省略，与委托和事件一致</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; a = <span class="literal">null</span>;</span><br><span class="line">a += (str, x) =&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>大括号和小括号也可省略，省略大括号默认是返回值且只有一行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; a = (x) =&gt; &#123; <span class="keyword">return</span> x * <span class="number">5</span>; &#125;; <span class="comment">// 有返回值</span></span><br><span class="line">a += x =&gt; x * <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>内层的函数可以引用包含在它外层的函数的变量，即使外层函数的执行已经终止。</p><p>注：该变量提供的值并非变量创建时的值，而是在父函数范围内的最终值。 </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action action;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里就形成了闭包</span></span><br><span class="line">        <span class="comment">// 因为当构造函数执行完毕时，其中声明的临时变量value的生命周期被改变了</span></span><br><span class="line">        action = () =&gt; &#123;</span><br><span class="line">            Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="协变逆变"><a href="#协变逆变" class="headerlink" title="协变逆变"></a>协变逆变</h1><h2 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h2><p><strong>协变：</strong> 和谐的变化，自然的变化。例如因为里氏替换原则，所以子类变父类是和谐的。</p><p><strong>逆变：</strong> 逆常规的变化，不正常的变化。例如父类变子类是不和谐的。</p><p>逆变和协变是用来修饰泛型的，关键字：</p><ul><li>协变： <code>out</code></li><li>逆变： <code>in</code></li></ul><p>是用于在泛型中修饰泛型字母的，只有泛型接口和泛型委托能使用。</p><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p><strong>返回值和参数：</strong></p><p>用 <code>out</code> 修饰的泛型只能作为返回值，用 <code>in</code> 修饰的泛型只能作为参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">TestOut</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TestIn</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;()</span>;</span><br></pre></td></tr></table></figure><p><strong>结合里氏替换原则：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协变 父类总是能被子类替换</span></span><br><span class="line">TestOut&lt;Son&gt; os = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Son();</span><br><span class="line">&#125;;</span><br><span class="line">TestOut&lt;Father&gt; of = os;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆变 父类总是能被子类替换</span></span><br><span class="line">TestIn&lt;Father&gt; iF = <span class="keyword">value</span> =&gt; &#123; &#125;;</span><br><span class="line">TestIn&lt;Son&gt; iS = iF;</span><br><span class="line">iS(<span class="keyword">new</span> Son()); <span class="comment">// 实际上调用的是iF</span></span><br></pre></td></tr></table></figure><hr><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><a href="https://www.flashfish777.cn/posts/fdbe57b8.html#%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">blog</a></p><h2 id="相关语法"><a href="#相关语法" class="headerlink" title="相关语法"></a>相关语法</h2><p>C#提供了线程类 <code>Tread</code> ，需要引用命名空间 <code>System.Threading</code> 使用。</p><p><strong>声明一个线程：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread类重载了四种构造函数，最常用的需要传入一个无参无返回委托（或函数）</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(NewThreadFun);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NewThreadFun</span>()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p><strong>启动线程：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.Start();</span><br></pre></td></tr></table></figure><p><strong>设置为后台线程：</strong></p><p>声明的线程默认为前台线程，当前台线程都结束的时候整个程序才会结束，即使还有后台线程正在运行。后台线程不会防止应用程序的进程被终止掉，因此如果有线程没有设置为后台线程，此线程还未结束的话，可能导致进程无法正常关闭。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.IsBackground = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><strong>关闭释放一个线程：</strong></p><p>如果开启的线程不是死循环，是能够结束的逻辑，那么不用刻意的去关闭它。</p><p>如果想要终止一个线程，可以通过线程提供的方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.Abort(); <span class="comment">// 终止线程</span></span><br><span class="line">t = <span class="literal">null</span>; <span class="comment">// 置空（GC自动回收）</span></span><br></pre></td></tr></table></figure><p><strong>线程休眠：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tread.Sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 线程类的静态函数，让线程休眠n毫秒再继续执行</span></span><br><span class="line"><span class="comment">// 在哪个线程内部执行休眠的就是哪个线程</span></span><br></pre></td></tr></table></figure><h2 id="线程之间共享数据"><a href="#线程之间共享数据" class="headerlink" title="线程之间共享数据"></a>线程之间共享数据</h2><p>多个线程使用的内存是共享的，都属于该应用程序（进程），所以要注意，当多线程同时操作同一片内存区域时可能会出现问题，可以通过加锁的形式避免问题。</p><p>关键字： <code>lock</code></p><p>原理：当我们在多个线程当中想要访问同样的东西进行逻辑处理时，为了避免不必要的逻辑顺序执行的差错，可以使用 <code>lock</code> 锁避免同时执行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="keyword">lock</span>( obj ) <span class="comment">// 需要传入一个引用类型变量，这里以obj为例</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 语句...</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    Console.WriteLine(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">lock</span>( obj )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 语句...</span></span><br><span class="line">    a = <span class="number">99</span>;</span><br><span class="line">    Console.WriteLine(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当程序执行到 <code>lock</code> 语句块时，会先检测传入的引用类型变量，如果该变量（ <code>obj</code> ）被锁住了，程序就会一直等到 <code>obj</code> 解锁之后再运行 <code>lock</code> 语句块中的逻辑；相反，如果 <code>obj</code> 没被锁，程序就会执行 <code>lock</code> 语句块中的逻辑，同时将 <code>obj</code> 锁住，在逻辑执行完毕后解锁 <code>obj</code> 。</p><h2 id="多线程的意义"><a href="#多线程的意义" class="headerlink" title="多线程的意义"></a>多线程的意义</h2><p>多线程可以用来处理一些复杂耗时的逻辑，比如寻路、网络通信等等，可以专门开一个线程异步处理逻辑，避免卡顿。</p><hr><h1 id="预处理器指令"><a href="#预处理器指令" class="headerlink" title="预处理器指令"></a>预处理器指令</h1><h2 id="什么是预处理器指令"><a href="#什么是预处理器指令" class="headerlink" title="什么是预处理器指令"></a>什么是预处理器指令</h2><p><strong>预处理器指令是指导编译器在实际编译开始之前对信息进行预处理的指令。</strong> 预处理器指令都是以 <code>‘#’</code> 开始，且因为它们不是语句，所以不以分号结束。</p><h2 id="常见的预处理器指令"><a href="#常见的预处理器指令" class="headerlink" title="常见的预处理器指令"></a>常见的预处理器指令</h2><table><thead><tr><th align="left">指令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>#define</code></td><td align="left">定义一个符号，可以用于条件编译。</td></tr><tr><td align="left"><code>#undef</code></td><td align="left">取消定义一个符号。</td></tr><tr><td align="left"><code>#if</code></td><td align="left">开始一个条件编译块，如果符号被定义则包含代码块。</td></tr><tr><td align="left"><code>#elif</code></td><td align="left">如果前面的 <code>#if</code> 或 <code>#elif</code> 条件不满足，且当前条件满足，则包含代码块。</td></tr><tr><td align="left"><code>#else</code></td><td align="left">如果前面的 <code>#if</code> 或 <code>#elif</code> 条件不满足，则包含代码块。</td></tr><tr><td align="left"><code>#endif</code></td><td align="left">结束一个条件编译块。</td></tr><tr><td align="left"><code>#warning</code></td><td align="left">生成编译器警告信息。</td></tr><tr><td align="left"><code>#error</code></td><td align="left">生成编译器错误信息。</td></tr><tr><td align="left"><code>#region</code></td><td align="left">标记一段代码区域，可以在IDE中折叠和展开这段代码，便于代码的组织和阅读。</td></tr><tr><td align="left"><code>#endregion</code></td><td align="left">结束一个代码区域。</td></tr><tr><td align="left"><code>#line</code></td><td align="left">更改编译器输出中的行号和文件名，可以用于调试或生成工具的代码。</td></tr><tr><td align="left"><code>#pragma</code></td><td align="left">用于给编译器发送特殊指令，例如禁用或恢复特定的警告。</td></tr><tr><td align="left"><code>#nullable</code></td><td align="left">控制可空性上下文和注释，允许启用或禁用对可空引用类型的编译器检查。</td></tr></tbody></table><hr><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="程序集"><a href="#程序集" class="headerlink" title="程序集"></a>程序集</h2><p>程序集是经由编译器编译得到的，供进一步编译执行的中间产物，在windows系统中，它一般表现为 <code>.dll（代码库文件）</code> 或 <code>.exe（可执行文件）</code> 的格式。 </p><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>元数据就是用来描述数据的数据。</p><p>例如程序中的类，类中的函数、变量等信息就是程序的元数据。有关程序以及类型的数据被称为元数据，它们保存在程序集中。</p><h2 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h2><p>程序正在运行时，可以查看其他程序集或者自身的元数据。一个运行的程序查看本身或者其他程序的元数据的行为就叫做反射。</p><h2 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h2><p>因为反射可以在程序编译后获得信息，所以它提高了程序的拓展性和灵活性。</p><ol><li>程序运行时得到所有元数据，包括元数据的特性</li><li>程序运行时实例化对象，操作对象</li><li>程序运行时创建对象，用这些对象执行任务</li></ol><h2 id="相关语法-1"><a href="#相关语法-1" class="headerlink" title="相关语法"></a>相关语法</h2><p>这里先放一个例子类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">string</span> str</span>) : <span class="title">this</span>(<span class="params">i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">string</span> str</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Type类"><a href="#Type类" class="headerlink" title="Type类"></a>Type类</h3><p><code>Type（类的信息类）</code> 是反射功能的基础，它是访问元数据的主要方式。使用 <code>Type</code> 的成员获取有关类型声明的信息，有关类型的成员（如构造函数、方法、字段、属性和类的事件）。</p><p><strong>获取Type：</strong></p><ol><li><p><code>object</code> 类中的 <code>GetType()</code> 方法可以获取对象的Type：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">42</span>;</span><br><span class="line">Type type = a.GetType();</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>typeof</code> 关键字传入类名，也可以等到对象的Type：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type type = <span class="keyword">typeof</span>(Test);</span><br></pre></td></tr></table></figure></li><li><p>通过类的名字也可以获取类型（注意类名必须包含命名空间，不然找不到）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type type = Type.GetType(<span class="string">&quot;System.Int32&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p><strong>得到类的程序集信息：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(type.Assembly);</span><br></pre></td></tr></table></figure><p><strong>获取类中的所有公共成员：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先得到Type</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span><br><span class="line"><span class="comment">// 然后得到所有公共成员</span></span><br><span class="line"><span class="comment">// 需要引用命名空间 System.Reflection</span></span><br><span class="line">MemberInfo[] infos = t.GetMembers();</span><br></pre></td></tr></table></figure><p><strong>获取类的公共构造函数并调用：</strong></p><ol><li><p>获取所有构造函数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConstructorInfo[] ctors = t.GetConstructors();</span><br></pre></td></tr></table></figure></li><li><p>获取其中一个构造函数并执行</p><p>得构造函数传入Type数组，数组中内容按顺序是参数类型；</p><p>执行构造函数传入object数组，表示按顺序传入的参数。</p><ol><li><p>得到无参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConstructorInfo info = t.GetConstructor(<span class="keyword">new</span> Type[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>执行无参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造没有参数需要传null，该方法会返回object对象</span></span><br><span class="line">Test test = info.Invoke(<span class="literal">null</span>) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure></li><li><p>得到有参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConstructorInfo info = t.GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br><span class="line"><span class="comment">// 获取只有一个int类型参数的构造函数</span></span><br><span class="line">ConstructorInfo info = t.GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">typeof</span>(<span class="built_in">string</span>) &#125;);</span><br><span class="line"><span class="comment">// 获取两个参数的构造函数</span></span><br></pre></td></tr></table></figure><p>执行有参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test test1 = info.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">88</span> &#125;) <span class="keyword">as</span> Test;</span><br><span class="line">Test test2 = info.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">88</span>, <span class="string">&quot;Hello&quot;</span>&#125;) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><strong>获取类的公共成员变量：</strong></p><ol><li><p>得到所有成员变量：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FieldInfo[] fieldInfos = t.GetFields();</span><br></pre></td></tr></table></figure></li><li><p>得到指定名称的公共成员变量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FieldInfo infoJ = t.GetField(<span class="string">&quot;j&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过反射获取和设置对象的值</p><ol><li><p>通过反射获取对象的某个变量的值</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line">test.j = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(infoJ.GetValue(test));</span><br></pre></td></tr></table></figure></li><li><p>通过反射设置指定对象的某个变量的值</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infoJ.SetValue(test, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><strong>获取类的公共成员方法：</strong></p><ol><li><p>得到所有成员方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodInfo[] methods = t.GetMethods();</span><br></pre></td></tr></table></figure></li><li><p>获取一个成员方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果存在方法重载，用Type数组表示参数类型</span></span><br><span class="line">MethodInfo method1 = t.GetMethod(<span class="string">&quot;Speak&quot;</span>, <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">typeof</span>(<span class="built_in">string</span>) &#125;);</span><br><span class="line">MethodInfo method2 = t.GetMethod(<span class="string">&quot;Speak&quot;</span>, <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br></pre></td></tr></table></figure></li><li><p>调用方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数相当于是那个对象要执行这个成员方法</span></span><br><span class="line"><span class="comment">// 如果是静态方法，第一个参数传null即可</span></span><br><span class="line">method1.Invoke(test, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">1</span>, <span class="string">&quot;123&quot;</span> &#125;);</span><br><span class="line">method2.Invoke(test, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure></li></ol><p><strong>其他：</strong></p><ul><li>得枚举： <code>GetEnumName</code> 、 <code>GetEnumNames</code></li><li>得事件： <code>GetEvent</code> 、 <code>GetEvents</code></li><li>得接口： <code>GetInterface</code> 、 <code>GetInterfaces</code></li><li>得属性： <code>GetProperty</code> 、 <code>GetPropertys</code></li></ul><h3 id="Assembly类"><a href="#Assembly类" class="headerlink" title="Assembly类"></a>Assembly类</h3><p>程序集类。主要用来加载其他程序集，加载后才能用Type来使用其他程序集的信息，如果想要使用不是当前程序集的内容，需要先加载程序集。比如 <code>dll（库文件）</code> ，简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。</p><p>三种加载程序集的函数：</p><ul><li><p>一般用来加载在同一文件下的其他程序集</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assembly assembly1 = Assembly.Load(<span class="string">&quot;程序集名称&quot;</span>)；</span><br></pre></td></tr></table></figure></li><li><p>一般用来加载不在同一文件下的其他程序集</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Assembly assembly2 = Assembly.LoadFrom(<span class="string">&quot;包含程序集清单的文件的名称或路径&quot;</span>);</span><br><span class="line">Assembly assembly3 = Assembly.LoadFile(<span class="string">&quot;要加载的文件的完全限定路径&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先加载一个指定程序集</span></span><br><span class="line">Assembly assembly Assembly.LoadFrom(<span class="string">&quot;...&quot;</span>);</span><br><span class="line"><span class="comment">// 获取所有Type</span></span><br><span class="line">Type[] types = assembly.GetTypes();</span><br><span class="line"><span class="comment">// 加载程序集中的一个类对象，之后才能使用反射</span></span><br><span class="line">Type icon = assembly.GetType(<span class="string">&quot;...&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Activator类"><a href="#Activator类" class="headerlink" title="Activator类"></a>Activator类</h3><p>实例化对象的类，用于将Type对象快捷实例化为对象。</p><ol><li><p>无参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span><br><span class="line">Test testObj = Activator.CreateInstance(t) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure></li><li><p>有参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testObj = Activator.CreateInstance(t, <span class="number">99</span>) <span class="keyword">as</span> Test; <span class="comment">// 一个参数的</span></span><br><span class="line">testObj = Activator.CreateInstance(t, <span class="number">99</span>, <span class="string">&quot;123&quot;</span>) <span class="keyword">as</span> Test; <span class="comment">// 两个参数的</span></span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h2><p>特性是允许我们向程序的程序集添加元数据的语言结构，它是用于保存程序结构信息的某种特殊类型的类。特性提供功能强大的方法以将声明信息与C#代码（类型、方法、属性等）相关联。特性与程序实体关联后，即可在运行时使用反射查询特性信息。特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集中，它可以放置在几乎所有的声明中（类、变量、函数等等）。</p><p><strong>简而言之：特性本质上是个类，我们可以利用特性类为元数据添加额外信息。比如一个类、成员变量、成员方法等等为它们添加更多的额外信息，之后可以通过反射来获取这些额外信息。</strong></p><h2 id="自定义特性"><a href="#自定义特性" class="headerlink" title="自定义特性"></a>自定义特性</h2><p>声明一个类继承特性基类 <code>Attribute</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyTestAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 根据需求来写特性中的成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> info;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestAttribute</span>(<span class="params"><span class="built_in">string</span> info</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用特性"><a href="#使用特性" class="headerlink" title="使用特性"></a>使用特性</h2><p>基本语法： <code>[特性名(参数列表)]</code> </p><p>本质上就是在调用特性类的构造函数，写在类、函数、变量上一行，表示它们具有该特性信息。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MyTest(<span class="string">&quot;这是一个类&quot;</span>)</span>] <span class="comment">// 特性名中的Attribute系统会默认省略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可以加到成员变量前</span></span><br><span class="line">    [<span class="meta">MyTest(<span class="string">&quot;这是一个成员变量&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以加到函数前</span></span><br><span class="line">    [<span class="meta">MyTest(<span class="string">&quot;这是一个函数&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 甚至可以加到函数参数前</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun2</span>(<span class="params"> [MyTest(<span class="string">&quot;这是一个函数参数&quot;</span></span>)]<span class="built_in">int</span> x )</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限制特性使用范围"><a href="#限制特性使用范围" class="headerlink" title="限制特性使用范围"></a>限制特性使用范围</h2><p>通过为特性类加特性限制其使用范围</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)</span>]</span><br><span class="line"><span class="comment">// 参数一：AttributeTargets —— 特性能够用在哪些地方</span></span><br><span class="line"><span class="comment">// 参数二：AllowMultiple —— 是否允许多个特性实例用在同一个目标上</span></span><br><span class="line"><span class="comment">// 参数三：Inherited —— 特性是否能被派生类和重写成员继承</span></span><br></pre></td></tr></table></figure><h2 id="系统自带特性"><a href="#系统自带特性" class="headerlink" title="系统自带特性"></a>系统自带特性</h2><h3 id="过时特性"><a href="#过时特性" class="headerlink" title="过时特性"></a>过时特性</h3><p><strong>关键字：</strong> <code>Obsolete</code> 特性</p><p>用于提示用户使用的方法等成员已经过时，建议使用新方法。一般加在函数前的特性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数一：调用过时方法时提示的内容</span></span><br><span class="line"><span class="comment">// 参数二：是否禁止调用该方法（true：报错 false：仅警告）</span></span><br><span class="line">[<span class="meta">Obsolete(<span class="string">&quot;Speak方法过时了，建议使用新的方法&quot;</span>， false)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用者信息特性"><a href="#调用者信息特性" class="headerlink" title="调用者信息特性"></a>调用者信息特性</h3><p>使用时需要引用命名空间 <code>System.Runtime.CompilerServices</code> ，一般作为参数的特性。</p><ul><li>获取哪个文件调用： <code>CallerFilePath</code> 特性</li><li>获取哪一行调用： <code>CallerLineNumber</code> 特性</li><li>获取哪个函数调用： <code>CallerMemberName</code> 特性</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpeakCaller</span>(<span class="params"><span class="built_in">string</span> str, [CallerFilePath]<span class="built_in">string</span> fileName = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       [CallerLineNumber]<span class="built_in">int</span> line = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                                    [CallerMemberName]<span class="built_in">string</span> memberName = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(str);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用的文件是&quot;</span> + fileName);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用的行数是&quot;</span> + line);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用的方法名是&quot;</span> + memberName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件编译特性"><a href="#条件编译特性" class="headerlink" title="条件编译特性"></a>条件编译特性</h3><p><strong>关键字：</strong> <code>Conditional</code> 特性</p><p>它会和预处理指令 <code>#define</code> 配合使用，需要引用命名空间 <code>System.Diagnostics</code> ，主要可以用在一些调试代码上（有时想执行有时不想执行的代码）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#defiine Fun</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">Conditional(<span class="string">&quot;Fun&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">Fun(); <span class="comment">// 加了这个特性函数才会执行</span></span><br></pre></td></tr></table></figure><h3 id="外部dll包函数特性"><a href="#外部dll包函数特性" class="headerlink" title="外部dll包函数特性"></a>外部dll包函数特性</h3><p><strong>关键字：</strong> <code>DllImport</code> 特性</p><p>用来标记非 <code>.Net（C#）</code> 的函数，表明该函数在一个外部的DLL中定义。一般用来调用 C 或 C++ 的DLL包写好的方法。使用时需要引用命名空间 <code>System.Runtime.InteropServices</code> 。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">&quot;Test.dll&quot;</span>)</span>] <span class="comment">// 假如用一个Test包中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h2><p><strong>迭代器（iterator）</strong> 又称光标（cursor）是程序设计的软件设计模式。迭代器模式提供一个方法顺序访问一个聚合对象中的各个元素而又不暴露其内部的标识。</p><p>从表面效果上看，迭代器是可以在容器对象（例如链表或数组）上遍历访问的接口，设计人员无需关心容器对象的内存分配的实现细节，可以用 <code>foreach</code> 遍历的类，都是实现了迭代器的。</p><h2 id="标准迭代器的实现方法"><a href="#标准迭代器的实现方法" class="headerlink" title="标准迭代器的实现方法"></a>标准迭代器的实现方法</h2><p><strong>关键接口：</strong> <code>IEnumerator</code> ， <code>IEnumerable</code></p><p><strong>命名空间：</strong> <code>System.Collections</code></p><p>可以通过同时继承 <code>IEnumerator</code> 和 <code>IEnumerable</code> 实现其中的方法。</p><h2 id="用-yield-return-语法糖实现迭代器"><a href="#用-yield-return-语法糖实现迭代器" class="headerlink" title="用 yield return 语法糖实现迭代器"></a>用 yield return 语法糖实现迭代器</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] list;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomList</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// yield 关键字 配合迭代器使用</span></span><br><span class="line">            <span class="comment">// 可以理解为 暂时返回 保留当前状态</span></span><br><span class="line">            <span class="comment">// 一会还会再回来</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用-yield-return-语法糖为泛型类实现迭代器"><a href="#用-yield-return-语法糖为泛型类实现迭代器" class="headerlink" title="用 yield return 语法糖为泛型类实现迭代器"></a>用 yield return 语法糖为泛型类实现迭代器</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span>&lt;<span class="title">T</span>&gt; : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="特殊语法"><a href="#特殊语法" class="headerlink" title="特殊语法"></a>特殊语法</h1><h2 id="var隐式类型"><a href="#var隐式类型" class="headerlink" title="var隐式类型"></a>var隐式类型</h2><p>概念： <code>var</code> 是一种特殊的变量类型，它可以用来表示任意类型的变量。</p><p>注意：</p><ul><li><code>var</code> 不能作为类的成员，只能用于临时变量声明</li><li><code>var</code> 变量必须初始化</li></ul><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><h2 id="设置对象初始值"><a href="#设置对象初始值" class="headerlink" title="设置对象初始值"></a>设置对象初始值</h2><p>概念：声明对象时，可以直接写大括号的形式初始化公共成员变量和属性。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test t1 = <span class="keyword">new</span> Test() &#123; x = <span class="number">1</span>, str = <span class="string">&quot;123&quot;</span>, Name = <span class="string">&quot;xxx&quot;</span> &#125;;</span><br><span class="line">Test t2 = <span class="keyword">new</span> Test() &#123; Name = <span class="string">&quot;yyy&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 先执行构造函数再执行初始化的内容</span></span><br></pre></td></tr></table></figure><h2 id="设置集合初始值"><a href="#设置集合初始值" class="headerlink" title="设置集合初始值"></a>设置集合初始值</h2><p>概念：声明集合对象时也可以通过大括号直接初始化内部属性。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] array1 = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list1 = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">List&lt;Test&gt; list2 = <span class="keyword">new</span> List&lt;Test&gt;() &#123;</span><br><span class="line">    <span class="keyword">new</span> Test(),</span><br><span class="line">    <span class="keyword">new</span> Test() &#123; Name = <span class="string">&quot;xxx&quot;</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Test() &#123; x = <span class="number">1</span>, str = <span class="string">&quot;123&quot;</span>, Name = <span class="string">&quot;yyy&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;() &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="string">&quot;123&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">2</span>, <span class="string">&quot;34655&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">3</span>, <span class="string">&quot;45676&quot;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h2><p>概念：变量可以使用 <code>var</code> 声明为自定义的匿名类型。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> &#123; age = <span class="number">10</span>, money = <span class="number">11</span>, name = <span class="string">&quot;小明&quot;</span> &#125;;</span><br><span class="line">COnsole.WriteLine(v.age);</span><br><span class="line"><span class="comment">// 匿名类型无法声明成员方法</span></span><br></pre></td></tr></table></figure><h2 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h2><p>概念：值类型不能赋值为空，但再声明时在值类型后面加 <code>?</code> 表示这是一个可空类型，就可以赋值为空了。</p><p>示例;</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? c = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="keyword">if</span> (c.HasValue)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全获取可空类型值</span></span><br><span class="line">COnsole.WriteLine(Value.GetValueOrDefault(<span class="number">100</span>));</span><br><span class="line"><span class="comment">// 有值就返回值，空的就返回括号里的参数，无参默认返回该类型的默认值</span></span><br></pre></td></tr></table></figure><p><code>?</code> 还可判断一个对象是否为空：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> o = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (o != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    o.Tostring();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于以上代码 能帮我们自动判断o是否为空</span></span><br><span class="line"><span class="comment">// 如果是null就不会执行，也不会报错</span></span><br><span class="line">o?.Tostring();</span><br></pre></td></tr></table></figure><h2 id="空合并操作符"><a href="#空合并操作符" class="headerlink" title="空合并操作符"></a>空合并操作符</h2><p>概念：空合并操作符 <code>??</code> ，如果左边值为空，就返回右边值，否则返回左边值，只要是可以为空的类型都能使用。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? v = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>? i = v == <span class="literal">null</span> ? <span class="number">100</span> : v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于以上代码</span></span><br><span class="line">i = v ?? <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h2 id="内插字符串"><a href="#内插字符串" class="headerlink" title="内插字符串"></a>内插字符串</h2><p>概念：用 <code>$</code> 来构造字符串，让字符串可以拼接变量。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;你好，<span class="subst">&#123;name&#125;</span>，年龄<span class="subst">&#123;age&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="单句逻辑简略写法"><a href="#单句逻辑简略写法" class="headerlink" title="单句逻辑简略写法"></a>单句逻辑简略写法</h2><p>概念：使用 <code>=&gt;</code> 省略大括号，需要返回值则同时省略 <code>return</code> ，只要是只有一句代码都可以这样用。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        <span class="keyword">set</span> =&gt; sex = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> =&gt; a + b; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;12312321&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>end</p>]]></content>
    
    
    <summary type="html">在学了一段时间Unity后发现C#基础语法还是有些欠缺，所以又去重新学习然后补了这篇笔记...</summary>
    
    
    
    <category term="笔记" scheme="http://www.flashfish777.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C#" scheme="http://www.flashfish777.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity日记：存档系统</title>
    <link href="http://www.flashfish777.cn/posts/a985624f.html"/>
    <id>http://www.flashfish777.cn/posts/a985624f.html</id>
    <published>2024-07-25T22:00:00.000Z</published>
    <updated>2024-07-25T22:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在游戏开发的世界中，存档系统是不可或缺的一部分，它让玩家的游戏进度得以保存，增强了游戏的可玩性和用户体验。今天分享一下如何在Unity中实现游戏存档的功能，特别是<strong>PlayerPrefs</strong>和<strong>JSON存档</strong>这两种常见方式，帮助开发者理解它们的适用场景、优缺点以及如何有效使用它们来构建强大的存档机制。</p><p>随着游戏复杂度的提升，存档系统的设计和实现变得尤为重要。合理的存档策略能够显著提升玩家的满意度和忠诚度。然而，Unity自带的PlayerPrefs虽然简单易用，但在处理复杂数据或大量数据时显得力不从心。而JSON作为一种轻量级的数据交换格式，因其易于人阅读和编写，以及良好的跨平台特性，在游戏存档中得到了广泛应用。因此，本文将简单介绍这两种方法，帮助开发者根据项目需求做出最佳选择。</p><p><strong>Unity存档系统的用途</strong>：</p><ul><li><strong>保存游戏进度</strong>：让玩家能够在退出游戏后重新加载之前的游戏状态。</li><li><strong>设置和配置保存</strong>：存储玩家的游戏设置，如音量、难度等。</li><li><strong>成就和解锁内容</strong>：记录玩家的成就和已解锁的内容，作为游戏进度的一部分。</li><li><strong>跨平台同步</strong>：在支持云存档的情况下，实现不同设备间的游戏进度同步。</li></ul><h1 id="PlayerPrefs"><a href="#PlayerPrefs" class="headerlink" title="PlayerPrefs"></a>PlayerPrefs</h1><h2 id="PlayerPrefs存储数据"><a href="#PlayerPrefs存储数据" class="headerlink" title="PlayerPrefs存储数据"></a>PlayerPrefs存储数据</h2><p><code>PlayerPrefs</code>是Unity提供的一个简单的数据持久化系统，用于保存和加载玩家偏好设置和游戏数据。它仅支持存储和检索<code>整型（int）</code>、<code>浮点型（float）</code>和<code>字符串（string）</code>数据。</p><p>Unity的<code>PlayerPrefs</code>是Unity引擎提供的一个用于存储和检索玩家偏好设置和游戏状态数据的简单数据持久化系统。它允许开发者跨会话（即游戏运行之间）保存和加载简单的数据类型，如整型（<code>int</code>）、浮点型（<code>float</code>）和字符串（<code>string</code>）。这些数据通常存储在设备的本地存储中，如注册表（在Windows上）或偏好设置文件（在macOS和iOS上）等，具体取决于目标平台。</p><h2 id="PlayerPrefs的特点"><a href="#PlayerPrefs的特点" class="headerlink" title="PlayerPrefs的特点"></a>PlayerPrefs的特点</h2><ol><li><strong>简单易用</strong>：<code>PlayerPrefs</code> API 非常直观，易于上手。只需几行代码就可以实现数据的保存和加载。</li><li><strong>跨平台</strong>：<code>PlayerPrefs</code> 数据在不同的Unity支持平台上具有高度的可移植性。无论游戏在哪个平台上运行，<code>PlayerPrefs</code> 都能以相同的方式工作。</li><li><strong>限制</strong>：尽管<code>PlayerPrefs</code> 非常方便，但它也有一些限制。首先，它只支持整型、浮点型和字符串数据类型。其次，由于数据存储在一个统一的命名空间中，不同游戏或应用可能会无意中覆盖彼此的<code>PlayerPrefs</code> 数据（尽管这可以通过在键名中包含唯一标识符来避免）。最后，<code>PlayerPrefs</code> 数据的存储量也有限制，虽然这个限制对于大多数用途来说都足够大，但在处理大量数据时可能会成为问题。</li></ol><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>使用简单，无需额外配置。</td><td>数据类型有限，不支持复杂数据结构（如数组、列表、字典等）。</td></tr><tr><td>跨平台兼容性好，适用于大多数Unity支持的平台。</td><td>存储容量有限，不适合存储大量数据。</td></tr><tr><td></td><td>安全性较低，数据容易被用户修改。</td></tr></tbody></table><h2 id="PlayerPrefs的基本用法"><a href="#PlayerPrefs的基本用法" class="headerlink" title="PlayerPrefs的基本用法"></a>PlayerPrefs的基本用法</h2><h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>使用<code>PlayerPrefs.SetInt</code>、<code>PlayerPrefs.SetFloat</code>和<code>PlayerPrefs.SetString</code>等静态方法将数据保存到<code>PlayerPrefs</code>中。调用<code>PlayerPrefs.Save()</code>可以手动保存更改，但通常这不是必需的，因为Unity会在游戏结束时自动保存<code>PlayerPrefs</code>数据。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetInt</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span>; <span class="comment">// key 键 value 值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetFloat</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">float</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.SetInt(<span class="string">&quot;score&quot;</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><h3 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h3><p>使用<code>PlayerPrefs.GetInt</code>、<code>PlayerPrefs.GetFloat</code>和<code>PlayerPrefs.GetString</code>等静态方法从<code>PlayerPrefs</code>中检索数据。这些方法需要一个键名作为参数，并返回与该键名关联的数据。如果指定的键名不存在，则可以提供一个默认值作为第二个参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetInt</span>(<span class="params"><span class="built_in">string</span> key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">GetFloat</span>(<span class="params"><span class="built_in">string</span> key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetString</span>(<span class="params"><span class="built_in">string</span> key</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> highScore = PlayerPrefs.GetInt(<span class="string">&quot;HighScore&quot;</span>, <span class="number">0</span>); <span class="comment">// 如果HighScore不存在，则返回0</span></span><br><span class="line"><span class="built_in">string</span> username = PlayerPrefs.GetString(<span class="string">&quot;Username&quot;</span>, <span class="string">&quot;Guest&quot;</span>); <span class="comment">// 如果Username不存在，则返回&quot;Guest&quot;</span></span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>使用<code>PlayerPrefs.DeleteKey</code>方法可以删除<code>PlayerPrefs</code>中的单个键值对。<code>PlayerPrefs.DeleteAll</code>方法会删除<code>PlayerPrefs</code>中的所有数据。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.DeleteKey(<span class="string">&quot;HighScore&quot;</span>); <span class="comment">// 删除HighScore键值对</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">PlayerPrefs.DeleteAll(); <span class="comment">// 删除所有PlayerPrefs数据，慎用！</span></span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerData</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> playerName; <span class="comment">// 角色名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> playerHealth; <span class="comment">// 角色血量</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 playerPosition; <span class="comment">// 角色位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Score; <span class="comment">// 得分</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        LoadFromPlayerPrefs(); <span class="comment">// 游戏开始时加载调用存储的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当保存并退出按钮被触发时执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveAndBack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        SaveByPlayerPrefs(); <span class="comment">// 保存数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveByPlayerPrefs</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PlayerPrefs.SetString(<span class="string">&quot;PlayerName&quot;</span>, playerName);</span><br><span class="line">        PlayerPrefs.SetFloat(<span class="string">&quot;PlayerHealth&quot;</span>, playerHealth);</span><br><span class="line">        PlayerPrefs.Setint(<span class="string">&quot;Score&quot;</span>, Score);</span><br><span class="line">        PlayerPrefs.SetFloat(<span class="string">&quot;PlayerPo_x&quot;</span>, playerPosition.x);</span><br><span class="line">        PlayerPrefs.SetFloat(<span class="string">&quot;PlayerPo_y&quot;</span>, playerPosition.y);</span><br><span class="line">        PlayerPrefs.SetFloat(<span class="string">&quot;PlayerPo_z&quot;</span>, playerPosition.z);</span><br><span class="line">        PlayerPrefs.Save();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadFromPlayerPrefs</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        playerName = PlayerPrefs.GetString(<span class="string">&quot;PlayerName&quot;</span>, <span class="string">&quot;None&quot;</span>);</span><br><span class="line">        playerHealth = PlayerPrefs.GetFloat(<span class="string">&quot;PlayerHealth&quot;</span>, <span class="number">100f</span>);</span><br><span class="line">        Score = PlayerPrefs.Getint(<span class="string">&quot;Score&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        playerPosition = <span class="keyword">new</span>(PlayerPrefs.GetFloat(<span class="string">&quot;PlayerPo_x&quot;</span>, <span class="number">0f</span>),</span><br><span class="line">                             PlayerPrefs.GetFloat(<span class="string">&quot;PlayerPo_y&quot;</span>, <span class="number">0f</span>), </span><br><span class="line">                             PlayerPrefs.GetFloat(<span class="string">&quot;PlayerPo_z&quot;</span>, <span class="number">0f</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>由于<code>PlayerPrefs</code>数据存储在设备的本地存储中，因此它可能受到设备存储空间或用户隐私设置的影响。</li><li>在使用<code>PlayerPrefs</code>时，建议为键名添加前缀或后缀，以确保它们在不同游戏或应用之间保持唯一性。</li><li>虽然<code>PlayerPrefs</code>提供了基本的数据持久化功能，但对于需要处理复杂数据结构或大量数据的游戏来说，可能需要考虑使用更高级的数据存储解决方案，如数据库或文件系统。</li></ul><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p><strong>PlayerPrefs适合用来存储暂时性数据，如：</strong></p><ul><li>玩家设定偏好</li><li>简单的数据</li><li>游戏原型制作时暂时的存储方案</li></ul><mark class="hl-label orange">总之，PlayerPrefs设计的初衷就不是为了真正的玩家存档而服务的，但它有其存在的理由，如何使用好这个工具，才是我们作为游戏制作者应该掌握的关键。</mark><p><strong>相关资料 -&gt;</strong> <a href="https://docs.unity3d.com/ScriptReference/PlayerPrefs.html">https://docs.unity3d.com/ScriptReference/PlayerPrefs.html</a></p><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p><code>JSON</code>是<code>JavaScript Object Notation（JavaScript对象注释/表示法）</code>的简称，是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成。在Unity中，我们可以通过序列化&#x2F;反序列化对象到JSON字符串的方式来实现存档功能。</p><p><strong>参考资料 -&gt;</strong> <a href="https://www.json.org/json-zh.html">https://www.json.org/json-zh.html</a></p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>JSON是一种基于文本的格式，用于表示数据。它使用键值对来表示对象，使用数组来表示一组值。例如，一个表示玩家的JSON对象可能如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;gold&quot;</span><span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;equipment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;剑&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;武器&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;盾&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;防具&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>支持复杂数据结构，如数组、列表、字典等。</li><li>数据量大小无限制（受限于系统存储空间）。</li><li>安全性较高，可通过加密等手段保护数据。</li><li>跨平台兼容性好，JSON是标准的文本格式，易于在不同平台间交换数据。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>需要编写额外的序列化&#x2F;反序列化代码。</li><li>相对于PlayerPrefs，使用上稍显复杂。</li></ul><h3 id="与PlayerPrefs对比"><a href="#与PlayerPrefs对比" class="headerlink" title="与PlayerPrefs对比"></a>与PlayerPrefs对比</h3><ul><li>JSON更适合存储复杂数据结构和大量数据。</li><li>JSON提供了更高的灵活性和可扩展性。</li><li>在处理简单数据类型和少量数据时，PlayerPrefs可能更便捷。</li></ul><h2 id="JsonUtility"><a href="#JsonUtility" class="headerlink" title="JsonUtility"></a>JsonUtility</h2><p>在Unity中，要将对象保存为JSON字符串，需要对其进行序列化；同样，要从JSON字符串恢复对象，需要对其进行反序列化。Unity提供了<code>JsonUtility</code>类来简化这一过程。</p><ul><li><strong>序列化</strong>：使用<code>JsonUtility.ToJson()</code>方法将对象转换为JSON字符串。</li><li><strong>反序列化</strong>：使用<code>JsonUtility.FromJson&lt;T&gt;()</code>方法将JSON字符串转换回对象。</li></ul><p><img src="https://image.flashfish777.cn/img/post_9_1.jpg"></p><h2 id="使用JsonUtility进行存档"><a href="#使用JsonUtility进行存档" class="headerlink" title="使用JsonUtility进行存档"></a>使用JsonUtility进行存档</h2><h3 id="定义可序列化的类"><a href="#定义可序列化的类" class="headerlink" title="定义可序列化的类"></a>定义可序列化的类</h3><p>在Unity中，只有标记为<code>[Serializable]</code>的类才能被<code>JsonUtility</code>序列化。因此，需要为要存档的数据定义可序列化的类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> level;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> gold;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Equipment&gt; equipment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Equipment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意，并不是所有数据都可以被正常的序列化：</p><p><img src="https://image.flashfish777.cn/img/post_9_2.jpg"></p><p><img src="https://image.flashfish777.cn/img/post_9_3.jpg"></p><p><img src="https://image.flashfish777.cn/img/post_9_4.jpg"></p><h3 id="序列化并保存数据"><a href="#序列化并保存数据" class="headerlink" title="序列化并保存数据"></a>序列化并保存数据</h3><p>在Unity中，可以通过以下步骤将<code>PlayerData</code>对象序列化为JSON字符串，并保存到文件中：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SavePlayerData</span>(<span class="params">PlayerData playerData, <span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将数据序列化</span></span><br><span class="line">    <span class="built_in">string</span> json = JsonUtility.ToJson(playerData);</span><br><span class="line">    <span class="comment">// 获取存储文件地址</span></span><br><span class="line">    <span class="built_in">string</span> filePath = Path.Combine(Application.persistentDataPath, fileName + <span class="string">&quot;.json&quot;</span>);</span><br><span class="line">    <span class="comment">// 将JSON写入文件中</span></span><br><span class="line">    File.WriteAllText(filePath, json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取并反序列化数据"><a href="#读取并反序列化数据" class="headerlink" title="读取并反序列化数据"></a>读取并反序列化数据</h3><p>当需要加载存档时，可以从文件中读取JSON字符串，并使用<code>JsonUtility.FromJson&lt;T&gt;()</code>方法将其反序列化为<code>PlayerData</code>对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PlayerData <span class="title">LoadPlayerData</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取存储文件地址</span></span><br><span class="line">    <span class="built_in">string</span> filePath = Path.Combine(Application.persistentDataPath, fileName + <span class="string">&quot;.json&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断是否有对应文件</span></span><br><span class="line">    <span class="keyword">if</span> (File.Exists(filePath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取JSON字符串</span></span><br><span class="line">        <span class="built_in">string</span> json = File.ReadAllText(filePath);</span><br><span class="line">        <span class="comment">// 将JSON反序列化</span></span><br><span class="line">        PlayerData playerData = JsonUtility.FromJson&lt;PlayerData&gt;(json);</span><br><span class="line">        <span class="keyword">return</span> playerData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有文件打印提示</span></span><br><span class="line">        Debug.LogError(<span class="string">$&quot;File <span class="subst">&#123;filePath&#125;</span> not found!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>首先创建一个公有的静态类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SaveSystemTutorial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SaveSystem</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 存档</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveByJson</span>(<span class="params"><span class="built_in">string</span> saveFileName, <span class="built_in">object</span> data</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> json = JsonUtility.ToJson(data);</span><br><span class="line">            <span class="keyword">var</span> path = Path.Combine(Application.persistentDataPath, saveFileName);</span><br><span class="line">            <span class="comment">/* Application.persistentDataPath用来提供一个存储永久数据的路径，并且</span></span><br><span class="line"><span class="comment">             当我们将游戏打包发布在不同平台上时，这个路径会随着我们发布的平台自动变更 */</span></span><br><span class="line">            </span><br><span class="line">            Debug.Log(<span class="string">$&quot;save data to <span class="subst">&#123;path&#125;</span>.&quot;</span>); <span class="comment">// 这里我们可以输出这个路径找到文件</span></span><br><span class="line"></span><br><span class="line">            File.WriteAllText(path, json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读档</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">LoadFromJson</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> saveFileName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> path = Path.Combine(Application.persistentDataPath, saveFileName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> json = File.ReadAllText(path);</span><br><span class="line">            <span class="keyword">var</span> data = JsonUtility.FromJson&lt;T&gt;(json);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteSaveFile</span>(<span class="params"><span class="built_in">string</span> saveFileName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> path = Path.Combine(Application.persistentDataPath, saveFileName);</span><br><span class="line"></span><br><span class="line">            File.Delete(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再其他脚本中使用<code>SaveSystemTutorial</code>命名空间并实现存储数据函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> SaveSystemTutorial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name; <span class="comment">// 角色名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> health; <span class="comment">// 角色血量</span></span><br><span class="line">       <span class="keyword">public</span> Vector3 position; <span class="comment">// 角色位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> score; <span class="comment">// 得分</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;GameObject&gt; enermy; <span class="comment">// 敌人列表</span></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">System.Serializable</span>]</span><br><span class="line">    <span class="keyword">class</span> <span class="title">SaveData</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> playerName; <span class="comment">// 角色名称</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> playerHealth; <span class="comment">// 角色血量</span></span><br><span class="line">           <span class="keyword">public</span> Vector3 playerPosition; <span class="comment">// 角色位置</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Score; <span class="comment">// 得分</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;GameObject&gt; Enermy; <span class="comment">// 敌人列表</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveAndBack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SaveData data = <span class="keyword">new</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            playerName = name;</span><br><span class="line">            playerHealth = health;</span><br><span class="line">               playerPosition = position;</span><br><span class="line">            Score = score;</span><br><span class="line">            Enermy = enermy;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        SaveSystem.SaveByJson(<span class="string">&quot;player.save&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadData</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取文件地址判断文件是否存在</span></span><br><span class="line">        <span class="keyword">var</span> Path = Application.persistentDataPath + <span class="string">&quot;\\player.save&quot;</span>;</span><br><span class="line">        SaveData data;</span><br><span class="line">        <span class="keyword">if</span> (File.Exists(HistoryPath))</span><br><span class="line">        &#123;</span><br><span class="line">            data = SaveSystem.LoadFromJson&lt;SaveData&gt;(<span class="string">&quot;player.save&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将数据赋回</span></span><br><span class="line">            name = data.playerName;</span><br><span class="line">            health = data.playerHealth;</span><br><span class="line">            position = data.playerPosition;</span><br><span class="line">            score = data.Score;</span><br><span class="line">            enermy = data.Enermy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> Debug.Log(<span class="string">&quot;Not Found!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后通过输出的文件路径就可以找到我们的存档啦：</p><p><img src="https://image.flashfish777.cn/img/post_9_5.jpg"></p><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><strong>数据安全性</strong>：直接以明文形式保存JSON文件可能会带来数据泄露的风险。在需要保护用户数据的情况下，应考虑对JSON数据进行加密。</li><li><strong>跨平台兼容性</strong>：<code>Application.persistentDataPath</code>会自动处理不同平台上的文件路径差异，使得存档系统能够跨平台工作。</li><li><strong>性能考虑</strong>：对于大型游戏或频繁存档的场景，需要关注序列化&#x2F;反序列化操作对性能的影响。</li><li><strong>错误处理</strong>：在文件读写过程中，应添加适当的错误处理逻辑，以应对文件不存在、磁盘空间不足等异常情况。</li></ol><h2 id="使用JSON文件而不是PlayerPrefs的原因"><a href="#使用JSON文件而不是PlayerPrefs的原因" class="headerlink" title="使用JSON文件而不是PlayerPrefs的原因"></a>使用JSON文件而不是PlayerPrefs的原因</h2><p>前面提到过<strong>PlayerPrefs</strong>可以存储字符串类型的数据，而JSON数据实际上就是字符串，所以PlayerPrefs实际上也可以存储JSON数据。</p><p>不建议用PlayerPrefs存JSON的原因主要有以下几点：</p><h3 id="存储效率与灵活性"><a href="#存储效率与灵活性" class="headerlink" title="存储效率与灵活性"></a>存储效率与灵活性</h3><p>PlayerPrefs的存储方式相对简单直接，但这也限制了其存储效率和灵活性。当需要存储大量数据时，PlayerPrefs可能会因为频繁地读写磁盘而导致性能下降。此外，由于PlayerPrefs只支持简单的数据类型，因此在处理复杂数据结构时，往往需要将数据转换为字符串进行存储，这在读取时又需要反序列化回原始数据结构，增加了额外的处理步骤和可能的性能开销。相比之下，直接使用JSON文件或其他数据库系统存储复杂数据，可以更加高效和灵活地管理数据。</p><h3 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h3><p>虽然PlayerPrefs本身在数据安全方面并没有直接的漏洞，但由于其存储的数据类型简单且易于访问，因此如果游戏或应用程序中涉及敏感信息（如用户密码、支付信息等），则不建议使用PlayerPrefs进行存储。此外，由于PlayerPrefs的数据通常存储在用户设备的文件系统中，因此如果设备被恶意软件攻击或用户拥有足够的权限，那么存储在PlayerPrefs中的数据就有可能被非法读取或篡改。对于需要保护用户数据安全的场景，建议使用更加安全的数据存储方案。</p><h3 id="可扩展性和可维护性"><a href="#可扩展性和可维护性" class="headerlink" title="可扩展性和可维护性"></a>可扩展性和可维护性</h3><p>随着游戏或应用程序的不断发展，可能需要存储的数据量也会不断增加，数据结构也会变得更加复杂。如果一直使用PlayerPrefs来存储这些数据，那么随着数据的增加和数据结构的复杂化，代码的可读性、可维护性和可扩展性都会受到影响。相比之下，使用JSON文件或其他数据库系统来存储数据，可以更加方便地管理数据结构和数据变更，提高代码的可读性、可维护性和可扩展性。</p><p>所以，虽然PlayerPrefs在存储简单数据方面具有一定的优势，但在需要处理复杂数据结构、大量数据或敏感信息时，建议使用更加高效、灵活和安全的数据存储方案。对于JSON数据的存储和读取，建议使用Unity内置的JsonUtility类或其他第三方JSON库来实现序列化和反序列化操作，并将数据存储在文件系统或数据库中以便后续管理和使用。</p><h2 id="适用范围-1"><a href="#适用范围-1" class="headerlink" title="适用范围"></a>适用范围</h2><p><strong>联网</strong></p><ul><li>优秀的网络数据交换载体</li><li>云存档</li></ul><p><strong>本地存储</strong></p><ul><li>非敏感而需要大量读取的数据，如：Mod数据</li><li>玩家的偏好设置等</li></ul><p><strong>相关资料 -&gt;</strong> <a href="https://docs.unity3d.com/ScriptReference/JsonUtility.html">https://docs.unity3d.com/ScriptReference/JsonUtility.html</a></p><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>通过本文章的介绍，我们深入了解了Unity中的两种主要存档方式——PlayerPrefs和JSON存档。每种方法都有其独特的优势和适用场景。开发者应根据项目的具体需求、数据复杂度以及目标平台的特性来选择最合适的存档策略。无论是追求简单快捷的PlayerPrefs，还是注重数据复杂性和安全性的JSON存档，都能在Unity中找到实现方法，为玩家带来更加流畅和丰富的游戏体验。</p><p>—end—</p>]]></content>
    
    
    <summary type="html">一个完美的存档系统对一款小游戏来说无异于是一种锦上添花的存在，本文将介绍关于Unity PlayerPrefs和JSON存档的实现，以及它们的优缺点...</summary>
    
    
    
    <category term="知识分享" scheme="http://www.flashfish777.cn/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="游戏开发" scheme="http://www.flashfish777.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="Unity" scheme="http://www.flashfish777.cn/tags/Unity/"/>
    
    <category term="C#" scheme="http://www.flashfish777.cn/tags/C/"/>
    
    <category term="数据持久化" scheme="http://www.flashfish777.cn/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Unity日记：场景切换与并发编程</title>
    <link href="http://www.flashfish777.cn/posts/fdbe57b8.html"/>
    <id>http://www.flashfish777.cn/posts/fdbe57b8.html</id>
    <published>2024-07-10T22:00:00.000Z</published>
    <updated>2024-07-10T22:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity场景切换"><a href="#Unity场景切换" class="headerlink" title="Unity场景切换"></a>Unity场景切换</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在游戏开发中，场景切换，这一看似简单的操作，实则蕴含着提升游戏体验、增强故事叙述能力的无限潜力。今天，就让我们一同踏上这场Unity中场景切换的魔法之旅，揭开那些让游戏世界流畅衔接、引人入胜的秘密。</p><p>在快节奏的游戏开发中，场景切换往往被视为一个“必经之路”，而非核心功能。然而，正是这些看似不起眼的环节，构成了玩家游戏体验的重要组成部分。一个精心设计的场景切换不仅能有效减少加载时间带来的等待感，还能通过视觉和情感的引导，加深玩家对游戏世界的沉浸感。更重要的是，它还能作为游戏叙事的一部分，引导玩家逐步揭开故事的真相，体验更加丰富和深刻的游戏内容。想象一下，你的玩家正在紧张刺激的战斗后，通过一段华丽的过渡动画，瞬间穿越到宁静祥和的村庄；或者是在解开谜题后，随着一阵悠扬的音乐，眼前的景象逐渐模糊，再清晰时已是另一个充满挑战的关卡。这样的场景切换，不仅让玩家感受到游戏的连贯性和惊喜，更激发了他们对未知世界的好奇心和探索欲。而这，正是我们今天要探讨的——如何在Unity中利用场景切换的魔法，为你的游戏增添无限魅力。</p><p>撰写一篇关于在Unity中进行场景切换的博客文章是一个很好的主意，因为这对于开发任何类型的游戏或应用来说都是一项基础且重要的技能。以下是一个结构化的博客文章大纲，以及一些关键内容的建议，帮助你撰写这篇博客。</p><h2 id="什么是场景（Scene）？"><a href="#什么是场景（Scene）？" class="headerlink" title="什么是场景（Scene）？"></a>什么是场景（Scene）？</h2><p>在Unity中，**场景（Scene）**是构建游戏世界的基石。所有GameObject都在场景中，它包含了游戏运行时所需的所有元素，如3D模型、灯光、摄像机、UI界面、音效以及脚本逻辑等。每个场景都代表了一个独立的游戏环境或关卡，玩家在其中进行互动和探索。Unity编辑器提供了直观的工具来创建、编辑和管理多个场景。开发者可以轻松地添加、删除或修改场景中的元素，并通过场景管理器来组织和管理这些场景文件。游戏通常由多个场景组成，这些场景通过场景切换相互连接，共同构成了完整的游戏流程。场景切换不仅是技术上的实现，更是游戏叙事和玩家体验的重要组成部分。</p><p><img src="https://image.flashfish777.cn/img/post_8_1.jpg"></p><h2 id="如何切换场景"><a href="#如何切换场景" class="headerlink" title="如何切换场景"></a>如何切换场景</h2><h3 id="SceneManager类"><a href="#SceneManager类" class="headerlink" title="SceneManager类"></a>SceneManager类</h3><p><code>SceneManager</code>是Unity提供的一个用于<strong>管理场景加载、卸载和切换</strong>的类。它提供了丰富的API来支持场景的各种操作。</p><p>1.首先打开菜单栏的<code>File</code>-&gt; <code>Build Settings</code>，确保你的场景已经添加到这里，记住对应场景的序号。</p><p><img src="https://image.flashfish777.cn/img/post_8_2.jpg"></p><p>2.<code>SceneManager</code>类提供了<code>SceneManager.LoadScene</code>方法实现场景的加载与切换，以下是代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;  </span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement; <span class="comment">// 确保使用了UnityEngine.SceneManagement命名空间</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneSwitcher</span> : <span class="title">MonoBehaviour</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 场景切换函数，该函数可以通过按钮或在任何需要的情况下被调用，实现场景转换  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SceneChange</span>()</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 使用SceneManager的LoadScene方法来加载新场景  </span></span><br><span class="line">        <span class="comment">// 第一个参数是场景名称</span></span><br><span class="line">        <span class="comment">// 第二个参数是加载模式</span></span><br><span class="line">        SceneManager.LoadScene(<span class="string">&quot;nextScene&quot;</span>, LoadSceneMode.Single);</span><br><span class="line">        <span class="comment">// SceneManager.LoadScene(1); // 第一个参数可直接使用场景名称，也可使用对应的场景序号</span></span><br><span class="line">        <span class="comment">// 无论使用的是场景名称还是序号，场景都必须要被添加在Build中</span></span><br><span class="line">        <span class="comment">// 第二个参数一般情况下省略</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.函数被调用时，游戏会<strong>暂停当前场景的所有操作</strong>，等待新场景完全加载到内存中并激活后，再继续执行后续操作。这个过程是<strong>阻塞的</strong>，即<strong>直到新场景加载完成，游戏才会继续运行</strong>。这个过程，也被称为同步加载。</p><h3 id="同步加载"><a href="#同步加载" class="headerlink" title="同步加载"></a>同步加载</h3><p><strong>过程：</strong></p><ol><li><strong>触发加载</strong>：通过调用场景加载的方法，并传入要加载的场景名称或索引作为参数，来触发场景的加载过程。</li><li><strong>等待加载</strong>：在加载过程中，游戏会暂停当前场景的所有操作（如渲染、物理计算、用户输入响应等），直到新场景完全加载到内存中。</li><li><strong>场景切换</strong>：当新场景加载完成后，Unity会销毁当前场景（如果加载模式为Single），并激活新场景，然后游戏继续执行后续操作。</li></ol><p>可如果我们的目标场景数据十分庞大呢？这意味着我们在<strong>等待加载</strong>的过程中就会出现我们都遇到过的事情，那就是卡顿。我们需要等很长时间来加载目标场景的数据。这时如果我们使用同步加载，在这期间游戏处于暂停中，玩家很可能以为自己卡了，大大降低体验度。<strong>使用异步加载就可以解决这个问题。</strong></p><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p><strong>异步加载</strong>中加载新场景的行为是在<strong>后台线程</strong>中进行的，不影响主线程（即游戏当前场景）的运行。它的过程为<code>触发加载</code> -&gt; <code>后台加载</code> -&gt;  <code>场景切换</code> </p><p>使用了异步加载，我们就可以在等待加载的过程中播放一些其他操作，如待机画面、加载进度条等。</p><p>以下是使用异步加载进行场景切换并添加加载进度条与点击继续的操作示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;  </span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI; <span class="comment">// 引用UI相关命名空间</span></span><br><span class="line"><span class="keyword">using</span> TMPro;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneLoader</span> : <span class="title">MonoBehaviour</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> GameObject loadScreen; <span class="comment">// 加载界面Panel</span></span><br><span class="line">    <span class="keyword">public</span> Slider slider; <span class="comment">// 加载界面进度条</span></span><br><span class="line">    <span class="keyword">public</span> TextMeshProUGUI text; <span class="comment">// 进度文本</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadScene</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(Loadlevel()); <span class="comment">// 使用协程</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 异步加载场景，控制进度条</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Loadlevel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        loadScreen.SetActive(<span class="literal">true</span>); <span class="comment">// 显示加载界面</span></span><br><span class="line"></span><br><span class="line">        AsyncOperation operation = SceneManager.LoadSceneAsync(<span class="string">&quot;MainScene&quot;</span>);</span><br><span class="line">        <span class="comment">// SceneManager.LoadSceneAsync方法返回一个AsyncOperation对象，</span></span><br><span class="line">        <span class="comment">// 在加载过程中，你可以通过返回的AsyncOperation对象来获取加载进度、检查是否加载完成等。</span></span><br><span class="line"></span><br><span class="line">        operation.allowSceneActivation = <span class="literal">false</span>; <span class="comment">// 默认加载完成不切换场景</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!operation.isDone)</span><br><span class="line">        &#123;</span><br><span class="line">            slider.<span class="keyword">value</span> = operation.progress; <span class="comment">// 让进度条的值等于加载进度（slider与加载进度的值都是0~1的浮点数）</span></span><br><span class="line"></span><br><span class="line">            text.text = (<span class="built_in">int</span>)(operation.progress * <span class="number">100</span>) + <span class="string">&quot;%&quot;</span>; <span class="comment">// 显示加载进度百分数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (operation.progress &gt;= <span class="number">0.9f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                slider.<span class="keyword">value</span> = <span class="number">1</span>; <span class="comment">// 场景加载完成后，progress返回的值不是1，所以要单独设定进度条的值</span></span><br><span class="line">                text.text = <span class="string">&quot;点击任意位置继续&quot;</span>; <span class="comment">// 加载完成后百分比进度变为提示</span></span><br><span class="line">                <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    operation.allowSceneActivation = <span class="literal">true</span>; <span class="comment">// 切换场景</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了很大型的游戏项目之外，大部分情况下，场景的加载总是一瞬间完成的，如果仍然想要做出像大型游戏加载那样的加载界面效果，可以尝试使用异步加载制作伪加载进度条，即进度条的进度与播放时间由开发者设定，实际上与加载时间无关，实现过渡界面的效果。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table><thead><tr><th></th><th>同步加载</th><th>异步加载</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>加载新场景时，游戏会暂停当前场景的所有操作，等待新场景完全加载并激活后继续执行。</td><td>加载新场景的行为是在后台线程中进行的，不影响主线程（即游戏当前场景）的运行。</td></tr><tr><td><strong>过程</strong></td><td>1. 触发加载<br>2. 等待加载（游戏暂停）<br>3. 场景切换（加载完成后继续）</td><td>1. 触发加载<br>2. 后台加载（游戏继续运行）<br>3. 场景切换（加载完成后通过回调或检查状态继续）</td></tr></tbody></table><p><strong>对游戏流畅度的影响</strong>：</p><ul><li><strong>同步加载</strong>：由于加载过程中游戏会暂停，因此当加载的场景较大或资源较多时，会导致明显的卡顿或延迟，影响用户体验。</li><li><strong>异步加载</strong>：加载过程在后台进行，不影响游戏当前场景的运行，因此即使加载大型场景也不会造成游戏卡顿，提升了游戏的流畅度和用户体验。</li></ul><p><strong>使用场景</strong>：</p><ul><li><strong>同步加载</strong>：适用于场景较小、资源较少，或对加载时间要求不高的场合。</li><li><strong>异步加载</strong>：更适用于场景较大、资源较多，或对加载时间有较高要求的场合，如制作场景切换过程中的过渡界面、实现无缝加载等。</li></ul><p><strong>实现方式</strong>：</p><ul><li><strong>同步加载</strong>：直接调用加载场景的方法，并等待加载完成。</li><li><strong>异步加载</strong>：调用加载场景的方法时，需要处理返回的异步对象（如<code>AsyncOperation</code>），以便在加载过程中进行进度监控、加载完成后的回调等。</li></ul><p>同步加载和异步加载在Unity中各有其适用场景和优缺点。在实际开发中，应根据游戏的具体需求和资源情况来选择合适的加载方式。</p><h2 id="场景间的数据传递"><a href="#场景间的数据传递" class="headerlink" title="场景间的数据传递"></a>场景间的数据传递</h2><ul><li><strong>全局变量</strong>：使用静态类或单例模式存储全局数据，以便在不同场景之间共享信息。</li><li><strong>PlayerPrefs</strong>：适用于存储少量非敏感数据，如玩家设置。 <a class="btn-beautify green larger" href="/posts/a985624f.html#PlayerPrefs" title="Unity日记：存档系统-PlayerPrefs"><i class="far fa-hand-point-right"></i><span>Unity日记：存档系统-PlayerPrefs</span></a></li><li><strong>SceneManager的<code>DontDestroyOnLoad</code>方法</strong>：用于在场景切换时保留某些对象，如游戏管理器或UI系统。</li></ul><hr><h1 id="关于并发编程"><a href="#关于并发编程" class="headerlink" title="关于并发编程"></a>关于并发编程</h1><p>在Unity中，我们刚刚探讨了场景切换的两种方式：同步加载与异步加载。特别是异步加载，通过<code>SceneManager.LoadSceneAsync</code>方法，我们能够在<strong>不阻塞主线程</strong>的情况下加载新场景，这种非阻塞的特性极大地提升了游戏的流畅度和用户体验。而实现这种异步加载背后，Unity的<code>协程（Coroutine）</code>机制扮演了至关重要的角色。<strong>协程</strong>允许我们在Unity的主线程上**“伪并行”**地执行代码块，每个协程在每次迭代后都会暂停，直到下一次主线程循环中再次被唤醒。这种机制虽然并非传统意义上的并行处理，但它有效地利用了Unity的单一更新循环，模拟了并发执行的效果。</p><p>那么，当我们谈论到并发编程时，我们实际上是在探讨如何在多个处理单元（如CPU核心）上同时执行多个任务，以充分利用硬件资源，提高程序的整体执行效率。在Unity这样的游戏开发环境中，并发编程不仅限于简单的协程使用，它还包括多线程编程、任务并行库（TPL）的使用（在Unity中不直接支持，但可通过C#的<code>System.Threading</code>和<code>System.Threading.Tasks</code>命名空间实现跨平台兼容性处理）、以及针对特定硬件优化的并行计算API（如Compute Shaders、Job System和Burst Compiler等Unity 2018及以后版本中引入的高级功能）。</p><p>从异步加载和协程的视角过渡到并发编程，我们可以理解为：**协程为我们提供了一种在游戏主循环内管理复杂流程和异步操作的有效方式，而并发编程则是将这种思想扩展到了更广泛的层面，即跨越多个处理单元来并行执行多个任务。**在Unity中，合理利用并发编程技术，可以显著减少游戏运行时的延迟，提升游戏性能，特别是在处理大量数据计算、物理模拟、AI决策等计算密集型任务时。</p><p>然而，并发编程也伴随着复杂性增加和潜在的资源竞争、死锁等问题。因此，在设计并发系统时，开发者需要仔细规划任务之间的依赖关系，合理使用同步机制，确保数据的一致性和系统的稳定性。在Unity的上下文中，这意味着要深入理解<a href="https://blog.csdn.net/xiaoyaoACi/article/details/119324146?spm=1001.2014.3001.5502">Unity的生命周期</a>、线程安全以及如何利用Unity提供的并发工具和最佳实践来优化游戏性能。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>并发编程</strong>是一种程序设计方法，‌它由若干个可同时执行的程序模块组成，‌这些模块被称为进程。‌这些进程可以同时在多台处理器上并行执行，‌也可以在一台处理器上交替执行。‌采用并发程序设计可以使外围设备和处理器并行工作，‌从而缩短程序执行时间，‌提高计算机系统效率。‌</p><p>在并发编程中，‌有几个核心概念需要理解：‌</p><ul><li><strong>进程与线程</strong>：‌进程是执行过程中分配和管理资源的基本单位，‌而线程是进程的一个执行单元，‌是进程内可调度的实体。‌线程也可以被称为轻量级进程，‌它是比进程更小的独立运行的基本单位。‌多个线程可以存在于一个进程中，‌并发执行并共享资源（‌如内存）‌，‌而不同的进程不共享这些资源。‌</li><li><strong>同步和异步</strong>：‌同步和异步通常用来形容一次方法调用。‌同步方法调用需要调用者等待方法调用返回后才能继续后续的行为，‌而异步方法调用一旦开始，‌方法调用就会立即返回，‌允许调用者继续执行其他操作，‌而异步方法在另一个线程中“真实”地执行。</li><li><strong>并发和并行</strong>：‌并发和并行都可以用来表示两个或多个任务一起执行，‌但侧重点不同。‌并发强调任务可以交替执行，‌而并行则强调真正的同时执行。‌在单核CPU下，‌通过任务调度器将CPU的时间片分配给不同的程序使用，‌由于CPU在时间片之间快速切换，‌人类感觉是同时运行的，‌这被称为并发。‌而在多核CPU下，‌多个核心可以同时处理多个线程，‌这才是真正的并行执行。</li><li><strong>临界区</strong>：‌临界区通常指共享数据，‌可以被多个线程使用。‌当有线程进入临界区时，‌其他线程或进程必须等待。‌例如，‌当一个线程正在修改共享变量时，‌其他试图访问该变量的线程必须等待直到第一个线程完成操作。‌</li></ul><h2 id="进程、线程与协程的关系"><a href="#进程、线程与协程的关系" class="headerlink" title="进程、线程与协程的关系"></a>进程、线程与协程的关系</h2><p><img src="https://image.flashfish777.cn/img/post_8_3.jpg" alt="进程、线程与协程的关系"></p><p>线程和协程都是进程的子集，一个进程可以有多个协程，一线程也可以有多个协程，进程基于程序主体。</p><p><strong>IO密集型一般使用多线程或多进程</strong>。<strong>CPU密集型一般使用多进程</strong>。<strong>强调非阻塞异步并发的一般都用协程</strong>。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是系统分配资源和调度资源的一个独立单位，<strong>每个进程都有自己的独立内存空间</strong>，<strong>不同进程间可以进行进程间通信</strong>。进程<strong>重量级比较大</strong>，占据独立内存，上下文进程间的切换开销（栈寄存器、虚拟内存、文件句柄）比较大，但相对稳定安全。进程的上级为操作系统，有自己固定的堆栈。</p><p><strong>进程间通信（IPC）</strong></p><ul><li><strong>管道（Pipe）</strong>：管道是Unix中最古老的进程间通信的形式，我们把从一个进程连接到另一个进程的一个数据流称为一个“管道”。其本质是内核中固定大小的缓冲区。</li><li><strong>命名管道（Named Pipes）</strong>：“命名管道”又名“命名管线”（Named Pipes），命名管道支持可靠的、单向或双向的数据通信。不同于匿名管道的是：命名管道可以在不相关的进程之间和不同计算机之间使用，服务器建立命名管道时给它指定一个名字，任何进程都可以通过该名字打开管道的另一端，根据给定的权限和服务器进程通信。</li><li><strong>消息队列（MQ，Message Quene）</strong>：消息队列用于在进程间通信的过程中将消息按照队列存储起来，常见的MQ有ActiveMQ、RocketMQ、RabbitMQ、Kafka等。</li><li><strong>信号量（Semaphore）</strong>：有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前,线程必须获取一个信号量。</li><li><strong>共享内存（Share Memory）</strong>：共享内存是三个IPC机制中的一个。它允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在进行的进程之间传递数据的一种非常有效的方式。</li><li><strong>套接字（Socket）</strong>：就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。</li></ul><p>对于游戏开发者来说，最为常用的无疑是Socket，这是长连接网络游戏的核心。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程也被称为轻量级进程，是<strong>操作系统调度（CPU调度）执行的最小单位</strong>，是进程的子集。</p><p>线程<strong>本身基本不拥有资源</strong>，而是访问隶属于进程的资源，一个进程拥有至少一个或多个线程，<strong>线程间共享进程的地址空间</strong>。</p><p>由于<strong>线程是阻塞式</strong>的，如果想要同步执行IO，每个IO都必须开启一个新线程，<strong>多线程开销较大</strong>，适合多任务处理，进程崩溃不影响其他进程，而线程只是一个进程的不同执行路线。</p><p><strong>线程有自己的堆栈</strong>，却<strong>没有单独的地址空间</strong>，<strong>进程死就等于所有线程死</strong>，所以多进程要比多线程健壮。但在进程切换时，消耗资源较大，效率较差。</p><p>线程是并发的，且是阻塞式同步的，一旦资源死锁，线程将陷入混乱。在同步线程的执行过程中，<strong>线程的执行切换是由CPU轮转时间片的分配来决定的</strong>。</p><p><img src="https://image.flashfish777.cn/img/post_8_4.jpg" alt="线程状态图"></p><ul><li>新建状态：new创建一个线程时，还没开始运行，就是新建状态。</li><li>就绪状态：新建后，调用start()方法，线程就处于就绪态，等待CPU调度。</li><li>运行状态：当线程获得了CPU时间后，进入运行状态，执行run()里的内容</li><li>阻塞状态：线程运行中随时可能被阻塞：比如调用sleep()方法；等待获取锁被阻塞；线程在等待其他触发条件。暂时让出CPU资源。</li><li>死亡状态：有两个原因导致线程死亡：run()方法正常结束；一个未捕获的异常终止了run()方法</li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><strong>Unity 中所有脚本运行公用一条主线程，而协程是开辟的伪线程。这个伪线程可以让一个方法分多次执行，相当于让主线程劈几个叉。</strong></p><p>协程还称微线程，纤程，<strong>本质是一个单线程</strong>。<strong>协程是比线程更轻量级的存在</strong>，协程<strong>不由操作系统内核所管理</strong>，而是完全由程序所控制（也就是在<strong>用户态执行</strong>）。</p><p>协程的好处是性能大幅提升，不会像线程切换那样消耗资源。同一时间只能执行某个协程，开辟<strong>多个协程开销不大</strong>。<strong>适合对任务进行分时处理</strong>。</p><p><strong>协程有自己的寄存器和上下文栈</strong>。协程调度切换时，将寄存器和<strong>上下文栈保存到其他地方</strong>，并在协程切换回来时<strong>恢复之前保存的寄存器和上下文栈</strong>。由于<strong>直接对栈进行操作</strong>，<strong>基本没有内核切换的开销</strong>，可以<strong>不加锁的访问全局变量</strong>，所以上下文切换非常快。</p><p>一个线程可以有多个协程，一个进程也可以单独拥有多个协程。<strong>线程和进程都是同步机制，而协程是异步机制，无需阻塞</strong>。协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用时的状态。多协程间对CPU的使用是依次进行的，每次只有一个协程工作，而其他协程处于休眠状态。</p><p>实际上多个协程是在一个线程中的，只不过每个协程对CPU进行分时。<strong>协程可以访问和使用Unity的所有方法和Component</strong>。<strong>函数（子程序）的调用是通过栈实现的</strong>，一个线程就是执行一个函数，函数调用总是一个入口，一个返回，调用顺序是明确的，而<strong>协程在函数内部是可以中断的</strong>，然后<strong>转而执行其他函数</strong>，在<strong>适当的时候再返回来继续执行</strong>。函数（子程序）的切换不是由线程切换，而是程序自身控制，因此没有线程切换开销。和多线程相比，线程越多，协程的性能优势就越明显，切协程因为依次执行，<strong>不存在线程安全问题，变量访问不会冲突</strong>，共享资源也无需加锁，只需要判断状态即可，所以执行效率比线程高很多。</p><p><strong>协程的语法</strong></p><ul><li><code>yield</code>：暂停，通常用 <code>yield return null</code> 来暂停协程。</li><li><code>StartCoroutine(方法名())</code>：恢复执行。</li><li><code>WaitForSeconds</code>：引入时间延迟，默认情况下，协程将在 yield 后的帧上恢复。使用 <code>yield return new WaitForSecond(.1f)</code> 后，将延迟0.1秒后执行协程。</li></ul><p>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> url = <span class="string">&quot;https://xxxx.xxxx.xxxx/xxxx.jpg&quot;</span>;</span><br><span class="line">    WWW www = <span class="keyword">new</span> WWW(url);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> WWW;</span><br><span class="line">    renderer.material.mainTexture = www.texture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当程序执行到 <code>yield return WWW</code>; 时就不会直接往下执行了，而是等到网络请求结束后的第一帧的<code>WWW</code>协程节点触发时才继续执行，也就是说，当网络请求结束后，纹理才会被替换。</p><p><strong>yield return对象</strong></p><ul><li><code>null或数字</code>：在Update后执行，适合分解耗时的逻辑处理。</li><li><code>WaitForFixedUpdate</code>：在FixedUpdate后执行，适合分解物理操作。</li><li><code>WaitForSeconds</code>：在指定时间后执行，适合延迟调用。</li><li><code>WaitForSecondsRealtime</code>：在指定时间后执行，适合延迟调用。不受时间缩放影响。</li><li><code>WaitForEndOfFrame</code>：在每帧结束后执行，适合相机跟随操作。</li><li><code>Coroutine</code>：在另一个协程执行完毕后再执行。</li><li><code>WaitUntil</code>：在委托返回true时执行，适合等待某一操作。</li><li><code>WaitWhile</code>：在委托返回false时执行，适合等待某一操作。</li><li><code>WWW</code>：在请求结束后执行，适合加载数据，如文件、贴图、材质等。</li></ul><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>通过并发编程，我们可以实现更复杂的游戏逻辑，如大规模场景中的动态光照计算、复杂物理效果的实时模拟等，而无需担心这些任务会拖慢游戏的主循环。此外，随着Unity对并发编程支持的不断增强，开发者们将有更多机会探索和利用现代硬件的并行处理能力，为玩家带来更加流畅、逼真的游戏体验。</p><p>从场景切换的异步加载到并发编程的深入探索，我学到了很多。通过掌握并发编程的精髓，我们不仅能够提升游戏的运行效率，还能为游戏设计带来更多可能性，让创意与技术的碰撞绽放出更加璀璨的光芒。</p><p>—end—</p>]]></content>
    
    
    <summary type="html">从加载进度条到Unity的进程、线程与协程...</summary>
    
    
    
    <category term="知识分享" scheme="http://www.flashfish777.cn/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="游戏开发" scheme="http://www.flashfish777.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="Unity" scheme="http://www.flashfish777.cn/tags/Unity/"/>
    
    <category term="C#" scheme="http://www.flashfish777.cn/tags/C/"/>
    
    <category term="并发编程" scheme="http://www.flashfish777.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
