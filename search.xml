<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VSCode插件推荐2</title>
      <link href="/posts/20a54dfa.html"/>
      <url>/posts/20a54dfa.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>众所可能不周知，经过了很长时间的磨合，我已经变成了<mark class="hl-label blue">VSCode</mark>的形状。<br>这玩意儿用起来实在是太爽，<strong>轻量级</strong>、<strong>速度快</strong>，<strong>插件多到爆炸</strong>，想干什么都能找到对应的工具。而且界面还特别清爽，<strong>主题随便换</strong>，实在不满意甚至能DIY，想怎么折腾就怎么折腾，完全符合我的审美。<br>拿我自己来说，作为一名计算机专业的大学牲，我有无数的专业课需要实操，<code>Cpp</code>、<code>Java</code>、<code>Python</code>、<code>Web前端</code>、<code>数据库</code>、<code>计网</code>，除此之外，我自己还在学习<code>C#</code>。虽然对我来说都不难，但多的让人头大。<br>很多人学<code>Cpp</code>时下载<code>DevC++</code>、<code>Clion</code>，学<code>Java</code>时下载<code>IDEA</code>，学<code>Python</code>时又下<code>PyCharm</code>，学数据库时又下<code>SqlServer</code>、下<code>navicat</code>，学前端时又下<code>WebStorm</code>，想写<code>C#</code>还要下<code>Visual Studio</code>。先不说运行时的效率，就光这些“大块头”就要把存储空间占满了，动辄十几几十个G，没一个省油的灯，况且对于我们学习学校的课程来说，完全用不到这么专业的IDE。<br>我从大学刚刚开始就接触了VSCode，之后也一直在用（中途用过一次VS2022，每次打开都要把我的内存占满，最后直接卸载了）。学习C语言和算法时我安装C&#x2F;Cpp的插件，学Java时我安装Java语言的插件，学数据库时我安装数据库插件用VSCode连接数据库，学习使用git时我用VSCode的终端就能打开bash，还能通过插件连接github储存库进行一键式的版本管理，什么东西都是即安即用，最多配个环境。<br>有同学要问了老师老师你安这么多插件VSCode不也会超负荷的吗？当然不会。VSCode独特的配置文件可以将不同配置文件中的插件与设置隔离起来，哪个文件夹用哪个配置文件，就会加载对应的插件，完全不用担心插件太多太杂。</p><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1em421j7wZ&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><p><img src="https://s2.loli.net/2025/03/22/ANBg7OIqRJGtoZr.png" alt="配置文件"></p><p>总之，真的十分推荐VSCode！这次将再次推荐一些好用的插件 -&gt;&gt;&gt;</p><hr><h1 id="功能篇"><a href="#功能篇" class="headerlink" title="功能篇"></a>功能篇</h1><h2 id="any-rule"><a href="#any-rule" class="headerlink" title="any-rule"></a>any-rule</h2><p>你要的“正则”都在这！</p><p><img src="https://s2.loli.net/2025/03/23/5gyIHwxSi2z8MKW.png" alt="any-rule"></p><p><strong>Any-rule</strong> 是一款正则表达式插件，旨在帮助开发者快速生成和使用正则表达式。它内置了大量常用的正则表达式模板，覆盖了多种常见场景，如匹配邮箱、URL、手机号等。</p><p><strong>主要功能</strong></p><ol><li><strong>常用正则表达式模板</strong>：<ul><li>提供丰富的正则表达式模板，涵盖邮箱、URL、IP地址、手机号、身份证号等常见需求。</li></ul></li><li><strong>快速生成正则表达式</strong>：<ul><li>通过快捷键或命令面板，快速生成所需的正则表达式。</li></ul></li><li><strong>自定义正则表达式</strong>：<ul><li>支持自定义正则表达式模板，满足个性化需求。</li></ul></li><li><strong>实时测试</strong>：<ul><li>提供实时测试功能，可在编辑器中直接测试正则表达式的匹配效果。</li></ul></li></ol><p><strong>使用方法</strong></p><ol><li><strong>通过命令面板</strong>：<ul><li>打开命令面板（快捷键 <code>Ctrl+Shift+P</code>）。    </li><li>输入 “Any-rule” 并选择相应模板。</li></ul></li><li><strong>通过快捷键</strong>：<ul><li>使用快捷键 <code>Ctrl+Alt+R</code> 打开 Any-rule 菜单，选择所需正则表达式。</li></ul></li><li><strong>自定义模板</strong>：<ul><li>在设置中配置自定义正则表达式模板。</li></ul></li></ol><p>Any-rule 插件简化了正则表达式的生成和使用，适合需要频繁处理正则表达式的开发者。通过内置模板和自定义功能，能显著提升开发效率。</p><h2 id="var-translate-en"><a href="#var-translate-en" class="headerlink" title="var-translate-en"></a>var-translate-en</h2><p>中文一键翻译为英文并转换成驼峰命名,提效神器🚀</p><p><img src="https://s2.loli.net/2025/03/23/Do7bhdlZwMP1JzG.png" alt="var-translate-en"></p><p><strong>Var-Translate-EN</strong> 是一款变量命名辅助工具 + 翻译工具，主要用于将中文变量名翻译为英文，且支持中英互译，帮助开发者编写更规范的代码并解决不认识的生词。它特别适合在需要中英互相转换的场景中使用，比如处理英文注释或中文命名的遗留代码。</p><p><strong>主要功能</strong></p><ol><li><strong>中文变量名翻译</strong>：<ul><li>将中文变量名自动翻译为英文，支持驼峰命名、下划线命名等多种格式。</li></ul></li><li><strong>多种命名风格</strong>：<ul><li>支持多种命名风格，如驼峰式（camelCase）、下划线式（snake_case）、常量式（UPPER_CASE）等。</li></ul></li><li><strong>批量翻译</strong>：<ul><li>支持批量翻译选中的多个变量名，提升效率。</li></ul></li><li><strong>自定义词典</strong>：<ul><li>允许用户添加自定义翻译词典，满足特定领域或项目的需求。</li></ul></li><li><strong>实时预览</strong>：<ul><li>在翻译时提供实时预览功能，方便开发者确认翻译结果。</li></ul></li></ol><p><strong>使用方法</strong></p><ol><li><strong>选中变量名</strong>：<ul><li>在代码中选中需要翻译的中文变量名。</li></ul></li><li><strong>调用插件</strong>：<ul><li>右键点击选中的变量名，选择 <strong>Var-Translate-EN</strong> 选项。</li><li>或者使用快捷键（默认快捷键为 <code>Ctrl+Alt+T</code>）。</li></ul></li><li><strong>选择命名风格</strong>：<ul><li>在弹出的选项中选择所需的命名风格（如驼峰式、下划线式等）。</li></ul></li><li><strong>确认翻译</strong>：<ul><li>插件会自动将中文变量名翻译为英文，并替换到代码中。</li></ul></li></ol><p><strong>自定义词典</strong></p><ol><li>打开 VSCode 设置（<code>Ctrl+,</code>）。</li><li>搜索 “Var-Translate-EN”。</li><li>在配置中添加自定义词典，例如：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;var-translate-en.customDictionary&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;用户名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;accountName&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;订单编号&quot;</span><span class="punctuation">:</span> <span class="string">&quot;orderId&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Todo-Tree"><a href="#Todo-Tree" class="headerlink" title="Todo Tree"></a>Todo Tree</h2><p>方便的查找与修改TODO、BUG、TEST等指令</p><p><img src="https://s2.loli.net/2025/03/23/S7Rl4EnNuVdFI69.png" alt="Todo Tree"></p><p><strong>Todo Tree</strong> 是一款任务管理插件，用于快速查找和整理代码中的注释标签（如 <code>TODO</code>、<code>FIXME</code> 等）。它能够将散落在代码中的任务注释集中展示在一个树形结构中，方便开发者管理和跟踪任务进度。</p><p><strong>主要功能</strong></p><ol><li><strong>注释标签高亮</strong>：<ul><li>自动高亮代码中的注释标签（如 <code>TODO</code>、<code>FIXME</code>、<code>NOTE</code> 等）。</li></ul></li><li><strong>任务树形结构</strong>：<ul><li>将代码中的所有任务注释以树形结构展示在侧边栏中，方便查看和管理。</li></ul></li><li><strong>快速跳转</strong>：<ul><li>点击树形结构中的任务，可以快速跳转到对应的代码位置。</li></ul></li><li><strong>自定义标签</strong>：<ul><li>支持自定义注释标签，满足不同项目的需求。</li></ul></li><li><strong>过滤和搜索</strong>：<ul><li>支持按标签、文件路径等条件过滤任务，快速定位目标。</li></ul></li><li><strong>多工作区支持</strong>：<ul><li>支持同时管理多个工作区中的任务注释。</li></ul></li></ol><p><strong>使用方法</strong></p><ol><li><strong>查看任务树</strong>：<ul><li>安装插件后，左侧活动栏会显示一个树形图标，点击即可打开 Todo Tree 面板。</li></ul></li><li><strong>添加注释标签</strong>：<ul><li>在代码中添加注释标签，例如：</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// TODO: 优化性能</span><br><span class="line">// FIXME: 修复空指针异常</span><br><span class="line">// NOTE: 需要进一步测试</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>高亮显示</strong>：<ul><li>插件会自动高亮这些注释标签，并在 Todo Tree 面板中展示。</li></ul></li><li><strong>快速跳转</strong>：<ul><li>点击 Todo Tree 面板中的任务，可以直接跳转到对应的代码位置。</li></ul></li><li><strong>自定义标签</strong>：<ul><li>在设置中配置自定义标签，例如：</li></ul></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;todo-tree.general.tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;TODO&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;FIXME&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;NOTE&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;CUSTOM&quot;</span></span><br><span class="line"><span class="punctuation">]</span>   </span><br></pre></td></tr></table></figure><ol start="6"><li><strong>过滤任务</strong>：<ul><li>在 Todo Tree 面板的搜索框中输入关键字，可以按标签、文件路径等条件过滤任务。</li></ul></li></ol><p><strong>Todo Tree</strong> 是一款非常实用的任务管理插件，特别适合需要跟踪和管理代码中任务注释的开发者。它通过树形结构集中展示任务，支持自定义标签和高亮颜色，能够显著提升代码维护效率。如果你经常使用 <code>TODO</code>、<code>FIXME</code> 等注释标签，这款插件会是一个很好的助手。</p><h2 id="数据库天团："><a href="#数据库天团：" class="headerlink" title="数据库天团："></a>数据库天团：</h2><p><strong>vscode-database &amp; Prettier SQL VSCode &amp; MySQL</strong></p><p><img src="https://s2.loli.net/2025/03/23/8IO1KpXDYHNwRv6.png" alt="database"></p><p>当你看到别人用他们的IDEA、VS轻松地连接到数据库并随意操作也不用羡慕！VSCode也有独特的数据库插件：</p><h3 id="vscode-database"><a href="#vscode-database" class="headerlink" title="vscode-database"></a>vscode-database</h3><p><strong>vscode-database</strong> 是一款数据库管理插件，支持直接在 <code>VSCode</code> 中连接、查询和管理多种数据库（如 <code>MySQL</code>、<code>PostgreSQL</code>、<code>SQLite</code>、<code>Redis</code> 等）。它集成了数据库连接、SQL 查询、数据编辑、表结构管理等功能，适合开发者在编写代码的同时直接操作数据库。</p><p><strong>主要功能</strong></p><ol><li><strong>多数据库支持</strong>：<ul><li>支持多种常见数据库，包括 <code>MySQL</code>、<code>PostgreSQL</code>、<code>SQLite</code>、<code>Redis</code>、<code>MongoDB</code> 等。</li></ul></li><li><strong>数据库连接管理</strong>：<ul><li>提供直观的界面管理数据库连接，支持保存连接配置。</li></ul></li><li><strong>SQL 查询与执行</strong>：<ul><li>支持编写和执行 SQL 查询，并查看查询结果。</li></ul></li><li><strong>数据编辑</strong>：<ul><li>可以直接在插件中编辑数据库表中的数据。</li></ul></li><li><strong>表结构管理</strong>：<ul><li>支持查看和修改表结构（如添加、删除、修改字段）。</li></ul></li><li><strong>查询历史</strong>：<ul><li>自动保存 SQL 查询历史，方便快速复用。</li></ul></li><li><strong>数据导出</strong>：<ul><li>支持将查询结果导出为 CSV、JSON 等格式。</li></ul></li><li><strong>智能提示</strong>：<ul><li>提供 SQL 语法高亮和智能提示，提升编写效率。</li></ul></li></ol><h3 id="Prettier-SQL-VSCode"><a href="#Prettier-SQL-VSCode" class="headerlink" title="Prettier SQL VSCode"></a>Prettier SQL VSCode</h3><p><strong>Prettier SQL</strong> 是一款 SQL 语言格式化工具，基于 <a href="https://prettier.io/">Prettier</a> 生态开发。它专注于对 SQL 代码进行自动格式化，帮助开发者保持代码风格的一致性，提升代码的可读性和维护性。</p><p><strong>主要功能</strong></p><ol><li><strong>SQL 代码格式化</strong>：<ul><li>自动格式化 SQL 代码，支持常见的 SQL 语法（如 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等）。</li></ul></li><li><strong>支持多种 SQL 方言</strong>：<ul><li>支持多种 SQL 方言，包括 MySQL、PostgreSQL、SQL Server、SQLite 等。</li></ul></li><li><strong>与 Prettier 集成</strong>：<ul><li>作为 Prettier 的插件，可以与 Prettier 的其他功能（如 JavaScript、TypeScript 格式化）无缝集成。</li></ul></li><li><strong>配置文件支持</strong>：<ul><li>支持通过 <code>.prettierrc</code> 配置文件自定义格式化规则。</li></ul></li><li><strong>快捷键格式化</strong>：<ul><li>支持通过快捷键快速格式化 SQL 代码。</li></ul></li><li><strong>保存时自动格式化</strong>：<ul><li>支持在保存文件时自动格式化 SQL 代码。</li></ul></li></ol><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p><strong>MySQL</strong> 插件是一款数据库管理工具，专门用于连接、查询和管理 MySQL 数据库。它提供了直观的界面和强大的功能，使开发者能够直接在 VSCode 中操作数据库，而无需切换到其他数据库管理工具。</p><p><strong>主要功能</strong></p><ol><li><strong>数据库连接管理</strong>：<ul><li>支持连接本地或远程的 MySQL 数据库。</li><li>支持多数据库连接配置。</li></ul></li><li><strong>SQL 查询与执行</strong>：<ul><li>提供 SQL 编辑器，支持语法高亮、自动补全和代码格式化。</li><li>可以直接在 VSCode 中编写和执行 SQL 查询。</li></ul></li><li><strong>数据表管理</strong>：<ul><li>查看和编辑数据库中的表结构。</li><li>支持表数据的增删改查（CRUD）操作。</li></ul></li><li><strong>查询结果展示</strong>：<ul><li>以表格形式展示查询结果，支持排序、筛选和导出数据。</li></ul></li><li><strong>数据库对象浏览</strong>：<ul><li>浏览数据库中的表、视图、存储过程、函数等对象。</li></ul></li><li><strong>事务支持</strong>：<ul><li>支持事务操作，可以提交或回滚事务。</li></ul></li><li><strong>导出与导入</strong>：<ul><li>支持将查询结果或表数据导出为 CSV、JSON 等格式。</li><li>支持导入外部数据到数据库中。</li></ul></li></ol><p><img src="https://s2.loli.net/2025/03/23/LTYl5AXC83hMZeg.png" alt="MySQL"></p><p>当然，不止<code>MySQL</code>，如果你用到如<code>Redis</code>、<code>MogoDB</code>等其他数据库，也可以下载对应的插件使用。</p><p><img src="https://s2.loli.net/2025/03/23/GFkiDA6I4213uyg.png" alt="数据库天团"></p><hr><h1 id="美化篇"><a href="#美化篇" class="headerlink" title="美化篇"></a>美化篇</h1><h2 id="Ayu"><a href="#Ayu" class="headerlink" title="Ayu"></a>Ayu</h2><p>巨好看的深色主题</p><p><img src="https://s2.loli.net/2025/03/23/V21lesOMUGSgyXD.png" alt="Ayu"></p><p><strong>Ayu</strong> 是一款非常受欢迎的代码编辑器主题插件，以其简洁、现代的设计风格和舒适的视觉体验而闻名。Ayu 提供了多种配色方案（如亮色、暗色和幻影色），适合不同开发者的审美偏好和工作环境。<br>（ps：个人觉得<code>Ayu Dark</code>最好看！）</p><h2 id="Gradient-Theme"><a href="#Gradient-Theme" class="headerlink" title="Gradient Theme"></a>Gradient Theme</h2><p>无敌好看的渐变代码主题</p><p><img src="https://s2.loli.net/2025/03/23/dyLhnT5p7g9vqXV.png" alt="Gradient Theme"></p><p><strong>Gradient Theme</strong> 是一款主题插件，以其渐变色设计和现代风格著称。它为代码编辑器提供了独特的视觉体验，通过柔和的渐变色背景和精心设计的语法高亮，使代码更加美观且易于阅读。<br><strong>Gradient Theme</strong> 的渐变色真的超级好看！是我现在仍在用的一款主题，每一种风格都很漂亮，还可以自定义渐变色！使用后别忘了在命令中心打开 <code>Gradient Theme: Enable Gradient</code> 配置！不然不会显示渐变哦。</p><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1EWtjezEYn&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><h2 id="vscode-teriri-custom-style"><a href="#vscode-teriri-custom-style" class="headerlink" title="vscode-teriri-custom-style"></a>vscode-teriri-custom-style</h2><p>不计效率地为 vscode 添加样式与动画</p><p><img src="https://s2.loli.net/2025/03/23/DlfFey5qXokGMiC.png" alt="vscode-teriri-custom-style"></p><p><a href="https://github.com/TeR1R1/vscode-teriri-custom-style">-&gt; GitHub仓库</a></p><p><strong>重头戏来了！</strong><br>超级超级棒，超级推荐的一个项目！如果你不局限于主题、背景、特效插件这样的美化，想让你的VSCode变得更加 下炫酷， <code>vscode-teriri-custom-style</code> 可以做到这些！</p><p><code>vscode-teriri-custom-style</code> 是一个为VSCode开发的的自定义样式项目，为开发者提供个性化的编辑器界面和代码高亮方案。该项目通过自定义 CSS 和配置文件，允许用户根据自己的喜好调整 VSCode 的外观和功能，从而提升开发体验。</p><p>非线性移动动画与进入动画、毛玻璃与圆角效果、高亮动画、发光字体、光标动画、炫酷的RGB光效、提示窗口动画、资源管理器动画……各种炫酷的效果随意添加，只需要安装 CSS 加载器，例如 <code>Apc Customize UI++</code> 插件, <code>Custom CSS and JS Loader</code> 等，能加载 CSS 文件就行。</p><p><img src="https://s2.loli.net/2025/03/23/7CF4hmg9AryK2BL.png" alt="Custom CSS and JS Loader"></p><p>安装好插件后将项目中对应的 CSS 文件导入即可。具体的教程与演示在项目仓库中写的很详细，感兴趣的朋友可以自行查看。</p><p>当然，<code>vscode-teriri-custom-style</code> 只是项目作者自行研究的动画效果合辑。只要通过 CSS 加载器插件加载需要的 CSS 文件就可以通过 CSS 做到更多的效果。</p><hr><h1 id="JetBrains-Rider"><a href="#JetBrains-Rider" class="headerlink" title="JetBrains Rider"></a>JetBrains Rider</h1><p>就在前段时间，公认的全球最受喜爱，最佳游戏开发IDE <code>JetBrains Rider</code> 对非商业用途的用户开放了免费使用，这无疑是一个超级大的好消息。众所周知 <code>JetBrains</code> 家的IDE无论是 <code>IDEA</code> 、 <code>PyCharm</code> 、 <code>CLion</code> 、 <code>WebStorm</code> 等都受到了广泛开发者的喜爱，虽然并没有用过 <code>JetBrains</code> 的产品，但我相信好评是有目共睹的，于是在了解了 <code>Rider</code> 非商业化免费之后，我也立马下载下来体验了一番。</p><p><strong>Rider</strong> 是由 JetBrains 开发的一款跨平台集成开发环境（IDE），专为 <code>.NET</code>、<code>C#</code> 和 <code>Unity</code> 开发而设计。它基于 <code>IntelliJ</code> 平台和 <code>ReSharper</code> 技术，提供了强大的代码编辑、调试和重构功能，支持多种 <code>.NET</code> 项目类型，包括 <code>.NET Framework</code>、<code>.NET Core</code>、<code>Mono</code> 和 <code>Unity</code> 项目。</p><h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><ol><li><strong>跨平台支持</strong>：<ul><li>Rider 支持 <code>Windows</code>、<code>macOS</code> 和 <code>Linux</code> 操作系统，开发者可以在不同平台上无缝切换。</li></ul></li><li><strong>强大的代码编辑功能</strong>：<ul><li>提供语法高亮、代码自动补全、实时错误检测和代码重构功能，帮助开发者高效编写代码。</li><li>支持超过 2200 种实时代码检查，并提供快速修复建议。。</li></ul></li><li><strong>Unity 开发支持</strong>：<ul><li>作为一个游戏开发者，Rider 对 Unity 的支持让我印象深刻。它能够直接识别 Unity 项目中的脚本，并提供智能提示和调试功能。</li><li>在 Unity 中编写 C# 脚本时，Rider 的代码补全和重构功能极大地提升了开发效率。此外，它还支持 Unity 的 API 文档快速查看，方便随时查阅。</li></ul></li><li><strong>调试与测试</strong>：<ul><li>Rider 内置的调试器非常强大，支持断点、变量监视、表达式评估等功能。调试 Unity 项目时，它能够与 Unity 编辑器无缝衔接，实时查看游戏状态。</li></ul></li><li><strong>丰富的插件生态系统</strong>：<ul><li>支持多种插件扩展，包括 Git 版本控制、数据库工具、AI工具等等。</li></ul></li></ol><p>一开始我还觉得编辑器可能对我的开发影响不大，毕竟我已经习惯了用 VSCode 做任何事情。可是用了一段时间 Rider 我才发现它的专业性确实要更加更加强大，无论是代码补全还是对Unity的完美支持都完全秒杀 VSCode 插件的组合式开发环境，更别说 Rider还能完美的支持Unity Shader 的语法了。<br>相比之下 VSCode 倒像是可以支持各种语言环境的文本编辑器，它的涉猎广泛，但不够深入。 Rider 相比之下至少在 Unity 开发上更加专业。况且 Rider 也有插件系统不是嘛。<br>所以我觉得我应该重新对待 VSCode ，我不能再过度的依赖它。对于我来说，Unity 开发是我的主要工作，所以我选择使用 Rider 。在学习其他语言或进行其他不需要我涉猎很深的工作时 VSCode 可能仍是最好的选择。</p><h2 id="配置推荐"><a href="#配置推荐" class="headerlink" title="配置推荐"></a>配置推荐</h2><p>在 Rider 的使用上我或许不是很熟练与专业，但我可以给出我的一些建议。<br>首先快捷键配置我选择 VSCode 的，毕竟用习惯了。主题我选择用 <code>VSCode Theme</code> 插件，代码字体选用 <code>Consolas</code> ，哪里不像 VSCode 我用着都很别扭哈哈哈。</p><p><img src="https://s2.loli.net/2025/03/23/AoDZcyWkrBUbNQg.png"></p><p>提示级别是这样的，因为我觉得尽管正确的命名与拼写是必要的，但总会有一些特殊情况，编辑器一直提示的话我会觉得很烦，至于规范化的事情自己注意就好了。还有性能检查也是我觉得很棒的一个功能，它可以提示你那些方法或操作的开销比较大或其他，在开发时很有参考意义。</p><p>至于其他不错的功能就一起探索吧！</p><hr><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>以上就是我的一些推荐和想说的话，希望能为你带来帮助。如果你有任何推荐的VSCode插件或者独特的使用心得，欢迎在评论区留言分享，让我们一起学习，共同进步！期待在未来的编程道路上，与更多的你相遇，共同书写属于我们的精彩篇章。</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
            <tag> Rider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TapTap聚光灯GameJam</title>
      <link href="/posts/249f88d5.html"/>
      <url>/posts/249f88d5.html</url>
      
        <content type="html"><![CDATA[<div class="note danger info flat"><p><strong>别急。</strong></p></div><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 游戏 </category>
          
          <category> GameJam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> 开发历程 </tag>
            
            <tag> GameJam </tag>
            
            <tag> TapTap聚光灯GameJam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Inno Setup 安装包制作教程</title>
      <link href="/posts/54db36cb.html"/>
      <url>/posts/54db36cb.html</url>
      
        <content type="html"><![CDATA[<h1> Inno Setup 打包教程 </h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对计算机相对熟悉之后，我们发现大部分应用都是一整个文件，里面可能会有 <code>exe</code> 可执行文件及其他素材文件、库文件、依赖等等。比如我的 LecSnake ，windows平台打包之后是一个这样的文件夹：</p><p><img src="https://s2.loli.net/2025/03/26/jlUCmtAcfbagqxz.png" alt="&#x2F;LecSnake&#x2F;"></p><p>以后我们可能还会做更多的游戏以及其他的项目。那么我们想发给朋友玩的时候难道只能压缩成压缩包然后发给别人解压吗？<br>我们一般在网上下载东西时都是下载安装程序。再通过安装程序将应用文件夹下载至磁盘中。那么我们自己的应用是否也可以打包成 方便 快捷 高级 的安装程序呢？<br>本文将介绍 <code>Inno Setup</code> 及使用 <code>Inno Setup</code> 快捷方便的将应用文件夹打包成安装程序的方法。</p><h1 id="Inno-Setup"><a href="#Inno-Setup" class="headerlink" title="Inno Setup"></a>Inno Setup</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Inno Setup</code> 是一个免费的 Windows 安装程序制作工具，具有以下特点：</p><ul><li>小巧高效（单EXE即可运行）</li><li>支持所有现代Windows版本</li><li>内置多语言支持</li><li>支持脚本扩展功能</li></ul><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>访问 <a href="http://www.jrsoftware.org/isdl.php">官方下载页面</a> 下载最新版本（当前推荐版本：6.2.2）</p><p><img src="https://s2.loli.net/2025/03/26/Dv5ByhNPFVecH2X.png" alt="download"></p><p>下面那个 <code>Netherlands</code> 要快一些。</p><h3 id="安装选项"><a href="#安装选项" class="headerlink" title="安装选项"></a>安装选项</h3><p>建议：</p><ul><li>记得安到D盘哦</li><li>剩下全部默认就可以了</li></ul><h2 id="基础打包步骤"><a href="#基础打包步骤" class="headerlink" title="基础打包步骤"></a>基础打包步骤</h2><h3 id="使用脚本向导创建基础脚本"><a href="#使用脚本向导创建基础脚本" class="headerlink" title="使用脚本向导创建基础脚本"></a>使用脚本向导创建基础脚本</h3><p>（推荐）</p><p>通过开始菜单或桌面快捷方式启动 <code>Inno Setup Compiler</code> ，打开之后会有一个 <code>Welcome</code> 窗口:</p><p><img src="https://s2.loli.net/2025/03/26/LObHZgcm4sqfKA5.png" alt="innopost3.png"></p><p>选择 “<code>Create a new script using the Script Wizard</code>“，点击 <code>OK</code> 。</p><p>也可以通过主程序左上角 <code>File/New</code> 来创建一个新的脚本文件向导。</p><p><code>Inno Setup</code> 的运行原理简单来说就是通过一组脚本规则来创建对应的安装程序，脚本规则中主要包括安装路径、文件夹位置、应用程序配置、语言等等规则，我们要做的就是配置好这些规则，然后运行脚本文件生成安装程序。同时还可以将脚本文件保存下来，打包具有相似配置的应用时直接使用即可。</p><p>接下来直接点击 <code>Next</code> 来到 <code>Application Information</code> (应用信息)界面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Application name : Myproject // 此处填写最终生成的应用名称，及 Myproject.exe</span><br><span class="line">Application version : 1.0 // 此处填写应用的版本</span><br><span class="line">Application publisher : yourname // 发布者信息，什么都可以，非必要</span><br><span class="line">Application website : // 网站网址，非必要</span><br><span class="line"></span><br><span class="line">-&gt; Next</span><br></pre></td></tr></table></figure><p>来到 <code>Application Folder</code> ，这里设定安装完成后的文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Application destination base folder : 默认安装路径，不用动，也可以自定义</span><br><span class="line">Application folder Name : 生成的文件夹名称</span><br><span class="line">允许用户更改安装路径一般为true</span><br><span class="line">第四个不用管</span><br><span class="line"></span><br><span class="line">-&gt; Next</span><br></pre></td></tr></table></figure><p>来到 <code>Application Files</code> ，设定源文件：</p><p><img src="https://s2.loli.net/2025/03/26/tMGPvNVdF62W8x5.png" alt="innopost4.png"></p><p>点击 <code>Browse</code> 选择要打包应用的可执行文件 (<code>exe</code>)，然后在下方点击 <code>Add folder</code> 将应用文件夹全部添加上去即可 Next 。</p><p>下一步 <code>Application File Association</code> 不需要，勾掉（<code>false</code>）就可以了。</p><p>下一步 <code>Application Shortcuts</code> 默认。</p><p>下一步 <code>Application Documentation</code> 跳过。</p><p>下一步 <code>Setup Install Mode</code> 默认。</p><p>下一步 <code>Application Registry Keys And Values</code> 跳过。</p><p>下一步语言选择英语即可。</p><p>下一步 <code>Compiler Settings</code> 配置安装包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Custom compiler output folder: // 运行脚本文件后安装包生成的目录</span><br><span class="line">Compiler output base file name: LecSnake_Setup // 安装包名称</span><br><span class="line">Custom Setup icon file: // 安装包icon文件，非必要</span><br><span class="line">Setup password: // 安装密码，非必要</span><br><span class="line"></span><br><span class="line">-&gt; Next</span><br></pre></td></tr></table></figure><p>下一步 <code>Inno Setup Preprocessor</code> 保持默认即可。</p><p>点击 Finish 后即可看到生成的脚本文件，在自动弹出的弹窗点击“是”将开始执行脚本，或者在主程序左上角 <code>Run/Run</code> 随时执行脚本文件。等待一段时间执行完成后，在之前填写的 <code>Custom compiler output folder</code> 目录中即可找到安装程序。随后你可以选择保存脚本文件等待下一次的使用。</p><p>BiliBili教程-&gt;</p><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1MZQ8YTEeg&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><hr><h3 id="直接配置脚本文件"><a href="#直接配置脚本文件" class="headerlink" title="直接配置脚本文件"></a>直接配置脚本文件</h3><p>如果你已经了解了创建安装程序的基本规则，并相对熟悉了脚本文件的大致配置你可以直接修改脚本文件来配置规则，这样不仅自由度更高也更加方便修改。</p><p>以下展示大致脚本代码介绍与步骤：</p><h4 id="填写基本信息"><a href="#填写基本信息" class="headerlink" title="填写基本信息"></a>填写基本信息</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Setup]</span><br><span class="line">AppName=My Application</span><br><span class="line">AppVersion=<span class="number">1.0</span></span><br><span class="line">DefaultDirName=<span class="comment">&#123;pf&#125;</span>\MyApp</span><br><span class="line">DefaultGroupName=MyApp</span><br><span class="line">OutputDir=userdocs:Inno Setup Examples Output</span><br></pre></td></tr></table></figure><h4 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h4><p>在脚本的<code>[Files]</code>段添加：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Files]</span><br><span class="line">Source: &quot;C:\MyApp\*&quot;; DestDir: &quot;<span class="comment">&#123;app&#125;</span>&quot;; Flags: ignoreversion recursesubdirs</span><br></pre></td></tr></table></figure><h4 id="创建开始菜单项"><a href="#创建开始菜单项" class="headerlink" title="创建开始菜单项"></a>创建开始菜单项</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Icons]</span><br><span class="line"><span class="keyword">Name</span>: &quot;<span class="comment">&#123;group&#125;</span>\My <span class="keyword">Program</span>&quot;; Filename: &quot;<span class="comment">&#123;app&#125;</span>\MyApp.exe&quot;</span><br></pre></td></tr></table></figure><h4 id="编译脚本"><a href="#编译脚本" class="headerlink" title="编译脚本"></a>编译脚本</h4><p>点击工具栏的”Compile”按钮（或按F9），生成的安装包默认在<code>Output</code>目录</p><h3 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h3><h4 id="添加卸载程序"><a href="#添加卸载程序" class="headerlink" title="添加卸载程序"></a>添加卸载程序</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Setup]</span><br><span class="line">Uninstallable=yes</span><br><span class="line">UninstallFilesDir=<span class="comment">&#123;app&#125;</span>\uninstall</span><br><span class="line"></span><br><span class="line">[UninstallDelete]</span><br><span class="line"><span class="keyword">Type</span>: files; <span class="keyword">Name</span>: &quot;<span class="comment">&#123;app&#125;</span>\config.ini&quot;</span><br></pre></td></tr></table></figure><h4 id="注册表操作"><a href="#注册表操作" class="headerlink" title="注册表操作"></a>注册表操作</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Registry]</span><br><span class="line">Root: HKLM; Subkey: &quot;Software\MyApp&quot;; ValueType: <span class="keyword">string</span>; ValueName: &quot;InstallPath&quot;; ValueData: &quot;<span class="comment">&#123;app&#125;</span>&quot;</span><br></pre></td></tr></table></figure><h4 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Languages]</span><br><span class="line"><span class="keyword">Name</span>: &quot;english&quot;; MessagesFile: &quot;compiler:<span class="keyword">Default</span>.isl&quot;</span><br><span class="line"><span class="keyword">Name</span>: &quot;chinesesimplified&quot;; MessagesFile: &quot;compiler:Languages\ChineseSimplified.isl&quot;</span><br></pre></td></tr></table></figure><h4 id="自定义安装页面"><a href="#自定义安装页面" class="headerlink" title="自定义安装页面"></a>自定义安装页面</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Code]</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">InitializeWizard</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="comment">// 创建自定义页面示例</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>BiliBili:更美化的安装程序 -&gt; </p><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1jQ4y1o7zX&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>好啦，现在你不仅可以将应用程序打包成安装包，更方便的分享给朋友下载，还可以打包出更好看、更高级的安装程序。相信 <code>Inno Setup</code> 会为你带来帮助，我以后也会分享更多有趣、有用的东西，谢谢观看！</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装包 </tag>
            
            <tag> InnoSetup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity进阶学习笔记</title>
      <link href="/posts/bdafbbe3.html"/>
      <url>/posts/bdafbbe3.html</url>
      
        <content type="html"><![CDATA[<div class="note danger info flat"><p><strong>别急。</strong></p></div><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LecSnake - 3d贪吃蛇</title>
      <link href="/posts/5a49393d.html"/>
      <url>/posts/5a49393d.html</url>
      
        <content type="html"><![CDATA[<h1 id="一个Unity新手的3D贪吃蛇开发历程"><a href="#一个Unity新手的3D贪吃蛇开发历程" class="headerlink" title="一个Unity新手的3D贪吃蛇开发历程"></a>一个Unity新手的3D贪吃蛇开发历程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚好放寒假的时候，在大致进行了系统的Unity与C#的学习之后，我觉得我是时候做出一款游戏出来了。尽管之前跟随网上的教程完成过一两个简单的小项目，可那时候毕竟只能算是照猫画虎，学习了这么多知识之后也有必要通过一些项目来把这些知识巩固在脑海中，所以我就打算从头开始，自己做一款小游戏，不管是怎样的，至少先做出来再说吧！<br>我打算从相对简单的开始，不能急于求成。于是我打算做一种3D的贪吃蛇小游戏。因为我认为我这个项目的目的不是做的有多精美，多好玩，而是加强我的基本程序能力、熟练的使用unity编辑器的基础功能，在我需要的时候我能自己学会用什么、点什么、在哪里写些什么，而不是像最初稀里糊涂的跟着教程有样学样。<br>我打算在一个大场景中生成各种障碍物和食物，让贪吃蛇在场景中吃到食物来增加身体长度。在经过一段时间的研究与学习，经历了很多困难的解决与想法的改变后，最终我如愿完成了<strong>LecSnake（我们是卷王）-3D贪吃蛇小游戏</strong>。<br>在这个项目中，我不再是教程的模仿者，而是真正成为了系统的设计者。每一个技术决策背后，都是对Unity编辑器的深入探索和C#编程思维的锤炼。</p><p><img src="https://s2.loli.net/2025/03/19/dYlSAVHUgkP58vM.png" alt="Login"></p><p><img src="https://s2.loli.net/2025/03/21/eX8nhkplUNzGPWi.png" alt="游戏截图"></p><p><a href="https://github.com/flashfish777/LecSnake">项目链接</a></p><hr><h2 id="开发历程"><a href="#开发历程" class="headerlink" title="开发历程"></a>开发历程</h2><h3 id="🐍-贪吃蛇的进化"><a href="#🐍-贪吃蛇的进化" class="headerlink" title="🐍 贪吃蛇的进化"></a>🐍 贪吃蛇的进化</h3><p><strong>第一阶段：物理系统</strong>  </p><p>理想：</p><ul><li>用Rigidbody实现头部运动控制</li><li>通过Joint连接身体部件</li><li>期待呈现自然的物理摆动效果</li></ul><p>现实：</p><ul><li>刚体的摩擦力和重力导致速度不稳定</li><li>多节身体相互碰撞产生”卡顿链式反应”</li><li>惯性作用使转弯时身体完全失控</li></ul><p>一开始，我用刚体圆球来代表蛇的身体，用<code>WASD</code>控制蛇头的前后左右移动，然后用<code>Joint</code>组件来连接身体与身体，需要增加长度时，就在蛇尾部生成一个body球，然后连接到最后。我本想以此模拟顺滑的物理效果，可我发现并非如此。我发现刚体是有摩擦力和重力的，随着身体越来越多移动会越来越困难，这导致速度不平均。于是我花了很长时间磨合摩擦力与重力的数值，想通过调节数值来解决这个问题，最后我发现即使不使用重力不使用摩擦力都不能解决这个问题，于是我又将蛇头的移动方式从按下按键施加力变为简单的每帧改变坐标，我甚至锁定了所有身体的y轴使它们不再接触地面，但即使解决了速度问题依然还有其他问题，例如身体总会不规则的旋转，用线连接的身体也会有惯性导致蛇的身体乱动，而且最终也并没有很好的实现转弯时平滑的物理效果。所以我放弃了使用刚体来模拟物理效果，再次经过了一段时间的探索后，我找到了足够实现我需求的理想方法：</p><p><strong>第二阶段：返璞归真的坐标追踪法</strong>  </p><p>经过两周的反复试验，终于找到优雅的解决方案：</p><ul><li>改用立方体消除不规则旋转</li><li>创建历史坐标队列记录头部轨迹</li><li>身体部件按固定间隔跟随对应坐标</li></ul><p>我将球形身体改为方形，这样连起来更美观且能解决很多问题，然后在蛇的移动上，我使用了一个<code>historyPosition</code>列表存储蛇头走过的位置，然后将身体的坐标逐帧改为对应的坐标，而蛇头则是自动向前，由<code>AD</code>键控制左转和右转，空格加速。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 向前移动</span></span><br><span class="line">    transform.position += transform.forward * moveSpeed * Time.deltaTime;</span><br><span class="line">    <span class="comment">// 加速</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKey(KeyCode.Space))</span><br><span class="line">    &#123;</span><br><span class="line">        moveSpeed = <span class="number">40</span>;</span><br><span class="line">        bodySpeed = <span class="number">40</span>;</span><br><span class="line">fastCount += Time.deltaTime;</span><br><span class="line"><span class="keyword">if</span> (fastCount &gt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">0</span>) score--;</span><br><span class="line">            fastCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        moveSpeed = <span class="number">20</span>;</span><br><span class="line">        bodySpeed = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方向操控</span></span><br><span class="line"><span class="built_in">float</span> steerDirection = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">    transform.Rotate(Vector3.up * steerDirection * steerSpeed * Time.deltaTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存位置移动史</span></span><br><span class="line">positionHistory.Insert(<span class="number">0</span>, transform.position);</span><br><span class="line">    <span class="keyword">while</span> (positionHistory.Count &gt; bodyList.Count * Gap)</span><br><span class="line">        positionHistory.RemoveAt(positionHistory.Count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动身体</span></span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> body <span class="keyword">in</span> bodyList)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 point = positionHistory[Mathf.Clamp(index * Gap, <span class="number">0</span>, positionHistory.Count - <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让贪吃蛇的身体沿头部轨迹运动</span></span><br><span class="line">        Vector3 moveDirection = point - body.transform.position;</span><br><span class="line">        body.transform.position += moveDirection * bodySpeed * Time.deltaTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让身体朝向头部移动的方向</span></span><br><span class="line">        body.transform.LookAt(point);</span><br><span class="line"></span><br><span class="line">index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方案不仅实现了顺滑的蛇体运动，更让我深刻理解了<strong>数据驱动</strong>的设计哲学。当放弃对物理引擎的执念后，问题反而迎刃而解。<br>这样就实现了贪吃蛇的平滑移动了。这是我认为最耗脑筋的一个点，也是用了最长时间的一个点。</p><hr><h3 id="🍎-食物与障碍物"><a href="#🍎-食物与障碍物" class="headerlink" title="🍎 食物与障碍物"></a>🍎 食物与障碍物</h3><p>老实说这个地方没什么好讲的，当时做的时候也是简单完成，唯一值得思考的点就是在随机生成的时候要考虑到重叠生成，比如一个食物生成到一个树（障碍物）里面去了，于是我还思考了一下，考虑将场景分成很多格子来生成物体，随机格子的位置即可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (num &lt; <span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> x = Random.Range(<span class="number">1</span>, <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">int</span> z = Random.Range(<span class="number">1</span>, <span class="number">32</span>);</span><br><span class="line">    Quaternion spawnRotation = Quaternion.Euler(<span class="number">0</span>, Random.Range(<span class="number">0</span>, <span class="number">360</span>), <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!map[z, x])</span><br><span class="line">    &#123;</span><br><span class="line">        map[z, x] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        x = x &lt;= <span class="number">16</span> ? ((x - <span class="number">17</span>) * <span class="number">2</span> + <span class="number">1</span>) : ((x - <span class="number">16</span>) * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">        z = z &lt;= <span class="number">16</span> ? ((<span class="number">17</span> - z) * <span class="number">2</span> - <span class="number">1</span>) : ((<span class="number">16</span> - z) * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Vector3 spawnPosition = <span class="keyword">new</span> Vector3(x * <span class="number">25</span>, <span class="number">0.5f</span>, z * <span class="number">25</span>);</span><br><span class="line">        Instantiate(Treelist[<span class="number">0</span>], spawnPosition, spawnRotation);</span><br><span class="line"></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用后才发现按这样生成出来的位置都太有规律性了，有时候太整齐不是什么好事。如果贪吃蛇只能四向移动的话这样的生成方法明显更优。</p><p>在贪吃蛇碰到食物或障碍物后会将该物体销毁并执行对应的加分减分操作，然后再在场景一个一个随机位置生成一个对应物体使之不会越来越少。但后来我发现，其实可以在碰到物体时直接随机更改一下物体的坐标就可以了，而不用销毁再生成，省去了不必要的步骤与消费。</p><hr><h3 id="🗺️-小地图的实现"><a href="#🗺️-小地图的实现" class="headerlink" title="🗺️ 小地图的实现"></a>🗺️ 小地图的实现</h3><p>之后我想到在左上角放一个缩略地图的功能，可以更方便玩家查看附近的情况。具体步骤在之前的文章介绍过：<br> <a class="btn-beautify green larger" href="/posts/bf08e6b6.html" title="Unity日记：小地图"><i class="far fa-hand-point-right"></i><span>Unity日记：小地图</span></a></p><p>这个功能的实现，让我对Unity的多摄像机协作有了更深理解。</p><hr><h3 id="⚙️-暂停与设置"><a href="#⚙️-暂停与设置" class="headerlink" title="⚙️ 暂停与设置"></a>⚙️ 暂停与设置</h3><p>我添加了暂停按钮，通过<code>Time.timeScale</code>调整游戏的时间状态，并添加了一些选项设置。通过调节摄像机与音频给玩家带来不同的体验。<br><img src="https://s2.loli.net/2025/03/21/VReJ3ZzfDkbKmoC.png" alt="暂停的设置界面"></p><p>这个模块的开发，让我体会到<strong>系统隔离</strong>的重要性。</p><hr><h3 id="🔄-主界面场景切换"><a href="#🔄-主界面场景切换" class="headerlink" title="🔄 主界面场景切换"></a>🔄 主界面场景切换</h3><p>做到这里主要的功能基本就完成了，最后我想给游戏添加一个开始界面与背景，于是便在游戏启动时默认播放一个描述背景故事的视频，点击可以跳过，随后便进入开始界面。<br><img src="https://s2.loli.net/2025/03/19/dYlSAVHUgkP58vM.png" alt="开始界面"></p><p>我将它放在了一个独立的场景里，在场景中房里几颗树木烘托氛围。当玩家点击开始后就会跳转到游戏的主场景了。关于场景切换，在之前的文章亦有记载：</p><a class="btn-beautify red larger" href="/posts/fdbe57b8.html#%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD" title="Unity日记：场景切换与并发编程-异步加载"><i class="far fa-hand-point-right"></i><span>Unity日记：场景切换与并发编程-异步加载</span></a><p>在这个过程中，我真正理解了游戏状态管理的艺术。</p><hr><h3 id="💾-存档系统"><a href="#💾-存档系统" class="headerlink" title="💾 存档系统"></a>💾 存档系统</h3><p>在最后的最后，一款能让人玩下去的游戏一定离不开存档，于是我了解并学习了有关数据持久化的相关知识，并为我的贪吃蛇游戏添加了存档。存档实现的详情见以下文章：</p><a class="btn-beautify yellow larger" href="/posts/posts/a985624f.html#%E7%A4%BA%E4%BE%8B-1" title="Unity日记：存档系统-JSON-示例"><i class="far fa-hand-point-right"></i><span>Unity日记：存档系统-JSON-示例</span></a><p>我存储了食物和障碍物的坐标列表、<code>historyPosition</code>列表以及得分等数据简单实现了贪吃蛇游戏的存档系统。</p><p>2024年12月续：值得一提的是，我在面试微派的时候，面试官曾问我有没有想过不存食物和障碍物的坐标且仍能实现存档，当时我还云里雾里，知道面试官提了随机数种子的概念，我才想到可以用相同的随机数种子，生成的随机坐标就是和上一次一样的坐标了，障碍物和食物也会在原先的位置，这样只需要存以下种子，就依然可以实现存档。妙哉！</p><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个项目最宝贵的收获，是让我建立起<strong>独立解决问题</strong>的自信。当看到自己构思的系统通过自己的努力真正运转起来时，那种喜悦远超复制十个教程项目。期待在下一个项目中挑战更复杂的游戏程序设计，相信我的程序水平会越来越成熟！</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 游戏 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> 开发历程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习笔记</title>
      <link href="/posts/9526375f.html"/>
      <url>/posts/9526375f.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p><strong>CSharp知识点</strong></p></div><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><table><thead><tr><th align="left">类型</th><th align="left">描述</th><th align="left">范围</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">bool</td><td align="left">布尔值</td><td align="left">True 或 False</td><td align="left">False</td></tr><tr><td align="left">byte</td><td align="left">8 位无符号整数</td><td align="left">0 到 255</td><td align="left">0</td></tr><tr><td align="left">char</td><td align="left">16 位 Unicode 字符</td><td align="left">U +0000 到 U +ffff</td><td align="left">‘\0’</td></tr><tr><td align="left">decimal</td><td align="left">128 位精确的十进制值，28-29 有效位数</td><td align="left">(-7.9 x 1028 到 7.9 x 1028) &#x2F; 100 到 28</td><td align="left">0.0M</td></tr><tr><td align="left">double</td><td align="left">64 位双精度浮点型</td><td align="left">(+&#x2F;-)5.0 x 10-324 到 (+&#x2F;-)1.7 x 10308</td><td align="left">0.0D</td></tr><tr><td align="left">float</td><td align="left">32 位单精度浮点型</td><td align="left">-3.4 x 1038 到 + 3.4 x 1038</td><td align="left">0.0F</td></tr><tr><td align="left">int</td><td align="left">32 位有符号整数类型</td><td align="left">-2,147,483,648 到 2,147,483,647</td><td align="left">0</td></tr><tr><td align="left">long</td><td align="left">64 位有符号整数类型</td><td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td><td align="left">0L</td></tr><tr><td align="left">sbyte</td><td align="left">8 位有符号整数类型</td><td align="left">-128 到 127</td><td align="left">0</td></tr><tr><td align="left">short</td><td align="left">16 位有符号整数类型</td><td align="left">-32,768 到 32,767</td><td align="left">0</td></tr><tr><td align="left">uint</td><td align="left">32 位无符号整数类型</td><td align="left">0 到 4,294,967,295</td><td align="left">0</td></tr><tr><td align="left">ulong</td><td align="left">64 位无符号整数类型</td><td align="left">0 到 18,446,744,073,709,551,615</td><td align="left">0</td></tr><tr><td align="left">ushort</td><td align="left">16 位无符号整数类型</td><td align="left">0 到 65,535</td><td align="left">0</td></tr></tbody></table><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。</p><p>换句话说，它们指的是一个内存位置。使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是由一个变量改变的，其他变量会自动反映这种值的变化。<strong>内置的</strong> 引用类型有：<strong>object</strong>、<strong>dynamic</strong> 和 <strong>string</strong>。</p><h3 id="对象（Object）类型"><a href="#对象（Object）类型" class="headerlink" title="对象（Object）类型"></a>对象（Object）类型</h3><p><strong>对象（Object）类型</strong> 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 <code>System.Object</code> 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。</p><p>当一个值类型转换为对象类型时，则被称为 <strong>装箱</strong>；另一方面，当一个对象类型转换为值类型时，则被称为 <strong>拆箱</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> obj;</span><br><span class="line">obj = <span class="number">100</span>; <span class="comment">// 这是装箱</span></span><br></pre></td></tr></table></figure><h3 id="动态（Dynamic）类型"><a href="#动态（Dynamic）类型" class="headerlink" title="动态（Dynamic）类型"></a>动态（Dynamic）类型</h3><p>您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。</p><p>声明动态类型的语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> &lt;variable_name&gt; = <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> d = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。</p><h3 id="字符串（String）类型"><a href="#字符串（String）类型" class="headerlink" title="字符串（String）类型"></a>字符串（String）类型</h3><p><strong>字符串（String）类型</strong> 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：引号和 @引号。</p><p>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;runoob.com&quot;</span>;</span><br></pre></td></tr></table></figure><p>一个 @引号字符串：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">@&quot;runoob.com&quot;</span>;</span><br></pre></td></tr></table></figure><p>C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\）当作普通字符对待，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">@&quot;C:\Windows&quot;</span>;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;C:\\Windows&quot;</span>;</span><br></pre></td></tr></table></figure><p>@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">@&quot;&lt;script type=&quot;&quot;text/javascript&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;!--</span></span><br><span class="line"><span class="string">    --&gt;</span></span><br><span class="line"><span class="string">&lt;/script&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>用户自定义引用类型有：class（类）、interface（接口） 或 delegate（委托）。我们将在以后的章节中讨论这些类型。</p><h2 id="指针类型（不安全代码）"><a href="#指针类型（不安全代码）" class="headerlink" title="指针类型（不安全代码）"></a>指针类型（不安全代码）</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。</p><p>声明指针类型的语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type* identifier;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span>* cptr;</span><br><span class="line"><span class="built_in">int</span>* p1, p2, p3;</span><br><span class="line"><span class="built_in">int</span>*[] p4; <span class="comment">// p4是 指针的数组 而不是 数组的指针</span></span><br><span class="line"><span class="keyword">void</span>* p5; <span class="comment">// 指向未知类型的指针</span></span><br><span class="line"><span class="built_in">int</span>** p6; <span class="comment">// 指针的指针</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>当一个代码块使用 <strong>unsafe</strong> 修饰符标记时，C# 允许在函数中使用指针变量。<strong>不安全代码</strong>或非托管代码是指使用了<strong>指针</strong>变量的代码块</p><p>您可以使用 <strong>ToString()</strong> 方法检索存储在指针变量所引用位置的数据。下面的实例演示了这点：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UnsafeCodeApplication</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">            <span class="keyword">unsafe</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> <span class="keyword">var</span> = <span class="number">20</span>;</span><br><span class="line">                <span class="built_in">int</span>* p = &amp;<span class="keyword">var</span>;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Data is: &#123;0&#125; &quot;</span> , <span class="keyword">var</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Data is: &#123;0&#125; &quot;</span> , p-&gt;ToString());</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Address is: &#123;0&#125; &quot;</span> , (<span class="built_in">int</span>)p);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Data is: 20</span><br><span class="line">Data is: 20</span><br><span class="line">Address is: 77128984</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>为了编译不安全代码，您必须切换到命令行编译器指定 <strong>&#x2F;unsafe</strong> 命令行。</p><p>例如，为了编译包含不安全代码的名为 prog1.cs 的程序，需在命令行中输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csc /unsafe prog1.cs</span><br></pre></td></tr></table></figure><hr><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul><li>在namespace语句块中声明枚举（常用）</li><li>在class、struct语句块中也可以声明枚举</li><li><strong>枚举不能在函数语句块中声明！</strong></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Enum_practise</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">enum</span> Day &#123;</span><br><span class="line">        Sun,</span><br><span class="line">        Mon,</span><br><span class="line">        Tue,</span><br><span class="line">        Wed,</span><br><span class="line">        Thu,</span><br><span class="line">        Fri,</span><br><span class="line">        Sat</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnumTest</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Day today = Day.Sun;</span><br><span class="line">            <span class="keyword">switch</span> (today)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> Day.Sun:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期日&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Mon:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期一&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Tue:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期二&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Wed:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期三&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Thu:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;V我50&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Fri:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期五&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Sat:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期六&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量类型可以是所有变量类型</span></span><br><span class="line"><span class="built_in">int</span>[] arr1;</span><br><span class="line"><span class="built_in">int</span>[] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">int</span>[] arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] arr4 = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] arr5 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[,] arr;</span><br><span class="line"><span class="built_in">int</span>[,] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">int</span>[,] arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>, <span class="number">3</span>] &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                              &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">                              &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">int</span>[,] arr4 = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                              &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">                              &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">int</span>[,] arr5 = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">                &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><h2 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h2><p><strong>真正的数组的数组。与二维数组的区别：每个一维数组的长度可以不一样。</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[][] arr;</span><br><span class="line"><span class="built_in">int</span>[][] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][];</span><br><span class="line"><span class="built_in">int</span>[][] arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][] &#123; <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                              <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">5</span> &#125;,</span><br><span class="line">                              <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">6</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">int</span>[][] arr4 = <span class="keyword">new</span> <span class="built_in">int</span>[][] &#123; <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                              <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">5</span> &#125;,</span><br><span class="line">                              <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">6</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">int</span>[][] arr5 = &#123; <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                 <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">5</span> &#125;,</span><br><span class="line">                 <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">6</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h1><h2 id="ref-和-out"><a href="#ref-和-out" class="headerlink" title="ref 和 out"></a>ref 和 out</h2><h3 id="按引用传递参数（ref）"><a href="#按引用传递参数（ref）" class="headerlink" title="按引用传递参数（ref）"></a>按引用传递参数（ref）</h3><p>引用参数是一个对变量的<strong>内存位置的引用</strong>。当按引用传递参数时，与值参数不同的是，它不会为这些参数创建一个新的存储位置。引用参数表示与提供给方法的实际参数具有相同的内存位置。</p><p>在 C# 中，使用 <strong>ref</strong> 关键字声明引用参数。下面的实例演示了这点：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> x, <span class="keyword">ref</span> <span class="built_in">int</span> y</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">int</span> temp;</span><br><span class="line"></span><br><span class="line">         temp = x; <span class="comment">/* 保存 x 的值 */</span></span><br><span class="line">         x = y;    <span class="comment">/* 把 y 赋值给 x */</span></span><br><span class="line">         y = temp; <span class="comment">/* 把 temp 赋值给 y */</span></span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         NumberManipulator n = <span class="keyword">new</span> NumberManipulator();</span><br><span class="line">         <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">         <span class="built_in">int</span> a = <span class="number">100</span>;</span><br><span class="line">         <span class="built_in">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在交换之前，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在交换之前，b 的值： &#123;0&#125;&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 调用函数来交换值 */</span></span><br><span class="line">         n.swap(<span class="keyword">ref</span> a, <span class="keyword">ref</span> b);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在交换之后，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在交换之后，b 的值： &#123;0&#125;&quot;</span>, b);</span><br><span class="line"> </span><br><span class="line">         Console.ReadLine();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在交换之前，a 的值：100</span><br><span class="line">在交换之前，b 的值：200</span><br><span class="line">在交换之后，a 的值：200</span><br><span class="line">在交换之后，b 的值：100</span><br></pre></td></tr></table></figure><p>结果表明，<em>swap</em> 函数内的值改变了，且这个改变可以在 <em>Main</em> 函数中反映出来。</p><h3 id="按输出传递参数（out）"><a href="#按输出传递参数（out）" class="headerlink" title="按输出传递参数（out）"></a>按输出传递参数（out）</h3><p>return 语句可用于只从函数中返回一个值。但是，可以使用 <strong>输出参数</strong> 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。</p><p>下面的实例演示了这点：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> x </span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">int</span> temp = <span class="number">5</span>;</span><br><span class="line">         x = temp;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         NumberManipulator n = <span class="keyword">new</span> NumberManipulator();</span><br><span class="line">         <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">         <span class="built_in">int</span> a = <span class="number">100</span>;</span><br><span class="line">         </span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在方法调用之前，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">/* 调用函数来获取值 */</span></span><br><span class="line">         n.getValue(<span class="keyword">out</span> a);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在方法调用之后，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在方法调用之前，a 的值： 100</span><br><span class="line">在方法调用之后，a 的值： 5</span><br></pre></td></tr></table></figure><p>提供给输出参数的变量不需要赋值。当需要从一个参数没有指定初始值的方法中返回值时，输出参数特别有用。请看下面的实例，来理解这一点：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValues</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> x, <span class="keyword">out</span> <span class="built_in">int</span> y </span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;请输入第一个值： &quot;</span>);</span><br><span class="line">          x = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;请输入第二个值： &quot;</span>);</span><br><span class="line">          y = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         NumberManipulator n = <span class="keyword">new</span> NumberManipulator();</span><br><span class="line">         <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">         <span class="built_in">int</span> a , b;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">/* 调用函数来获取值 */</span></span><br><span class="line">         n.getValues(<span class="keyword">out</span> a, <span class="keyword">out</span> b);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在方法调用之后，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在方法调用之后，b 的值： &#123;0&#125;&quot;</span>, b);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果（取决于用户输入）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请输入第一个值：</span><br><span class="line">7</span><br><span class="line">请输入第二个值：</span><br><span class="line">8</span><br><span class="line">在方法调用之后，a 的值： 7</span><br><span class="line">在方法调用之后，b 的值： 8</span><br></pre></td></tr></table></figure><h3 id="ref-和-out的区别"><a href="#ref-和-out的区别" class="headerlink" title="ref 和 out的区别"></a>ref 和 out的区别</h3><ul><li>ref 传入的变量必须初始化，out 不用 （买票上车）</li><li>out 传入的变量必须在内部赋值，ref 不用 （买票下车）</li></ul><h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><p>变长参数允许在调用方法时传入不定长度的参数。变长参数是一个语法糖，本质上还是基于数组的实现</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>使用 params 关键字可以指定被params修饰的参数在传参时数目可变：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseParams</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">object</span>[] list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(list[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>调用方式主要有三种，第一种是传一个数组，第二种是传n个参数，第三种是不传入参数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UseParams(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="string">&quot;test&quot;</span>&#125;); <span class="comment">// 传入数组</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UseParams(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">// 传入多个参数</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UseParams(); <span class="comment">// 不传参</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>params关键字后面必为数组</li><li>数组类型可以是任意的类型</li><li>函数参数可以有别的参数和params关键字修饰的参数</li><li>函数参数中只能最多出现一个params关键字并且一定是在最后一组参数，前面可以有n个其他参数</li></ul><h2 id="命名实参"><a href="#命名实参" class="headerlink" title="命名实参"></a>命名实参</h2><p>通过命名实参，你可以为形参指定实参，方法是将实参与该形参的名称匹配，而不是与形参在形参列表中的位置匹配。有了命名实参，将不再需要将实参的顺序与所调用方法的形参列表中的形参顺序相匹配。 每个形参的实参都可按形参名称进行指定。 例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintOrderDetails(<span class="string">&quot;Gift Shop&quot;</span>, <span class="number">31</span>, <span class="string">&quot;Red Mug&quot;</span>);</span><br><span class="line"><span class="comment">// 卖家姓名、订单号和产品名称</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用命名实参调用</span></span><br><span class="line">PrintOrderDetails(orderNum: <span class="number">31</span>, productName: <span class="string">&quot;Red Mug&quot;</span>, sellerName: <span class="string">&quot;Gift Shop&quot;</span>);</span><br><span class="line">PrintOrderDetails(productName: <span class="string">&quot;Red Mug&quot;</span>, sellerName: <span class="string">&quot;Gift Shop&quot;</span>, orderNum: <span class="number">31</span>);</span><br></pre></td></tr></table></figure><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>有<strong>参数默认值</strong>的参数，一般称为可选参数。当调用函数时可以不传入该参数，不传就会使用默认值作为参数的值。</p><p>例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExampleMethod</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">required</span>, <span class="built_in">string</span> optionalstr = <span class="string">&quot;default string&quot;</span>, <span class="built_in">int</span> optionalint = <span class="number">10</span></span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line">anExample.ExampleMethod(<span class="number">3</span>); <span class="comment">// 后两个参数为默认值</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li><p>支持多参数默认值，每个参数都可以有默认值</p></li><li><p>如果要混用，可选参数必须写在普通参数后面</p></li><li><p>默认值必须是以下类型的表达式之一：</p><ul><li>常量表达式</li><li><code>new ValType() </code>形式的表达式，其中 <code>ValType</code> 是值类型，例如 <code>enum</code> 或 <code>struct</code></li><li><code>default(ValType)</code> 形式的表达式，其中 <code>ValType</code> 是值类型</li></ul></li><li><p>如果调用方为一系列可选形参中的任意一个形参提供了实参，则它必须为前面的所有可选形参提供实参，实参列表中不支持使用逗号分隔的间隔，如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//anExample.ExampleMethod(3, ,4);</span></span><br></pre></td></tr></table></figure><p>如果想要选择性提供实参，可以使用命名实参来实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anExample.ExampleMethod(<span class="number">3</span>, optionalint: <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>重载允许在<strong>同一作用域内定义多个同名函数</strong>，但这些函数<strong>必须在参数类型、个数或顺序上存在区别</strong>，以便编译器可以根据传递给函数的参数来确定调用哪个函数。在C#中，函数的重载是通过函数签名（函数名称和参数类型、数目以及顺序）来确定的，并不包括返回类型。可以定义相同函数名的函数，只要它们的参数有所不同即可。如果有多个函数符合调用条件，则编译器会选择最匹配的函数。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>命名一组功能相似的函数，减少函数名的数量，避免命名空间的污染</li><li>提升代码复用性与可读性</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ClassOverload CO = <span class="keyword">new</span> ClassOverload();</span><br><span class="line">        CO.GetInfo();</span><br><span class="line">        CO.GetInfo(<span class="number">2</span>);</span><br><span class="line">        CO.GetInfo(<span class="string">&quot;我是第3个重载方法&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        CO.GetInfo(<span class="number">2</span>, <span class="string">&quot;我是第4个重载方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ClassOverload</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是第1个重载方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo</span>(<span class="params"><span class="built_in">int</span> Num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;我是第<span class="subst">&#123;Num&#125;</span>个重载方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo</span>(<span class="params"><span class="built_in">string</span> Name, <span class="built_in">int</span> Num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Name&#125;</span>我有<span class="subst">&#123;Num&#125;</span>个参数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo</span>(<span class="params"><span class="built_in">int</span> Num, <span class="built_in">string</span> Name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Name&#125;</span>我有<span class="subst">&#123;Num&#125;</span>个参数,我的参数顺序与第3个方法不同&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol><li><p>在使用重载时只能通过不同的参数样式</p></li><li><p>不能通过访问权限、返回类型进行重新加载</p></li><li><p>方法的数目不会对重新加载造成影响</p></li><li><p>对于继承来说，如果某一方法在父类中是访问权限是private，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果</p></li><li><p>接口不能重载</p></li></ol><hr><h1 id="结构体（与类的区别）"><a href="#结构体（与类的区别）" class="headerlink" title="结构体（与类的区别）"></a>结构体（与类的区别）</h1><p>结构体提供了一种轻量级的数据类型，适用于表示简单的数据结构，具有较好的性能特性和值语义。</p><p><strong>与类的区别</strong></p><p>类和结构体在设计和使用时有不同的考虑因素，类适合表示复杂的对象和行为，支持继承和多态性，而结构体则更适合表示轻量级数据和值类型，以提高性能并避免引用的管理开销。</p><p>类和结构体有以下几个基本的不同点：</p><p><strong>数据类型：</strong></p><ul><li><strong>结构体是值类型（Value Type）：</strong> 结构体是值类型，它们在栈上分配内存，而不是在堆上。当将结构体实例传递给方法或赋值给另一个变量时，将复制整个结构体的内容。</li><li><strong>类是引用类型（Reference Type）：</strong> 类是引用类型，它们在堆上分配内存。当将类实例传递给方法或赋值给另一个变量时，实际上是传递引用（内存地址）而不是整个对象的副本。</li></ul><p><strong>变量：</strong></p><ul><li>结构体中声明的变量不能直接初始化。</li><li>类可以在声明时对变量初始化。</li></ul><p><strong>继承和多态性：</strong></p><ul><li><strong>结构体不能继承：</strong> 结构体不能继承其他结构体或类，也不能作为其他结构体或类的基类。结构体成员不能指定为 abstract、virtual 或 protected。</li><li><strong>类支持继承：</strong> 类支持继承和多态性，可以通过派生新类来扩展现有类的功能。</li></ul><p><strong>默认构造函数：</strong></p><ul><li><strong>结构体不能有无参数的构造函数、不能定义析构函数：</strong> 结构体不能包含无参数的构造函数。每个结构体都必须有至少一个有参数的构造函数。不能定义析构函数。</li><li><strong>类可以有无参数的构造函数：</strong> 类可以包含无参数的构造函数，如果没有提供构造函数，系统会提供默认的无参数构造函数。</li></ul><p><strong>实例：</strong></p><ul><li>类必须使用 New 操作符才能被实例化。</li><li>结构体可以不使用 New 操作符即可被实例化。如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。</li></ul><p><strong>赋值行为：</strong></p><ul><li>类型为类的变量在赋值时存储的是引用，因此两个变量指向同一个对象。</li><li>结构体变量在赋值时会复制整个结构，因此每个变量都有自己的独立副本。</li></ul><p><strong>传递方式：</strong></p><ul><li>类型为类的对象在方法调用时通过引用传递，这意味着在方法中对对象所做的更改会影响到原始对象。</li><li>结构体对象通常通过值传递，这意味着传递的是结构体的副本，而不是原始结构体对象本身。因此，在方法中对结构体所做的更改不会影响到原始对象。</li></ul><p><strong>可空性：</strong></p><ul><li>**结构体是值类型，不能直接设置为 null：**因为 <strong>null</strong> 是引用类型的默认值，而不是值类型的默认值。如果你需要表示结构体变量的缺失或无效状态，可以使用 <strong>Nullable<T></strong> 或称为 <strong>T?</strong> 的可空类型。</li><li><strong>类默认可为null：</strong> 类的实例默认可以为 <code>null</code>，因为它们是引用类型。</li></ul><p><strong>性能和内存分配：</strong></p><ul><li><strong>结构体通常更轻量：</strong> 由于结构体是值类型且在栈上分配内存，它们通常比类更轻量，适用于简单的数据表示。</li><li><strong>类可能有更多开销：</strong> 由于类是引用类型，可能涉及更多的内存开销和管理。</li></ul><hr><h1 id="面向对象理论"><a href="#面向对象理论" class="headerlink" title="面向对象理论"></a>面向对象理论</h1><h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><p><strong>类中一般包含：</strong></p><ul><li>特征——成员变量</li><li>行为——成员方法</li><li>保护特征——成员属性</li><li>构造函数和析构函数</li><li>索引器</li><li>运算符重载</li><li>静态成员</li></ul><p><strong>对象</strong>是类创建出来的，相当于申明一个指定类的变量，类创建对象的过程一般称为实例化对象，类对象都是引用类型的。</p><p><strong>实例化</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p;</span><br><span class="line">Person p2 = <span class="literal">null</span>; <span class="comment">// 与上面相同，没有分配堆内存，栈中为null</span></span><br><span class="line">Person p3 = <span class="keyword">new</span> Person(); <span class="comment">// 分配了堆内存</span></span><br></pre></td></tr></table></figure><h4 id="成员变量和访问修饰符"><a href="#成员变量和访问修饰符" class="headerlink" title="成员变量和访问修饰符"></a>成员变量和访问修饰符</h4><p><strong>成员变量基本规则</strong></p><ul><li>申明在类语句块中</li><li>用来描述对象的特征</li><li>可以是任意变量类型</li><li>数量不作限制</li><li>可以初始化</li><li>是否赋值根据需求来定</li></ul><p><strong>访问修饰符</strong></p><table><thead><tr><th></th><th>当前类</th><th>当前程序集下的类</th><th>其他程序集下的子类</th><th>其他程序集下的类</th></tr></thead><tbody><tr><td>public</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>protected</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>internal（默认）</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>private</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table><p><code>protected internal</code>: 成员可以由当前程序集或子类中的代码访问。</p><p><code>private protected</code>: 成员可以在其定义的类及子类中被访问，但仅当这些子类在同一个程序集中时。</p><p>**注意：**如果没有指定，则使用默认的访问标识符。类的默认访问标识符是 <strong>internal</strong>，成员的默认访问标识符是 <strong>private</strong>。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><strong>基本概念：</strong> 类的 <strong>构造函数</strong> 是类的一个特殊的成员函数，当创建类的新对象时执行。在实例化对象时，会调用的用于初始化的函数。</p><p><strong>写法：</strong> </p><ul><li><strong>构造函数的名称与类的名称完全相同</strong>，它没有任何返回类型。</li><li><strong>默认的构造函数</strong>没有任何参数。但是如果你需要一个带有参数的构造函数可以有参数，这种构造函数叫做<strong>参数化构造函数</strong>。</li><li>没有特殊需求时一般都是public的</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>构造函数可以被重载</li><li><code>this</code>关键字代表当前调用该函数的对象自己，数据类型为当前对象</li><li>如果不自己实现无参构造函数而实现了有参构造函数，会失去默认的无参构造</li></ul><p><strong>特殊写法：</strong></p><p>可以通过 <code>:</code> 运算符重用其他构造函数代码，例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Manager</span> : <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span>(<span class="params"><span class="built_in">int</span> annualSalary</span>) : <span class="title">base</span>(<span class="params">annualSalary</span>) <span class="comment">// 使用基类构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Add further instructions here.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">int</span> weeklySalary, <span class="built_in">int</span> numberOfWeeks</span>) : <span class="title">this</span>(<span class="params">weeklySalary * numberOfWeeks</span>) <span class="comment">// 使用当前类其他构造函数</span></span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做时，当使用此构造函数，函数会先调用 <code>:</code> 之后的构造函数，再执行当前构造函数的代码。</p><h4 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h4><p>主构造函数是 C# 12 中的一项新功能，可用于直接在构造函数参数列表中定义和初始化属性。此功能消除了对重复代码的需要，并使代码更加简洁和可读。</p><p>**概念：**主构造函数是一种简洁的语法，用于声明一个构造函数，其参数在类型的主体中的任何位置都可用。</p><p>**注意：**主构造函数的参数在整个类定义的范围内，因此可以使用它们来初始化属性、字段或其他成员。但是，默认情况下，它们不会存储为字段或属性，除非您显式将它们分配给一个字段或属性。它们也不能作为 或 访问，因为它们不是类的成员。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">string</span> firstName, <span class="built_in">string</span> lastName, DateTime hireDate, <span class="built_in">decimal</span> salary</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; = firstName;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; = lastName;  </span><br><span class="line">    <span class="keyword">public</span> DateTime HireDate &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; = hireDate;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Salary &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; = salary;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码等效于以下没有主构造函数的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> DateTime HireDate &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Salary &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">string</span> firstName, <span class="built_in">string</span> lastName, DateTime hireDate, <span class="built_in">decimal</span> salary</span>)</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        FirstName = firstName;  </span><br><span class="line">        LastName = lastName;  </span><br><span class="line">        HireDate = hireDate;  </span><br><span class="line">        Salary = salary;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**特殊写法：**使用主构造参数时仍可使用 <code>this</code> 或 <code>base</code> 关键字，使用特殊写法调用其他构造函数。</p><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p><strong>基本概念：</strong> 类的 <strong>析构函数</strong> 是类的一个特殊的成员函数，当类的对象超出范围时执行。当引用类型的堆内存被回收时，会调用该函数</p><p><strong>写法</strong>： 析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。</p><p><strong>注意：</strong></p><ul><li>析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载</li><li>对于需要手动管理内存的语言（比如c++），需要在析构函数中做一些内存回收处理，但是c#中存在自动垃圾回收机制GC，所以几乎不会这怎么使用析构函数，除非你想在某一个对象被垃圾回收时，做一些特殊处理</li><li>在Unity开发中析构函数几乎不会使用，所以该知识点只做了解即可</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Person() &#123;&#125; <span class="comment">// 析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="垃圾回收机制（GC）"><a href="#垃圾回收机制（GC）" class="headerlink" title="垃圾回收机制（GC）"></a>垃圾回收机制（GC）</h4><p><strong>概念：</strong></p><p>在编写程序时，会产生很多的数据 比如:int string 变量，这些数据都存储在内存里，如果不合理的管理他们，就会内存溢出导致程序崩溃。C#内置了自动垃圾回收GC，在编写代码时可以不需要担心内存溢出的问题 变量失去引用后 GC会帮我们自动回收，但不包括数据流，和一些数据库的连接，这就需要我们手动的释放资源</p><p><strong>垃圾回收</strong>，英文简写<strong>GC</strong>（<code>Garbage Collector</code>）。垃圾回收的过程是在遍历堆（Heap）上动态分配的所有对象，通过识别它们是否被引用来确定哪些对象是垃圾，哪些对象仍要被使用。所谓的垃圾就是没有被任何变量、对象引用的内容，垃圾就需要被回收释放。</p><p>垃圾回收有很多种算法，比如引用计数（Reference Counting）、标记清除（Mark Sweep）、标记整理（Mark Compact）、复制整合（Copy Collection）等。</p><p><strong>机制：</strong></p><p>代的概念：代是垃圾回收机制使用的一种算法（分代算法），新分配的对象都会被配置在弟0代内存中，每次分配都可能会进行垃圾回收以释放内存（0代内存满时），大对象总被认为是第二代内存，不会对大对象进行搬迁压缩，目的是减少性能损耗，85000字节（83kb）以上的对象为大对象。</p><p>过程：垃圾回收共分3代，每次创建对象的时候 都是在第0代分配内存，并且每一代都配有初始内存空间。假设现在程序已经跑了一段时间了，而第0代分配的空间已经满了，<strong>这时候就会进行垃圾回收，把失去引用的对象释放</strong>，此时未使用完的对象将进入到第1代。垃圾回收后，第0代就已经空了，后面创建的对象就会重新放入第0代，以此类推。0代满后，又会重新垃圾回收，还在使用的对象又会放入第1代，此后运行一段时间 1代也已经满了，而0代还在使用的对象也会移动到1代，这时候已经不够放了，又会进行垃圾回收，1代的将移动到2代，0代的将移动到1代（即1代进行垃圾回收时0代也会同时进行垃圾回收），以此类推。假如代数都满了，但对象都还在使用，并没有回收多少，这时GC就会自动的把初始内存给扩大，比如原来2MB扩大到4MB，还不够使用的情况下内存就满了，就会抛出异常。</p><p>**注意：**GC只负责堆内存的垃圾回收，引用类型都是存在堆中的，所以它们的分配和释放都通过垃圾回收机制来管理。栈上的内存是由系统自动管理的，值类型是在栈中分配内存的，它们有自己的生命周期，不用对他们进行管理，会自动分配和释放。</p><p><strong>手动执行垃圾回收：</strong></p><p>垃圾回收一般情况下是自动执行，如果想要手动执行垃圾回收，需要调动此行代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GC.Collect();</span><br></pre></td></tr></table></figure><p>一般情况下不会频繁进行垃圾回收，因为垃圾回收过程比较复杂耗时，可能会造成程序卡顿，通常在Loading界面时顺便进行一次垃圾回收。</p><h4 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h4><p><strong>概念：</strong></p><p>用于保护成员变量，为成员变量的获取和赋值添加逻辑处理。解决访问修饰符的局限性。属性可以让成员变量在外部只能获取不能修改或者只能修改不能获取。</p><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符  属性类型  属性名</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span>&#123;&#125; <span class="comment">//get需要返回值，没有返回值就会报错</span></span><br><span class="line">    <span class="keyword">set</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 可以在设置之前添加一些逻辑规则</span></span><br><span class="line">            <span class="comment">// 实现加密等操作</span></span><br><span class="line">            name = <span class="keyword">value</span>; </span><br><span class="line">            <span class="comment">// value关键字，表示外部传入的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 可以在返回之前添加一些逻辑规则</span></span><br><span class="line">            <span class="comment">// 实现解密等操作</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">            <span class="comment">// 这个属性可以获取内容</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">p.Name = <span class="string">&quot;LiMing&quot;</span>; <span class="comment">// &#x27;=&#x27; 默认调用set</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(p.Name); <span class="comment">// 直接使用默认调用get</span></span><br></pre></td></tr></table></figure><p>**成员属性中get和set前可以加访问修饰符：**默认不加会使用属性声明时的权限，加的访问修饰符要低于属性的访问权限，不能让set和get的访问权限都低于属性权限。</p><p><strong>自动属性</strong><br>类似于自动的成员变量，set和get会自动生成成员变量将他们包裹起来。</p><p>作用：外部能得不能改的特征，如果类中有一个特征是只希望外部能得不能改的，又没有什么特殊处理，就可以直接使用自动属性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> Height</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//没有在set,get中写逻辑的需求或者想法</span></span><br><span class="line"><span class="keyword">get</span>;</span><br><span class="line"><span class="keyword">set</span>;</span><br><span class="line"><span class="comment">//可以添加访问修饰符</span></span><br><span class="line"><span class="comment">//如：private set;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> Sex &#123; <span class="keyword">set</span>; <span class="keyword">get</span>; &#125; = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h4><p>**概念：**索引器允许通过类实例的索引来访问该类的实例成员。它的声明类似于属性，但具有参数。通常情况下，索引器用于允许类的实例像数组一样通过索引进行访问。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Person[] friends;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Person <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> friends[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// value代表传入的值</span></span><br><span class="line">            friends[index] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">p[<span class="number">0</span>] = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>索引器支持多维索引</li><li>C#允许对索引器进行重载</li><li>索引器可以具有多个参数，但每个参数的类型必须唯一</li><li>索引器的参数可以是值类型或引用类型</li><li>可以根据需要只声明 get 或 set 访问器，但至少必须实现其中一个</li></ul><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p><strong>概念：</strong></p><p>静态关键字：<code>static</code>，用static修饰的成员变量，方法，属性等称为静态成员。静态成员可以直接用类名点出来使用。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//静态成员变量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">float</span> PI=<span class="number">3.1415926f</span>;</span><br><span class="line">   <span class="comment">//成员变量</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> testInt=<span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//静态成员方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">CalcCircle</span>(<span class="params"><span class="built_in">float</span> r</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> PI*r*r;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//成员方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">     Console.WriteLine(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(Test.PI);</span><br><span class="line">Console.WriteLine（Test.CalcCircle(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p><strong>原理：</strong></p><p>为什么可以点出来使用：静态成员会有一片静态存储空间，与程序同生共死，一般不参与垃圾回收机制（除非静态引用变量定义为Null,才会参与垃圾回收）</p><p>程序不是无中生有的，我们要使用对象，变量，函数都是要在内存中分配内存空间，在程序中产生一个抽象的对象。</p><p>静态成员的特点：程序开始运行时就分配内存空间，所以我们可以直接使用。静态成员与程序同生共死，只要使用了它，直到程序结束才会被释放，一个静态成员有唯一的小房间，静态成员就有了唯一性。</p><p><strong>注意：</strong></p><ul><li>静态函数不能使用非静态成员，非静态函数可以使用静态成员</li><li>const常量和静态变量都可以通过类名点出来使用，但const常量必须初始化，不能修改，static没有这个规则，static可以修饰很多。const常量一定是写在访问修饰符后面，而static没有这个要求。</li></ul><h4 id="静态类和静态构造函数"><a href="#静态类和静态构造函数" class="headerlink" title="静态类和静态构造函数"></a>静态类和静态构造函数</h4><p><strong>静态类：<strong>用<code>static</code>关键字修饰的类称作静态类，静态类只能包含静态成员且不能被实例化。例如</strong>Console</strong>就是一个静态类。</p><p>**作用：**将常用的静态成员写在静态类中，方便使用。静态类不能被实例化，更能体现工具类的唯一性。</p><p>**静态构造函数：**用<code>static</code>关键字修饰的构造函数为静态构造函数，静态类和普通类都可以有静态构造函数。静态构造函数不能使用访问修饰符、不能有参数且只会自动调用一次。</p><p>**作用：**静态构造函数用于初始化静态变量。</p><p>静态构造函数不可继承、不可被直接调用，当创建类实例或引用任何静态成员之前，静态构造函数被自动执行，并且只执行一次。</p><h4 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h4><p>**概念：**为现有的非静态变量类型添加新方法。</p><p><strong>作用：</strong></p><ul><li>提升程序拓展性</li><li>不需要在对象中重新写方法</li><li>不需要继承来添加方法</li><li>为别人封装的类型写额外的方法</li></ul><p><strong>特点：</strong></p><ul><li>一定是写在静态类中</li><li>一定是个静态函数</li><li>第一个参数为拓展目标</li><li>第一个参数用this修饰</li></ul><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 返回值 函数名(<span class="keyword">this</span> 拓展类名 参数名, 参数类型 参数名, 参数类型 参数名, ...)</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为int拓展了一个成员方法</span></span><br><span class="line">    <span class="comment">//成员方法是需要实例化对象后才能使用的</span></span><br><span class="line">    <span class="comment">//value代表使用该方法的实例化对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpeakValue</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拓展的方法的逻辑</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;为int的拓展方法&quot;</span> + <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpeakStringInfo</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> str, <span class="built_in">string</span> str2, <span class="built_in">string</span> str3</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;为string拓展的方法&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;调用方法的对象&quot;</span> + str);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;传的参数&quot;</span> + str2 + str3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun2</span>(<span class="params"><span class="keyword">this</span> Test t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是为Test类拓展的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是自带的成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">i.SpeakValue();</span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;000&quot;</span>;</span><br><span class="line">str.SpeakStringInfo(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line">t.Fun2();</span><br></pre></td></tr></table></figure><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>**概念：**让自定义类和结构体能够使用运算符。</p><p><strong>关键字：</strong> <code>operator</code></p><p><strong>特点：</strong></p><ul><li>一定是一个公共的静态方法</li><li>返回值写在operator前</li><li>逻辑处理自定义</li></ul><p>**作用：**让自定义类和结构体对象可以进行运算。</p><p><strong>注意：</strong></p><ul><li><p>二元运算符需要成对实现</p><ul><li><p><code>==</code>（相等）对应 <code>!=</code>（不等）</p></li><li><p><code>&gt;</code>（大于）对应 <code>&lt;</code>（小于）</p></li><li><p><code>&gt;=</code>（大于等于）对应 <code>&lt;=</code>（小于等于）</p></li></ul></li><li><p>一个符号可以多个重载</p></li><li><p>不能使用 ref 和 out </p></li><li><p>参数列表至少要有一个当前类（或结构体）类型的参数</p></li></ul><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回类型 <span class="keyword">operator</span> 运算符( 参数列表 )</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> x;</span><br><span class="line">    <span class="built_in">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span>+(Point p1, Point p2)</span><br><span class="line">    &#123;</span><br><span class="line">        Point p = <span class="keyword">new</span> Point();</span><br><span class="line">        p.x = p1.x + p2.x;</span><br><span class="line">        p.y = p1.y + p2.y;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point();</span><br><span class="line">p.x = <span class="number">1</span>;</span><br><span class="line">p.y = <span class="number">1</span>;</span><br><span class="line">Point p2 = <span class="keyword">new</span> Point();</span><br><span class="line">p2.x = <span class="number">2</span>;</span><br><span class="line">p2.y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">Point p3 = p + p2;</span><br></pre></td></tr></table></figure><h4 id="内部类和分部类"><a href="#内部类和分部类" class="headerlink" title="内部类和分部类"></a>内部类和分部类</h4><p>**内部类：**在一个类中声明的类。</p><p>**特点：**使用时要用包裹者点出自己。</p><p>**作用：**亲密关系的变现 。</p><p>**注意：**访问修饰符作用很大。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> Body body;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Body</span></span><br><span class="line">    &#123;</span><br><span class="line">        Arm leftArm;</span><br><span class="line">        Arm rightArm;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">class</span> <span class="title">Arm</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person.Body body = <span class="keyword">new</span> Person.Body();</span><br></pre></td></tr></table></figure><p>**分部类：**把一个类分成几部分声明（关键字：<code>partial</code>）。</p><p>**作用：**增加程序的拓展性。</p><p><strong>注意：</strong></p><ul><li>分部类可以写在不同的脚本文件中</li><li>分部类的访问修饰符要一致</li><li>分部类中不能有重复成员</li></ul><p>**分部方法：**将方法的声明和实现分离（局限性大，了解即可）。</p><p><strong>特点：</strong></p><ul><li>不能加访问修饰符，默认私有</li><li>只能在分部类中声明</li><li>返回值只能是void</li><li>可以有参数但不能用 out 关键字</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> number;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"><span class="built_in">int</span> speed</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetHeight</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"><span class="built_in">int</span> speed</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承的基本原则"><a href="#继承的基本原则" class="headerlink" title="继承的基本原则"></a>继承的基本原则</h4><p>**基本概念：**当一个类A继承一个类B时，类A将会继承类B的所有成员，A类将拥有B类的所有特征和行为。被继承的类称为父类、基类、超类，继承的类称为子类、派生类。子类可以有自己的特征和行为。</p><p><strong>特点：</strong></p><ul><li>单根性：子类只能有一个父类（单继承）</li><li>传递性：子类可以间接继承父类的父类</li></ul><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 : 被继承的类名</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**同名成员：**在子类中出现与父类同名的成员，默认将父类的成员覆盖，也可以使用<code>new</code>关键字表示覆盖，但极其不建议使用同名成员。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">new</span> <span class="built_in">string</span> name;</span><br></pre></td></tr></table></figure><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><p>里氏替换原则是面向对象七大原则中最重要的原则</p><p>**基本概念：**任何父类出现的地方，子类都可替代。</p><p>**重点：**语法表现——父类容器装子类对象，因为子类对象包含了父类的所有内容。</p><p>**作用：**方便进行对象存储和管理。</p><p>**基本实现：**用父类容器装载子类对象</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Monster</span> : <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Boss</span> : <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">GameObject player = <span class="keyword">new</span> Player();</span><br><span class="line">GameObject[] objects = <span class="keyword">new</span> GameObject[] &#123; <span class="keyword">new</span> Player(), <span class="keyword">new</span> Monster(), <span class="keyword">new</span> Boss() &#125;;</span><br></pre></td></tr></table></figure><p><strong>is 和 as 关键字：</strong></p><ol><li><p><code>is</code>：判断一个类对象是否是指定类对象，返回值为<code>bool</code>，是为真，不是为假</p></li><li><p><code>as</code>：将一个对象转换为指定类对象，返回值为指定类型对象，成功返回指定类型对象，失败返回<code>null</code></p></li><li><p>基本语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 书接上回</span></span><br><span class="line"><span class="keyword">if</span> (player <span class="keyword">is</span> Player)</span><br><span class="line">&#123;</span><br><span class="line">    Player p = player <span class="keyword">as</span> Player;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注：不能用子类容器装父类对象</strong></p><h4 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h4><p>**特点：**当声明一个子类对象时，先执行父类的构造函数，再执行子类的构造函数。</p><p>**注意：**父类的无参构造很重要。子类可以通过base关键字代表父类，调用父类构造。</p><p>**继承中构造函数的执行顺序：**父类的父类的构造 -&gt; 父类构造 -&gt; 子类构造。子类实例化时，默认自动调用的是父类的无参构造，所以如果父类的无参构造被顶掉，会出错。</p><p><strong>通过base调用指定的父类构造：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Son</span> : <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span>(<span class="params"><span class="built_in">int</span> i</span>) : <span class="title">base</span>(<span class="params">i</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="万物之父和装箱拆箱"><a href="#万物之父和装箱拆箱" class="headerlink" title="万物之父和装箱拆箱"></a>万物之父和装箱拆箱</h4><p><strong>万物之父：</strong> <code>object</code> 是所有类型的基类，它是一个类（引用类型）。</p><p>**作用：**可以利用里氏替换原则，用 <code>object</code> 容器装所有对象。可以用来表示不确定类型，作为函数参数类型。</p><p><strong>装箱拆箱：</strong></p><ul><li>装箱：把值类型用引用类型存储（栈内存会迁移到堆内存中）</li><li>拆箱：把引用类型存储的值取出来（堆内存会迁移到栈内存中）</li><li>好处：不确定类型时可以方便参数的存储和传递</li><li>坏处：存在内存迁移，增加性能消耗</li></ul><h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><p>**概念：**密封类是使用 <code>sealed</code> 密封关键字修饰的类。密封类无法被继承。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Son</span> : <span class="title">Father</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>**作用：**在面向对象程序设计中，密封类的主要作用就是不允许最底层子类被继承，可以保证程序的规范性，安全性。</p><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="Vob"><a href="#Vob" class="headerlink" title="Vob"></a>Vob</h4><p>**多态的概念：**多态按字面的意思就是“多种状态”，让继承同一父类的子类们 在执行相同方法时有不同的表现（状态）。</p><p><strong>多态的实现：</strong></p><ul><li>编译时多态——函数重载</li><li>运行时多态：Vob、抽象函数、接口</li></ul><p><strong>Vob：</strong></p><ul><li>v： <code>virtual</code>（虚函数）</li><li>o： <code>override</code> （重写）</li><li>b： <code>base</code> （父类）</li><li>（n）： <code>new</code> （覆盖）</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GameObject</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//虚函数 可以被子类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;游戏对象进行攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//重写虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//base的作用</span></span><br><span class="line">        <span class="comment">//代表父类 可以通过base来保留父类的行为</span></span><br><span class="line">        <span class="keyword">base</span>.Atk();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;玩家对象进行攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Monster</span> : <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monster</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;怪物对象进行攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**主要目的：**同一父类的对象 执行相同行为（方法）有不同的表现。</p><p>**解决的问题：**让同一个对象有唯一行为的特征。</p><h4 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h4><p>**概念：**被抽象关键字 <code>abstract</code> 修饰的类为抽象类，方法称为抽象方法。</p><p><strong>特点：</strong></p><ul><li>抽象类不能被实例化，但仍可以使用里氏替换原则装它的子类</li><li>抽象方法只能在抽象类中声明，抽象方法没有方法体且不能是私有的</li><li>继承抽象类必须重写其抽象方法</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The dog barks.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The cat meows.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>**概念：**接口是行为的抽象规范，它也是一种自定义类型。关键字： <code>interface</code> 。</p><p><strong>接口声明的规范：</strong></p><ol><li>不能包含成员变量</li><li>只能包含方法、属性、索引器、事件</li><li>成员不能被实现</li><li>成员不能是私有的，但可以不写访问修饰符，默认是公共的</li><li>接口不能继承类，但可以继承另一个接口</li></ol><p><strong>接口的使用规范：</strong></p><ol><li>类可以继承多个接口</li><li>类继承接口后，必须实现接口中所有成员</li></ol><p><strong>特点：</strong></p><ol><li>和类的声明类似</li><li>接口只能用来继承，不能被实例化，但可以作为容器存储对象（里氏替换原则）</li><li>接口名称通常以大写字母 “I” 开头，表示接口（Interface）的含义，然后跟随具体的接口名称</li></ol><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;攻击&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IExampleInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Method1</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method2</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IExampleInterface2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method4</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IExampleInterfaceSon</span> : <span class="title">IExampleInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Method3</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Book</span> : <span class="title">GameObject</span>, <span class="title">IExampleInterfaceSon</span>, <span class="title">IExampleInterface2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method2</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method3</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method4</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显式实现接口：</strong></p><p>当一个类继承多个接口，但接口中存在同名方法时，可以使用显式实现接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Atk</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ISuperAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Atk</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">IAtk</span>, <span class="title">ISuperAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> IAtk.Atk() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> ISuperAtk.Atk() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**注：**显式实现接口不能写访问修饰符。</p><h4 id="密封方法"><a href="#密封方法" class="headerlink" title="密封方法"></a>密封方法</h4><p>**概念：**密封方法是使用 <code>sealed</code> 密封关键字修饰的重写方法，让虚方法或抽象方法在之后不能再被重写。</p><p>**特点：**和 <code>override</code> 一起出现。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="面向对象七大原则"><a href="#面向对象七大原则" class="headerlink" title="面向对象七大原则"></a>面向对象七大原则</h2><h3 id="开闭原则OCP"><a href="#开闭原则OCP" class="headerlink" title="开闭原则OCP"></a>开闭原则OCP</h3><p>开闭原则是设计原则基础的基础，是面向对象的核心原则，其它原则均围绕开闭原则进行展开。 </p><p>**开闭原则指的是一个软件实体应对对扩展开放，对修改关闭(Software entities should be open for extension, but closed for modification)。**这个原则是说在设计一个模块的时候，应对使这个模块可以在不被修改的前提下被扩展，换言之，应对可以不必修改源代码的情况下改变这个模块的行为。 </p><p><strong>满足开闭原则的软件系统的优越性：</strong> </p><ul><li><p>通过扩展已有的软件系统，可以提供新的行为，以满足对软件的新需求，使变化中的软件系统有一定的适应性和灵活性</p></li><li><p>已有的软件模块，特别是最重要的抽象层模块不能再修改，这就使变化中的软件系统有一定的稳定性和延续性</p></li></ul><p><strong>实现开闭原则的关键：</strong></p><p>抽象化是解决问题的关键，在面向对象的编程语言里，可以给系统定义出一套相对较为固定的抽象设计，此设计允许无穷无尽的行为在实现层被实现。在语言里，可以给出一个或多个抽象类或者接口，规定出所有的具体类必须提供的方法的特征作为系统设计的抽象层。这个抽象层预见了所有的可扩展性，因此，在任何扩展情况下都不会改变。这就使得系统的抽象不需要修改，从而满足了开闭原则的第二条，对修改关闭。 </p><p>同时，由于从抽象层导出一个或多个新的具体类可以改变系统的行为，因此系统的设计对扩展是开放的，这就满足了开闭原则的第一条。 </p><p><strong>对可变性的封装原则：</strong> </p><p><strong>把变化的东西封装起来，把不变的抽象出来。</strong> 这是对开闭原则的另外一种描述，它讲的是找到一个系统的可变因素，将之封装起来。该原则意味着两点: </p><ul><li><p>一种可变性不应当散落在代码的很多角落，而应当封装到一个对象里面。继承应当被看做是封装变化的方法，而不应该被认为是一种从一般对象生成特殊对象的方法</p></li><li><p>一种可变性不应当与另外一种可变性混合在一起。这意味着一般的继承层次不会超过两层</p></li></ul><h3 id="里氏替换原则LSP"><a href="#里氏替换原则LSP" class="headerlink" title="里氏替换原则LSP"></a>里氏替换原则LSP</h3><p>任何基类可以出现的地方，子类一定可以出现。**即父类存在的地方，子类是可以替换的。**替换后行为不变，结果会变化。调用子类行为。 子类和父类必须有相同行为才能完全地实现替换。 </p><p>实现开闭原则的关键是抽象化，而里氏代换原则中的基类和子类的继承关系正是抽象化的具体体现，所以里氏代换原则是对实现抽象化的具体步骤的规范。违反里氏代换原则一个最经典的例子便是把正方形设计成长方形的子类。</p><h3 id="依赖倒置原则DIP"><a href="#依赖倒置原则DIP" class="headerlink" title="依赖倒置原则DIP"></a>依赖倒置原则DIP</h3><p>**要依赖于抽象，不要依赖于实现。**说的白一点就是要依赖于抽象类和接口不要依赖具体类，具体类也就是我们可以用new关键字实例化的类。依赖倒转原则是实现开闭原则的一个手段。</p><h3 id="单一职责原则SRP（体现高内聚）"><a href="#单一职责原则SRP（体现高内聚）" class="headerlink" title="单一职责原则SRP（体现高内聚）"></a>单一职责原则SRP（体现高内聚）</h3><p><strong>每一个类应该专注于做一件事情。</strong></p><h3 id="接口隔离原则ISP"><a href="#接口隔离原则ISP" class="headerlink" title="接口隔离原则ISP"></a>接口隔离原则ISP</h3><p>**应当为客户端提供尽可能小的单独接口，而不要提供大的总接口。**暴露行为让后面的实现类知道的越少越好。</p><h3 id="迪米特法则（体现松偶合）"><a href="#迪米特法则（体现松偶合）" class="headerlink" title="迪米特法则（体现松偶合）"></a>迪米特法则（体现松偶合）</h3><p><strong>又叫最少知识原则，一个对象对另一个对象知道的越少越好，即一个软件实体应当尽可能少的与其他实体发生相互作用。</strong></p><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p><strong>要尽量使用合成&#x2F;聚合达到复用，而不是继承关系达到复用的目的。尽量少用继承。</strong> 就如我们前面说的，如果为了复用，便使用继承的方式将两个不相干的类联系在一起，这样的方式是违反合成&#x2F;聚合复用原则的，更进一步的后果那便是违反里氏代换原则。合成&#x2F;聚合复用和里氏代换原则相辅相成，合成&#x2F;聚合复用原则要求我们在复用时首先考虑合成&#x2F;聚合关系，而里氏代换原则是要求我们在使用继承时，必须满足一定的条件。 </p><p><strong>原则：一个类中有另一个类的对象。</strong></p><hr><h2 id="面向对象设计模式"><a href="#面向对象设计模式" class="headerlink" title="面向对象设计模式"></a>面向对象设计模式</h2><p><a href="https://blog.csdn.net/JSANXWT/article/details/126479362">面向对象设计的23种设计模式</a></p><hr><h2 id="面向对象相关"><a href="#面向对象相关" class="headerlink" title="面向对象相关"></a>面向对象相关</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>命名空间是用来组织和重用代码的，就像是一个工具包，类就像是一件一件的工具，都是声明在命名空间中的。命名空间的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。</p><p><strong>定义：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">namespace_name</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>命名空间可以分开声明且可以嵌套：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyGame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyGame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">UI</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">TestUI</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">Image</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">TestImage</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同一命名空间下不能含有同名类，不同命名空间下可以含有同名类：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Run</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Move</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Fly</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Move</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>1.使用 <code>using</code> 关键字引用其他命名空间使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MyGame; <span class="comment">// 只如此引用仍要通过指明出处才能引用该命名空间下的命名空间的类</span></span><br><span class="line"><span class="keyword">using</span> MyGame.UI; <span class="comment">// 如此引用只能使用UI命名空间的类，可以与MyGame同时引用</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Now</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameObject gameobject = <span class="keyword">new</span> GameObject();</span><br><span class="line">        Player player = <span class="keyword">new</span> Player();</span><br><span class="line">        TestUI testUI = <span class="keyword">new</span> TestUI();</span><br><span class="line">        </span><br><span class="line">        MyGame.Image.TestImage testImage = <span class="keyword">new</span> MyGame.Image.TestImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.指明出处使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Now</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.Console.WriteLine(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        MyGame.GameObject gameObject = <span class="keyword">new</span> MyGame.GameObject();</span><br><span class="line">        MyGame.Player player = <span class="keyword">new</span> MyGame.Player();</span><br><span class="line">        MyGame.Image.TestImage testImage = <span class="keyword">new</span> MyGame.Image.TestImage();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同名类只能通过指明出处使用</span></span><br><span class="line">        Run.Move move1 = <span class="keyword">new</span> Run.Move();</span><br><span class="line">        Fly.Move move2 = <span class="keyword">new</span> Fly.Move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（引用命名空间后也可指明出处使用）</p><p><strong>注：命名空间中的类默认为 internal 。</strong></p><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><h4 id="object中的静态方法"><a href="#object中的静态方法" class="headerlink" title="object中的静态方法"></a>object中的静态方法</h4><p><strong>静态方法 <code>Equals</code> ：</strong></p><p>判断两个对象是否相等。最终的判断权交给左侧对象的 Equals 成员方法，不管值类型还是引用类型都会按照左侧对象的 Equals 成员方法的规则来进行比较。</p><p><strong>静态方法 <code>ReferenceEquals</code> ：</strong></p><p>比较两个对象是否是相同的引用，主要是用来比较引用类型的对象，值类型对象返回值始终是 false 。</p><h4 id="object中的成员方法"><a href="#object中的成员方法" class="headerlink" title="object中的成员方法"></a>object中的成员方法</h4><p><strong>普通方法 <code>GetType</code> ：</strong></p><p>该方法的主要作用是获取对象运行时的类型 Type ，通过 Type 结合反射相关知识点可以做很多关于对象的操作。该方法在反射相关知识点中是非常重要的方法。</p><p><strong>普通方法 <code>MemberwiseClone</code>  ：</strong></p><p>该方法用于获取对象的浅拷贝对象，意思就是会返回一个新的对象，但是新对象中的引用变量会和老对象中的一致。</p><h4 id="object中的虚方法"><a href="#object中的虚方法" class="headerlink" title="object中的虚方法"></a>object中的虚方法</h4><p><strong>虚方法 <code>Equals</code> ：</strong></p><p>默认实现还是比较两者是否为同一个引用，即相当于 <code>ReferenceEquals</code> 。但是微软在所有类型值的基类 <code>System.ValueType</code> 中重写了该方法，用来比较值相等。我们也可以重写该方法，定义自己的比较规则。</p><p><strong>虚方法 <code>GetHashCode</code> ：</strong></p><p>该方法时获取对象的哈希码（一种通过算法算出的，表示对象的唯一编码，不同对象的哈希码有可能一样，具体值根据哈希算法决定），我们可以通过重写该函数来自己定义对象的哈希码算法，正常情况下，基本不用。</p><p><strong>虚方法 <code>ToString</code> ：</strong></p><p>该方法用于返回当前对象代表的字符串，我们可以重写它定义我们自己的对象转字符串规则，该方法非常常用。当我们调用打印方法时，默认使用的就是对象的 <code>ToString</code> 方法后打印出来的内容。</p><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>, <span class="number">1</span>, <span class="number">3333</span>);</span><br><span class="line">Console.Write(str);</span><br><span class="line"><span class="comment">// 输出 13333</span></span><br></pre></td></tr></table></figure><h4 id="正向查找字符位置"><a href="#正向查找字符位置" class="headerlink" title="正向查找字符位置"></a>正向查找字符位置</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> index = str.IndexOf(<span class="string">&quot;好&quot;</span>); <span class="comment">// 找不到返回-1</span></span><br><span class="line">Console.Write(index);</span><br><span class="line"><span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><h4 id="反向查找指定字符串位置"><a href="#反向查找指定字符串位置" class="headerlink" title="反向查找指定字符串位置"></a>反向查找指定字符串位置</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> index = str.LastIndexOf(<span class="string">&quot;哈哈&quot;</span>); <span class="comment">// 找不到返回-1</span></span><br><span class="line">Console.Write(index);</span><br><span class="line"><span class="comment">// 输出 4</span></span><br></pre></td></tr></table></figure><h4 id="移除指定位置后的字符（包括指定位置）"><a href="#移除指定位置后的字符（包括指定位置）" class="headerlink" title="移除指定位置后的字符（包括指定位置）"></a>移除指定位置后的字符（包括指定位置）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Remove(<span class="number">3</span>); <span class="comment">// 只会返回新字符串，不会修改原字符串</span></span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 你好哈</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Remove(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">// 第二个参数决定移除的字符个数</span></span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 你好哈哈哈</span></span><br></pre></td></tr></table></figure><h4 id="替换指定字符串"><a href="#替换指定字符串" class="headerlink" title="替换指定字符串"></a>替换指定字符串</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Replace(<span class="string">&quot;哈哈&quot;</span>, <span class="string">&quot;嘻嘻&quot;</span>);</span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 你好嘻嘻哈哈</span></span><br></pre></td></tr></table></figure><h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;jhsdgfhsdgfs&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.ToUpper(); <span class="comment">// 转大写</span></span><br><span class="line">newstr = str.ToLower(); <span class="comment">// 转小写</span></span><br></pre></td></tr></table></figure><h4 id="字符串截取（包含指定位置）"><a href="#字符串截取（包含指定位置）" class="headerlink" title="字符串截取（包含指定位置）"></a>字符串截取（包含指定位置）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Substring(<span class="number">2</span>); <span class="comment">// 截取从指定位置开始之后的字符串</span></span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 哈哈哈哈</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Substring(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 第二个参数表示截取指定个数</span></span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 哈哈</span></span><br></pre></td></tr></table></figure><h4 id="字符串切割"><a href="#字符串切割" class="headerlink" title="字符串切割"></a>字符串切割</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;1,2,3,4,5,6,7,8&quot;</span>;</span><br><span class="line"><span class="built_in">string</span>[] strs = str.Split(<span class="string">&#x27;,&#x27;</span>); <span class="comment">// 以逗号切割</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; strs.Length; i ++)</span><br><span class="line">    Console.Write(strs[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">// 输出 1 2 3 4 5 6 7 8</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p><code>string</code> 是特殊的引用，每次重新赋值或者拼接时会分配新的内存空间，如果一个字符串经常改变会非常浪费空间。</p><p><code>StringBuilder</code> 是c#提供的一个用于处理字符串的公共类，主要解决的问题是：直接修改字符串而不创建新的对象，需要频繁修改和拼接的字符串可以使用它，可以提升性能。</p><p><strong>注意使用时需要引用命名空间</strong></p><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;12213123123&quot;</span>, <span class="number">50</span>); <span class="comment">// 初始化与指定容量（可选）</span></span><br><span class="line"><span class="comment">// StringBuilder始终会有空余容量，超过会自动扩容，每次自动扩容容量翻一倍</span></span><br><span class="line">Console.WriteLine(str.Capacity); <span class="comment">// 获取容量</span></span><br><span class="line">Console.WriteLine(str.Length); <span class="comment">// 获取字符串长度</span></span><br></pre></td></tr></table></figure><p><strong>方法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加</span></span><br><span class="line">str.Append(<span class="string">&quot;8888&quot;</span>); <span class="comment">// 加到字符串末尾</span></span><br><span class="line">str.AppendFormat(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>, <span class="number">444</span>, <span class="number">666</span>); <span class="comment">// 通过拼接的形式添加</span></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">str.Insert(<span class="number">0</span>, <span class="string">&quot;2784356&quot;</span>); <span class="comment">// 插入位置 插入内容</span></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">str.Remove(<span class="number">0</span>, <span class="number">10</span>); <span class="comment">// 起始位置 删除个数</span></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">str.Clear();</span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="comment">// str[1] 直接索引</span></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 直接修改</span></span><br><span class="line"><span class="comment">// 替换</span></span><br><span class="line">str.Replace(<span class="string">&quot;34&quot;</span>, <span class="string">&quot;283645&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>StringBuilder</code> 的所有方法执行后都会直接修改原字符串，不需要重新定义。</p><hr><h1 id="数据结构类"><a href="#数据结构类" class="headerlink" title="数据结构类"></a>数据结构类</h1><h2 id="ArrayList类（可变数组）"><a href="#ArrayList类（可变数组）" class="headerlink" title="ArrayList类（可变数组）"></a>ArrayList类（可变数组）</h2><p><strong>概念：</strong> <code>ArrayList</code> 本质是一个 <code>object</code>类型的数组，实现了很多方法。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引用命名空间 System.Collections</span></span><br><span class="line">ArrayList array = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个增加</span></span><br><span class="line">array.Add(<span class="number">1</span>);</span><br><span class="line">array.Add(<span class="string">&quot;3424&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量增加（把另一个List容器里面的内容全部加到后面）</span></span><br><span class="line">array.AddRange(array2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">array.Insert(<span class="number">1</span>, <span class="string">&quot;12345&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.Remove(<span class="string">&quot;ghfjk&quot;</span>); <span class="comment">// 删除第一个指定元素</span></span><br><span class="line">array.RemoveAt(<span class="number">0</span>); <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">array.Clear(); <span class="comment">// 清空</span></span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到指定位置的元素</span></span><br><span class="line">Console.WriteLine(array[<span class="number">0</span>]); <span class="comment">// 直接读取下标</span></span><br><span class="line"><span class="comment">// 查看元素是否存在</span></span><br><span class="line">array.Contains(<span class="string">&quot;123&quot;</span>); <span class="comment">// 返回bool类型，有就返回true，没有返回false</span></span><br><span class="line"><span class="comment">// 正向查找元素位置</span></span><br><span class="line"><span class="built_in">int</span> index = array.IndexOf(<span class="string">&quot;gfh&quot;</span>); <span class="comment">// 返回元素下标，没有返回-1</span></span><br><span class="line"><span class="comment">// 反向查找元素位置</span></span><br><span class="line">index = array.LastIndexOf(<span class="string">&quot;111&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">0</span>] = <span class="string">&quot;3334&quot;</span>; <span class="comment">// 直接修改</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>装箱拆箱：</strong></p><p><code>ArrayList</code> 本质上是一个可以自动扩容的 <code>object</code> 数组，当往其中进行值类型存储时就是在装箱，当值类型对象取出来转换使用时就是在拆箱，所以 <code>ArrayList</code> 尽量少用，有更好的数据容器。</p><p><strong>注：</strong> <code>ArrayList</code> 同样具有容量，原理和作用与 <code>StringBuilder</code> 相同。</p><h2 id="Stack类（栈）"><a href="#Stack类（栈）" class="headerlink" title="Stack类（栈）"></a>Stack类（栈）</h2><p><strong>概念：</strong> <code>Stack</code> 的本质也是 <code>object</code> 数组，封装了栈的存储规则，栈是一种先进后出的数据结构。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引用命名空间 System.Collections</span></span><br><span class="line">stack stack = <span class="keyword">new</span> Stack();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压栈</span></span><br><span class="line">stack.Push(<span class="number">0</span>);</span><br><span class="line">stack.Push(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>取出</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弹栈</span></span><br><span class="line"><span class="built_in">object</span> v = stack.Pop();</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈无法查看指定位置的元素，只能查看栈顶的内容</span></span><br><span class="line">v = stack.Peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看元素是否存在于栈中</span></span><br><span class="line">stack.Contains(<span class="string">&quot;123&quot;</span>); <span class="comment">// true / false</span></span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈无法改变其中的元素，只能压和弹，实在要改，只有清空</span></span><br><span class="line">stack.Clear();</span><br></pre></td></tr></table></figure></li></ul><h2 id="Queue类（队列）"><a href="#Queue类（队列）" class="headerlink" title="Queue类（队列）"></a>Queue类（队列）</h2><p><strong>概念：</strong> <code>Queue</code> 的本质也是 <code>object</code> 数组，封装了队列的存储规则，队列是一种先进先出的数据结构。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引用命名空间 System.Collections</span></span><br><span class="line">Queue queue = <span class="keyword">new</span> Queue();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.Enqueue(<span class="number">1</span>);</span><br><span class="line">queue.Enqueue(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>取出</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> v = queue.Dequeue();</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看队列头部元素</span></span><br><span class="line">v = queue.Peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看元素是否在队列中</span></span><br><span class="line">queue.Contains(<span class="string">&quot;123&quot;</span>); <span class="comment">// true / false</span></span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列无法改变其中的元素，只能进和出，实在要改，只有清空</span></span><br><span class="line">queue.Clear();</span><br></pre></td></tr></table></figure></li></ul><h2 id="Hashtable类（哈希表）"><a href="#Hashtable类（哈希表）" class="headerlink" title="Hashtable类（哈希表）"></a>Hashtable类（哈希表）</h2><p><strong>概念：</strong> <code>Hashtable</code> （又称散列表）是基于键的哈希代码组织起来的键值对集合，它的主要作用是提高数据查询的效率，使用键来访问集合中的元素。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引用命名空间 System.Collections</span></span><br><span class="line">Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：不能出现相同键</span></span><br><span class="line">hashtable.Add(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">hashtable.Add(<span class="number">2</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">hashtable.Add(<span class="string">&quot;123&quot;</span>, <span class="number">2</span>); <span class="comment">// 第一个参数是key</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接通过键删除</span></span><br><span class="line">hashtable.Remove(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">hashtable.Clear();</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过键查找值 找不到会返回空</span></span><br><span class="line">Console.WriteLine(hashtable[<span class="string">&quot;key&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看是否存在</span></span><br><span class="line"><span class="comment">// 根据键检测</span></span><br><span class="line">hashtable.Contains(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">hashtable.ContainsKey(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="comment">// 根据值检测</span></span><br><span class="line">hashtable.Contains.ContainsValue(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能改键对应的内容，无法修改键</span></span><br><span class="line">hashtable[<span class="string">&quot;123&quot;</span>] = <span class="number">100.5f</span>;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型-1"><a href="#泛型-1" class="headerlink" title="泛型"></a>泛型</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>泛型实现了类型参数化，达到代码重用的目的，通过类型参数化来实现同一份代码上操作多种类型。</p><p>泛型相当于类型占位符，定义类或方法时使用替代符代表变量类型，当真正使用类或者方法时再具体指定类型。</p><h3 id="泛型类和接口"><a href="#泛型类和接口" class="headerlink" title="泛型类和接口"></a>泛型类和接口</h3><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestClass1</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestClass1</span> &#123; &#125; </span><br><span class="line"><span class="comment">// 泛型属于类名的一部分，即使它们名字相同，如果泛型不同（是否引用泛型、泛型引用个数），它们也不是同一个类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ITest</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型占位字母可以有多个，用逗号分开</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestClass2</span>&lt;<span class="title">T</span>, <span class="title">E</span>, <span class="title">M</span>, <span class="title">XXX</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T value1;</span><br><span class="line">    <span class="keyword">public</span> E value2;</span><br><span class="line">    <span class="keyword">public</span> XXX value3;</span><br><span class="line">    <span class="keyword">public</span> M value4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TestClass1&lt;<span class="built_in">int</span>&gt; t1 = <span class="keyword">new</span> TestClass1&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">t1.<span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line">TestClass1&lt;<span class="built_in">string</span>&gt; t2 = <span class="keyword">new</span> TestClass1&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">t2.<span class="keyword">value</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line">TestClass2&lt;<span class="built_in">int</span>, <span class="built_in">string</span>, <span class="built_in">float</span>, <span class="built_in">bool</span>&gt; t3 = <span class="keyword">new</span> TestClass2&lt;<span class="built_in">int</span>, <span class="built_in">string</span>, <span class="built_in">float</span>, <span class="built_in">bool</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>继承：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承时实现指定</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span> : <span class="title">ITest</span>&lt;<span class="title">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p><strong>普通类中的泛型方法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun1</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span> &#123; <span class="comment">/* 函数逻辑 */</span> &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 泛型可以有多个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun2</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt;()</span></span><br><span class="line">    &#123;</span><br><span class="line">        T t = <span class="literal">default</span>(T);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 可以用泛型类型做一些逻辑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 泛型作返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">TestFun3</span>&lt;<span class="title">T</span>&gt;()</span></span><br><span class="line">    &#123;</span><br><span class="line">        T Value;</span><br><span class="line">        <span class="keyword">return</span> Value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Test1 t1 = <span class="keyword">new</span> Test2();</span><br><span class="line"></span><br><span class="line">t1.TestFun1&lt;<span class="built_in">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">t1.TestFun1&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;12321312&quot;</span>);</span><br><span class="line"></span><br><span class="line">t1.TestFun2&lt;<span class="built_in">bool</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = t1.TestFun3&lt;<span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>泛型类中的泛型方法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T Value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这种不是泛型方法，T是类的泛型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">T t</span>)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这种才算泛型方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">E</span>&gt;(<span class="params">E e</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test2&lt;<span class="built_in">int</span>&gt; t2 = <span class="keyword">new</span> Test2&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">t2.TestFun&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;123213&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h3><ul><li>不同类型对象的相同逻辑处理就可以用泛型</li><li>使用泛型可以一定程度上避免装箱拆箱</li></ul><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><h3 id="什么是泛型约束"><a href="#什么是泛型约束" class="headerlink" title="什么是泛型约束"></a>什么是泛型约束</h3><p>**概念：**让泛型的类型有一定的限制。</p><p><strong>关键字：</strong> <code>where</code></p><p><strong>泛型约束一共有6种：</strong></p><ol><li>值类型： <code>where 泛型字母 : struct</code></li><li>引用类型： <code>where 泛型字母 : class</code></li><li>存在无参公共构造函数： <code>where 泛型字母 : new()</code></li><li>某个类本身或其派生类： <code>where 泛型字母 : 类名</code></li><li>某个接口的派生类型： <code>where 泛型字母 : 接口名</code></li><li>另一个泛型类型本身或者派生类型： <code>where 泛型字母 : 另一个泛型字母</code></li></ol><h3 id="约束的组合使用"><a href="#约束的组合使用" class="headerlink" title="约束的组合使用"></a>约束的组合使用</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span>, <span class="title">new</span>() &#123; &#125;</span><br><span class="line"><span class="comment">// 可以通过逗号组合使用</span></span><br></pre></td></tr></table></figure><h3 id="多个泛型有约束"><a href="#多个泛型有约束" class="headerlink" title="多个泛型有约束"></a>多个泛型有约束</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>, <span class="title">M</span>, <span class="title">E</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span>, <span class="title">new</span>() <span class="keyword">where</span> <span class="title">M</span> : <span class="title">new</span>() <span class="keyword">where</span> <span class="title">E</span> : <span class="title">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="泛型数据结构类"><a href="#泛型数据结构类" class="headerlink" title="泛型数据结构类"></a>泛型数据结构类</h1><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p><strong>概念：</strong> <code>List</code> 本质是一个可变类型的泛型数组，实现了很多方法。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入命名空间 System.Collections.Generic</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.Add(<span class="number">1</span>); <span class="comment">// 单加</span></span><br><span class="line">list.AddRange(list2); <span class="comment">// 批量加</span></span><br><span class="line">list.Insert(<span class="number">0</span>, <span class="number">999</span>); <span class="comment">// 插入</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.Remove(<span class="number">1</span>); <span class="comment">// 删除指定元素</span></span><br><span class="line">list.RemoveAt(<span class="number">0</span>); <span class="comment">// 删除指定位置元素</span></span><br><span class="line">list.Clear(); <span class="comment">// 清空</span></span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list[0] // 直接通过下标查找指定位置元素</span></span><br><span class="line">list.Contains(<span class="number">1</span>); <span class="comment">// 查看元素是否存在</span></span><br><span class="line">list.IndexOf(<span class="number">2</span>); <span class="comment">// 正向查找元素位置</span></span><br><span class="line">list.LastIndexOf(<span class="number">2</span>); <span class="comment">// 反向查找元素位置</span></span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list[<span class="number">0</span>] = <span class="number">99</span>; <span class="comment">// 直接修改</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>List排序</strong></p><ul><li><p>List自带的排序方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">list.Sort(); <span class="comment">// 默认升序</span></span><br></pre></td></tr></table></figure></li><li><p>自定义类的排序</p><p>继承并实现 <code>ICompareble</code> 接口或 <code>ICompareble&lt;T&gt;</code> 接口中的 <code>CompareTo</code> 方法，自定义排序规则，再使用 <code>Sort</code> 方法。</p></li><li><p>通过委托函数进行排序</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Fun</span>(<span class="params">自定义类名 a, 自定义类名 b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 传入的两个对象为列表中的两个对象</span></span><br><span class="line">    <span class="comment">// 进行两两比较</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现排序规则（返回值规则与CompareTo一样）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.Sort(Fun); <span class="comment">// 将排序函数传入Sort执行</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h2><p>**概念：**可以将 <code>Dictionary</code> 理解为拥有泛型的 <code>Hashtable</code> ，它也是基于键的哈希代码组织起来的键值对，键值对类型从 <code>object</code> 变为了可以自己制定的泛型。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入命名空间 System.Collections.Generic</span></span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意不能出现相同键</span></span><br><span class="line">dictionary.Add();</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能通过键删除</span></span><br><span class="line">dictionary.Remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">dictionary.Clear();</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dictionary[4] // 通过键查看值，找不到会返回空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看是否存在</span></span><br><span class="line"><span class="comment">// 根据键检测</span></span><br><span class="line">dictionary.ContainsKey(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 根据值检测</span></span><br><span class="line">dictionary.ContainsValue(<span class="string">&quot;23874&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary[<span class="number">1</span>] = <span class="string">&quot;555&quot;</span>; <span class="comment">// 直接修改</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="LinkedList（链表）"><a href="#LinkedList（链表）" class="headerlink" title="LinkedList（链表）"></a>LinkedList（链表）</h2><p><strong>概念：</strong>  <code>LinkedList</code> 本质是一个可变类型的泛型双向链表</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入命名空间 System.Collections.Generic</span></span><br><span class="line">LinkedList&lt;<span class="built_in">int</span>&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表尾部添加元素</span></span><br><span class="line">linkedList.AddLast(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 在链表头部添加元素</span></span><br><span class="line">linkedList.AddFirst(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 在某一个节点之后添加一个节点</span></span><br><span class="line">linkedList.AddAfter(node, <span class="number">15</span>);</span><br><span class="line"><span class="comment">// 在某一个节点之前添加一个节点</span></span><br><span class="line">linkedList.AddBefore(node, <span class="number">20</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除头节点</span></span><br><span class="line">linkedList.RemoveFirst();</span><br><span class="line"><span class="comment">// 移除尾节点</span></span><br><span class="line">linkedList.RemoveLast();</span><br><span class="line"><span class="comment">// 移除指定元素（不是指定位置的元素）</span></span><br><span class="line">linkedList.Remove(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">linkedList.Clear();</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头节点</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; first = linkedList.First;</span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; last = linkedList.Last;</span><br><span class="line"><span class="comment">// 找到指定值的节点,找不到返回空</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; node = linkedList.Find(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 判断是否存在</span></span><br><span class="line">linkedList.Contains(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先得到节点，再修改值</span></span><br><span class="line">node.Value = <span class="number">8</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="泛型栈和队列"><a href="#泛型栈和队列" class="headerlink" title="泛型栈和队列"></a>泛型栈和队列</h2><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入命名空间 System.Collections.Generic</span></span><br><span class="line"><span class="comment">// 名称不变，加上泛型即可</span></span><br><span class="line">Stack&lt;<span class="built_in">int</span>&gt; stack = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">Queue&lt;<span class="built_in">string</span>&gt; queue = <span class="keyword">new</span> Queue&lt;<span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>使用上与普通栈和队列基本没有区别。</strong></p><hr><h1 id="委托和事件"><a href="#委托和事件" class="headerlink" title="委托和事件"></a>委托和事件</h1><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>**委托是函数的容器。**可以理解为表示函数的变量类型，用来存储和传递函数。委托的本质是一个类，用来定义函数的类型（返回值和参数的类型），不同的函数必须对应和各自“格式”一致的委托。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><strong>关键字：</strong> <code>delegate</code></p><p><strong>语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="built_in">delegate</span> 返回值 委托名(参数列表);</span><br></pre></td></tr></table></figure><p><strong>可以声明在namespace和class语句块中，更多的写在namespace中，访问修饰符默认为public。</strong></p><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyFun1</span>()</span>; <span class="comment">// 声明了一个可以用来存储无参无返回值的函数的容器</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyFun2</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span>()</span> &#123; &#125; <span class="comment">// 无参无返回</span></span><br><span class="line"></span><br><span class="line">MyFun1 f1 = <span class="keyword">new</span> MyFun(Fun); <span class="comment">//装载Fun函数</span></span><br><span class="line">MyFun1 f2 = Fun; <span class="comment">// 另一种实现方法</span></span><br><span class="line"></span><br><span class="line">f1.Invoke(); <span class="comment">// 调用委托</span></span><br><span class="line">f2(); <span class="comment">// 另一种调用方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Fun2</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123; <span class="keyword">return</span> x; &#125; <span class="comment">// 有参有返回</span></span><br><span class="line"></span><br><span class="line">MyFun2 ff1 = Fun2;</span><br><span class="line">ff1(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>委托常用在：</p><ul><li>作为类的成员</li><li>作为函数的参数</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MyFun1 fun1;</span><br><span class="line">    <span class="keyword">public</span> MyFun2 fun2;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">MyFun1 fun1, MyFun2 Fun2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        fun1();</span><br><span class="line">        fun2(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多播委托（存储多个函数）"><a href="#多播委托（存储多个函数）" class="headerlink" title="多播委托（存储多个函数）"></a>多播委托（存储多个函数）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyFun1 f1 = Fun;</span><br><span class="line"></span><br><span class="line">f1 += Fun; <span class="comment">// 存了两个Fun函数</span></span><br><span class="line">f1 += Funa;</span><br><span class="line">f1 += Funb; <span class="comment">// 存储多个函数</span></span><br><span class="line"></span><br><span class="line">f1(); <span class="comment">// 调用委托时全部执行（按添加顺序）</span></span><br><span class="line"></span><br><span class="line">f1 -= FUn; <span class="comment">// 从f1委托中移除Fun函数</span></span><br><span class="line"></span><br><span class="line">f1 = <span class="literal">null</span>; <span class="comment">// 相当于清空委托 </span></span><br></pre></td></tr></table></figure><h3 id="系统定义好的委托"><a href="#系统定义好的委托" class="headerlink" title="系统定义好的委托"></a>系统定义好的委托</h3><p>使用系统自带委托，需要引用 <code>System</code> 命名空间。</p><p><strong>Action</strong></p><p>一个无参无返回的委托。</p><p><strong>Func&lt;out&gt;</strong></p><p>可以指定返回值类型的泛型委托。</p><p><strong>Action&lt;in…&gt;</strong></p><p>可以传n个参数的委托，系统提供了1到16个参数的委托。</p><p><strong>Func&lt;in…, out&gt;</strong></p><p>可以传n个参数的有返回值的委托，系统也提供了1到16个参数的写法。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>事件是一种特殊的变量类型。事件是基于委托的存在，是委托的安全包裹，让委托的使用更有安全性。</p><h3 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h3><p>委托怎么用，事件就怎么用。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">event</span> 委托类型 时间名;</span><br></pre></td></tr></table></figure><p><strong>与委托的区别：</strong></p><ul><li>事件只能作为成员存在于类和接口以及结构体中</li><li>事件不能在类的外部赋值</li><li>事件不能在类的外部调用</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 委托成员变量</span></span><br><span class="line">    <span class="keyword">public</span> Action myFun;</span><br><span class="line">    <span class="comment">// 事件成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action myEvent;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 事件的使用与委托一样</span></span><br><span class="line">        myFun = TestFun;</span><br><span class="line">        myFun += TestFun;</span><br><span class="line">        myFun();</span><br><span class="line">        myFun.Invoke();</span><br><span class="line">        </span><br><span class="line">        myEvent = TestFun;</span><br><span class="line">        myEvent += TestFun;</span><br><span class="line">        myEvent();</span><br><span class="line">        myEvent.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托可以在外部赋值</span></span><br><span class="line">t.myFun = <span class="literal">null</span>;</span><br><span class="line">t.myFun = TestFun;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件不能在外部赋值，但可以添加和移除记录的函数</span></span><br><span class="line"><span class="comment">// t.myEvent = TestFun;</span></span><br><span class="line">t.myEvent += TestFun;</span><br><span class="line">t.myEvent -= TestFun;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托可以在外部调用，事件不能在外面调用</span></span><br><span class="line">t.myFun();</span><br></pre></td></tr></table></figure><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ol><li>防止外部随意置空委托</li><li>防止外部随意调用委托</li><li>事件相当于对委托进行了一次封装，让其更加安全</li></ol><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>匿名函数，就是没有名字的函数。匿名函数的使用主要是配合委托和事件进行使用，脱离委托和事件一般不会用到匿名函数。</p><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delegate</span> (参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 函数逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h3><p>在函数中传递委托参数时和委托或事件赋值时使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Action a = <span class="built_in">delegate</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我是匿名函数&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">a += <span class="built_in">delegate</span> () &#123; <span class="comment">/* 函数逻辑 */</span> &#125;;</span><br><span class="line"></span><br><span class="line">Action&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; b = <span class="built_in">delegate</span> (<span class="built_in">int</span> x, <span class="built_in">string</span> str) &#123; <span class="comment">/* 函数逻辑 */</span> &#125;; <span class="comment">// 有参</span></span><br><span class="line"></span><br><span class="line">Func&lt;<span class="built_in">string</span>&gt; c = <span class="built_in">delegate</span> () &#123; <span class="keyword">return</span> <span class="string">&quot;123&quot;</span> &#125;; <span class="comment">// 有返回</span></span><br></pre></td></tr></table></figure><p>作为函数参数传递或作为函数返回值使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Action action;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 作为参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun1</span>(<span class="params"><span class="built_in">int</span> a, Action fun</span>)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 作为返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">Fun2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">delegate</span> () &#123;</span><br><span class="line">            <span class="comment">// 函数逻辑</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数传递</span></span><br><span class="line">t.Fun1(<span class="number">20</span>, <span class="built_in">delegate</span> () &#123;</span><br><span class="line">    <span class="comment">// 函数逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line">Action ac = t.Fun2(); <span class="comment">// 存起来</span></span><br><span class="line">t.Fun2()(); <span class="comment">// 直接调用</span></span><br></pre></td></tr></table></figure><h3 id="匿名函数的缺点"><a href="#匿名函数的缺点" class="headerlink" title="匿名函数的缺点"></a>匿名函数的缺点</h3><p>因为没有名字，所以添加到委托或事件中后不记录无法单独移除。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p>lambda表达式可以理解为匿名函数的简写，它除了写法不同外，使用上和匿名函数一模一样，都是配合委托或事件使用的。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用-6"><a href="#使用-6" class="headerlink" title="使用"></a>使用</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Action a = () =&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line">Action&lt;<span class="built_in">int</span>&gt; b = (<span class="built_in">int</span> x) =&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>参数类型也可省略，与委托和事件一致</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; a = <span class="literal">null</span>;</span><br><span class="line">a += (str, x) =&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>大括号和小括号也可省略，省略大括号默认是返回值且只有一行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; a = (x) =&gt; &#123; <span class="keyword">return</span> x * <span class="number">5</span>; &#125;; <span class="comment">// 有返回值</span></span><br><span class="line">a += x =&gt; x * <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>内层的函数可以引用包含在它外层的函数的变量，即使外层函数的执行已经终止。</p><p>注：该变量提供的值并非变量创建时的值，而是在父函数范围内的最终值。 </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action action;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里就形成了闭包</span></span><br><span class="line">    <span class="comment">// 因为当构造函数执行完毕时，其中声明的临时变量value的生命周期被改变了</span></span><br><span class="line">    action = () =&gt; &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="协变逆变"><a href="#协变逆变" class="headerlink" title="协变逆变"></a>协变逆变</h1><h2 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h2><p>**协变：**和谐的变化，自然的变化。例如因为里氏替换原则，所以子类变父类是和谐的。</p><p>**逆变：**逆常规的变化，不正常的变化。例如父类变子类是不和谐的。</p><p>逆变和协变是用来修饰泛型的，关键字：</p><ul><li>协变： <code>out</code></li><li>逆变： <code>in</code></li></ul><p>是用于在泛型中修饰泛型字母的，只有泛型接口和泛型委托能使用。</p><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p><strong>返回值和参数：</strong></p><p>用 <code>out</code> 修饰的泛型只能作为返回值，用 <code>in</code> 修饰的泛型只能作为参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">TestOut</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TestIn</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;()</span>;</span><br></pre></td></tr></table></figure><p><strong>结合里氏替换原则：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协变 父类总是能被子类替换</span></span><br><span class="line">TestOut&lt;Son&gt; os = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Son();</span><br><span class="line">&#125;;</span><br><span class="line">TestOut&lt;Father&gt; of = os;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆变 父类总是能被子类替换</span></span><br><span class="line">TestIn&lt;Father&gt; iF = <span class="keyword">value</span> =&gt; &#123; &#125;;</span><br><span class="line">TestIn&lt;Son&gt; iS = iF;</span><br><span class="line">iS(<span class="keyword">new</span> Son()); <span class="comment">// 实际上调用的是iF</span></span><br></pre></td></tr></table></figure><hr><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><a href="https://www.flashfish777.cn/posts/fdbe57b8.html#%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">blog</a></p><h2 id="相关语法"><a href="#相关语法" class="headerlink" title="相关语法"></a>相关语法</h2><p>C#提供了线程类 <code>Tread</code> ，需要引用命名空间 <code>System.Threading</code> 使用。</p><p><strong>声明一个线程：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread类重载了四种构造函数，最常用的需要传入一个无参无返回委托（或函数）</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(NewThreadFun);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NewThreadFun</span>()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p><strong>启动线程：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.Start();</span><br></pre></td></tr></table></figure><p><strong>设置为后台线程：</strong></p><p>声明的线程默认为前台线程，当前台线程都结束的时候整个程序才会结束，即使还有后台线程正在运行。后台线程不会防止应用程序的进程被终止掉，因此如果有线程没有设置为后台线程，此线程还未结束的话，可能导致进程无法正常关闭。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.IsBackground = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><strong>关闭释放一个线程：</strong></p><p>如果开启的线程不是死循环，是能够结束的逻辑，那么不用刻意的去关闭它。</p><p>如果想要终止一个线程，可以通过线程提供的方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.Abort(); <span class="comment">// 终止线程</span></span><br><span class="line">t = <span class="literal">null</span>; <span class="comment">// 置空（GC自动回收）</span></span><br></pre></td></tr></table></figure><p><strong>线程休眠：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tread.Sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 线程类的静态函数，让线程休眠n毫秒再继续执行</span></span><br><span class="line"><span class="comment">// 在哪个线程内部执行休眠的就是哪个线程</span></span><br></pre></td></tr></table></figure><h2 id="线程之间共享数据"><a href="#线程之间共享数据" class="headerlink" title="线程之间共享数据"></a>线程之间共享数据</h2><p>多个线程使用的内存是共享的，都属于该应用程序（进程），所以要注意，当多线程同时操作同一片内存区域时可能会出现问题，可以通过加锁的形式避免问题。</p><p>关键字： <code>lock</code></p><p>原理：当我们在多个线程当中想要访问同样的东西进行逻辑处理时，为了避免不必要的逻辑顺序执行的差错，可以使用 <code>lock</code> 锁避免同时执行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="keyword">lock</span>( obj ) <span class="comment">// 需要传入一个引用类型变量，这里以obj为例</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 语句...</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    Console.WriteLine(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">lock</span>( obj )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 语句...</span></span><br><span class="line">    a = <span class="number">99</span>;</span><br><span class="line">    Console.WriteLine(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当程序执行到 <code>lock</code> 语句块时，会先检测传入的引用类型变量，如果该变量（ <code>obj</code> ）被锁住了，程序就会一直等到 <code>obj</code> 解锁之后再运行 <code>lock</code> 语句块中的逻辑；相反，如果 <code>obj</code> 没被锁，程序就会执行 <code>lock</code> 语句块中的逻辑，同时将 <code>obj</code> 锁住，在逻辑执行完毕后解锁 <code>obj</code> 。</p><h2 id="多线程的意义"><a href="#多线程的意义" class="headerlink" title="多线程的意义"></a>多线程的意义</h2><p>多线程可以用来处理一些复杂耗时的逻辑，比如寻路、网络通信等等，可以专门开一个线程异步处理逻辑，避免卡顿。</p><hr><h1 id="预处理器指令"><a href="#预处理器指令" class="headerlink" title="预处理器指令"></a>预处理器指令</h1><h2 id="什么是预处理器指令"><a href="#什么是预处理器指令" class="headerlink" title="什么是预处理器指令"></a>什么是预处理器指令</h2><p>**预处理器指令是指导编译器在实际编译开始之前对信息进行预处理的指令。**预处理器指令都是以 <code>‘#’</code> 开始，且因为它们不是语句，所以不以分号结束。</p><h2 id="常见的预处理器指令"><a href="#常见的预处理器指令" class="headerlink" title="常见的预处理器指令"></a>常见的预处理器指令</h2><table><thead><tr><th align="left">指令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>#define</code></td><td align="left">定义一个符号，可以用于条件编译。</td></tr><tr><td align="left"><code>#undef</code></td><td align="left">取消定义一个符号。</td></tr><tr><td align="left"><code>#if</code></td><td align="left">开始一个条件编译块，如果符号被定义则包含代码块。</td></tr><tr><td align="left"><code>#elif</code></td><td align="left">如果前面的 <code>#if</code> 或 <code>#elif</code> 条件不满足，且当前条件满足，则包含代码块。</td></tr><tr><td align="left"><code>#else</code></td><td align="left">如果前面的 <code>#if</code> 或 <code>#elif</code> 条件不满足，则包含代码块。</td></tr><tr><td align="left"><code>#endif</code></td><td align="left">结束一个条件编译块。</td></tr><tr><td align="left"><code>#warning</code></td><td align="left">生成编译器警告信息。</td></tr><tr><td align="left"><code>#error</code></td><td align="left">生成编译器错误信息。</td></tr><tr><td align="left"><code>#region</code></td><td align="left">标记一段代码区域，可以在IDE中折叠和展开这段代码，便于代码的组织和阅读。</td></tr><tr><td align="left"><code>#endregion</code></td><td align="left">结束一个代码区域。</td></tr><tr><td align="left"><code>#line</code></td><td align="left">更改编译器输出中的行号和文件名，可以用于调试或生成工具的代码。</td></tr><tr><td align="left"><code>#pragma</code></td><td align="left">用于给编译器发送特殊指令，例如禁用或恢复特定的警告。</td></tr><tr><td align="left"><code>#nullable</code></td><td align="left">控制可空性上下文和注释，允许启用或禁用对可空引用类型的编译器检查。</td></tr></tbody></table><hr><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="程序集"><a href="#程序集" class="headerlink" title="程序集"></a>程序集</h2><p>程序集是经由编译器编译得到的，供进一步编译执行的中间产物，在windows系统中，它一般表现为 <code>.dll（代码库文件）</code> 或 <code>.exe（可执行文件）</code> 的格式。 </p><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>元数据就是用来描述数据的数据。</p><p>例如程序中的类，类中的函数、变量等信息就是程序的元数据。有关程序以及类型的数据被称为元数据，它们保存在程序集中。</p><h2 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h2><p>程序正在运行时，可以查看其他程序集或者自身的元数据。一个运行的程序查看本身或者其他程序的元数据的行为就叫做反射。</p><h2 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h2><p>因为反射可以在程序编译后获得信息，所以它提高了程序的拓展性和灵活性。</p><ol><li>程序运行时得到所有元数据，包括元数据的特性</li><li>程序运行时实例化对象，操作对象</li><li>程序运行时创建对象，用这些对象执行任务</li></ol><h2 id="相关语法-1"><a href="#相关语法-1" class="headerlink" title="相关语法"></a>相关语法</h2><p>这里先放一个例子类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">string</span> str</span>) : <span class="title">this</span>(<span class="params">i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">string</span> str</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Type类"><a href="#Type类" class="headerlink" title="Type类"></a>Type类</h3><p><code>Type（类的信息类）</code> 是反射功能的基础，它是访问元数据的主要方式。使用 <code>Type</code> 的成员获取有关类型声明的信息，有关类型的成员（如构造函数、方法、字段、属性和类的事件）。</p><p><strong>获取Type：</strong></p><ol><li><p><code>object</code> 类中的 <code>GetType()</code> 方法可以获取对象的Type：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">42</span>;</span><br><span class="line">Type type = a.GetType();</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>typeof</code> 关键字传入类名，也可以等到对象的Type：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type type = <span class="keyword">typeof</span>(Test);</span><br></pre></td></tr></table></figure></li><li><p>通过类的名字也可以获取类型（注意类名必须包含命名空间，不然找不到）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type type = Type.GetType(<span class="string">&quot;System.Int32&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p><strong>得到类的程序集信息：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(type.Assembly);</span><br></pre></td></tr></table></figure><p><strong>获取类中的所有公共成员：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先得到Type</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span><br><span class="line"><span class="comment">// 然后得到所有公共成员</span></span><br><span class="line"><span class="comment">// 需要引用命名空间 System.Reflection</span></span><br><span class="line">MemberInfo[] infos = t.GetMembers();</span><br></pre></td></tr></table></figure><p><strong>获取类的公共构造函数并调用：</strong></p><ol><li><p>获取所有构造函数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConstructorInfo[] ctors = t.GetConstructors();</span><br></pre></td></tr></table></figure></li><li><p>获取其中一个构造函数并执行</p><p>得构造函数传入Type数组，数组中内容按顺序是参数类型；</p><p>执行构造函数传入object数组，表示按顺序传入的参数。</p><ol><li><p>得到无参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConstructorInfo info = t.GetConstructor(<span class="keyword">new</span> Type[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>执行无参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造没有参数需要传null，该方法会返回object对象</span></span><br><span class="line">Test test = info.Invoke(<span class="literal">null</span>) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure></li><li><p>得到有参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConstructorInfo info = t.GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br><span class="line"><span class="comment">// 获取只有一个int类型参数的构造函数</span></span><br><span class="line">ConstructorInfo info = t.GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">typeof</span>(<span class="built_in">string</span>) &#125;);</span><br><span class="line"><span class="comment">// 获取两个参数的构造函数</span></span><br></pre></td></tr></table></figure><p>执行有参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test test1 = info.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">88</span> &#125;) <span class="keyword">as</span> Test;</span><br><span class="line">Test test2 = info.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">88</span>, <span class="string">&quot;Hello&quot;</span>&#125;) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><strong>获取类的公共成员变量：</strong></p><ol><li><p>得到所有成员变量：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FieldInfo[] fieldInfos = t.GetFields();</span><br></pre></td></tr></table></figure></li><li><p>得到指定名称的公共成员变量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FieldInfo infoJ = t.GetField(<span class="string">&quot;j&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过反射获取和设置对象的值</p><ol><li><p>通过反射获取对象的某个变量的值</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line">test.j = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(infoJ.GetValue(test));</span><br></pre></td></tr></table></figure></li><li><p>通过反射设置指定对象的某个变量的值</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infoJ.SetValue(test, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><strong>获取类的公共成员方法：</strong></p><ol><li><p>得到所有成员方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodInfo[] methods = t.GetMethods();</span><br></pre></td></tr></table></figure></li><li><p>获取一个成员方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果存在方法重载，用Type数组表示参数类型</span></span><br><span class="line">MethodInfo method1 = t.GetMethod(<span class="string">&quot;Speak&quot;</span>, <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">typeof</span>(<span class="built_in">string</span>) &#125;);</span><br><span class="line">MethodInfo method2 = t.GetMethod(<span class="string">&quot;Speak&quot;</span>, <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br></pre></td></tr></table></figure></li><li><p>调用方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数相当于是那个对象要执行这个成员方法</span></span><br><span class="line"><span class="comment">// 如果是静态方法，第一个参数传null即可</span></span><br><span class="line">method1.Invoke(test, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">1</span>, <span class="string">&quot;123&quot;</span> &#125;);</span><br><span class="line">method2.Invoke(test, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure></li></ol><p><strong>其他：</strong></p><ul><li>得枚举： <code>GetEnumName</code> 、 <code>GetEnumNames</code></li><li>得事件： <code>GetEvent</code> 、 <code>GetEvents</code></li><li>得接口： <code>GetInterface</code> 、 <code>GetInterfaces</code></li><li>得属性： <code>GetProperty</code> 、 <code>GetPropertys</code></li></ul><h3 id="Assembly类"><a href="#Assembly类" class="headerlink" title="Assembly类"></a>Assembly类</h3><p>程序集类。主要用来加载其他程序集，加载后才能用Type来使用其他程序集的信息，如果想要使用不是当前程序集的内容，需要先加载程序集。比如 <code>dll（库文件）</code> ，简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。</p><p>三种加载程序集的函数：</p><ul><li><p>一般用来加载在同一文件下的其他程序集</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assembly assembly1 = Assembly.Load(<span class="string">&quot;程序集名称&quot;</span>)；</span><br></pre></td></tr></table></figure></li><li><p>一般用来加载不在同一文件下的其他程序集</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Assembly assembly2 = Assembly.LoadFrom(<span class="string">&quot;包含程序集清单的文件的名称或路径&quot;</span>);</span><br><span class="line">Assembly assembly3 = Assembly.LoadFile(<span class="string">&quot;要加载的文件的完全限定路径&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先加载一个指定程序集</span></span><br><span class="line">Assembly assembly Assembly.LoadFrom(<span class="string">&quot;...&quot;</span>);</span><br><span class="line"><span class="comment">// 获取所有Type</span></span><br><span class="line">Type[] types = assembly.GetTypes();</span><br><span class="line"><span class="comment">// 加载程序集中的一个类对象，之后才能使用反射</span></span><br><span class="line">Type icon = assembly.GetType(<span class="string">&quot;...&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Activator类"><a href="#Activator类" class="headerlink" title="Activator类"></a>Activator类</h3><p>实例化对象的类，用于将Type对象快捷实例化为对象。</p><ol><li><p>无参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span><br><span class="line">Test testObj = Activator.CreateInstance(t) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure></li><li><p>有参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testObj = Activator.CreateInstance(t, <span class="number">99</span>) <span class="keyword">as</span> Test; <span class="comment">// 一个参数的</span></span><br><span class="line">testObj = Activator.CreateInstance(t, <span class="number">99</span>, <span class="string">&quot;123&quot;</span>) <span class="keyword">as</span> Test; <span class="comment">// 两个参数的</span></span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h2><p>特性是允许我们向程序的程序集添加元数据的语言结构，它是用于保存程序结构信息的某种特殊类型的类。特性提供功能强大的方法以将声明信息与C#代码（类型、方法、属性等）相关联。特性与程序实体关联后，即可在运行时使用反射查询特性信息。特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集中，它可以放置在几乎所有的声明中（类、变量、函数等等）。</p><p><strong>简而言之：特性本质上是个类，我们可以利用特性类为元数据添加额外信息。比如一个类、成员变量、成员方法等等为它们添加更多的额外信息，之后可以通过反射来获取这些额外信息。</strong></p><h2 id="自定义特性"><a href="#自定义特性" class="headerlink" title="自定义特性"></a>自定义特性</h2><p>声明一个类继承特性基类 <code>Attribute</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyTestAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 根据需求来写特性中的成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> info;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestAttribute</span>(<span class="params"><span class="built_in">string</span> info</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用特性"><a href="#使用特性" class="headerlink" title="使用特性"></a>使用特性</h2><p>基本语法： <code>[特性名(参数列表)]</code> </p><p>本质上就是在调用特性类的构造函数，写在类、函数、变量上一行，表示它们具有该特性信息。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MyTest(<span class="string">&quot;这是一个类&quot;</span>)</span>] <span class="comment">// 特性名中的Attribute系统会默认省略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可以加到成员变量前</span></span><br><span class="line">    [<span class="meta">MyTest(<span class="string">&quot;这是一个成员变量&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以加到函数前</span></span><br><span class="line">    [<span class="meta">MyTest(<span class="string">&quot;这是一个函数&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 甚至可以加到函数参数前</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun2</span>(<span class="params"> [MyTest(<span class="string">&quot;这是一个函数参数&quot;</span></span>)]<span class="built_in">int</span> x )</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限制特性使用范围"><a href="#限制特性使用范围" class="headerlink" title="限制特性使用范围"></a>限制特性使用范围</h2><p>通过为特性类加特性限制其使用范围</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)</span>]</span><br><span class="line"><span class="comment">// 参数一：AttributeTargets —— 特性能够用在哪些地方</span></span><br><span class="line"><span class="comment">// 参数二：AllowMultiple —— 是否允许多个特性实例用在同一个目标上</span></span><br><span class="line"><span class="comment">// 参数三：Inherited —— 特性是否能被派生类和重写成员继承</span></span><br></pre></td></tr></table></figure><h2 id="系统自带特性"><a href="#系统自带特性" class="headerlink" title="系统自带特性"></a>系统自带特性</h2><h3 id="过时特性"><a href="#过时特性" class="headerlink" title="过时特性"></a>过时特性</h3><p><strong>关键字：</strong> <code>Obsolete</code> 特性</p><p>用于提示用户使用的方法等成员已经过时，建议使用新方法。一般加在函数前的特性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数一：调用过时方法时提示的内容</span></span><br><span class="line"><span class="comment">// 参数二：是否禁止调用该方法（true：报错 false：仅警告）</span></span><br><span class="line">[<span class="meta">Obsolete(<span class="string">&quot;Speak方法过时了，建议使用新的方法&quot;</span>， false)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用者信息特性"><a href="#调用者信息特性" class="headerlink" title="调用者信息特性"></a>调用者信息特性</h3><p>使用时需要引用命名空间 <code>System.Runtime.CompilerServices</code> ，一般作为参数的特性。</p><ul><li>获取哪个文件调用： <code>CallerFilePath</code> 特性</li><li>获取哪一行调用： <code>CallerLineNumber</code> 特性</li><li>获取哪个函数调用： <code>CallerMemberName</code> 特性</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpeakCaller</span>(<span class="params"><span class="built_in">string</span> str, [CallerFilePath]<span class="built_in">string</span> fileName = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       [CallerLineNumber]<span class="built_in">int</span> line = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                        [CallerMemberName]<span class="built_in">string</span> memberName = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(str);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用的文件是&quot;</span> + fileName);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用的行数是&quot;</span> + line);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用的方法名是&quot;</span> + memberName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件编译特性"><a href="#条件编译特性" class="headerlink" title="条件编译特性"></a>条件编译特性</h3><p><strong>关键字：</strong> <code>Conditional</code> 特性</p><p>它会和预处理指令 <code>#define</code> 配合使用，需要引用命名空间 <code>System.Diagnostics</code> ，主要可以用在一些调试代码上（有时想执行有时不想执行的代码）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#defiine Fun</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">Conditional(<span class="string">&quot;Fun&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">Fun(); <span class="comment">// 加了这个特性函数才会执行</span></span><br></pre></td></tr></table></figure><h3 id="外部dll包函数特性"><a href="#外部dll包函数特性" class="headerlink" title="外部dll包函数特性"></a>外部dll包函数特性</h3><p><strong>关键字：</strong> <code>DllImport</code> 特性</p><p>用来标记非 <code>.Net（C#）</code> 的函数，表明该函数在一个外部的DLL中定义。一般用来调用 C 或 C++ 的DLL包写好的方法。使用时需要引用命名空间 <code>System.Runtime.InteropServices</code> 。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">&quot;Test.dll&quot;</span>)</span>] <span class="comment">// 假如用一个Test包中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h2><p>**迭代器（iterator）**又称光标（cursor）是程序设计的软件设计模式。迭代器模式提供一个方法顺序访问一个聚合对象中的各个元素而又不暴露其内部的标识。</p><p>从表面效果上看，迭代器是可以在容器对象（例如链表或数组）上遍历访问的接口，设计人员无需关心容器对象的内存分配的实现细节，可以用 <code>foreach</code> 遍历的类，都是实现了迭代器的。</p><h2 id="标准迭代器的实现方法"><a href="#标准迭代器的实现方法" class="headerlink" title="标准迭代器的实现方法"></a>标准迭代器的实现方法</h2><p><strong>关键接口：</strong> <code>IEnumerator</code> ， <code>IEnumerable</code></p><p><strong>命名空间：</strong> <code>System.Collections</code></p><p>可以通过同时继承 <code>IEnumerator</code> 和 <code>IEnumerable</code> 实现其中的方法。</p><h2 id="用-yield-return-语法糖实现迭代器"><a href="#用-yield-return-语法糖实现迭代器" class="headerlink" title="用 yield return 语法糖实现迭代器"></a>用 yield return 语法糖实现迭代器</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] list;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomList</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// yield 关键字 配合迭代器使用</span></span><br><span class="line">        <span class="comment">// 可以理解为 暂时返回 保留当前状态</span></span><br><span class="line">        <span class="comment">// 一会还会再回来</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用-yield-return-语法糖为泛型类实现迭代器"><a href="#用-yield-return-语法糖为泛型类实现迭代器" class="headerlink" title="用 yield return 语法糖为泛型类实现迭代器"></a>用 yield return 语法糖为泛型类实现迭代器</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span>&lt;<span class="title">T</span>&gt; : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="特殊语法"><a href="#特殊语法" class="headerlink" title="特殊语法"></a>特殊语法</h1><h2 id="var隐式类型"><a href="#var隐式类型" class="headerlink" title="var隐式类型"></a>var隐式类型</h2><p>概念： <code>var</code> 是一种特殊的变量类型，它可以用来表示任意类型的变量。</p><p>注意：</p><ul><li><code>var</code> 不能作为类的成员，只能用于临时变量声明</li><li><code>var</code> 变量必须初始化</li></ul><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><h2 id="设置对象初始值"><a href="#设置对象初始值" class="headerlink" title="设置对象初始值"></a>设置对象初始值</h2><p>概念：声明对象时，可以直接写大括号的形式初始化公共成员变量和属性。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test t1 = <span class="keyword">new</span> Test() &#123; x = <span class="number">1</span>, str = <span class="string">&quot;123&quot;</span>, Name = <span class="string">&quot;xxx&quot;</span> &#125;;</span><br><span class="line">Test t2 = <span class="keyword">new</span> Test() &#123; Name = <span class="string">&quot;yyy&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 先执行构造函数再执行初始化的内容</span></span><br></pre></td></tr></table></figure><h2 id="设置集合初始值"><a href="#设置集合初始值" class="headerlink" title="设置集合初始值"></a>设置集合初始值</h2><p>概念：声明集合对象时也可以通过大括号直接初始化内部属性。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] array1 = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list1 = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">List&lt;Test&gt; list2 = <span class="keyword">new</span> List&lt;Test&gt;() &#123;</span><br><span class="line">    <span class="keyword">new</span> Test(),</span><br><span class="line">    <span class="keyword">new</span> Test() &#123; Name = <span class="string">&quot;xxx&quot;</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Test() &#123; x = <span class="number">1</span>, str = <span class="string">&quot;123&quot;</span>, Name = <span class="string">&quot;yyy&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;() &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="string">&quot;123&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">2</span>, <span class="string">&quot;34655&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">3</span>, <span class="string">&quot;45676&quot;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h2><p>概念：变量可以使用 <code>var</code> 声明为自定义的匿名类型。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> &#123; age = <span class="number">10</span>, money = <span class="number">11</span>, name = <span class="string">&quot;小明&quot;</span> &#125;;</span><br><span class="line">COnsole.WriteLine(v.age);</span><br><span class="line"><span class="comment">// 匿名类型无法声明成员方法</span></span><br></pre></td></tr></table></figure><h2 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h2><p>概念：值类型不能赋值为空，但再声明时在值类型后面加 <code>?</code> 表示这是一个可空类型，就可以赋值为空了。</p><p>示例;</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? c = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="keyword">if</span> (c.HasValue)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全获取可空类型值</span></span><br><span class="line">COnsole.WriteLine(Value.GetValueOrDefault(<span class="number">100</span>));</span><br><span class="line"><span class="comment">// 有值就返回值，空的就返回括号里的参数，无参默认返回该类型的默认值</span></span><br></pre></td></tr></table></figure><p><code>?</code> 还可判断一个对象是否为空：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> o = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (o != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    o.Tostring();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于以上代码 能帮我们自动判断o是否为空</span></span><br><span class="line"><span class="comment">// 如果是null就不会执行，也不会报错</span></span><br><span class="line">o?.Tostring();</span><br></pre></td></tr></table></figure><h2 id="空合并操作符"><a href="#空合并操作符" class="headerlink" title="空合并操作符"></a>空合并操作符</h2><p>概念：空合并操作符 <code>??</code> ，如果左边值为空，就返回右边值，否则返回左边值，只要是可以为空的类型都能使用。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? v = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>? i = v == <span class="literal">null</span> ? <span class="number">100</span> : v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于以上代码</span></span><br><span class="line">i = v ?? <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h2 id="内插字符串"><a href="#内插字符串" class="headerlink" title="内插字符串"></a>内插字符串</h2><p>概念：用 <code>$</code> 来构造字符串，让字符串可以拼接变量。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;你好，<span class="subst">&#123;name&#125;</span>，年龄<span class="subst">&#123;age&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="单句逻辑简略写法"><a href="#单句逻辑简略写法" class="headerlink" title="单句逻辑简略写法"></a>单句逻辑简略写法</h2><p>概念：使用 <code>=&gt;</code> 省略大括号，需要返回值则同时省略 <code>return</code> ，只要是只有一句代码都可以这样用。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        <span class="keyword">set</span> =&gt; sex = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> =&gt; a + b; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;12312321&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>end</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity日记：存档系统</title>
      <link href="/posts/a985624f.html"/>
      <url>/posts/a985624f.html</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在游戏开发的世界中，存档系统是不可或缺的一部分，它让玩家的游戏进度得以保存，增强了游戏的可玩性和用户体验。今天分享一下如何在Unity中实现游戏存档的功能，特别是<strong>PlayerPrefs</strong>和<strong>JSON存档</strong>这两种常见方式，帮助开发者理解它们的适用场景、优缺点以及如何有效使用它们来构建强大的存档机制。</p><p>随着游戏复杂度的提升，存档系统的设计和实现变得尤为重要。合理的存档策略能够显著提升玩家的满意度和忠诚度。然而，Unity自带的PlayerPrefs虽然简单易用，但在处理复杂数据或大量数据时显得力不从心。而JSON作为一种轻量级的数据交换格式，因其易于人阅读和编写，以及良好的跨平台特性，在游戏存档中得到了广泛应用。因此，本文将简单介绍这两种方法，帮助开发者根据项目需求做出最佳选择。</p><p><strong>Unity存档系统的用途</strong>：</p><ul><li><strong>保存游戏进度</strong>：让玩家能够在退出游戏后重新加载之前的游戏状态。</li><li><strong>设置和配置保存</strong>：存储玩家的游戏设置，如音量、难度等。</li><li><strong>成就和解锁内容</strong>：记录玩家的成就和已解锁的内容，作为游戏进度的一部分。</li><li><strong>跨平台同步</strong>：在支持云存档的情况下，实现不同设备间的游戏进度同步。</li></ul><h1 id="PlayerPrefs"><a href="#PlayerPrefs" class="headerlink" title="PlayerPrefs"></a>PlayerPrefs</h1><h2 id="PlayerPrefs存储数据"><a href="#PlayerPrefs存储数据" class="headerlink" title="PlayerPrefs存储数据"></a>PlayerPrefs存储数据</h2><p><code>PlayerPrefs</code>是Unity提供的一个简单的数据持久化系统，用于保存和加载玩家偏好设置和游戏数据。它仅支持存储和检索<code>整型（int）</code>、<code>浮点型（float）</code>和<code>字符串（string）</code>数据。</p><p>Unity的<code>PlayerPrefs</code>是Unity引擎提供的一个用于存储和检索玩家偏好设置和游戏状态数据的简单数据持久化系统。它允许开发者跨会话（即游戏运行之间）保存和加载简单的数据类型，如整型（<code>int</code>）、浮点型（<code>float</code>）和字符串（<code>string</code>）。这些数据通常存储在设备的本地存储中，如注册表（在Windows上）或偏好设置文件（在macOS和iOS上）等，具体取决于目标平台。</p><h2 id="PlayerPrefs的特点"><a href="#PlayerPrefs的特点" class="headerlink" title="PlayerPrefs的特点"></a>PlayerPrefs的特点</h2><ol><li><strong>简单易用</strong>：<code>PlayerPrefs</code> API 非常直观，易于上手。只需几行代码就可以实现数据的保存和加载。</li><li><strong>跨平台</strong>：<code>PlayerPrefs</code> 数据在不同的Unity支持平台上具有高度的可移植性。无论游戏在哪个平台上运行，<code>PlayerPrefs</code> 都能以相同的方式工作。</li><li><strong>限制</strong>：尽管<code>PlayerPrefs</code> 非常方便，但它也有一些限制。首先，它只支持整型、浮点型和字符串数据类型。其次，由于数据存储在一个统一的命名空间中，不同游戏或应用可能会无意中覆盖彼此的<code>PlayerPrefs</code> 数据（尽管这可以通过在键名中包含唯一标识符来避免）。最后，<code>PlayerPrefs</code> 数据的存储量也有限制，虽然这个限制对于大多数用途来说都足够大，但在处理大量数据时可能会成为问题。</li></ol><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>使用简单，无需额外配置。</td><td>数据类型有限，不支持复杂数据结构（如数组、列表、字典等）。</td></tr><tr><td>跨平台兼容性好，适用于大多数Unity支持的平台。</td><td>存储容量有限，不适合存储大量数据。</td></tr><tr><td></td><td>安全性较低，数据容易被用户修改。</td></tr></tbody></table><h2 id="PlayerPrefs的基本用法"><a href="#PlayerPrefs的基本用法" class="headerlink" title="PlayerPrefs的基本用法"></a>PlayerPrefs的基本用法</h2><h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>使用<code>PlayerPrefs.SetInt</code>、<code>PlayerPrefs.SetFloat</code>和<code>PlayerPrefs.SetString</code>等静态方法将数据保存到<code>PlayerPrefs</code>中。调用<code>PlayerPrefs.Save()</code>可以手动保存更改，但通常这不是必需的，因为Unity会在游戏结束时自动保存<code>PlayerPrefs</code>数据。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetInt</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span>; <span class="comment">// key 键 value 值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetFloat</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">float</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.SetInt(<span class="string">&quot;score&quot;</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><h3 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h3><p>使用<code>PlayerPrefs.GetInt</code>、<code>PlayerPrefs.GetFloat</code>和<code>PlayerPrefs.GetString</code>等静态方法从<code>PlayerPrefs</code>中检索数据。这些方法需要一个键名作为参数，并返回与该键名关联的数据。如果指定的键名不存在，则可以提供一个默认值作为第二个参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetInt</span>(<span class="params"><span class="built_in">string</span> key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">GetFloat</span>(<span class="params"><span class="built_in">string</span> key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetString</span>(<span class="params"><span class="built_in">string</span> key</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> highScore = PlayerPrefs.GetInt(<span class="string">&quot;HighScore&quot;</span>, <span class="number">0</span>); <span class="comment">// 如果HighScore不存在，则返回0</span></span><br><span class="line"><span class="built_in">string</span> username = PlayerPrefs.GetString(<span class="string">&quot;Username&quot;</span>, <span class="string">&quot;Guest&quot;</span>); <span class="comment">// 如果Username不存在，则返回&quot;Guest&quot;</span></span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>使用<code>PlayerPrefs.DeleteKey</code>方法可以删除<code>PlayerPrefs</code>中的单个键值对。<code>PlayerPrefs.DeleteAll</code>方法会删除<code>PlayerPrefs</code>中的所有数据。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.DeleteKey(<span class="string">&quot;HighScore&quot;</span>); <span class="comment">// 删除HighScore键值对</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">PlayerPrefs.DeleteAll(); <span class="comment">// 删除所有PlayerPrefs数据，慎用！</span></span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerData</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> playerName; <span class="comment">// 角色名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> playerHealth; <span class="comment">// 角色血量</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 playerPosition; <span class="comment">// 角色位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Score; <span class="comment">// 得分</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        LoadFromPlayerPrefs(); <span class="comment">// 游戏开始时加载调用存储的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当保存并退出按钮被触发时执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveAndBack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        SaveByPlayerPrefs(); <span class="comment">// 保存数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveByPlayerPrefs</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PlayerPrefs.SetString(<span class="string">&quot;PlayerName&quot;</span>, playerName);</span><br><span class="line">        PlayerPrefs.SetFloat(<span class="string">&quot;PlayerHealth&quot;</span>, playerHealth);</span><br><span class="line">        PlayerPrefs.Setint(<span class="string">&quot;Score&quot;</span>, Score);</span><br><span class="line">        PlayerPrefs.SetFloat(<span class="string">&quot;PlayerPo_x&quot;</span>, playerPosition.x);</span><br><span class="line">        PlayerPrefs.SetFloat(<span class="string">&quot;PlayerPo_y&quot;</span>, playerPosition.y);</span><br><span class="line">        PlayerPrefs.SetFloat(<span class="string">&quot;PlayerPo_z&quot;</span>, playerPosition.z);</span><br><span class="line">        PlayerPrefs.Save();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadFromPlayerPrefs</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        playerName = PlayerPrefs.GetString(<span class="string">&quot;PlayerName&quot;</span>, <span class="string">&quot;None&quot;</span>);</span><br><span class="line">        playerHealth = PlayerPrefs.GetFloat(<span class="string">&quot;PlayerHealth&quot;</span>, <span class="number">100f</span>);</span><br><span class="line">        Score = PlayerPrefs.Getint(<span class="string">&quot;Score&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        playerPosition = <span class="keyword">new</span>(PlayerPrefs.GetFloat(<span class="string">&quot;PlayerPo_x&quot;</span>, <span class="number">0f</span>),</span><br><span class="line">                             PlayerPrefs.GetFloat(<span class="string">&quot;PlayerPo_y&quot;</span>, <span class="number">0f</span>), </span><br><span class="line">                             PlayerPrefs.GetFloat(<span class="string">&quot;PlayerPo_z&quot;</span>, <span class="number">0f</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>由于<code>PlayerPrefs</code>数据存储在设备的本地存储中，因此它可能受到设备存储空间或用户隐私设置的影响。</li><li>在使用<code>PlayerPrefs</code>时，建议为键名添加前缀或后缀，以确保它们在不同游戏或应用之间保持唯一性。</li><li>虽然<code>PlayerPrefs</code>提供了基本的数据持久化功能，但对于需要处理复杂数据结构或大量数据的游戏来说，可能需要考虑使用更高级的数据存储解决方案，如数据库或文件系统。</li></ul><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p><strong>PlayerPrefs适合用来存储暂时性数据，如：</strong></p><ul><li>玩家设定偏好</li><li>简单的数据</li><li>游戏原型制作时暂时的存储方案</li></ul><mark class="hl-label orange">总之，PlayerPrefs设计的初衷就不是为了真正的玩家存档而服务的，但它有其存在的理由，如何使用好这个工具，才是我们作为游戏制作者应该掌握的关键。</mark><p><strong>相关资料 -&gt;</strong> <a href="https://docs.unity3d.com/ScriptReference/PlayerPrefs.html">https://docs.unity3d.com/ScriptReference/PlayerPrefs.html</a></p><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p><code>JSON</code>是<code>JavaScript Object Notation（JavaScript对象注释/表示法）</code>的简称，是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成。在Unity中，我们可以通过序列化&#x2F;反序列化对象到JSON字符串的方式来实现存档功能。</p><p><strong>参考资料 -&gt;</strong> <a href="https://www.json.org/json-zh.html">https://www.json.org/json-zh.html</a></p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>JSON是一种基于文本的格式，用于表示数据。它使用键值对来表示对象，使用数组来表示一组值。例如，一个表示玩家的JSON对象可能如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;gold&quot;</span><span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;equipment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;剑&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;武器&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;盾&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;防具&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>支持复杂数据结构，如数组、列表、字典等。</li><li>数据量大小无限制（受限于系统存储空间）。</li><li>安全性较高，可通过加密等手段保护数据。</li><li>跨平台兼容性好，JSON是标准的文本格式，易于在不同平台间交换数据。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>需要编写额外的序列化&#x2F;反序列化代码。</li><li>相对于PlayerPrefs，使用上稍显复杂。</li></ul><h3 id="与PlayerPrefs对比"><a href="#与PlayerPrefs对比" class="headerlink" title="与PlayerPrefs对比"></a>与PlayerPrefs对比</h3><ul><li>JSON更适合存储复杂数据结构和大量数据。</li><li>JSON提供了更高的灵活性和可扩展性。</li><li>在处理简单数据类型和少量数据时，PlayerPrefs可能更便捷。</li></ul><h2 id="JsonUtility"><a href="#JsonUtility" class="headerlink" title="JsonUtility"></a>JsonUtility</h2><p>在Unity中，要将对象保存为JSON字符串，需要对其进行序列化；同样，要从JSON字符串恢复对象，需要对其进行反序列化。Unity提供了<code>JsonUtility</code>类来简化这一过程。</p><ul><li><strong>序列化</strong>：使用<code>JsonUtility.ToJson()</code>方法将对象转换为JSON字符串。</li><li><strong>反序列化</strong>：使用<code>JsonUtility.FromJson&lt;T&gt;()</code>方法将JSON字符串转换回对象。</li></ul><p><img src="https://s2.loli.net/2024/08/15/83eOAQ2m7DMXdyb.png"></p><h2 id="使用JsonUtility进行存档"><a href="#使用JsonUtility进行存档" class="headerlink" title="使用JsonUtility进行存档"></a>使用JsonUtility进行存档</h2><h3 id="定义可序列化的类"><a href="#定义可序列化的类" class="headerlink" title="定义可序列化的类"></a>定义可序列化的类</h3><p>在Unity中，只有标记为<code>[Serializable]</code>的类才能被<code>JsonUtility</code>序列化。因此，需要为要存档的数据定义可序列化的类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> level;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> gold;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Equipment&gt; equipment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Equipment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意，并不是所有数据都可以被正常的序列化：</p><p><img src="https://s2.loli.net/2024/08/15/z9n16XI3uceahAG.jpg"></p><p><img src="https://s2.loli.net/2024/08/15/P9NeZ53baFxLzRI.jpg"></p><p><img src="https://s2.loli.net/2024/08/15/McJIefSvCxDOnRz.jpg"></p><h3 id="序列化并保存数据"><a href="#序列化并保存数据" class="headerlink" title="序列化并保存数据"></a>序列化并保存数据</h3><p>在Unity中，可以通过以下步骤将<code>PlayerData</code>对象序列化为JSON字符串，并保存到文件中：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SavePlayerData</span>(<span class="params">PlayerData playerData, <span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将数据序列化</span></span><br><span class="line">    <span class="built_in">string</span> json = JsonUtility.ToJson(playerData);</span><br><span class="line">    <span class="comment">// 获取存储文件地址</span></span><br><span class="line">    <span class="built_in">string</span> filePath = Path.Combine(Application.persistentDataPath, fileName + <span class="string">&quot;.json&quot;</span>);</span><br><span class="line">    <span class="comment">// 将JSON写入文件中</span></span><br><span class="line">    File.WriteAllText(filePath, json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取并反序列化数据"><a href="#读取并反序列化数据" class="headerlink" title="读取并反序列化数据"></a>读取并反序列化数据</h3><p>当需要加载存档时，可以从文件中读取JSON字符串，并使用<code>JsonUtility.FromJson&lt;T&gt;()</code>方法将其反序列化为<code>PlayerData</code>对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PlayerData <span class="title">LoadPlayerData</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取存储文件地址</span></span><br><span class="line">    <span class="built_in">string</span> filePath = Path.Combine(Application.persistentDataPath, fileName + <span class="string">&quot;.json&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断是否有对应文件</span></span><br><span class="line">    <span class="keyword">if</span> (File.Exists(filePath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取JSON字符串</span></span><br><span class="line">        <span class="built_in">string</span> json = File.ReadAllText(filePath);</span><br><span class="line">        <span class="comment">// 将JSON反序列化</span></span><br><span class="line">        PlayerData playerData = JsonUtility.FromJson&lt;PlayerData&gt;(json);</span><br><span class="line">        <span class="keyword">return</span> playerData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有文件打印提示</span></span><br><span class="line">        Debug.LogError(<span class="string">$&quot;File <span class="subst">&#123;filePath&#125;</span> not found!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>首先创建一个公有的静态类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SaveSystemTutorial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SaveSystem</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 存档</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveByJson</span>(<span class="params"><span class="built_in">string</span> saveFileName, <span class="built_in">object</span> data</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> json = JsonUtility.ToJson(data);</span><br><span class="line">            <span class="keyword">var</span> path = Path.Combine(Application.persistentDataPath, saveFileName);</span><br><span class="line">            <span class="comment">/* Application.persistentDataPath用来提供一个存储永久数据的路径，并且</span></span><br><span class="line"><span class="comment">             当我们将游戏打包发布在不同平台上时，这个路径会随着我们发布的平台自动变更 */</span></span><br><span class="line">            </span><br><span class="line">            Debug.Log(<span class="string">$&quot;save data to <span class="subst">&#123;path&#125;</span>.&quot;</span>); <span class="comment">// 这里我们可以输出这个路径找到文件</span></span><br><span class="line"></span><br><span class="line">            File.WriteAllText(path, json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读档</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">LoadFromJson</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> saveFileName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> path = Path.Combine(Application.persistentDataPath, saveFileName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> json = File.ReadAllText(path);</span><br><span class="line">            <span class="keyword">var</span> data = JsonUtility.FromJson&lt;T&gt;(json);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteSaveFile</span>(<span class="params"><span class="built_in">string</span> saveFileName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> path = Path.Combine(Application.persistentDataPath, saveFileName);</span><br><span class="line"></span><br><span class="line">            File.Delete(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再其他脚本中使用<code>SaveSystemTutorial</code>命名空间并实现存储数据函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> SaveSystemTutorial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> name; <span class="comment">// 角色名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> health; <span class="comment">// 角色血量</span></span><br><span class="line">   <span class="keyword">public</span> Vector3 position; <span class="comment">// 角色位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> score; <span class="comment">// 得分</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;GameObject&gt; enermy; <span class="comment">// 敌人列表</span></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">System.Serializable</span>]</span><br><span class="line">    <span class="keyword">class</span> <span class="title">SaveData</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> playerName; <span class="comment">// 角色名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> playerHealth; <span class="comment">// 角色血量</span></span><br><span class="line">   <span class="keyword">public</span> Vector3 playerPosition; <span class="comment">// 角色位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Score; <span class="comment">// 得分</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;GameObject&gt; Enermy; <span class="comment">// 敌人列表</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveAndBack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SaveData data = <span class="keyword">new</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            playerName = name;</span><br><span class="line">    playerHealth = health;</span><br><span class="line">   playerPosition = position;</span><br><span class="line">    Score = score;</span><br><span class="line">        Enermy = enermy;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        SaveSystem.SaveByJson(<span class="string">&quot;player.save&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadData</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取文件地址判断文件是否存在</span></span><br><span class="line">        <span class="keyword">var</span> Path = Application.persistentDataPath + <span class="string">&quot;\\player.save&quot;</span>;</span><br><span class="line">        SaveData data;</span><br><span class="line">        <span class="keyword">if</span> (File.Exists(HistoryPath))</span><br><span class="line">        &#123;</span><br><span class="line">            data = SaveSystem.LoadFromJson&lt;SaveData&gt;(<span class="string">&quot;player.save&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将数据赋回</span></span><br><span class="line">        name = data.playerName;</span><br><span class="line">        health = data.playerHealth;</span><br><span class="line">        position = data.playerPosition;</span><br><span class="line">        score = data.Score;</span><br><span class="line">        enermy = data.Enermy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> Debug.Log(<span class="string">&quot;Not Found!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后通过输出的文件路径就可以找到我们的存档啦：</p><p><img src="https://s2.loli.net/2024/08/15/pKWsrT2CBDm6Py4.png"></p><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><strong>数据安全性</strong>：直接以明文形式保存JSON文件可能会带来数据泄露的风险。在需要保护用户数据的情况下，应考虑对JSON数据进行加密。</li><li><strong>跨平台兼容性</strong>：<code>Application.persistentDataPath</code>会自动处理不同平台上的文件路径差异，使得存档系统能够跨平台工作。</li><li><strong>性能考虑</strong>：对于大型游戏或频繁存档的场景，需要关注序列化&#x2F;反序列化操作对性能的影响。</li><li><strong>错误处理</strong>：在文件读写过程中，应添加适当的错误处理逻辑，以应对文件不存在、磁盘空间不足等异常情况。</li></ol><h2 id="使用JSON文件而不是PlayerPrefs的原因"><a href="#使用JSON文件而不是PlayerPrefs的原因" class="headerlink" title="使用JSON文件而不是PlayerPrefs的原因"></a>使用JSON文件而不是PlayerPrefs的原因</h2><p>前面提到过<strong>PlayerPrefs</strong>可以存储字符串类型的数据，而JSON数据实际上就是字符串，所以PlayerPrefs实际上也可以存储JSON数据。</p><p>不建议用PlayerPrefs存JSON的原因主要有以下几点：</p><h3 id="存储效率与灵活性"><a href="#存储效率与灵活性" class="headerlink" title="存储效率与灵活性"></a>存储效率与灵活性</h3><p>PlayerPrefs的存储方式相对简单直接，但这也限制了其存储效率和灵活性。当需要存储大量数据时，PlayerPrefs可能会因为频繁地读写磁盘而导致性能下降。此外，由于PlayerPrefs只支持简单的数据类型，因此在处理复杂数据结构时，往往需要将数据转换为字符串进行存储，这在读取时又需要反序列化回原始数据结构，增加了额外的处理步骤和可能的性能开销。相比之下，直接使用JSON文件或其他数据库系统存储复杂数据，可以更加高效和灵活地管理数据。</p><h3 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h3><p>虽然PlayerPrefs本身在数据安全方面并没有直接的漏洞，但由于其存储的数据类型简单且易于访问，因此如果游戏或应用程序中涉及敏感信息（如用户密码、支付信息等），则不建议使用PlayerPrefs进行存储。此外，由于PlayerPrefs的数据通常存储在用户设备的文件系统中，因此如果设备被恶意软件攻击或用户拥有足够的权限，那么存储在PlayerPrefs中的数据就有可能被非法读取或篡改。对于需要保护用户数据安全的场景，建议使用更加安全的数据存储方案。</p><h3 id="可扩展性和可维护性"><a href="#可扩展性和可维护性" class="headerlink" title="可扩展性和可维护性"></a>可扩展性和可维护性</h3><p>随着游戏或应用程序的不断发展，可能需要存储的数据量也会不断增加，数据结构也会变得更加复杂。如果一直使用PlayerPrefs来存储这些数据，那么随着数据的增加和数据结构的复杂化，代码的可读性、可维护性和可扩展性都会受到影响。相比之下，使用JSON文件或其他数据库系统来存储数据，可以更加方便地管理数据结构和数据变更，提高代码的可读性、可维护性和可扩展性。</p><p>所以，虽然PlayerPrefs在存储简单数据方面具有一定的优势，但在需要处理复杂数据结构、大量数据或敏感信息时，建议使用更加高效、灵活和安全的数据存储方案。对于JSON数据的存储和读取，建议使用Unity内置的JsonUtility类或其他第三方JSON库来实现序列化和反序列化操作，并将数据存储在文件系统或数据库中以便后续管理和使用。</p><h2 id="适用范围-1"><a href="#适用范围-1" class="headerlink" title="适用范围"></a>适用范围</h2><p><strong>联网</strong></p><ul><li>优秀的网络数据交换载体</li><li>云存档</li></ul><p><strong>本地存储</strong></p><ul><li>非敏感而需要大量读取的数据，如：Mod数据</li><li>玩家的偏好设置等</li></ul><p><strong>相关资料 -&gt;</strong> <a href="https://docs.unity3d.com/ScriptReference/JsonUtility.html">https://docs.unity3d.com/ScriptReference/JsonUtility.html</a></p><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>通过本文章的介绍，我们深入了解了Unity中的两种主要存档方式——PlayerPrefs和JSON存档。每种方法都有其独特的优势和适用场景。开发者应根据项目的具体需求、数据复杂度以及目标平台的特性来选择最合适的存档策略。无论是追求简单快捷的PlayerPrefs，还是注重数据复杂性和安全性的JSON存档，都能在Unity中找到实现方法，为玩家带来更加流畅和丰富的游戏体验。</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> 数据持久化 </tag>
            
            <tag> Unity开发日记 </tag>
            
            <tag> PlayerPrefs </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity日记：场景切换与并发编程</title>
      <link href="/posts/fdbe57b8.html"/>
      <url>/posts/fdbe57b8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Unity场景切换"><a href="#Unity场景切换" class="headerlink" title="Unity场景切换"></a>Unity场景切换</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在游戏开发中，场景切换，这一看似简单的操作，实则蕴含着提升游戏体验、增强故事叙述能力的无限潜力。今天，就让我们一同踏上这场Unity中场景切换的魔法之旅，揭开那些让游戏世界流畅衔接、引人入胜的秘密。</p><p>在快节奏的游戏开发中，场景切换往往被视为一个“必经之路”，而非核心功能。然而，正是这些看似不起眼的环节，构成了玩家游戏体验的重要组成部分。一个精心设计的场景切换不仅能有效减少加载时间带来的等待感，还能通过视觉和情感的引导，加深玩家对游戏世界的沉浸感。更重要的是，它还能作为游戏叙事的一部分，引导玩家逐步揭开故事的真相，体验更加丰富和深刻的游戏内容。想象一下，你的玩家正在紧张刺激的战斗后，通过一段华丽的过渡动画，瞬间穿越到宁静祥和的村庄；或者是在解开谜题后，随着一阵悠扬的音乐，眼前的景象逐渐模糊，再清晰时已是另一个充满挑战的关卡。这样的场景切换，不仅让玩家感受到游戏的连贯性和惊喜，更激发了他们对未知世界的好奇心和探索欲。而这，正是我们今天要探讨的——如何在Unity中利用场景切换的魔法，为你的游戏增添无限魅力。</p><p>撰写一篇关于在Unity中进行场景切换的博客文章是一个很好的主意，因为这对于开发任何类型的游戏或应用来说都是一项基础且重要的技能。以下是一个结构化的博客文章大纲，以及一些关键内容的建议，帮助你撰写这篇博客。</p><h2 id="什么是场景（Scene）？"><a href="#什么是场景（Scene）？" class="headerlink" title="什么是场景（Scene）？"></a>什么是场景（Scene）？</h2><p>在Unity中，**场景（Scene）**是构建游戏世界的基石。所有GameObject都在场景中，它包含了游戏运行时所需的所有元素，如3D模型、灯光、摄像机、UI界面、音效以及脚本逻辑等。每个场景都代表了一个独立的游戏环境或关卡，玩家在其中进行互动和探索。Unity编辑器提供了直观的工具来创建、编辑和管理多个场景。开发者可以轻松地添加、删除或修改场景中的元素，并通过场景管理器来组织和管理这些场景文件。游戏通常由多个场景组成，这些场景通过场景切换相互连接，共同构成了完整的游戏流程。场景切换不仅是技术上的实现，更是游戏叙事和玩家体验的重要组成部分。</p><p><img src="https://s2.loli.net/2024/08/14/xEsImaKgpVlbftw.png"></p><h2 id="如何切换场景"><a href="#如何切换场景" class="headerlink" title="如何切换场景"></a>如何切换场景</h2><h3 id="SceneManager类"><a href="#SceneManager类" class="headerlink" title="SceneManager类"></a>SceneManager类</h3><p><code>SceneManager</code>是Unity提供的一个用于<strong>管理场景加载、卸载和切换</strong>的类。它提供了丰富的API来支持场景的各种操作。</p><p>1.首先打开菜单栏的<code>File</code>-&gt; <code>Build Settings</code>，确保你的场景已经添加到这里，记住对应场景的序号。</p><p><img src="https://s2.loli.net/2024/08/14/4uz5WVoXSaGmUYP.png"></p><p>2.<code>SceneManager</code>类提供了<code>SceneManager.LoadScene</code>方法实现场景的加载与切换，以下是代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;  </span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement; <span class="comment">// 确保使用了UnityEngine.SceneManagement命名空间</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneSwitcher</span> : <span class="title">MonoBehaviour</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 场景切换函数，该函数可以通过按钮或在任何需要的情况下被调用，实现场景转换  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SceneChange</span>()</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 使用SceneManager的LoadScene方法来加载新场景  </span></span><br><span class="line">        <span class="comment">// 第一个参数是场景名称</span></span><br><span class="line">        <span class="comment">// 第二个参数是加载模式</span></span><br><span class="line">        SceneManager.LoadScene(<span class="string">&quot;nextScene&quot;</span>, LoadSceneMode.Single);</span><br><span class="line">        <span class="comment">// SceneManager.LoadScene(1); // 第一个参数可直接使用场景名称，也可使用对应的场景序号</span></span><br><span class="line">        <span class="comment">// 无论使用的是场景名称还是序号，场景都必须要被添加在Build中</span></span><br><span class="line">        <span class="comment">// 第二个参数一般情况下省略</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.函数被调用时，游戏会<strong>暂停当前场景的所有操作</strong>，等待新场景完全加载到内存中并激活后，再继续执行后续操作。这个过程是<strong>阻塞的</strong>，即<strong>直到新场景加载完成，游戏才会继续运行</strong>。这个过程，也被称为同步加载。</p><h3 id="同步加载"><a href="#同步加载" class="headerlink" title="同步加载"></a>同步加载</h3><p><strong>过程：</strong></p><ol><li><strong>触发加载</strong>：通过调用场景加载的方法，并传入要加载的场景名称或索引作为参数，来触发场景的加载过程。</li><li><strong>等待加载</strong>：在加载过程中，游戏会暂停当前场景的所有操作（如渲染、物理计算、用户输入响应等），直到新场景完全加载到内存中。</li><li><strong>场景切换</strong>：当新场景加载完成后，Unity会销毁当前场景（如果加载模式为Single），并激活新场景，然后游戏继续执行后续操作。</li></ol><p>可如果我们的目标场景数据十分庞大呢？这意味着我们在<strong>等待加载</strong>的过程中就会出现我们都遇到过的事情，那就是卡顿。我们需要等很长时间来加载目标场景的数据。这时如果我们使用同步加载，在这期间游戏处于暂停中，玩家很可能以为自己卡了，大大降低体验度。<strong>使用异步加载就可以解决这个问题。</strong></p><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p><strong>异步加载</strong>中加载新场景的行为是在<strong>后台线程</strong>中进行的，不影响主线程（即游戏当前场景）的运行。它的过程为<code>触发加载</code> -&gt; <code>后台加载</code> -&gt;  <code>场景切换</code> </p><p>使用了异步加载，我们就可以在等待加载的过程中播放一些其他操作，如待机画面、加载进度条等。</p><p>以下是使用异步加载进行场景切换并添加加载进度条与点击继续的操作示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;  </span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI; <span class="comment">// 引用UI相关命名空间</span></span><br><span class="line"><span class="keyword">using</span> TMPro;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneLoader</span> : <span class="title">MonoBehaviour</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> GameObject loadScreen; <span class="comment">// 加载界面Panel</span></span><br><span class="line">    <span class="keyword">public</span> Slider slider; <span class="comment">// 加载界面进度条</span></span><br><span class="line">    <span class="keyword">public</span> TextMeshProUGUI text; <span class="comment">// 进度文本</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadScene</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(Loadlevel()); <span class="comment">// 使用协程</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 异步加载场景，控制进度条</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Loadlevel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        loadScreen.SetActive(<span class="literal">true</span>); <span class="comment">// 显示加载界面</span></span><br><span class="line"></span><br><span class="line">        AsyncOperation operation = SceneManager.LoadSceneAsync(<span class="string">&quot;MainScene&quot;</span>);</span><br><span class="line">        <span class="comment">// SceneManager.LoadSceneAsync方法返回一个AsyncOperation对象，</span></span><br><span class="line">        <span class="comment">// 在加载过程中，你可以通过返回的AsyncOperation对象来获取加载进度、检查是否加载完成等。</span></span><br><span class="line"></span><br><span class="line">        operation.allowSceneActivation = <span class="literal">false</span>; <span class="comment">// 默认加载完成不切换场景</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!operation.isDone)</span><br><span class="line">        &#123;</span><br><span class="line">            slider.<span class="keyword">value</span> = operation.progress; <span class="comment">// 让进度条的值等于加载进度（slider与加载进度的值都是0~1的浮点数）</span></span><br><span class="line"></span><br><span class="line">            text.text = (<span class="built_in">int</span>)(operation.progress * <span class="number">100</span>) + <span class="string">&quot;%&quot;</span>; <span class="comment">// 显示加载进度百分数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (operation.progress &gt;= <span class="number">0.9f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                slider.<span class="keyword">value</span> = <span class="number">1</span>; <span class="comment">// 场景加载完成后，progress返回的值不是1，所以要单独设定进度条的值</span></span><br><span class="line">                text.text = <span class="string">&quot;点击任意位置继续&quot;</span>; <span class="comment">// 加载完成后百分比进度变为提示</span></span><br><span class="line">                <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    operation.allowSceneActivation = <span class="literal">true</span>; <span class="comment">// 切换场景</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了很大型的游戏项目之外，大部分情况下，场景的加载总是一瞬间完成的，如果仍然想要做出像大型游戏加载那样的加载界面效果，可以尝试使用异步加载制作伪加载进度条，即进度条的进度与播放时间由开发者设定，实际上与加载时间无关，实现过渡界面的效果。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table><thead><tr><th></th><th>同步加载</th><th>异步加载</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>加载新场景时，游戏会暂停当前场景的所有操作，等待新场景完全加载并激活后继续执行。</td><td>加载新场景的行为是在后台线程中进行的，不影响主线程（即游戏当前场景）的运行。</td></tr><tr><td><strong>过程</strong></td><td>1. 触发加载<br>2. 等待加载（游戏暂停）<br>3. 场景切换（加载完成后继续）</td><td>1. 触发加载<br>2. 后台加载（游戏继续运行）<br>3. 场景切换（加载完成后通过回调或检查状态继续）</td></tr></tbody></table><p><strong>对游戏流畅度的影响</strong>：</p><ul><li><strong>同步加载</strong>：由于加载过程中游戏会暂停，因此当加载的场景较大或资源较多时，会导致明显的卡顿或延迟，影响用户体验。</li><li><strong>异步加载</strong>：加载过程在后台进行，不影响游戏当前场景的运行，因此即使加载大型场景也不会造成游戏卡顿，提升了游戏的流畅度和用户体验。</li></ul><p><strong>使用场景</strong>：</p><ul><li><strong>同步加载</strong>：适用于场景较小、资源较少，或对加载时间要求不高的场合。</li><li><strong>异步加载</strong>：更适用于场景较大、资源较多，或对加载时间有较高要求的场合，如制作场景切换过程中的过渡界面、实现无缝加载等。</li></ul><p><strong>实现方式</strong>：</p><ul><li><strong>同步加载</strong>：直接调用加载场景的方法，并等待加载完成。</li><li><strong>异步加载</strong>：调用加载场景的方法时，需要处理返回的异步对象（如<code>AsyncOperation</code>），以便在加载过程中进行进度监控、加载完成后的回调等。</li></ul><p>同步加载和异步加载在Unity中各有其适用场景和优缺点。在实际开发中，应根据游戏的具体需求和资源情况来选择合适的加载方式。</p><h2 id="场景间的数据传递"><a href="#场景间的数据传递" class="headerlink" title="场景间的数据传递"></a>场景间的数据传递</h2><ul><li><strong>全局变量</strong>：使用静态类或单例模式存储全局数据，以便在不同场景之间共享信息。</li><li><strong>PlayerPrefs</strong>：适用于存储少量非敏感数据，如玩家设置。 <a class="btn-beautify green larger" href="/posts/a985624f.html#PlayerPrefs" title="Unity日记：存档系统-PlayerPrefs"><i class="far fa-hand-point-right"></i><span>Unity日记：存档系统-PlayerPrefs</span></a></li><li><strong>SceneManager的<code>DontDestroyOnLoad</code>方法</strong>：用于在场景切换时保留某些对象，如游戏管理器或UI系统。</li></ul><hr><h1 id="关于并发编程"><a href="#关于并发编程" class="headerlink" title="关于并发编程"></a>关于并发编程</h1><p>在Unity中，我们刚刚探讨了场景切换的两种方式：同步加载与异步加载。特别是异步加载，通过<code>SceneManager.LoadSceneAsync</code>方法，我们能够在<strong>不阻塞主线程</strong>的情况下加载新场景，这种非阻塞的特性极大地提升了游戏的流畅度和用户体验。而实现这种异步加载背后，Unity的<code>协程（Coroutine）</code>机制扮演了至关重要的角色。<strong>协程</strong>允许我们在Unity的主线程上**“伪并行”**地执行代码块，每个协程在每次迭代后都会暂停，直到下一次主线程循环中再次被唤醒。这种机制虽然并非传统意义上的并行处理，但它有效地利用了Unity的单一更新循环，模拟了并发执行的效果。</p><p>那么，当我们谈论到并发编程时，我们实际上是在探讨如何在多个处理单元（如CPU核心）上同时执行多个任务，以充分利用硬件资源，提高程序的整体执行效率。在Unity这样的游戏开发环境中，并发编程不仅限于简单的协程使用，它还包括多线程编程、任务并行库（TPL）的使用（在Unity中不直接支持，但可通过C#的<code>System.Threading</code>和<code>System.Threading.Tasks</code>命名空间实现跨平台兼容性处理）、以及针对特定硬件优化的并行计算API（如Compute Shaders、Job System和Burst Compiler等Unity 2018及以后版本中引入的高级功能）。</p><p>从异步加载和协程的视角过渡到并发编程，我们可以理解为：**协程为我们提供了一种在游戏主循环内管理复杂流程和异步操作的有效方式，而并发编程则是将这种思想扩展到了更广泛的层面，即跨越多个处理单元来并行执行多个任务。**在Unity中，合理利用并发编程技术，可以显著减少游戏运行时的延迟，提升游戏性能，特别是在处理大量数据计算、物理模拟、AI决策等计算密集型任务时。</p><p>然而，并发编程也伴随着复杂性增加和潜在的资源竞争、死锁等问题。因此，在设计并发系统时，开发者需要仔细规划任务之间的依赖关系，合理使用同步机制，确保数据的一致性和系统的稳定性。在Unity的上下文中，这意味着要深入理解<a href="https://blog.csdn.net/xiaoyaoACi/article/details/119324146?spm=1001.2014.3001.5502">Unity的生命周期</a>、线程安全以及如何利用Unity提供的并发工具和最佳实践来优化游戏性能。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>并发编程</strong>是一种程序设计方法，‌它由若干个可同时执行的程序模块组成，‌这些模块被称为进程。‌这些进程可以同时在多台处理器上并行执行，‌也可以在一台处理器上交替执行。‌采用并发程序设计可以使外围设备和处理器并行工作，‌从而缩短程序执行时间，‌提高计算机系统效率。‌</p><p>在并发编程中，‌有几个核心概念需要理解：‌</p><ul><li><strong>进程与线程</strong>：‌进程是执行过程中分配和管理资源的基本单位，‌而线程是进程的一个执行单元，‌是进程内可调度的实体。‌线程也可以被称为轻量级进程，‌它是比进程更小的独立运行的基本单位。‌多个线程可以存在于一个进程中，‌并发执行并共享资源（‌如内存）‌，‌而不同的进程不共享这些资源。‌</li><li><strong>同步和异步</strong>：‌同步和异步通常用来形容一次方法调用。‌同步方法调用需要调用者等待方法调用返回后才能继续后续的行为，‌而异步方法调用一旦开始，‌方法调用就会立即返回，‌允许调用者继续执行其他操作，‌而异步方法在另一个线程中“真实”地执行。</li><li><strong>并发和并行</strong>：‌并发和并行都可以用来表示两个或多个任务一起执行，‌但侧重点不同。‌并发强调任务可以交替执行，‌而并行则强调真正的同时执行。‌在单核CPU下，‌通过任务调度器将CPU的时间片分配给不同的程序使用，‌由于CPU在时间片之间快速切换，‌人类感觉是同时运行的，‌这被称为并发。‌而在多核CPU下，‌多个核心可以同时处理多个线程，‌这才是真正的并行执行。</li><li><strong>临界区</strong>：‌临界区通常指共享数据，‌可以被多个线程使用。‌当有线程进入临界区时，‌其他线程或进程必须等待。‌例如，‌当一个线程正在修改共享变量时，‌其他试图访问该变量的线程必须等待直到第一个线程完成操作。‌</li></ul><h2 id="进程、线程与协程的关系"><a href="#进程、线程与协程的关系" class="headerlink" title="进程、线程与协程的关系"></a>进程、线程与协程的关系</h2><p><img src="https://s2.loli.net/2024/08/14/odIJbpK9kVWCFjB.png" alt="进程、线程与协程的关系"></p><p>线程和协程都是进程的子集，一个进程可以有多个协程，一线程也可以有多个协程，进程基于程序主体。</p><p><strong>IO密集型一般使用多线程或多进程</strong>。<strong>CPU密集型一般使用多进程</strong>。<strong>强调非阻塞异步并发的一般都用协程</strong>。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是系统分配资源和调度资源的一个独立单位，<strong>每个进程都有自己的独立内存空间</strong>，<strong>不同进程间可以进行进程间通信</strong>。进程<strong>重量级比较大</strong>，占据独立内存，上下文进程间的切换开销（栈寄存器、虚拟内存、文件句柄）比较大，但相对稳定安全。进程的上级为操作系统，有自己固定的堆栈。</p><p><strong>进程间通信（IPC）</strong></p><ul><li><strong>管道（Pipe）</strong>：管道是Unix中最古老的进程间通信的形式，我们把从一个进程连接到另一个进程的一个数据流称为一个“管道”。其本质是内核中固定大小的缓冲区。</li><li><strong>命名管道（Named Pipes）</strong>：“命名管道”又名“命名管线”（Named Pipes），命名管道支持可靠的、单向或双向的数据通信。不同于匿名管道的是：命名管道可以在不相关的进程之间和不同计算机之间使用，服务器建立命名管道时给它指定一个名字，任何进程都可以通过该名字打开管道的另一端，根据给定的权限和服务器进程通信。</li><li><strong>消息队列（MQ，Message Quene）</strong>：消息队列用于在进程间通信的过程中将消息按照队列存储起来，常见的MQ有ActiveMQ、RocketMQ、RabbitMQ、Kafka等。</li><li><strong>信号量（Semaphore）</strong>：有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前,线程必须获取一个信号量。</li><li><strong>共享内存（Share Memory）</strong>：共享内存是三个IPC机制中的一个。它允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在进行的进程之间传递数据的一种非常有效的方式。</li><li><strong>套接字（Socket）</strong>：就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。</li></ul><p>对于游戏开发者来说，最为常用的无疑是Socket，这是长连接网络游戏的核心。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程也被称为轻量级进程，是<strong>操作系统调度（CPU调度）执行的最小单位</strong>，是进程的子集。</p><p>线程<strong>本身基本不拥有资源</strong>，而是访问隶属于进程的资源，一个进程拥有至少一个或多个线程，<strong>线程间共享进程的地址空间</strong>。</p><p>由于<strong>线程是阻塞式</strong>的，如果想要同步执行IO，每个IO都必须开启一个新线程，<strong>多线程开销较大</strong>，适合多任务处理，进程崩溃不影响其他进程，而线程只是一个进程的不同执行路线。</p><p><strong>线程有自己的堆栈</strong>，却<strong>没有单独的地址空间</strong>，<strong>进程死就等于所有线程死</strong>，所以多进程要比多线程健壮。但在进程切换时，消耗资源较大，效率较差。</p><p>线程是并发的，且是阻塞式同步的，一旦资源死锁，线程将陷入混乱。在同步线程的执行过程中，<strong>线程的执行切换是由CPU轮转时间片的分配来决定的</strong>。</p><p><img src="https://s2.loli.net/2024/08/14/KeRThSdJEPGpFYy.png" alt="线程状态图"></p><ul><li>新建状态：new创建一个线程时，还没开始运行，就是新建状态。</li><li>就绪状态：新建后，调用start()方法，线程就处于就绪态，等待CPU调度。</li><li>运行状态：当线程获得了CPU时间后，进入运行状态，执行run()里的内容</li><li>阻塞状态：线程运行中随时可能被阻塞：比如调用sleep()方法；等待获取锁被阻塞；线程在等待其他触发条件。暂时让出CPU资源。</li><li>死亡状态：有两个原因导致线程死亡：run()方法正常结束；一个未捕获的异常终止了run()方法</li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><strong>Unity 中所有脚本运行公用一条主线程，而协程是开辟的伪线程。这个伪线程可以让一个方法分多次执行，相当于让主线程劈几个叉。</strong></p><p>协程还称微线程，纤程，<strong>本质是一个单线程</strong>。<strong>协程是比线程更轻量级的存在</strong>，协程<strong>不由操作系统内核所管理</strong>，而是完全由程序所控制（也就是在<strong>用户态执行</strong>）。</p><p>协程的好处是性能大幅提升，不会像线程切换那样消耗资源。同一时间只能执行某个协程，开辟<strong>多个协程开销不大</strong>。<strong>适合对任务进行分时处理</strong>。</p><p><strong>协程有自己的寄存器和上下文栈</strong>。协程调度切换时，将寄存器和<strong>上下文栈保存到其他地方</strong>，并在协程切换回来时<strong>恢复之前保存的寄存器和上下文栈</strong>。由于<strong>直接对栈进行操作</strong>，<strong>基本没有内核切换的开销</strong>，可以<strong>不加锁的访问全局变量</strong>，所以上下文切换非常快。</p><p>一个线程可以有多个协程，一个进程也可以单独拥有多个协程。<strong>线程和进程都是同步机制，而协程是异步机制，无需阻塞</strong>。协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用时的状态。多协程间对CPU的使用是依次进行的，每次只有一个协程工作，而其他协程处于休眠状态。</p><p>实际上多个协程是在一个线程中的，只不过每个协程对CPU进行分时。<strong>协程可以访问和使用Unity的所有方法和Component</strong>。<strong>函数（子程序）的调用是通过栈实现的</strong>，一个线程就是执行一个函数，函数调用总是一个入口，一个返回，调用顺序是明确的，而<strong>协程在函数内部是可以中断的</strong>，然后<strong>转而执行其他函数</strong>，在<strong>适当的时候再返回来继续执行</strong>。函数（子程序）的切换不是由线程切换，而是程序自身控制，因此没有线程切换开销。和多线程相比，线程越多，协程的性能优势就越明显，切协程因为依次执行，<strong>不存在线程安全问题，变量访问不会冲突</strong>，共享资源也无需加锁，只需要判断状态即可，所以执行效率比线程高很多。</p><p><strong>协程的语法</strong></p><ul><li><code>yield</code>：暂停，通常用 <code>yield return null</code> 来暂停协程。</li><li><code>StartCoroutine(方法名())</code>：恢复执行。</li><li><code>WaitForSeconds</code>：引入时间延迟，默认情况下，协程将在 yield 后的帧上恢复。使用 <code>yield return new WaitForSecond(.1f)</code> 后，将延迟0.1秒后执行协程。</li></ul><p>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> url = <span class="string">&quot;https://xxxx.xxxx.xxxx/xxxx.jpg&quot;</span>;</span><br><span class="line">WWW www = <span class="keyword">new</span> WWW(url);</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> WWW;</span><br><span class="line">renderer.material.mainTexture = www.texture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当程序执行到 <code>yield return WWW</code>; 时就不会直接往下执行了，而是等到网络请求结束后的第一帧的<code>WWW</code>协程节点触发时才继续执行，也就是说，当网络请求结束后，纹理才会被替换。</p><p><strong>yield return对象</strong></p><ul><li><code>null或数字</code>：在Update后执行，适合分解耗时的逻辑处理。</li><li><code>WaitForFixedUpdate</code>：在FixedUpdate后执行，适合分解物理操作。</li><li><code>WaitForSeconds</code>：在指定时间后执行，适合延迟调用。</li><li><code>WaitForSecondsRealtime</code>：在指定时间后执行，适合延迟调用。不受时间缩放影响。</li><li><code>WaitForEndOfFrame</code>：在每帧结束后执行，适合相机跟随操作。</li><li><code>Coroutine</code>：在另一个协程执行完毕后再执行。</li><li><code>WaitUntil</code>：在委托返回true时执行，适合等待某一操作。</li><li><code>WaitWhile</code>：在委托返回false时执行，适合等待某一操作。</li><li><code>WWW</code>：在请求结束后执行，适合加载数据，如文件、贴图、材质等。</li></ul><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>通过并发编程，我们可以实现更复杂的游戏逻辑，如大规模场景中的动态光照计算、复杂物理效果的实时模拟等，而无需担心这些任务会拖慢游戏的主循环。此外，随着Unity对并发编程支持的不断增强，开发者们将有更多机会探索和利用现代硬件的并行处理能力，为玩家带来更加流畅、逼真的游戏体验。</p><p>从场景切换的异步加载到并发编程的深入探索，我学到了很多。通过掌握并发编程的精髓，我们不仅能够提升游戏的运行效率，还能为游戏设计带来更多可能性，让创意与技术的碰撞绽放出更加璀璨的光芒。</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> Unity开发日记 </tag>
            
            <tag> 并发编程 </tag>
            
            <tag> 场景切换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity日记：小地图</title>
      <link href="/posts/bf08e6b6.html"/>
      <url>/posts/bf08e6b6.html</url>
      
        <content type="html"><![CDATA[<div class="note primary morden flat"><p><strong>今天分享一下如何在Unity小游戏中制作小地图！</strong></p></div><p>在Unity中制作小地图（或雷达）是游戏开发中常见的需求，用于展示游戏世界的局部或全局信息，帮助玩家更好地理解游戏环境。</p><h2 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h2><h3 id="搭建场景"><a href="#搭建场景" class="headerlink" title="搭建场景"></a>搭建场景</h3><p>首先，你需要在Unity中搭建一个简单的游戏场景。这可以包括玩家角色、敌人、障碍物等。</p><h3 id="创建新摄像机"><a href="#创建新摄像机" class="headerlink" title="创建新摄像机"></a>创建新摄像机</h3><ul><li><strong>新建摄像机</strong>：在Unity的层级列表（Hierarchy）中，直接右键选择<code>Camera</code>来创建一个新的摄像机。命名为<code>Minimap Camera</code>以区分主摄像机。</li><li><strong>设置摄像机位置</strong>：将<code>Minimap Camera</code>的位置设置为主角上方或其他你需要的地方，高度和角度都可以根据需要调整，确保摄像机可以捕捉到整个场景或你想要在小地图上显示的部分。</li><li><strong>移除Audio Listener</strong>：因为场景中只能有一个<code>Audio Listener</code>，所以需要从<code>Minimap Camera</code>中移除<code>Audio Listener</code>组件。</li></ul><h3 id="创建Render-Texture"><a href="#创建Render-Texture" class="headerlink" title="创建Render Texture"></a>创建Render Texture</h3><p>在Unity的Assets文件夹中，右键点击选择<code>Create</code> -&gt; <code>Render Texture</code>，创建一个新的Render Texture，命名为<code>Small Map</code>。</p><p><img src="https://s2.loli.net/2024/08/14/kDmMc3pjq8H4J5G.png"></p><h3 id="添加Raw-Image"><a href="#添加Raw-Image" class="headerlink" title="添加Raw Image"></a>添加Raw Image</h3><p>在Canvas中右键点击，选择<code>UI</code> -&gt; <code>Raw Image</code>来创建一个新的Raw Image，命名为<code>Minimap Image</code>。</p><p><img src="https://s2.loli.net/2024/08/14/E8bSOQ7DYuzNCZ1.png"></p><h2 id="配置摄像机"><a href="#配置摄像机" class="headerlink" title="配置摄像机"></a>配置摄像机</h2><h3 id="设置Render-Texture"><a href="#设置Render-Texture" class="headerlink" title="设置Render Texture"></a>设置Render Texture</h3><p><strong>分配Render Texture</strong>：选中<code>Minimap Camera</code>，在检视面板（Inspector）中找到<code>Target Texture</code>字段，将之前创建的<code>Minimap Render Texture</code>拖拽进去。</p><p><img src="https://s2.loli.net/2024/08/14/jE419cAVSPrINFx.png"></p><h3 id="设置Raw-Image"><a href="#设置Raw-Image" class="headerlink" title="设置Raw Image"></a>设置Raw Image</h3><ul><li><strong>分配Render Texture</strong>：将之前创建的<code>Minimap Render Texture</code>拖拽到<code>Minimap Image</code>的<code>Texture</code>字段中。</li></ul><p><img src="https://s2.loli.net/2024/08/14/Z56W3lRFpAkqLJU.png"></p><h3 id="调整大小和位置"><a href="#调整大小和位置" class="headerlink" title="调整大小和位置"></a>调整大小和位置</h3><p>最后根据需要调整<code>Minimap Image</code>的大小和位置，确保它适合你的UI布局，小地图就做好啦！</p><h2 id="丰富小地图操作"><a href="#丰富小地图操作" class="headerlink" title="丰富小地图操作"></a>丰富小地图操作</h2><p>除了简单的地图显示之外，还可以添加一些交互操作，丰富玩家的体验。</p><p>比如我增加了放大、缩小按钮，还实现了点击小地图全屏查看，再次点击恢复的操作。</p><p><img src="https://s2.loli.net/2024/08/14/4q2xDCr3c8dWgSw.png"></p><p><strong>示例：</strong></p><p>放大缩小：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MapSize</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject player; <span class="comment">// player</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 保持在玩家上方</span></span><br><span class="line">        transform.position = <span class="keyword">new</span> Vector3(player.transform.position.x, transform.position.y, player.transform.position.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将相机下移实现放大</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Big</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (transform.position.y &gt; <span class="number">20</span>)</span><br><span class="line">            transform.position = <span class="keyword">new</span> Vector3(transform.position.x, transform.position.y - <span class="number">20</span>, transform.position.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将相机上移实现缩小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Small</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (transform.position.y &lt; <span class="number">400</span>)</span><br><span class="line">            transform.position = <span class="keyword">new</span> Vector3(transform.position.x, transform.position.y + <span class="number">20</span>, transform.position.z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>点击全屏：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClickMap</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject Mapp; <span class="comment">// 地图</span></span><br><span class="line">    <span class="built_in">bool</span> isBig = <span class="literal">false</span>; <span class="comment">// 大小状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Click</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBig) smaller(); <span class="comment">// 变小</span></span><br><span class="line">        <span class="keyword">else</span> Bigger(); <span class="comment">// 变大</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过改变Raw Image在Canvas的大小和位置来实现全屏效果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bigger</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isBig = <span class="literal">true</span>;</span><br><span class="line">        Mapp.GetComponent&lt;RectTransform&gt;().sizeDelta = <span class="keyword">new</span> Vector2(<span class="number">1080</span>, <span class="number">1080</span>);</span><br><span class="line">        Mapp.GetComponent&lt;RectTransform&gt;().anchoredPosition = <span class="keyword">new</span> Vector2(<span class="number">960</span>, <span class="number">-540</span>);</span><br><span class="line">        GetComponent&lt;RectTransform&gt;().sizeDelta = <span class="keyword">new</span> Vector2(<span class="number">1080</span>, <span class="number">1080</span>);</span><br><span class="line">        GetComponent&lt;RectTransform&gt;().anchoredPosition = <span class="keyword">new</span> Vector2(<span class="number">960</span>, <span class="number">-540</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">smaller</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isBig = <span class="literal">false</span>;</span><br><span class="line">        Mapp.GetComponent&lt;RectTransform&gt;().sizeDelta = <span class="keyword">new</span> Vector2(<span class="number">320</span>, <span class="number">320</span>);</span><br><span class="line">        Mapp.GetComponent&lt;RectTransform&gt;().anchoredPosition = <span class="keyword">new</span> Vector2(<span class="number">160</span>, <span class="number">-160</span>);</span><br><span class="line">        GetComponent&lt;RectTransform&gt;().sizeDelta = <span class="keyword">new</span> Vector2(<span class="number">320</span>, <span class="number">320</span>);</span><br><span class="line">        GetComponent&lt;RectTransform&gt;().anchoredPosition = <span class="keyword">new</span> Vector2(<span class="number">160</span>, <span class="number">-160</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多有意思的操作层出不穷，这里只是做个示例哈。分享就到这里啦，别的文章再会！</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> Unity开发日记 </tag>
            
            <tag> 小地图 </tag>
            
            <tag> RenderTextrue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我与口袋方舟的故事...</title>
      <link href="/posts/83f43b84.html"/>
      <url>/posts/83f43b84.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直对游戏开发很感兴趣的我，经常在寻找与了解很多相关知识。</p><p>我们计算机与软件学院有幸组织了一次意义非凡的企业参访活动——走进成都西山居。这次活动让我对游戏行业有了更加深入的了解。</p><p>走进西山居的那一刻，我就被公司内浓厚的文化氛围和创意气息所吸引。位于中国（四川）自由贸易试验区成都高新区万象南路669号佳辰国际中心B座12层15号的西山居，不仅地理位置优越，更在行业内享有盛誉。作为一家以从事研究和试验发展为主的企业，西山居在游戏开发领域取得了令人瞩目的成就，特别是其经典游戏产品《剑侠情缘》系列，更是被誉为中国游戏第一品牌。</p><p>在参访过程中，人力资源总监曾荣竺老师为我们详细介绍了西山居的发展历程、公司文化以及在游戏领域的各项成果。她不仅让我们了解了西山居在游戏制作中的程序、策划、美术三大岗位的具体职责、技能要求以及发展方向，还通过生动的案例和深入浅出的讲解，为我们勾勒出了清晰的职业发展框架。这让我深刻认识到，在游戏行业这个充满挑战与机遇的领域中，只有不断学习、不断进步，才能立于不败之地。</p><p>除了企业介绍外，我们还聆听了正就职于西山居的往届学长的经验分享。他用自己的亲身经历告诉我们，如何通过参与项目制作、参加各类比赛积累实战经验，并最终成功入职西山居。他的建议让我受益匪浅，特别是关于如何尽早制定职业规划、关注行业动态与企业需求、重视实习与实践经历等方面的建议，更是为我未来的学习和实践提供了宝贵的指导。</p><p>在实地参观环节，我们走进了西山居的办公区，亲身感受到了游戏公司的日常工作环境与氛围。有序的办公空间、专注工作的团队成员、充满创意元素的装饰，都让我对游戏从业者的真实生活有了更加直观的了解。这种近距离的接触让我更加坚定了自己投身游戏行业的决心。</p><p>此次参访活动不仅让我对西山居公司有了更加深入的了解，也让我对游戏行业有了更加全面的认识。我深刻感受到，在这个充满竞争与机遇的时代里，只有不断学习、勇于创新、敢于挑战自我，才能在游戏行业这个充满魅力的领域中脱颖而出。同时，我也更加明确了自己的职业规划和发展方向。</p><p><img src="https://s2.loli.net/2024/08/13/4XCwe16O9cYkRgH.jpg" alt="参观照片"></p><p><img src="https://s2.loli.net/2024/08/13/NEhqxcQWyLAXBGf.jpg" alt="参观照片"></p><p><img src="https://s2.loli.net/2024/08/13/VwzPOA8y3NHvhER.jpg" alt="参观照片"></p><p>初次之外，我还报名了网易Y3高校游戏制作人大赛（尽管结果不尽人意…）</p><p><img src="https://s2.loli.net/2024/08/13/ZAFzMhxpiJ9rYRE.jpg"></p><p>直到我又看见口袋方舟的游戏创作训练营，毫不犹豫的报名了。</p><p><img src="https://s2.loli.net/2024/08/13/bpSKqeRXmWywIHM.jpg"></p><hr><div class="note success flat"><p><a href="https://creator.ark.online/">口袋方舟官网</a></p></div><h1 id="口袋方舟之旅"><a href="#口袋方舟之旅" class="headerlink" title="口袋方舟之旅"></a>口袋方舟之旅</h1><p>在这个充满无限创意与可能的时代，我有幸踏上了一段非凡的旅程——参与MetaApp的口袋方舟游戏开发训练营。这不仅是一次技术的探索，更是一场心灵的冒险，让我在游戏开发的浩瀚星海中找到了属于自己的小小方舟。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>口袋方舟编辑器以其低门槛、高自由度的特点，让即便是像我这样的游戏开发新手，也能轻松上手，实现自己的游戏创意。怀揣着对游戏开发的热爱与憧憬，我在学习与尝试中慢慢的熟悉了编辑器的使用。</p><p><img src="https://s2.loli.net/2024/08/13/TOeIniyaCwxVlRp.jpg" alt="口袋方舟编辑器"></p><h2 id="学习与开发"><a href="#学习与开发" class="headerlink" title="学习与开发"></a>学习与开发</h2><p>学习并开发小游戏的日子紧张而充实。从基础的编程知识到高级的游戏设计原理，从界面布局到交互逻辑，每一步都充满了挑战与收获。还有老师们细心解答问题，老师们不仅拥有深厚的专业知识，更有着对游戏开发的无限热情，他们耐心地解答我们的每一个疑问，鼓励我们大胆尝试，勇于创新。</p><p>在这个过程中，我逐渐掌握了使用口袋方舟编辑器开发游戏的各项技能。从构思游戏概念、设计关卡流程、使用预制体搭建游戏，到自己编写需要的代码、调试优化，每一个环节我都亲力亲为，深刻体会到了游戏开发的艰辛与乐趣。</p><p><img src="https://s2.loli.net/2024/08/13/8BqiOmh43dcPkaj.jpg" alt="TypeScript"></p><h2 id="两款小作品的诞生与发布"><a href="#两款小作品的诞生与发布" class="headerlink" title="两款小作品的诞生与发布"></a>两款小作品的诞生与发布</h2><p>经过无数个日夜的努力，我终于独立开发出了两款小游戏，并成功发布到了233平台上。第一款游戏《天空公主》是一款以帮助公主回家为主题的跑酷游戏，玩家需要操控主角越过各种障碍与陷阱，最终到达目的地。第二款游戏《探秘金字塔》则是一款find类游戏，玩家需要找到各种道具解开谜题，收集奖杯，找到最终宝藏。</p><p>这两款游戏的成功发布，不仅让我收获了满满的成就感，更让我看到了自己在游戏开发领域的潜力与可能。当第一个玩家进入游戏，我的心情无比激动！我收到了许多玩家的反馈与鼓励，他们的认可与支持成为了我继续前行的动力。</p><p><img src="https://s2.loli.net/2024/08/13/dUwXCyuzceZ6tMf.jpg" alt="天空公主"></p><p><img src="https://s2.loli.net/2024/08/13/ohxCrHu2qU9m1QF.jpg" alt="天空公主"></p><p><img src="https://s2.loli.net/2024/08/13/k8sIXaWpc3enN64.jpg" alt="探秘金字塔"></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>在参与训练营开发过程中，首先我收获了很多奖品与证书：</p><p><img src="https://s2.loli.net/2024/08/13/nr6xR1wFb9msDoh.jpg" alt="证书"></p><p><img src="https://s2.loli.net/2024/08/13/r7ZyI8XldO3kMfP.jpg" alt="证书"></p><p><img src="https://s2.loli.net/2024/08/13/Ot2jbmDFYWxQcv7.jpg" alt="鼠标垫"></p><p>其次，游戏本身也有广告收入：</p><p><img src="https://s2.loli.net/2024/08/13/O5fDV6STr4lkQHu.png" alt="游戏数据"></p><p>当然，回顾这段经历，我收获的更多的是知识与技能，更重要的是对游戏开发的热爱与坚持。我学会了如何在困难面前不屈不挠，如何在失败中寻找机遇，如何在成功中保持谦逊。这些宝贵的经验将伴随我走过未来的游戏开发之路。<strong>我十分感谢口袋方舟，让我实现了“做游戏给别人玩”的梦想。</strong></p><p>展望未来，我希望能继续深化自己在游戏开发领域的专业知识与技能，不断挑战自我，创作出更多优秀、有趣、富有创意的游戏作品。同时，我也期待能与更多志同道合的朋友一起交流学习，共同推动游戏开发行业的繁荣发展。</p><p>口袋方舟之旅虽然告一段落，但我的游戏开发之路才刚刚开始。我相信，只要心中有梦，脚下就有路。在未来的日子里，我将以更加饱满的热情和坚定的信念，继续在游戏开发的道路上勇往直前！</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 游戏 </category>
          
          <category> 非Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> MetaApp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode插件推荐</title>
      <link href="/posts/c5a23961.html"/>
      <url>/posts/c5a23961.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习编程的过程中，我有幸邂逅并深入使用了多款编译器与集成开发环境（IDE），如经典的<code>Dev-C++</code>，功能强大的<code>Visual Studio（VS）</code>，以及专为C&#x2F;C++和Python等语言设计的<code>CLion</code>，它们各自以其独特的魅力，在不同阶段陪伴并助力了我的学习与成长。</p><div class="note info no-icon flat"><p><strong>Dev-C++</strong></p></div><p>Dev-C++轻量级且易上手，是我初识编程时用的第一款编译器，让我能够快速上手C&#x2F;C++，打好基础。然而，随着学习的深入与项目规模的扩大和需求的复杂化，我开始意识到其在项目管理、代码补全及调试功能上的局限性。</p><div class="note primary no-icon flat"><p><strong>Visual Studio（VS）</strong></p></div><p>之后我接触到了VS2022这款IDE，最初相对Dev，我被它的高级感以及全面的开发能力、强大的调试工具和丰富的插件生态系统吸引。在VS的怀抱中，我感受到了前所未有的开发效率与便捷，虽然我学识尚浅，但我了解到无论是在Web开发、桌面应用还是游戏开发，VS都能提供强大的支持。但与此同时，VS的庞大体积与内存和偶尔的复杂配置也让我在追求轻量级与灵活性的项目中感到些许不便。</p><div class="note success no-icon flat"><p><strong>CLion</strong></p></div><p>CLion则以其对C&#x2F;C++的深入理解和优化，为我提供了更为专业和高效的C&#x2F;C++开发体验。智能的代码分析、快速重构工具以及无缝的集成调试，都让C&#x2F;C++项目的开发变得得心应手。然而，对于多语言支持或是特定框架的快速搭建，CLion或许不是最全面的选择。</p><p><strong>正是在这样的背景下，我遇到了<mark class="hl-label blue">VSCode</mark>。VSCode以其轻量级、跨平台、高度可扩展的特点，迅速成为了我的新宠。它不仅能够提供流畅的代码编辑体验，还通过丰富的插件生态，支持几乎所有主流编程语言及框架，从前端到后端，从Web到移动应用，无所不能。更重要的是，VSCode的启动迅速、界面简洁，让我在快节奏的编程生活中能够保持高效与专注。</strong></p><p>因此，今天我想和大家分享一些我在使用VSCode过程中发现的好用插件，这些插件不仅极大地提升了我的开发效率，也让我对VSCode的热爱更加深厚。接下来，就让我们一起探索这些宝藏插件吧！</p><hr><h1 id="功能篇"><a href="#功能篇" class="headerlink" title="功能篇"></a>功能篇</h1><h2 id="Prettier-Code-formatter"><a href="#Prettier-Code-formatter" class="headerlink" title="Prettier - Code formatter"></a>Prettier - Code formatter</h2><p><img src="https://s2.loli.net/2024/08/11/hG4BqQYTbAXr9xo.png" alt="Prettier - Code formatter"></p><p><code>Prettier - Code formatter</code> 是一款用于代码格式化的插件，‌它支持多种编程语言的代码格式化，‌旨在确保代码风格的一致性。‌Prettier 提供了一种简单的方法来自动调整代码格式，‌使其符合一组预定义的规则，‌从而帮助开发者提高代码的可读性和一致性。‌以下是关于 Prettier - Code formatter 插件的一些详细介绍：‌</p><ul><li><p><strong>配置方式：‌</strong>Prettier 的配置可以通过多种方式进行，‌包括在项目的根目录创建 <code>.prettierrc</code> 文件（‌支持 YML、‌JSON 等格式）‌，‌创建 <code>.prettier.config.js</code> 文件，‌或者在 <code>package.json</code> 文件中添加 Prettier 配置属性。‌这些配置文件允许用户自定义 Prettier 的规则，‌如缩进大小、‌是否使用制表符、‌引号风格等。‌</p></li><li><p><strong>集成使用：‌</strong>Prettier 可以与多种编辑器和构建工具集成，‌包括 Visual Studio Code（‌VSCode）‌、‌GitHub Actions 等。‌在 VSCode 中，‌Prettier 插件可以在保存文件时自动格式化代码，‌确保代码风格的一致性。‌此外，‌Prettier 还可以与 ESLint 集成，‌以确保代码不仅格式正确，‌而且符合一定的编码规范。</p></li><li><p><strong>角色分工：‌</strong>Prettier 主要负责代码的格式化工作，‌而 ESLint 则专注于代码质量和风格的检查。‌通过这种结合使用，‌开发者可以确保代码既没有语法错误，‌又具有一致的格式。‌</p></li><li><p><strong>配置选项：‌</strong>Prettier 提供了丰富的配置选项，‌允许用户根据自己的需求调整代码格式化的具体规则。‌例如，‌可以设置打印宽度、‌制表符宽度、‌是否使用单引号或双引号等。‌</p></li></ul><p>  总的来说，‌Prettier - Code formatter 是一个强大的工具，‌它通过自动化代码格式化过程，‌帮助开发者提高代码的可读性和一致性，‌是现代软件开发中不可或缺的一部分。‌</p><h2 id="Path-Intellisense"><a href="#Path-Intellisense" class="headerlink" title="Path Intellisense"></a>Path Intellisense</h2><p><img src="https://s2.loli.net/2024/08/11/s9aeyhHjiknbV4g.png" alt="Path Intellisense"></p><p><code>Path Intellisense</code>是一个简单但极其实用的VSCode扩展，‌它能够智能感知并自动补全你在代码中引用的文件路径。‌这个扩展通过实时提供匹配的路径建议，‌大大提高了编码效率。‌以下是该扩展的主要特点和功能：‌</p><ul><li><strong>自动补全：‌</strong>一旦你开始键入文件或目录名称，‌插件会实时提供匹配的路径建议，‌帮助你快速找到目标文件。‌</li><li><strong>忽略配置：‌</strong>你可以通过设置禁用TypeScript和JavaScript的内置路径提示，‌以便Path Intellisense成为默认的补全源。‌</li><li><strong>Node包智能感知：‌</strong>配合<code>npm intellisense</code>插件，‌可以实现对Node.js包的智能补全。‌</li><li><strong>应用场景：‌</strong>适用于任何需要引入文件的场景，‌如导入模块、‌读取配置文件等，‌特别适用于大型项目，‌其中有很多层级目录和众多文件。‌</li><li><strong>项目特点：‌</strong>无论是在当前目录还是其他目录，‌Path Intellisense都能即时提供准确的路径建议。‌支持自定义设置，‌如是否显示隐藏文件、‌是否添加文件扩展名，‌以及自动触发下一个建议等功能。‌此外，‌它还尊重<code>tsconfig.json</code>配置，‌特别是<code>baseUrl</code>选项，‌无需重复定义。‌还允许自定义路径映射，‌方便使用绝对路径或者与<code>webpack</code>的r<code>esolve</code>选项搭配使用。‌<br>安装与使用方面，‌你可以在VSCode命令面板中选择“Install Extension”，‌搜索Path Intellisense进行安装。‌然后在设置中添加相关配置，‌即可启用插件。‌通过GIF图可以看到，‌在编写代码时，‌只需敲击几下键盘，‌Path Intellisense就会展示出相应的文件路径，‌让你轻松完成引用。‌</li></ul><h2 id="Image-preview"><a href="#Image-preview" class="headerlink" title="Image preview"></a>Image preview</h2><p><img src="https://s2.loli.net/2024/08/11/27jec9roxbSqLls.png" alt="Image preview"></p><p><code>Image Preview</code>是一个专为Visual Studio Code设计的高效扩展，‌它允许用户在代码文件中直接预览图片，‌无需离开当前的工作流，‌从而极大地提升了工作效率。‌这个扩展在代码行号旁显示图像预览，‌并且在鼠标悬停时也会出现预览，‌提供了实时预览功能，‌能够实时检测并解析代码中的图像路径，‌无论它们是相对路径还是绝对URL。‌Image Preview支持各种文件类型，‌如CSS、‌HTML、‌Markdown等，‌甚至可以识别数据URI。‌它还支持本地文件和网络URL，‌提供了高度自定义性，‌允许用户通过配置项调整预览样式，‌比如设置最大宽度和高度。‌</p><p><img src="https://s2.loli.net/2024/08/11/6P1T43txWzgX9qV.png" alt="示例"></p><p>Image Preview非常适合前端开发、‌Markdown写作以及图片资源管理。‌在编写CSS或HTML时，‌可以立即查看所引用图片的效果，‌而不需要频繁切换到浏览器预览。‌在编辑Markdown文档时，‌可以快速验证插入的图片是否正确展示。‌对于大型项目，‌它可以方便地查看代码中的所有图片，‌避免了手动查找的问题。‌Image Preview的安装过程简单快捷，‌只需通过Visual Studio Code扩展市场搜索并安装即可。‌无论用户是新手还是经验丰富的开发者，‌这个扩展都会成为日常工作中不可或缺的工具。‌</p><p>此外，‌Image Preview还具有智能更新的功能，‌能够自动检测代码变化，‌实时更新预览，‌确保信息始终同步。‌它的简洁直观的预览效果和全面支持的特性，‌以及高度定制化和智能更新的功能，‌使得Image Preview成为提高编码体验和开发生产效率的有力工具。‌</p><h2 id="Error-Lens"><a href="#Error-Lens" class="headerlink" title="Error Lens"></a>Error Lens</h2><p><img src="https://s2.loli.net/2024/08/11/FOiKZRQ2tpNxE9U.png" alt="Error Lens"></p><p><code>Error Lens</code> 是一个非常有用的 Visual Studio Code 扩展，‌它主要改进了错误、‌警告和其他语言诊断的突出显示。‌通过安装这个扩展，‌你可以更直观地看到代码中的问题，‌从而更快地定位和解决错误。‌Error Lens 帮助开发者快速发现代码中的错误，‌直达问题所在，‌提高了代码调试的效率。‌安装完成后，‌需要重启 Visual Studio Code 以使扩展生效。‌此外，‌Error Lens 还提供了键盘快捷方式，‌使得操作更加便捷。‌通过按住 Alt 键，‌可以使用数字键选择和导航指示器，‌进一步提高了使用效率。‌</p><h2 id="Competitive-Programming-Helper-cph"><a href="#Competitive-Programming-Helper-cph" class="headerlink" title="Competitive Programming Helper (cph)"></a>Competitive Programming Helper (cph)</h2><p><img src="https://s2.loli.net/2024/08/11/AQLCaIXTg1pPSju.png" alt="Competitive Programming Helper (cph)"></p><p><strong>超级好用超级推荐的扩展！特别适合热衷刷题以及算法竞赛的小伙伴！</strong></p><p><code>Competitive Programming Helper (cph)</code>是一个非常实用的扩展工具，‌专门为竞赛编程设计，‌旨在提高编程效率和准确性。‌</p><p>cph的主要功能特点包括：‌</p><ol><li><strong>跨平台支持：‌</strong>兼容多种竞赛平台，‌满足多样化的编程需求。‌</li><li><strong>多语言支持：‌</strong>支持包括C++, C, Rust, Go, Python, Java, JavaScript (Node.js)等多种常见编程语言。‌</li><li><strong>一键操作：‌</strong>通过快捷键（‌如Ctrl+Alt+B）‌可以运行测试用例，‌简化操作流程，‌提高使用便捷性。‌</li><li><strong>可定制化：‌</strong>用户可以根据自己的偏好调整设置，‌甚至参与项目的贡献和开发，‌增加使用的灵活性和个性化。‌</li><li><strong>样例测试：‌</strong>以样例的方式对代码进行测试，‌帮助用户检查代码的正确性。‌</li><li><strong>错误流输出：‌</strong>如果在代码执行过程中出现错误流，‌cph会额外显示错误流信息，‌方便用户进行调试。‌</li></ol><p>用户通过VSCode插件中心安装即可用，简单方便。‌此外，‌cph扩展还提供了一个网页插件，‌可以在刷题时打开要做的题目的页面，‌然后在VSCode中通过点击网页上面的绿色小按钮，‌自动创建文件并将所有的测试用例的输入输出复制粘贴过来，‌用户只需直接编写代码即可。‌编写完之后，‌可以通过一键运行判断对错，‌从而提高刷题效率。‌</p><p><img src="https://s2.loli.net/2024/08/11/7ukJX9GtpLPrE8K.png" alt="cph"></p><h2 id="Code-Runner"><a href="#Code-Runner" class="headerlink" title="Code Runner"></a>Code Runner</h2><p><img src="https://s2.loli.net/2024/08/11/p2jAsXHRwJxBdkl.png" alt="Code Runner"></p><p><code>Code Runner</code>扩展是一款强大的Visual Studio Code插件，‌支持运行多种编程语言的代码文件和代码片段。‌</p><p>Code Runner扩展的主要特点包括：‌</p><ul><li><strong>广泛的语言支持：‌</strong>支持包括C、‌C++、‌Java、‌JavaScript、‌PHP、‌Python、‌Ruby、‌Go、‌Lua、‌Groovy、‌PowerShell、‌TypeScript、‌Swift、‌Julia、‌Rust、‌Kotlin、‌Dart、‌Haskell等在内的多种流行编程语言，‌使得这个扩展对于使用多种语言的开发者来说非常有用。‌</li><li><strong>便捷的代码运行：‌</strong>可以直接从编辑器或文件资源管理器中运行代码，‌无需切换到终端或配置复杂的运行环境，‌提高了使用便捷性。‌</li><li><strong>自定义命令执行：‌</strong>允许用户根据需要配置和运行自定义命令，‌为不同的项目和工作流程提供灵活性。‌</li><li><strong>输出控制和展示：‌</strong>直观地在输出窗口中显示代码运行结果，‌方便调试和结果检查。‌</li><li><strong>支持REPL：‌</strong>支持REPL(读取-求值-打印循环)，‌可以提高生产力和效率。‌</li></ul><p>Code Runner扩展的开发者是韩骏，‌他是VS Code中文社区创始人，‌该扩展目前已经有了超过450万的下载量，‌并且在其GitHub项目页面上有详细的文档和社区支持。‌此外，‌Code Runner扩展还支持执行自定义命令，‌使得用户可以根据自己的需求进行灵活配置，‌进一步提高工作效率。‌</p><hr><h1 id="美化篇"><a href="#美化篇" class="headerlink" title="美化篇"></a>美化篇</h1><h2 id="OSU-Mode-3"><a href="#OSU-Mode-3" class="headerlink" title="OSU Mode 3"></a>OSU Mode 3</h2><p><img src="https://s2.loli.net/2024/08/11/SiIz6Jodx5Fhybl.png" alt="OSU Mode 3"></p><p>这款扩展比较小众，是我在逛b站时偶然发现，启用后，在敲代码时，键入的字母及按键会俏皮的弹出，甚至右上角会显示连击次数，在达到一定次数后还可以弹出图片，这让枯燥的敲代码的过程变得十分有趣，虽然本质上意义不大，但还是挺有意思的。</p><p>我在使用的过程中只开启了按键的弹出，毕竟我认为小小花样可以调情，太花里胡哨就适得其反了。</p><p>字母大小、速度以及连击样式与图片都可以按自己的喜好调节，即使追溯起这个扩展的历史有些混乱，但作为使用者我也没有去考虑那么多……</p><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1dR4y1n7tW&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><h2 id="One-Dark-Pro"><a href="#One-Dark-Pro" class="headerlink" title="One Dark Pro"></a>One Dark Pro</h2><p><img src="https://s2.loli.net/2024/08/11/m1XtvPOpD5ZL9dS.png" alt="One Dark Pro"></p><p><strong>它真的很火，因为它真的很不错！超级赞的素颜主题！</strong></p><p><code>One Dark Pro</code>是一款源自Atom的经典主题，‌现已成为VS Code中最受欢迎的主题插件之一。‌它的设计简洁而深邃，‌无论是在编码还是阅读代码时，‌都能为用户提供舒适的视觉体验。‌One Dark Pro主题基于Material Design理念打造，‌提供多种内置风格，‌包括默认、‌扁平、‌暗黑和复古等，‌以适应不同的工作环境和个人喜好。‌此外，‌它还支持自定义配色，‌用户可以通过设置<code>workbench.colorCustomizations</code>和<code>editor.tokenColorCustomizations</code>来个性化调整颜色方案。‌One Dark Pro的特色功能还包括与Markdown预览的完美融合，‌使得文档编写更加美观易读。‌对于喜欢使用斜体代码的开发者，‌One Dark Pro提供了可配置的斜体模式，‌只需在设置中进行调整即可。‌此外，‌为了提高Python开发者的体验，‌它特别兼容了Pylance扩展，‌允许用户定制语义高亮颜色。‌One Dark Pro适用于各种开发场景，‌无论你是前端工程师、‌后端开发者还是数据科学家，‌都可以在这款主题下高效地工作。‌尤其是在长时间编程的情况下，‌其柔和的色彩搭配有助于减轻视觉疲劳，‌保持良好的专注力。‌</p><h2 id="Material-Icon-Theme"><a href="#Material-Icon-Theme" class="headerlink" title="Material Icon Theme"></a>Material Icon Theme</h2><p><img src="https://s2.loli.net/2024/08/11/cNhVk4swRKaLbmC.png" alt="Material Icon Theme"></p><p><strong>特别推荐！</strong></p><p><code>Material Icon Theme</code>无疑是一款让VScode界面焕然一新的必备神器，它不仅极大地提升了开发者的视觉体验，还通过细致入微的设计让代码库变得更加整洁、专业。</p><p>首先，Material Icon Theme以其精美的Material Design风格图标著称，这些图标被精心设计并应用到文件和文件夹上，使得开发者在浏览代码库时能够迅速识别出不同类型的文件。这种直观性不仅提高了工作效率，还减少了因寻找文件而浪费的时间。</p><p>其次，该扩展插件采用了SVG图形，这意味着图标在不同分辨率下都能保持极高的清晰度，无论是高分辨率的4K屏幕还是低分辨率的普通显示器，都能呈现出完美的视觉效果。此外，Material Icon Theme还支持自定义颜色、透明度和饱和度，让开发者可以根据个人喜好调整图标样式，打造个性化的开发环境。</p><p>更令人称赞的是，Material Icon Theme提供了一套完善的设置选项，允许开发者定制文件和文件夹的图标关联，甚至可以导入自己的SVG图标，实现真正的个性化图标设计。这种高度的可定制性使得Material Icon Theme能够满足不同开发者的需求，无论你是前端开发者、后端工程师，还是数据科学家，都能找到适合自己的图标配置。</p><p>在实用性方面，Material Icon Theme同样表现出色。它涵盖了多种编程语言、框架和通用文件类型的图标库，满足各类项目需求。同时，该插件还能与版本控制系统如Git紧密集成，显示文件的状态标记，如未跟踪、已修改和已暂存等，帮助开发者更好地管理代码变更。</p><p>最后，Material Icon Theme的易用性也是其一大亮点。通过VScode的命令面板或用户设置，开发者可以轻松完成图标配置，无需复杂的操作。这种简单而强大的功能使得Material Icon Theme成为VScode用户不可或缺的扩展插件之一。</p><p>综上所述，Material Icon Theme以其精美的图标设计、高度的可定制性、实用的功能以及简单易用的特点赢得了广泛的赞誉。如果你希望让你的VScode界面更具美感和实用性，那么这款插件绝对值得一试。</p><h2 id="background-cover"><a href="#background-cover" class="headerlink" title="background-cover"></a>background-cover</h2><p><img src="https://s2.loli.net/2024/08/11/RSNQoKestDjJiT7.png" alt="background-cover"></p><p><code>background-cover</code>是一个用于Visual Studio Code（‌VSCode）‌的插件，‌它允许用户替换VSCode界面的整体背景，‌而不仅仅是代码区的背景。‌这个插件提供了快捷的图形化配置界面，‌可以满足基本的配置需求，‌如设置图片路径、‌启用&#x2F;停用插件、‌背景透明度等功能。‌用户还可以通过图形界面快捷添加多张图片，‌并实现随机切换功能。‌此外，‌通过修改插件的配置文件，‌用户可以自定义背景样式，‌如调整图片大小、‌位置等，‌以实现个性化的界面背景设置。‌</p><p>该插件的原理是在VSCode加载、‌修改插件设置时，‌自动更新VSCode对应的CSS样式，‌以实现界面背景的更改。‌因此，‌用户可以通过找到插件中配置CSS样式的代码，‌并按照CSS的规则修改对应内容，‌来实现想要的效果。‌这包括调整背景图片的大小、‌位置以及背景颜色的设置等。‌</p><p>总的来说，‌background-cover插件为VSCode用户提供了一个方便的方式来个性化他们的开发环境，‌通过简单的图形化界面或通过修改配置文件来实现复杂的背景设置需求。‌</p><p>注：推荐，但静态壁纸还好，gif动图较占内存</p><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1bs4y1w7fw&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><hr><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>以上就是我精心挑选而且正在使用的一些VSCode插件，它们各具特色，功能强大，无论是在提升编码效率、增强代码质量，还是在美化编辑器、代码方面，都展现出了非凡的价值。我相信，随着你深入使用这些插件，它们将会成为你编程旅程中不可或缺的伙伴，助你在编码的世界里畅游无阻，探索无限可能。</p><p>当然，VSCode的插件生态如此丰富，我推荐的这些只是冰山一角。鼓励大家根据自己的实际需求和偏好，去发现更多适合自己的插件，不断优化自己的开发环境。记住，工欲善其事，必先利其器，一款好的开发工具加上高效的插件辅助，定能让你的编程之路更加顺畅，成就更加辉煌。</p><p>最后，感谢大家的阅读，希望这篇博客能为你带来一些启发和帮助。如果你有任何推荐的VSCode插件或者独特的使用心得，欢迎在评论区留言分享，让我们一起学习，共同进步！期待在未来的编程道路上，与更多的你相遇，共同书写属于我们的精彩篇章。</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp与算法浅记</title>
      <link href="/posts/c50a51df.html"/>
      <url>/posts/c50a51df.html</url>
      
        <content type="html"><![CDATA[<div class="note danger info flat"><p><strong>别急。</strong></p></div><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Roefian的大冒险：初识面向对象!</title>
      <link href="/posts/961490cd.html"/>
      <url>/posts/961490cd.html</url>
      
        <content type="html"><![CDATA[<h1 id="引言——一些简单的尝试"><a href="#引言——一些简单的尝试" class="headerlink" title="引言——一些简单的尝试"></a>引言——一些简单的尝试</h1><h2 id="万年历"><a href="#万年历" class="headerlink" title="万年历"></a>万年历</h2><a class="btn-beautify outline pink larger" href="/pages/WanNianLi/" title="源码"><i class="far fa-hand-point-right"></i><span>源码</span></a><p><img src="https://s2.loli.net/2024/08/12/nDgsW14aFojbQHz.png" alt="万年历"></p><div class="note info flat"><p><strong>图片展示功能有限，源码复制粘贴到编译器运行即可使用！</strong></p></div><p>该程序使用C++<strong>基本语法</strong>及一些<strong>字符串操作</strong>实现了判断闰年、判断某天为星期几、输出某年日历、输出某月日历四个功能。在代码实现中定义并实现了判断闰年、判断星期、输出日历等函数，在主函数中的主循环里做操作判断，分别调用这些函数来实现目标操作。（更多细节可以查看源码，这里不多做赘述）</p><p>‌在该程序中，我除对C语言的熟悉外，最大的收获是了解并使用了<strong>蔡勒公式</strong>来计算星期：<br><code>蔡勒（Zeller）公式</code>是一个用于计算星期的复杂公式，其推导过程涉及对历法规则（如‌闰年、月份天数等）的深入理解和数学运算。蔡勒公式基于‌格里高利历（公历），该历法在1582年进行了改革，废除了儒略历中的10天，并引入了更精确的闰年规则。在蔡勒公式中，为了简化计算，通常将1月和2月视为上一年的13月和14月。公式主要由几个部分组成，包括世纪数、年份、月份和日期，每个部分都通过特定的数学运算（如取整、乘法、加法等）与星期数相关联，<strong>最终，通过将所有部分相加并对7取模（即求余数），得到的结果即为所求日期的星期数（0代表星期日，1代表星期一，依此类推）</strong>。‌由于推导过程涉及大量数学细节和历法知识，这里不展开具体步骤。但可以通过查阅相关数学书籍或文献，了解更详细的推导过程。</p><h2 id="商城商品管理系统"><a href="#商城商品管理系统" class="headerlink" title="商城商品管理系统"></a>商城商品管理系统</h2><a class="btn-beautify outline red larger" href="/pages/ShopManager/" title="源码"><i class="far fa-hand-point-right"></i><span>源码</span></a><p><img src="https://s2.loli.net/2024/08/12/71tOKb4EMUQSTWy.png" alt="商品管理系统"></p><div class="note info flat"><p><strong>图片展示功能有限，源码复制粘贴到编译器运行即可使用！</strong></p></div><p>该程序使用了C++的<code>Vector（容器）</code>动态数组，使用<strong>结构体Vector</strong>代替了常见的管理系统练习项目常用的<strong>结构体链表</strong>这种数据结构。除了Vector相关操作，我还掌握并使用了<code>重载运算符</code>、<code>迭代器</code>等相关知识。</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>C++中的<code>vector</code>是一个非常灵活且功能强大的序列容器，它能够存储具有相同类型的元素序列，并自动管理这些元素的内存。<code>vector</code>属于C++标准模板库（STL）的一部分，它提供了<strong>动态数组</strong>的功能，但与普通数组相比，<code>vector</code>具有更高的<strong>灵活性</strong>和<strong>安全性</strong>。</p><h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><ol><li><p><strong>动态数组</strong>：Vector可以动态地增长和缩小，以适应不同数量的元素。这意味着你不需要在编译时就知道数组的大小，也不需要在数组满时手动分配更大的数组并复制元素。</p></li><li><p><strong>自动内存管理</strong>：Vector自动管理其元素的内存分配和释放。当Vector被销毁时，其所有元素也会被自动销毁。这减少了内存泄漏的风险。</p></li><li><p><strong>随机访问</strong>：Vector支持随机访问其元素，即你可以通过索引直接访问任何位置的元素，类似于普通数组。这使得Vector在处理需要频繁访问元素的应用时非常高效。</p></li><li><p><strong>迭代器</strong>：Vector提供了迭代器，允许你遍历容器中的元素。迭代器提供了对容器中元素的间接访问，并可以递增以访问下一个元素。</p></li><li><p><strong>容量和大小</strong>：Vector有两个重要的属性：<code>size()</code>和<code>capacity()</code>。<code>size()</code>返回容器中元素的数量，而<code>capacity()</code>返回容器在不重新分配内存的情况下可以存储的元素数量。</p></li></ol><h4 id="选择Vector的原因"><a href="#选择Vector的原因" class="headerlink" title="选择Vector的原因"></a>选择Vector的原因</h4><p>我认为结构体Vector相对于结构体链表的优点主要包括以下几点：</p><ul><li><p><strong>高效的随机访问能力</strong>：‌Vector在内存中通常以数组的形式存储，‌这使其支持高效的随机访问。‌与链表相比，‌通过索引直接访问Vector中的元素速度更快，‌因为不需要从头开始遍历链表。‌</p></li><li><p><strong>线程安全性</strong>：‌Vector的所有方法都是线程安全的，‌这意味着在多线程环境中，‌对Vector的操作可以保证数据的一致性和完整性。‌相比之下，‌链表通常不提供线程安全保证，‌因此在多线程环境下使用时需要额外的同步机制。‌</p></li><li><p><strong>较低的空间消耗</strong>：‌虽然链表在空间使用上具有较好的灵活性，‌能够根据需要动态添加和删除节点，‌但在某些情况下，‌Vector可能具有较低的空间消耗。‌这是因为Vector在初始化时分配足够的内存空间，‌减少了频繁内存分配和释放的开销，‌这在处理大量数据时尤其重要。‌</p></li><li><p><strong>简洁方便的写法</strong>：最重要的一点是，无论是在定义调用或删除等任何操作中，Vector的写法总要比链表简单很多。</p></li></ul><h3 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h3><p>C++ 中的<code>运算符重载（Operator Overloading）</code>是一种特殊形式的函数重载，它允许程序员为已存在的运算符（如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>!=</code> 等）赋予新的意义，以便它们可以<strong>用于类的对象</strong>。通过运算符重载，可以使对象的使用更加直观和方便，类似于内置数据类型的操作。更多概念与使用可以查看这里-&gt;<a href="https://www.runoob.com/cplusplus/cpp-overloading.html">菜鸟教程</a></p><p>在本程序中，为商品结构体重定义<code>==</code>运算符，方便find函数查找。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p><code>迭代器</code>是一种用于遍历容器元素的对象，它提供了一种通用的访问容器元素的方式，无论容器的类型和数据结构如何。迭代器在C++标准库中占有重要地位，是<strong>连接容器和算法的重要桥梁</strong>。<code>迭代器(Iterator)</code>是<code>指针(pointer)</code>的泛化，它允许程序员用相同的方式处理不同的数据结构（容器）。每种容器类型都定义了自己的迭代器类型，这种类型支持迭代器的各种行为。迭代器提供了一种方法来顺序访问容器中的各个元素，同时不需要暴露容器的内部表示，这使得算法能够独立于容器的具体实现。</p><p>在程序中我广泛应用迭代器查找和获取元素信息，同时配合find函数（<span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">相关概念</button><span class="hide-content">C++的find函数是定义在algorithm头文件中的一个通用算法，用于在给定范围内查找元素。它返回一个迭代器，指向查找到的元素的位置，如果没有找到，则返回结束迭代器（end迭代器）。</span></span>）与distance函数（<span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">相关概念</button><span class="hide-content">C++的distance函数用于计算两个迭代器之间的距离。它接受两个迭代器作为参数，并返回它们之间的距离。</span></span>）使用，大大提高了效率。</p><h2 id="关于程序设计方法"><a href="#关于程序设计方法" class="headerlink" title="关于程序设计方法"></a>关于程序设计方法</h2><p>程序设计方法是指在进行软件开发过程中，<strong>按照一定的规范和策略来设计和实现计算机程序</strong>的方法论。它涵盖了从需求分析、系统设计、编码实现到测试调试等多个环节，是软件开发领域中的重要理论支撑。程序设计方法旨在通过科学、合理的方法论指导程序的设计和实现，以提高软件的质量和开发效率，同时降低后期维护成本。它使得软件开发过程更加规范化和可控，有助于开发出高效、可靠的计算机程序。</p><p>主要的程序设计方法有：结构化程序设计、面向对象程序设计（OOP）、函数式编程、响应式程序设计、并行程序设计、领域驱动设计（DDD）等。</p><h3 id="结构化程序设计"><a href="#结构化程序设计" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h3><p>在初次尝试自己实现小型功能的项目时，我其实在懵懵懂懂中使用的是简易的<code>结构化程序设计方法（Structured Programming）</code>，也称为面向过程（POP）的程序设计方法。这种方法最早由E.W.Dijkstra在1965年提出，是软件发展的一个重要里程碑。</p><p>结构化程序设计方法主张按功能来分析系统需求，其主要原则可概括为<strong>自顶向下</strong>、<strong>逐步求精</strong>、<strong>模块化</strong>等。它强调将复杂的程序设计任务分解成若干个简单、易于理解和实现的模块，每个模块完成一个特定的功能。</p><h4 id="主要特点-1"><a href="#主要特点-1" class="headerlink" title="主要特点"></a>主要特点</h4><ol><li><strong>模块化</strong>：将程序划分为若干个模块，每个模块完成一个相对独立的功能。这样做的好处是提高了程序的可读性、可维护性和可重用性。</li><li><strong>自顶向下</strong>：从程序的整体功能出发，逐步细化到各个子功能，直到每个子功能都足够简单，可以直接用编程语言实现。</li><li><strong>逐步求精</strong>：在自顶向下的过程中，不断对程序进行细化，确保每个步骤都清晰明确，易于实现。</li><li><strong>控制结构</strong>：结构化程序设计非常强调程序的控制结构，即程序的执行流程。它认为任何算法都可以由<code>顺序结构</code>、<code>选择结构</code>和<code>循环结构</code>这三种基本结构组成。</li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong>：</p><ul><li>结构清晰，易于理解和维护。</li><li>提高了程序的可重用性。</li><li>有利于团队协作和分工。</li></ul><p><strong>缺点</strong>：</p><ul><li>设计不够直观，与人类习惯思维不一致。</li><li>适应性差，可扩展性不强。当用户需求发生改变时，可能需要自顶而下地修改模块结构，维护成本较高。</li></ul><p>结构化程序设计方法是面向对象程序设计之前的一种重要程序设计方法，它在软件工程中发挥了重要作用。然而，随着软件技术的不断发展，面向对象程序设计方法逐渐成为了主流。</p><hr><h1 id="Roefian的大冒险"><a href="#Roefian的大冒险" class="headerlink" title="Roefian的大冒险"></a>Roefian的大冒险</h1><a class="btn-beautify outline purple larger" href="https://github.com/flashfish777/roefian-s-adventure" title="GitHub仓库"><i class="far fa-hand-point-right"></i><span>GitHub仓库</span></a> <div class="note info flat"><p><strong>仓库中有源码及exe程序压缩包，下载即可运行</strong></p></div><p><img src="https://s2.loli.net/2024/08/12/4XFxCA2kJBoLGNH.png" alt="Boss"></p><p>在项目开发中，我选择了VS2022这款IDE、C++为编程语言以及EasyX图形库实现图形化界面。</p><h2 id="EasyX图形库"><a href="#EasyX图形库" class="headerlink" title="EasyX图形库"></a>EasyX图形库</h2><p><a href="https://easyx.cn/">EasyX图形库官方文档</a></p><h3 id="什么是图形库"><a href="#什么是图形库" class="headerlink" title="什么是图形库"></a>什么是图形库</h3><p><code>图形库（Graphics Library）</code>是一组用于<strong>图形处理</strong>的软件函数或类的集合，它们提供了<strong>绘制图形</strong>、<strong>处理图像</strong>、<strong>显示文本</strong>等功能的接口。图形库通常封装了底层的图形系统（如操作系统的图形接口或硬件的图形加速器）的复杂性，使得开发者可以更容易地在应用程序中实现图形界面和视觉效果。</p><p>图形库的主要作用包括：</p><ol><li><p><strong>简化图形开发</strong>：图形库提供了高级的图形处理功能，如绘图、图像处理、动画等，使得开发者无需深入了解底层的图形系统细节，就能实现复杂的图形效果。</p></li><li><p><strong>提高开发效率</strong>：通过使用图形库，开发者可以重用已有的图形处理函数和类，避免重复编写相同的代码，从而提高开发效率。</p></li><li><p><strong>跨平台兼容性</strong>：一些图形库被设计为跨平台的，即它们可以在不同的操作系统上运行，而无需对代码进行大量修改。这使得开发者可以编写一次代码，然后在多个平台上运行图形应用程序。</p></li><li><p><strong>性能优化</strong>：图形库通常会进行性能优化，以确保图形处理的高效性。它们可能会利用硬件加速功能（如GPU加速）来加快图形渲染速度，并提供对图形缓存、批处理等技术的支持。</p></li><li><p><strong>提供高级功能</strong>：除了基本的绘图功能外，图形库还可能提供一些高级功能，如文本渲染、图像处理（如缩放、旋转、裁剪等）、动画效果、用户交互（如鼠标和键盘事件处理）等。</p></li></ol><p>（简单来说就是让我们的代码运行不止于“小黑框”，而是拥有更漂亮的界面与更丰富的交互）</p><h3 id="为什么选择EasyX"><a href="#为什么选择EasyX" class="headerlink" title="为什么选择EasyX"></a>为什么选择EasyX</h3><p><code>EasyX</code>是一款基于C++语言开发的图形库，专为Windows平台设计，具有易于使用、功能强大等特点。基于C++语言开发，采用面向对象的编程方式，封装了Windows API中的GDI+接口。</p><ol><li><strong>简单易学</strong>：EasyX的API设计简单明了，无需掌握复杂的Win32或MFC开发技术，新手可以快速上手，制作出简单的图形界面和动画效果。</li><li><strong>功能全面</strong>：支持多种常用图形和文本操作，包括像素绘制、线条绘制、矩形绘制、圆形绘制、文字输出等功能，还可以播放音效和视频，支持鼠标键盘事件和定时器事件等高级功能。</li><li><strong>高效稳定</strong>：EasyX底层基于Windows API的GDI+接口实现，采用C++面向对象的设计方式，使得其运行高效稳定，能够充分利用计算机硬件资源，保证运行效果流畅。</li><li><strong>轻量级</strong>：EasyX是一个轻量级的图形库，不需要复杂的安装和配置过程，方便开发者快速集成和使用。</li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>（近四千五百行代码两周完成当时真是写麻了，甚至之后还加做了修改器……）</p><p><img src="https://s2.loli.net/2024/08/12/uWPrmYht4VfTjpa.jpg" alt="修改器"></p><p>游戏类型是横板2d闯关类型，有单、双人两种模式，内含八个关卡（包括一个隐藏关）、两个BOSS，玩家通过发射子弹攻击怪物，战胜一个关卡内全部怪物可获得补给并走进下一关，通过全部关卡即为通关，并按操作难度给出成就评价。</p><p>一些代码细节包括：</p><ul><li>每个游戏对象（Game Object）的封装</li><li>图片及音效素材的优化</li><li>游戏地图的链表实现及切换操作</li><li>子弹与怪物的生成与销毁（vector）</li><li>碰撞检测</li><li>单&#x2F;双人的模式</li><li>游戏UI与交互按钮的实现</li></ul><p>等等这些在这里先不做介绍，文章主要想写一些关于面向对象与对程序设计方法的浅谈（虽然前面写的确实过于冗杂了……）如有想了解细节可以通过研究代码以及评论或联系我等方式。</p><p>收获： </p><ul><li>熟悉并熟练应用了C++面向对象编程思想，熟悉了STL库的使用。 </li><li>应用了链表等数据结构与各种算法使程序更优化更简洁易懂。 </li><li>掌握了EasyX图形库的基本用法。 </li><li>了解了从抽象的代码到具象化的小游戏程序的过程。 </li><li>实现了简单的UI与交互按钮。</li></ul><p><strong>Roefian的大冒险小游戏的完成，实现了我“做游戏给自己玩”的梦想！虽然游戏本身很简陋，bug高级多，但能做出来我就已经很满足了！</strong></p><hr><h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在了解我使用C++结合EasyX图形库开发的小游戏之后，让我们对<code>面向对象程序设计（Object-Oriented Programming, OOP）</code>这一核心概念进行一番概览。面向对象程序设计是一种广泛使用的编程范式，<strong>它通过将现实世界中的事物抽象为“对象”来组织代码</strong>，这些对象之间通过消息传递进行交互，从而构建出复杂而灵活的软件系统。</p><h3 id="面向对象的核心概念"><a href="#面向对象的核心概念" class="headerlink" title="面向对象的核心概念"></a>面向对象的核心概念</h3><ol><li><p><strong>对象（Object）</strong>：<br>对象是面向对象编程中的基本单元，它封装了数据（属性）和操作这些数据的方法（行为）。每个对象都是某个类的实例，具有该类的所有属性和方法。</p></li><li><p><strong>类（Class）</strong>：<br>类是对一组具有相同属性和方法的对象的抽象描述。它定义了对象的蓝图，包括对象的属性（数据成员）和可以执行的操作（成员函数）。通过类，我们可以创建具有相似特性和行为的对象集合。</p></li><li><p><strong>封装（Encapsulation）</strong>：<br>封装是隐藏对象的属性和实现细节，仅对外公开接口（即方法）的过程。这有助于保护数据不被随意修改，同时简化了对象的使用方式，只需通过接口与对象交互即可。</p></li><li><p><strong>继承（Inheritance）</strong>：<br>继承允许我们定义一个类（子类或派生类）来继承另一个类（父类或基类）的属性和方法。子类可以拥有父类的所有特性，并可以添加新的特性或覆盖（重写）父类的某些方法。继承是实现代码复用的重要手段。</p></li><li><p><strong>多态（Polymorphism）</strong>：<br>多态允许我们以统一的方式处理不同类型的对象。在面向对象编程中，这通常通过接口（在C++中通过虚函数实现）来实现，使得子类对象可以替换父类对象的位置，而程序仍能正常运行，表现出不同的行为。</p></li></ol><h3 id="面向对象编程的优势"><a href="#面向对象编程的优势" class="headerlink" title="面向对象编程的优势"></a>面向对象编程的优势</h3><ul><li><strong>代码复用</strong>：通过继承，我们可以重用已有的代码，减少重复编写相同功能的代码。</li><li><strong>可维护性</strong>：封装使得每个对象都负责自己的数据和操作，降低了模块间的耦合度，使得系统更易于维护和扩展。</li><li><strong>灵活性</strong>：多态性使得程序能够灵活地处理不同类型的对象，提高了程序的扩展性和可重用性。</li><li><strong>易于理解</strong>：面向对象编程将现实世界中的事物抽象为对象，使得程序结构更加贴近人类思维方式，易于理解和设计。</li></ul><h3 id="在我的小游戏中的应用"><a href="#在我的小游戏中的应用" class="headerlink" title="在我的小游戏中的应用"></a>在我的小游戏中的应用</h3><p>在Roefian的大冒险小游戏中，我充分利用了面向对象编程的这些特性。例如，我定义了多个<strong>类</strong>来表示游戏中的不同元素，如玩家、敌人、子弹等。每个<strong>类</strong>都封装了相应的属性和方法，如位置、速度、绘制方法、移动方法等。通过继承怪物与子弹等的<strong>基类</strong>，我创建了不同类型的敌人及Boss，以及不同特征的子弹，它们共享一些基本的属性和方法，但又有各自独特的行为。此外，我还利用了多态性，在游戏的主循环中统一处理不同类型的对象，使得游戏逻辑更加清晰和灵活。</p><p>通过这个小游戏的开发，我深刻体会到了面向对象编程的强大和魅力，它不仅提高了我的编程效率，还让我对软件设计有了更深入的理解。</p><h2 id="面向对象程序设计的深入理解"><a href="#面向对象程序设计的深入理解" class="headerlink" title="面向对象程序设计的深入理解"></a>面向对象程序设计的深入理解</h2><h3 id="抽象与封装"><a href="#抽象与封装" class="headerlink" title="抽象与封装"></a>抽象与封装</h3><ul><li><p><strong>抽象</strong>：面向对象编程的核心之一是抽象。抽象意味着从复杂的现实世界中提取出最重要的特征，忽略掉不相关的细节。在编程中，我们通过定义类来抽象出具有共同属性和行为的一组对象。这种抽象不仅简化了问题，还使得代码更加通用和可复用。</p></li><li><p><strong>封装的进一步探讨</strong>：封装不仅仅是隐藏数据，它还涉及到如何<strong>安全地访问和修改这些数据</strong>。在C++中，我们通常使用<code>private</code>、<code>protected</code>和<code>public</code>关键字来控制成员的访问权限。<code>private</code>成员只能被类内部的成员函数访问，而<code>public</code>成员则对外部可见。<code>protected</code>成员在继承中扮演特殊角色，它们对派生类可见，但对外部不可见。</p></li></ul><h3 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h3><ul><li><p><strong>继承的层次与类型</strong>：除了基本的单继承外，C++还支持多重继承，即<strong>一个类可以继承自多个基类</strong>。然而，多重继承可能会引入复杂的菱形继承问题（Diamond Problem），因此在实际应用中需要谨慎使用。此外，还有虚继承的概念，它用于解决菱形继承中的二义性问题。</p></li><li><p><strong>组合</strong>：除了继承外，另一种实现代码复用的方式是组合（也称为聚合或包含）。组合是通过在类中包含其他类的对象作为成员来实现的。与继承不同，组合表示的是“has-a”关系，而不是“is-a”关系。组合更加灵活，因为它允许我们在<strong>运行时动态地改变对象的组合方式</strong>。</p></li></ul><h3 id="多态性的实现"><a href="#多态性的实现" class="headerlink" title="多态性的实现"></a>多态性的实现</h3><ul><li><p><strong>虚函数</strong>：在C++中，多态性主要通过虚函数实现。当一个基类的指针或引用指向派生类对象时，通过该指针或引用调用的虚函数将表现出派生类的行为。这是通过虚函数表（vtable）实现的，每个包含虚函数的类都有一个指向vtable的指针，vtable中存储了该类及其所有基类中虚函数的地址。</p></li><li><p><strong>纯虚函数与抽象类</strong>：如果一个类中含有至少一个纯虚函数（即只有声明没有实现的虚函数），则该类为抽象类。抽象类不能被实例化，但可以作为基类被其他类继承。纯虚函数用于在基类中定义一个接口，让派生类去实现具体的行为。</p></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>面向对象编程的一个高级应用是设计模式。设计模式是在软件工程中反复出现的问题的解决方案。它们不是代码本身，而是关于如何组织代码的指导原则。一些常见的面向对象设计模式包括：</p><ul><li><strong>工厂模式</strong>：用于创建对象而不将具体类的代码与客户端代码混合在一起。</li><li><strong>单例模式</strong>：确保一个类只有一个实例，并提供一个全局访问点。</li><li><strong>观察者模式</strong>：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</li></ul><h3 id="面向对象与游戏开发"><a href="#面向对象与游戏开发" class="headerlink" title="面向对象与游戏开发"></a>面向对象与游戏开发</h3><p>在游戏开发中，面向对象编程的优势尤为明显。通过将游戏世界中的每个实体（如角色、怪物、道具等）抽象为对象，并使用类来定义它们的属性和行为，我们可以构建出一个灵活且可扩展的游戏框架。此外，利用继承和多态性，我们可以轻松地实现不同类型的实体和它们之间的交互，从而增加游戏的多样性和可玩性。</p><p>比如游戏引擎 <strong>Unity</strong> 中的 <strong>C#</strong> 语言就是 <strong>面向对象的高级编程语言</strong> ，在Unity中，几乎所有的游戏元素都是通过<code>GameObject</code>来创建的。每个<code>GameObject</code>都可以附加多个<code>Component（组件）</code>，这些<code>Component</code>实际上就是类的<strong>实例</strong>，它们定义了<code>GameObject</code>的行为和属性。例如，一个角色<code>GameObject</code>可以附加<code>Rigidbody</code>组件来控制物理行为，附加<code>Animator</code>组件来控制动画等。在Unity中编写游戏逻辑时，通常会定义多个类来表示不同的游戏元素和逻辑模块。这些类之间通过继承、组合和聚合等关系相互关联，共同构成游戏的核心逻辑。</p><p>总之，面向对象编程是一种强大的编程范式，它为我们提供了一种更加自然和直观的方式来构建复杂的软件系统。通过深入理解面向对象的核心概念和设计原则，我们可以编写出更加高效、可维护和可扩展的代码。</p><h2 id="面向对象方法论"><a href="#面向对象方法论" class="headerlink" title="面向对象方法论"></a>面向对象方法论</h2><p><code>面向对象分析（OOA）</code>、<code>面向对象设计（OOD）</code>和<code>面向对象编程（OOP）</code>是软件工程中紧密相连且逐步深入的三个概念，它们共同构成了面向对象方法论的重要组成部分。</p><h3 id="面向对象分析（OOA）"><a href="#面向对象分析（OOA）" class="headerlink" title="面向对象分析（OOA）"></a>面向对象分析（OOA）</h3><p><strong>定义</strong>：<br>OOA是指通过对问题领域进行分析，识别出其中的实体、关系、行为等要素，并将其抽象为对象、类、继承等概念，以便更好地理解和描述问题。在OOA阶段，通常使用UML（统一建模语言）等工具来进行建模和描述。</p><p><strong>主要任务</strong>：</p><ul><li>确定对象和类：识别并定义系统中的关键对象和类。</li><li>确定结构：分析对象之间的关系，如继承、关联等。</li><li>确定属性和方法：定义对象的属性和操作这些属性的方法。</li></ul><p><strong>重要性</strong>：<br>OOA为后续的OOD和OOP阶段提供了基础，确保了对问题领域的深入理解和准确表达。</p><h3 id="面向对象设计（OOD）"><a href="#面向对象设计（OOD）" class="headerlink" title="面向对象设计（OOD）"></a>面向对象设计（OOD）</h3><p><strong>定义</strong>：<br>OOD是指在OOA的基础上，进一步考虑系统的结构和组织方式，确定类的属性、方法、接口等细节，并进行模块划分、关系建立等设计工作。OOD的目标是将问题领域的抽象模型转化为可执行的软件设计。</p><p><strong>主要任务</strong>：</p><ul><li>细化类和接口：为类和接口添加详细的属性和方法。</li><li>划分模块：将系统划分为多个模块，每个模块包含一组相关的类和接口。</li><li>设计交互：定义对象之间的交互方式和通信机制。</li></ul><p><strong>与OOA的关系</strong>：<br>OOD是对OOA结果的进一步细化和规范化，为OOP阶段提供了详细的设计蓝图。</p><h3 id="面向对象编程（OOP）"><a href="#面向对象编程（OOP）" class="headerlink" title="面向对象编程（OOP）"></a>面向对象编程（OOP）</h3><p><strong>定义</strong>：<br>OOP是指使用面向对象的思想和方法来实现软件系统。在OOP中，程序被组织为一组相互协作的对象，每个对象都有自己的状态和行为，并通过消息传递来进行交互。</p><p><strong>主要特点</strong>：</p><ul><li>封装：将对象的属性和方法绑定在一起，并限制外部对属性的直接访问。</li><li>继承：子类继承父类的属性和方法，实现代码重用和层次化组织。</li><li>多态：同一个操作在不同对象上表现出不同行为的能力。</li></ul><p><strong>与OOD的关系</strong>：<br>OOP是OOD的具体实现阶段，它按照OOD提供的设计蓝图，使用具体的编程语言来编写代码，实现软件系统。</p><h3 id="三者之间的关系"><a href="#三者之间的关系" class="headerlink" title="三者之间的关系"></a>三者之间的关系</h3><ul><li><strong>顺序关系</strong>：从OOA到OOD再到OOP，三者之间存在一定的顺序关系。首先进行面向对象的分析（OOA），然后基于分析结果进行面向对象的设计（OOD），最后根据设计进行面向对象的编程（OOP）。</li><li><strong>相互影响</strong>：虽然存在顺序关系，但三者之间并不是简单的线性关系，而是相互影响、相互支持的。OOA的结果会影响OOD的设计决策，而OOD的设计又会影响OOP的实现方式。同时，OOP的实践经验也可以反馈到OOA和OOD阶段，帮助改进和优化分析和设计过程。</li></ul><p>所以，面向对象分析、面向对象设计和面向对象程序设计是面向对象方法论中不可或缺的三个环节，它们共同推动了软件工程的发展和进步。</p><h2 id="面向对象程序设计的发展"><a href="#面向对象程序设计的发展" class="headerlink" title="面向对象程序设计的发展"></a>面向对象程序设计的发展</h2><p>面向对象程序设计的起源可以追溯到20世纪50年代末期，但其真正作为软件开发范式的主流思想则是在20世纪90年代以后。面向对象的思想是对结构化程序设计的一种继承和发展，它旨在改善结构化程序设计中的不足，使程序设计更加接近于人们看待真实世界的情况。</p><h3 id="关键里程碑"><a href="#关键里程碑" class="headerlink" title="关键里程碑"></a>关键里程碑</h3><ol><li><p><strong>ALGOL 60的封装尝试</strong>：</p><ul><li>50年代后期，在用FORTRAN语言编写大型程序时，常出现变量名在程序不同部分发生冲突的问题。为了解决这一问题，ALGOL语言的设计者在ALGOL 60中采用了以Begin……End为标识的程序块，使块内变量名是局部的，以避免它们与程序中块外的同名变量相冲突。这是编程语言中首次提供封装（保护）的尝试。</li></ul></li><li><p><strong>Simula语言的诞生</strong>：</p><ul><li>1960年代初期，Kristen Nygaard和Ole-Johan Dahl在挪威计算机中心工作时，为了满足系统模拟的需要，开始研发一种更加高抽象层面的编程语言。经过两年的努力，他们于1964年成功推出了Simula语言，这是人类历史上第一款面向对象的编程语言。在Simula中，类被称为process，属性被称为station，方法被称为customer。</li></ul></li><li><p><strong>Smalltalk语言的奠基</strong>：</p><ul><li>随后，Alan Kay结合前人的工作，开发出了Smalltalk语言。Smalltalk在系统设计中强调对象概念的统一，引入了对象、对象类、方法、实例等概念和术语，并采用了动态联编和单继承机制。Smalltalk被认为是真正的面向对象编程语言（OOP）的奠基者。</li></ul></li><li><p><strong>面向对象语言的蓬勃发展</strong>：</p><ul><li>从80年代起，基于以往提出的信息隐蔽和抽象数据类型等概念，以及由Modula2、Ada和Smalltalk等语言所奠定的基础，不同类型的面向对象语言（如Object-C、Eiffel、C++、Java、Object-Pascal、Python等）逐步发展和建立起来。这些语言各具特色，但都遵循面向对象的基本原则。</li></ul></li></ol><h3 id="面向对象程序设计的优点"><a href="#面向对象程序设计的优点" class="headerlink" title="面向对象程序设计的优点"></a>面向对象程序设计的优点</h3><p>与其他程序设计方法相比，面向对象程序设计具有以下显著优点：</p><ol><li><p><strong>符合人们习惯的思维方法</strong>：</p><ul><li>面向对象程序设计将现实世界中的事物抽象为对象，使得程序结构更加接近于人们的思维方式。这种方式便于分解大型的复杂多变的问题，使得软件开发者可以更方便地与问题提出者进行沟通和交流。</li></ul></li><li><p><strong>易于软件的维护和功能的增减</strong>：</p><ul><li>面向对象程序设计中的封装性和对象之间的松散组合，使得软件的修改和维护变得更加容易。当需要增加或修改软件功能时，只需要关注相关的对象和类，而不需要对整个系统进行全面的修改。</li></ul></li><li><p><strong>可重用性好</strong>：</p><ul><li>通过定义和实例化对象，可以在不同的项目中重复使用已经编写好的类。这种重用性不仅提高了软件开发的效率，还减少了代码中的冗余和错误。</li></ul></li><li><p><strong>可扩展性强</strong>：</p><ul><li>面向对象程序设计支持继承和多态等特性，使得代码更具扩展性。通过继承，可以创建新的类来扩展已有类的功能；通过多态，可以在运行时动态地选择不同的方法实现，提供更大的灵活性和可扩展性。</li></ul></li><li><p><strong>封装性提高了代码的安全性和可靠性</strong>：</p><ul><li>面向对象编程通过封装将数据和相关的方法组合在一起，形成类的实例。这样可以隐藏实现的细节，只暴露必要的接口给外部使用，从而提高了代码的安全性和可靠性。</li></ul></li></ol><p>因为这些原因，面向对象程序设计以其独特的优势在软件开发领域占据了重要地位，并成为了当今软件开发的主流范式之一。</p><hr><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>在软件开发的世界里，程序设计方法的多样性是其繁荣与创新的重要源泉。每一种程序设计方法，无论是结构化编程、面向对象编程、函数式编程，还是响应式编程、事件驱动编程、面向切面编程（AOP）等，都拥有其独特的优势与适用场景，而<strong>没有绝对的优与劣之分</strong>。关键在于，开发者需要根据具体项目的需求、团队的技能集、维护的便捷性、以及未来可扩展性等因素，灵活选择和运用最适合当前情况的程序设计方法。</p><p>结构化编程以其清晰的逻辑流程和模块化设计，特别适合处理那些<strong>流程控制较为明确</strong>、<strong>业务逻辑相对简单</strong>的应用场景。而面向对象编程则通过封装、继承和多态等特性，有效提升了代码的重用性、可维护性和可扩展性，尤其适合构建<strong>复杂</strong>、<strong>多变</strong>且<strong>需要长期维护</strong>的系统。函数式编程以其不可变性、纯函数和声明式编程模型，为<strong>并发编程</strong>和<strong>数据流处理</strong>等领域带来了新的思路和效率提升。</p><p>每一种方法都有其光芒四射的场合，也都有可能在某些情境下显得力不从心。因此，重要的是培养一种“<strong>以问题为中心</strong>”的思维模式，而不是盲目追求某种方法的“先进性”或“时髦性”。只有深刻理解项目需求，全面评估各种方法的利弊，才能在众多的选择中找到那把最合适的“钥匙”，打开通往高效、可靠软件开发之路的大门。最终，程序设计的成功与否，不在于方法本身，而在于我们如何智慧地运用这些方法，以解决实际问题并创造价值。</p><p>程序设计方法的不断完善和应用推动了软件开发行业的发展和进步。通过合理运用不同的程序设计方法，开发人员可以在保证软件质量的同时提高开发效率，实现更加高效、可靠的计算机程序。此外，随着新技术和新方法的不断涌现，程序设计方法也在不断演进和发展，以适应不断变化的软件开发需求。在未来，相信随着技术的不断进步和应用场景的不断拓展，程序设计方法也将继续演进和发展，为软件开发行业带来更多的创新和变革。</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 游戏 </category>
          
          <category> 非Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> Easyx图形库 </tag>
            
            <tag> OOP </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记</title>
      <link href="/posts/13675369.html"/>
      <url>/posts/13675369.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p><strong>C语言知识点</strong></p></div><h1 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h1><p>打空格！！！</p><p>逗号后面要打空格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d %d&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运算符前后要打空格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环里的分号后面要打空格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小括号和花括号之间要打空格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双斜杠注释后面打空格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双斜杠和这句话中间有空格</span></span><br></pre></td></tr></table></figure><p>其他还有什么地方要打空格自己意会</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="C主框架"><a href="#C主框架" class="headerlink" title="C主框架"></a>C主框架</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*****************</span></span><br><span class="line"><span class="comment">    *****************/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code>函数，又称主函数，是程序执行的起点。在执行程序时，由系统调用主函数，最后返回，结束程序。主要代码要写在主函数里。</p><p>主函数的类型一般是<code>int</code>，最后由<code>return</code>返回<code>0</code>来结束运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*****************</span></span><br><span class="line"><span class="comment">    *****************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数也可由其他类型定义，如<code>void</code>、<code>signed</code>等，但一般不常见且在一些情况下可能报错。以上为以<code>void</code>做主函数头（无需返回值）。</p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><h3 id="C语言标准库"><a href="#C语言标准库" class="headerlink" title="C语言标准库"></a>C语言标准库</h3><p><code>stdio.h</code>是C语言标准库，提供了C语言最基本的语法以及一些函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数学函数库"><a href="#数学函数库" class="headerlink" title="数学函数库"></a>数学函数库</h3><p><code>math.h</code>里有大量关于数学操作的函数，可以用来更方便的解决问题。常用的有：</p><ul><li><p><code>abs()</code>    对整形数据取绝对值</p></li><li><p><code>fabs()</code>    对浮点型数据取绝对值</p></li><li><p><code>sqrt()</code>    对数据取平方根（<code>double</code>型）</p></li><li><p><code>pow(x, y)</code>    求x的y次幂（<code>double</code>型）</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incude<span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">-3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> c = <span class="number">12.5</span>;</span><br><span class="line">    <span class="type">float</span> d = <span class="number">-5.123</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %lf %f\n&quot;</span>, <span class="built_in">abs</span>(a), <span class="built_in">abs</span>(b), <span class="built_in">fabs</span>(c), <span class="built_in">fabs</span>(d));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> aa = <span class="built_in">sqrt</span>(a);</span><br><span class="line">    <span class="type">int</span> bb = <span class="built_in">pow</span>(b, <span class="number">3</span>); <span class="comment">// -3的3次方</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, aa, bb);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9 3 12.5 5.123</span><br><span class="line">3 -27</span><br></pre></td></tr></table></figure><h3 id="string库"><a href="#string库" class="headerlink" title="string库"></a>string库</h3><ul><li><p><code>string.h</code>中的函数主要用于对字符串进行操作,常用的函数有：</p></li><li><p><code>strlen()</code>    返回字符串的长度。</p></li><li><p><code>strcmp(x, y)</code>    比较字符串<code>x</code>和<code>y</code>，当<code>x &lt; y</code>，返回值小于<code>0</code>；当<code>x = y</code>，返回值等于<code>0</code>；当<code>x &gt; y</code>，返回值大于<code>0</code>。</p></li><li><p><code>strcpy(x, y)</code>    将<code>y</code>指向的字符复制到<code>x</code>中</p></li><li><p><code>strcat(x, y)</code>    将字符串<code>y</code>连接到<code>x</code>的尾部</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">6</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">6</span>] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">6</span>] = <span class="string">&quot;55555&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(a));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">strcmp</span>(a, b);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小于\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;等于\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大于\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(c, b);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcat</span>(a, c);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">小于</span><br><span class="line">HelloWorld</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li><p><code>//</code>    单行注释</p></li><li><p><code>/**/</code>    整段注释</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;Hello World&quot;);</span></span><br><span class="line">    <span class="comment">//printf(&quot;Hello World&quot;);</span></span><br><span class="line">    <span class="comment">//printf(&quot;Hello World&quot;);</span></span><br><span class="line">    <span class="comment">//printf(&quot;Hello World&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="define定义标识符"><a href="#define定义标识符" class="headerlink" title="#define定义标识符"></a>#define定义标识符</h2><p>C语言中可以使用<code>#define</code>来定义一个标识符来表示一个常量,或定义一些宏，定义的标识符,并不占用程序内存,在预编译阶段对程序代码进行文本替换。定义标识符的操作在主函数外面。</p><p>最常见的用法就是<code>#define</code>来定义一些常量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI = 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;圆周率 = %d&quot;</span>, PI);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="typedef-关键字定义"><a href="#typedef-关键字定义" class="headerlink" title="typedef 关键字定义"></a>typedef 关键字定义</h2><p>C语言允许用户使用 <code>typedef</code> 关键字来定义自己习惯的数据类型名称，<code>typedef</code> 的真正含义是给一个已经存在的类型名称起一个别名，注意是已经存在的数据类型，而非变量，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">LL a = <span class="number">12345678</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="定义和赋值"><a href="#定义和赋值" class="headerlink" title="定义和赋值"></a>定义和赋值</h2><p><strong>定义：</strong><code>数据类型</code>  <code>数据名</code> <code>;</code></p><p><strong>定义时赋初值：</strong><code>数据类型</code>  <code>数据名</code>  <code>赋值符号（=）</code>  <code>初值</code> <code>;</code></p><p><strong>同时定义多个：</strong><code>数据类型</code>  <code>数据名</code>  <code>,</code>  <code>数据名</code> <code>;</code></p><p><strong>注意！</strong>  定义时没有赋初值的话这个数据的值就是随机的，有需要时千万别忘了赋初值，没有需要时也赋初值也是一个很好的习惯。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">3.14</span>, d = <span class="number">2.2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %lf %lf&quot;</span>, a, b, c, d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 5 3.14 2.2</span><br></pre></td></tr></table></figure><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><p>在程序运行的过程中，可以改变值的变量称为变量。</p><p>程序运行过程中，不可以发生改变的量叫做常量。</p><p>一般定义的数据默认为变量，可以用<code>define</code>定义常量，也可以在定义时的数据类型前加上<code>const</code>使之成为常量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3</span>,<span class="number">1415926</span>;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><table><thead><tr><th></th><th align="left">类型</th><th>存储大小</th><th>值范围</th></tr></thead><tbody><tr><td><strong>char</strong></td><td align="left">字符型</td><td>1字节</td><td>-128 到 127</td></tr><tr><td><strong>short</strong></td><td align="left">短整型</td><td>2字节</td><td>-32,768 到 32,767</td></tr><tr><td><strong>int</strong></td><td align="left">整型</td><td>4字节</td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td><strong>long</strong></td><td align="left">长整型</td><td>4字节</td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td><strong>long long</strong></td><td align="left">长长整形</td><td>8字节</td><td></td></tr></tbody></table><h3 id="浮点型（实型）"><a href="#浮点型（实型）" class="headerlink" title="浮点型（实型）"></a>浮点型（实型）</h3><table><thead><tr><th></th><th>类型</th><th>存储大小</th><th>值范围</th><th>精度</th></tr></thead><tbody><tr><td><strong>float</strong></td><td>单精度浮点数</td><td>4字节</td><td>1.2E-38 到 3.4E+38</td><td>6 位有效位</td></tr><tr><td><strong>double</strong></td><td>双精度浮点数</td><td>8字节</td><td>2.3E-308 到 1.7E+308</td><td>15 位有效位</td></tr><tr><td><strong>long double</strong></td><td>长双精度浮点数</td><td>16字节</td><td>3.4E-4932 到 1.1E+4932</td><td>19位有效位</td></tr></tbody></table><h3 id="unsigned"><a href="#unsigned" class="headerlink" title="unsigned"></a>unsigned</h3><p>整型变量的值的范围包括负数到正数。 但是在实际应用中，有的数据的范围常常只有正值（如学号、年龄等），为了充分利用变量的值的范围，可以将变量定义为“无符号”类型。可以在类型符号前面加上修饰符 <code>unsigned</code> ，表示指定该变量是“无符号整数”类型。如果加上修饰符 <code>signed</code>或什么都不加，则是“有符号”类型。</p><p>有符号整型数据存储单元中最高位代表数值的符号，如果指定为无符号型，不能存放负数，如 -123 等。由于无符号整型变量不用符号位，所以可表示数值的范围是一般整型变量中的两倍。</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p><a href="https://blog.csdn.net/xiandang8023/article/details/126036564">内存分配-CSDN</a></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在进行运算时，不同类型的数据要转换成同一类型。</p><h3 id="自动类型转换（隐式类型转换）"><a href="#自动类型转换（隐式类型转换）" class="headerlink" title="自动类型转换（隐式类型转换）"></a>自动类型转换（隐式类型转换）</h3><ul><li><p><code>float</code>型数据自动转换成<code>double</code>型；</p></li><li><p><code>char</code>与<code>short</code>型数据自动转换成<code>int</code>型；</p></li><li><p><code>int</code>型与<code>double</code>型数据运算，直接将<code>int</code>型转换成<code>double</code>型</p></li><li><p><code>int</code>型与<code>unsigned</code>型数据、直接将<code>int</code>型转换成<code>unsigned</code>型；</p></li><li><p><code>int</code>型与<code>long</code>型数据，直接将<code>int</code>型转换成<code>long</code>型。</p><p>如此等等，总之是由低级向高级型转换。另外不要错误地理解为先将<code>char</code>型或<code>short</code>型转换成<code>int</code>型，再转换成<code>unsigned</code>型，再转换成<code>long</code>型，直至<code>double</code>型。</p></li></ul><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>强制类型转换的一般形式为：<code>（类型名）</code> <code>（表达式）</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">7</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="type">float</span> y1, y2;</span><br><span class="line"><span class="type">float</span> y1 = a / b; <span class="comment">// y1的值a/b为3.0</span></span><br><span class="line">y2 = (<span class="type">float</span>) (a / b); <span class="comment">// y2的值为3.5， float将a强制转换为实型，b也随之自动转换为实型</span></span><br></pre></td></tr></table></figure><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p>每个字符都对应着一个ASCII码：<a href="https://www.runoob.com/w3cnote/ascii.html">ASCII码表</a></p><p><strong>常用：</strong></p><p><code>0</code>-&gt;<code>48</code></p><p><code>9</code>-&gt;<code>57</code></p><p><code>A</code>-&gt;<code>65</code></p><p><code>Z</code>-&gt;<code>90</code></p><p><code>a</code>-&gt;<code>97</code></p><p><code>z</code>-&gt;<code>122</code></p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>**十进制：**默认数制</p><p> **二进制：**以<code>0B</code>或<code>0b</code>前缀表示，如<code>0b0101</code></p><p>**八进制：**以<code>0</code>前缀表示，如<code>0123</code></p><p>**十六进制：**以<code>0X</code>或<code>0x</code>前缀表示，如<code>0x1A</code></p><p><strong>vc6.0中整形后加<code>l</code>或<code>L</code>表示是<code>long</code>型，加<code>u</code>表示是<code>unsigned</code>型</strong></p><h1 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h1><p>在C语言中，程序的执行分为三种结构：顺序结构、选择结构（分支结构）和循环结构。</p><p>顺序结构：代码从上到下顺序执行，中间没有任何判断和跳转。</p><h2 id="变量输入输出"><a href="#变量输入输出" class="headerlink" title="变量输入输出"></a>变量输入输出</h2><p>在C语言中，输入和输出是通过库函数<code>stdio.h</code>中的<code>scanf()</code>和<code>printf()</code>函数来实现的。在输入与输出时，<code>printf()</code>函数与<code>scanf()</code>函数的格式字符串用于指定输入输出的格式。格式字符串中的格式说明符（如<code>%d</code>表示整数，<code>%f</code>表示浮点数）必须与后面参数的类型和数量相匹配。如果格式字符串与参数不匹配，可能会导致未定义的行为或输出错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">float</span> c;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> e;</span><br><span class="line">    <span class="type">char</span> f[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    %d 十进制有符号整数</span></span><br><span class="line"><span class="comment">%lld long long整数</span></span><br><span class="line"><span class="comment">%u 十进制无符号整数</span></span><br><span class="line"><span class="comment">%f 浮点数</span></span><br><span class="line"><span class="comment">%lf 双精度浮点数</span></span><br><span class="line"><span class="comment">%s 字符串</span></span><br><span class="line"><span class="comment">%c 单个字符</span></span><br><span class="line"><span class="comment">%p 指针的值</span></span><br><span class="line"><span class="comment">%e 指数形式的浮点数</span></span><br><span class="line"><span class="comment">%x,%X 无符号以十六进制表示的整数</span></span><br><span class="line"><span class="comment">%0 无符号以八进制表示的整数</span></span><br><span class="line"><span class="comment">%g 自动选择合适的表示法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c %d %f %lf %lld %s&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d, &amp;e, f); <span class="comment">// 输入时变量要加取地址符（&amp;），字符串不用，详见指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    %nd 表示输出n位整型数,不够n位右对齐</span></span><br><span class="line"><span class="comment">    %.nf 表示小数点后保留n位</span></span><br><span class="line"><span class="comment">%n.mf 表示输出场宽为n+m的浮点数，其中小数位为m,整数位为n,小数点占一位不够n+m位右对齐</span></span><br><span class="line"><span class="comment">%0nd 表示在输出一个小于n位的数值时,将在前面补0使其总宽度为n位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%8d%8d%8d\n&quot;</span>, b, b*<span class="number">10</span>, b*<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%8.2f%8.2f%8.2f\n&quot;</span>, c, c*<span class="number">10</span>, c*<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%08lld%08lld%08lld&quot;</span>, e, e*<span class="number">10</span>, e/<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输入：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a 25 3.456 12.3456 111 hello</span><br></pre></td></tr></table></figure><p><strong>输出如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      25     250    2500</span><br><span class="line">    3.46   34.56  345.60</span><br><span class="line">000001110000111000000011</span><br></pre></td></tr></table></figure><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>C语言中的表达式主要由运算符和操作数构成。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><strong>算术运算符</strong>：<code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code></li><li><strong>赋值运算符</strong>：C语言中的赋值运算符<code>=</code>用于将一个表达式的值赋给变量。此外，C语言还支持复合赋值运算符，如<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code> 等，这些运算符可以简化赋值和算术运算的组合。</li><li><strong>自增自减运算符</strong>：C语言中的自增<code>++</code>和自减 <code>--</code> 运算符用于将变量的值增加或减少1。这些运算符只能用于变量，不能用于常量或表达式。</li><li><strong>位运算符</strong>：<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>^</code>、<code>&amp;</code>、<code>|</code></li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>在C语言中，运算符的优先级决定了表达式中各个运算对象之间的计算顺序，即哪个部分先计算，哪个部分后计算。下面是C语言中常用的运算符优先级列表，从高到低排列：</p><ol><li>括号 ()</li><li>一元运算符：++ - - !</li><li>算术运算符：* &#x2F; %</li><li>算术运算符：+ -</li><li>关系运算符：&lt; &gt; &lt;&#x3D; &gt;&#x3D;</li><li>等价运算符：&#x3D;&#x3D; !&#x3D;</li><li>位运算符：&lt;&lt; &gt;&gt;</li><li>位运算符：&amp;</li><li>位运算符：^</li><li>位运算符：|</li><li>条件运算符 ?:</li><li>赋值运算符：&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</li><li>逗号运算符: ,</li></ol><p>需要注意的是，同一优先级的运算符按照结合性进行计算，大部分运算符遵循<strong>从左至右</strong>的结合性，只有<strong>单目运算符</strong>、<strong>条件运算符</strong>、<strong>赋值运算符</strong>遵循<strong>从右至左</strong>的结合性。</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>C语言中的语句可以分为以下几类：</p><ul><li><strong>表达式语句</strong>：由表达式加上分号<code>;</code>组成，用于计算表达式的值并执行副作用。</li><li><strong>函数调用语句</strong>：由函数名、实际参数加上分号<code>;</code>组成，用于调用函数。</li><li><strong>控制语句</strong>：用于控制程序的执行流程，包括条件判断、循环执行、转向等。</li><li><strong>复合语句</strong>：用花括号<code>&#123;&#125;</code>括起来的一条或多条语句，也称为块。</li><li><strong>空语句</strong>：只有分号<code>;</code>组成的语句，不执行任何操作的语句。</li></ul><h1 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h1><h2 id="if-else-if-else判断结构"><a href="#if-else-if-else判断结构" class="headerlink" title="if-else if- else判断结构"></a>if-else if- else判断结构</h2><h3 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)&#123;</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">    ……</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个if语句，如果表示条件的逻辑表达式的结果不是0，那么就执行后面跟着的这对大括号内的语句；否则就跳过不执行，继续下面的其他语句。</p><p><strong>但是if语句还有一种形式可以不用{}。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &gt; b)</span><br><span class="line">    a += b + <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>if语句这一行结束的时候并没有表示语句结束的”;”，而后面的赋值语句写在if的下一行，而且缩进了，在这一行结束的时候有一个分号。</p><p>表明这条赋值语句是if语句的一部分，if语句拥有和控制这条赋值语句，决定其是否被执行。</p><p>简单地说就是if(逻辑表达式)后要么跟上”{“，要么跟上语句，不能直接写分号。</p><p>**总结：**有大括号的时候 条件满足的情况执行所有括号内语句，无大括号的时候 条件满足执行最近邻语句。</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>​<code>&lt;</code>  <code>&gt;=</code>  <code>&lt;</code>  <code>&lt;=</code> </p><p>​<code>!=</code>   用于测试“不相等”</p><p>​<code>==</code>   用于测试“相等”</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>​<code>&amp;&amp;</code>    </p><p>​逻辑与       理解为： 即 怎么  又 怎么       一假全假，全真为真</p><p>​<code>||</code>        </p><p>​逻辑或     理解为：   要么 怎么 要么 怎么      一真为真， 全假为假</p><p>​<code>！</code></p><p>​逻辑非     真取假  假取真</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;少年\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">18</span> &amp;&amp; age &lt; <span class="number">30</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;青年\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">30</span> &amp;&amp; age &lt; <span class="number">50</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;中年\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">50</span> &amp;&amp; age &lt; <span class="number">80</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;老年\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;老寿星\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch-case选择结构"><a href="#switch-case选择结构" class="headerlink" title="switch-case选择结构"></a>switch-case选择结构</h2><p><code>switch</code>语句也是一种分支语句。 常常用于多分支的情况。<code>else if</code> 语句也能实现多分支情况，但在某些情况下使用<code>else if</code>来实现，会使代码过于复杂。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(整型表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在一个 switch 中可以有任意数量的 case 语句。</span></span><br><span class="line">    <span class="keyword">case</span> 整形常量表达式:</span><br><span class="line">    语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch-case</code>语句一般搭配<code>break</code>和<code>default</code>使用</p><p>中断语句<code>break</code>是C语言中的关键字，用于跳出循环或<code>switch</code>语句的执行。<code>break</code>语句通常用于在满足某个条件时提前终止循环，或在<code>switch</code>语句中匹配到某个<code>case</code>后跳出。</p><p>当 <code>switch</code> 表达式的值并不匹配所有 <code>case</code> 标签的值时，这个 <code>default</code> 子句后面的语句就会执行，<code>switch</code> 语句可以有一个可选的 <code>default</code> <code>case</code>，出现在 <code>switch</code> 的结尾。<code>default</code> <code>case</code> 可用于在上面所有 <code>case</code> 都不为真时执行一个任务。<code>default</code> <code>case</code> 中的 <code>break</code> 语句不是必需的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;day);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (day)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期天\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注</strong>：C语言中的<code>switch</code>语句具有“穿透”性，这意味着如果在<code>switch case</code>中没有使用<code>break</code>语句，那么匹配的<code>case</code>之后的所有<code>case</code>都将被执行。</p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a ? b : c;</span><br></pre></td></tr></table></figure><p>意为若a成立，则执行b，否则执行c。相当于if-else中的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a)</span><br><span class="line">&#123;</span><br><span class="line">b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三目运算符有很多用法，如判断赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">x = a &gt; b ? a : b; <span class="comment">// x = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用三目运算符求出了a与b的最大值并赋给x，相较于</span></span><br><span class="line"><span class="comment">if (a &gt; b)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">x = a;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">x = b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">要简单。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如直接返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a * <span class="number">2</span> : b + a + b / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="布尔变量"><a href="#布尔变量" class="headerlink" title="布尔变量"></a>布尔变量</h2><p><strong>布尔类型</strong>是一种包含两种值的数据类型，即<code>0</code>和<code>1</code>。基本上，<code>bool</code>类型的值表示两种行为，即<code>true</code>或<code>false</code>。在这里，’<code>0&#39;</code>表示<code>false</code>值，而’<code>1</code>‘表示<code>true</code>值。</p><p><strong>在C中，<code>&#39;0&#39; </code>以<code>0</code>的形式存储，而其他整数以<code>1</code>的形式存储,即“非零即true”</strong></p><p>C语言标准库不自带<strong>bool</strong>类型，需要引用<code>stdbool.h</code>头文件或用<code>typedef</code>手动定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span> </span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span><span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="type">bool</span>;</span><br></pre></td></tr></table></figure><p>应用示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> x = <span class="literal">false</span>;  <span class="comment">// 变量初始化 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">true</span>) <span class="comment">// 条件语句</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x的值为真&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x的值为假&quot;</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x的值为假</span><br></pre></td></tr></table></figure><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><p>循环语句具有在某些条件满足的情况下，反复执行特定代码的功能。</p><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>语法形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h2><p>语法形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">语句;</span><br><span class="line">&#125; <span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure><p><code>do while</code> 循环是先直接进⼊循环体，执⾏循环语句，然后再执⾏ <code>while</code> 后的判断表达式，表达式为真，就会进⾏下⼀次，表达式为假，则不再继续循环。</p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>语法形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式1 ⽤于循环变量的初始化 ，表达式2 ⽤于循环结束条件的判断 ，表达式3 ⽤于循环变量的调整，三种表达式都可以省略，但分号不能省略。</p><p><code>for</code>循环和<code>while</code>循环可以相互转换。二者没有性能上的差别。实际开发中，根据具体结构的情况，选择哪个格式更合适、美观。</p><h2 id="break、continue"><a href="#break、continue" class="headerlink" title="break、continue"></a>break、continue</h2><p>在循环执行的过程中，如果某些状况发⽣的时候，需要提前终止循环，这是非常常见的现象。C语言中提供了 <code>break</code> 和 <code>continue</code> 两个关键字，就是应⽤到循环中的。</p><p><code>break</code> 的作用是用于永久的终止循环，只要 <code>break</code> 被执行，直接就会跳出循环，继续往后执行。</p><p><code>continue</code> 的作用是跳过本次循环 <code>continue</code> 后边的代码，在 <code>for</code>循环和 <code>while</code> 循环中有所差异的。</p><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>分支结构和循环结构在使用中都可以嵌套，像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Flag = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Flag) &#123;</span><br><span class="line">        <span class="type">int</span> Flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (Flag) &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> Flag = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            Flag++;</span><br><span class="line">            <span class="keyword">if</span> (Flag &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> Flag = <span class="number">0</span>; Flag &lt;= <span class="number">100</span>; ++Flag) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> Flag = <span class="number">0</span>; Flag &lt;= <span class="number">100</span>; ++Flag) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">static</span> <span class="type">int</span> Flag = <span class="number">-100</span>;</span><br><span class="line">                </span><br><span class="line">                Flag++;</span><br><span class="line">                <span class="keyword">if</span> (Flag &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> Flag = <span class="number">0</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (Flag) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Test 1\r\n&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Test 0\r\n&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong>函数</strong>是指将一组能完成一个功能或多个功能的语句放在一起的<strong>代码结构</strong>。在C语言程序中，至少会包含一个函数，即主函数<code>main()</code>。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><p>​库函数就是存放在函数库中的函数，具有明确的功能、入口调用参数和返回值。</p><p>​<strong>库函数必须知道的一个秘密就是：使用库函数，必须包含 #include 对应的头文件。</strong></p><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>​自定义函数和库函数一样，有函数名，返回值类型和函数参数。</p><p>​例：写一个函数可以找出两个整数中的最大值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (x &gt; y) ? (x) : (y);<span class="comment">//三目运算符：x大于y返回x，x小于y返回y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h2><p>一个在两个数中返回最大值的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (x &gt; y) ? (x) : (y);<span class="comment">//三目运算符：x大于y返回x，x小于y返回y</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> max = cmp(num1, num2);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;max = %d\n&quot;</span>, max);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 20</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max = 20</span><br></pre></td></tr></table></figure><p><strong>函数可以先声明后定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> max = cmp(num1, num2);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;max = %d\n&quot;</span>, max);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cmp(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (x &gt; y) ? (x) : (y);<span class="comment">//三目运算符：x大于y返回x，x小于y返回y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上的代码中，<code>int cmp(int x, int y);</code>先将函数声明，这样的语句叫做函数原型。</p><p>声明即告诉编译器有一个函数叫什么，参数是什么，返回类型是什么。但是具体是不是存在，函数声明决定不了。</p><p>创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</p><p>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。</p><h2 id="返回类型、函数名、形参、实参、返回"><a href="#返回类型、函数名、形参、实参、返回" class="headerlink" title="返回类型、函数名、形参、实参、返回"></a>返回类型、函数名、形参、实参、返回</h2><p>C 语言中的函数定义的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return_type <span class="title function_">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>**返回类型：**一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li><li>**函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li><li><strong>参数：<strong>当函数被调用时，您向参数传递一个值，这个值被称为</strong>实际参数</strong>。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。<strong>形式参数</strong>是指函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才实例化（分配内存单元），所以叫形式参数。形式参数当函数调用完成之后就自动销毁了。因此形式参数只在函数中有效。</li><li>**函数主体：**函数主体包含一组定义函数执行任务的语句。</li></ul><h2 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h2><p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：</p><ul><li><p>在函数或块内部的<strong>局部</strong>变量</p></li><li><p>在所有函数外部的<strong>全局</strong>变量</p></li><li><p>在<strong>形式</strong>参数的函数参数定义中</p></li></ul><p>在某个函数或块的内部声明的变量称为<strong>局部变量</strong>。它们只能被该函数或该代码块内部的语句使用。<strong>局部变量</strong>在函数外部是不可知的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 实际初始化 */</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  c = a + b;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// a，b，c，sum都是main函数的局部变量</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; i ++ )</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">int</span> d;</span><br><span class="line">      d = i * <span class="number">2</span>;</span><br><span class="line">      </span><br><span class="line">      sum += d;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// i，d是for语句中的局部变量</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of a = %d, b = %d and c = %d\n&quot;</span>, a, b, c);</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;sum = %d&quot;</span>, sum);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全局变量</strong>是定义在主函数外部，通常是在程序的顶部。<strong>全局变量</strong>在整个程序生命周期内都是有效的，在任意的函数内部能访问<strong>全局变量</strong>。</p><p>全局变量可以被任何函数或语句访问。也就是说，全局变量在声明后整个程序中都是可用的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 全局变量声明 */</span></span><br><span class="line"><span class="type">int</span> g;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 实际初始化 */</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  g = a + b;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of a = %d, b = %d and g = %d\n&quot;</span>, a, b, g);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全局变量在定义时默认初值为0</strong></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><a href="https://www.runoob.com/cprogramming/c-recursion.html">递归-菜鸟驿站</a></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><strong>数组</strong>是一种<strong>数据结构</strong>，它可以存储一个固定大小的相同类型元素的<strong>顺序集合</strong>。数组中的元素可以通过索引访问，<strong>索引通常从0开始</strong>。</p><h2 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type arrayName [ arraySize ];</span><br></pre></td></tr></table></figure><p>这叫做一维数组。<code>arraySize</code> 必须是一个大于零的整数常量，<code>type</code> 可以是任意有效的 C 数据类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>]; <span class="comment">// 声明一个整型数组，其中包含5个元素，未初始化</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 声明一个整型数组，并初始化</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 声明并初始化一个整型数组</span></span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = arr[3]; // a = 4</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>可以使用循环语句对数组进行遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n[<span class="number">10</span>]; <span class="comment">/* n 是一个包含 10 个整数的数组 */</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化数组元素 */</span>         </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        n[i] = i + <span class="number">100</span>; <span class="comment">/* 设置元素 i 为 i + 100 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出数组中每个元素的值 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;n[%d] = %d\n&quot;</span>, j, n[j] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n[0] = 100</span><br><span class="line">n[1] = 101</span><br><span class="line">n[2] = 102</span><br><span class="line">n[3] = 103</span><br><span class="line">n[4] = 104</span><br><span class="line">n[5] = 105</span><br><span class="line">n[6] = 106</span><br><span class="line">n[7] = 107</span><br><span class="line">n[8] = 108</span><br><span class="line">n[9] = 109</span><br></pre></td></tr></table></figure><h2 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h2><p>数组长度可以使用 <code>sizeof</code> 运算符来获取数组的长度，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); <span class="comment">// 获取数组长度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组长度为: %d\n&quot;</span>, length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组长度为: 5</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>C 语言支持多维数组。多维数组声明的一般形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type name[size1][size2]...[sizeN];</span><br></pre></td></tr></table></figure><p>多维数组最简单的形式是<strong>二维数组</strong>。一个二维数组，在本质上，是一个一维数组的列表。下面是一个二维数组，包含 3 行和 4 列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p><strong>初始化二维数组</strong></p><p>多维数组可以通过在括号内为每行指定值来进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   <span class="comment">/*  初始化索引号为 0 的行 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   <span class="comment">/*  初始化索引号为 1 的行 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;   <span class="comment">/*  初始化索引号为 2 的行 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样也是一样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br></pre></td></tr></table></figure><p>二维数组可以用嵌套的两个循环来遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 一个带有 5 行 2 列的数组 */</span></span><br><span class="line">   <span class="type">int</span> a[<span class="number">5</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">2</span>,<span class="number">4</span>&#125;, &#123;<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">4</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">   <span class="type">int</span> i, j;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出数组中每个元素的值 */</span></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++ )</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d] = %d\n&quot;</span>, i,j, a[i][j] );</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a[0][0] = 0</span><br><span class="line">a[0][1] = 0</span><br><span class="line">a[1][0] = 1</span><br><span class="line">a[1][1] = 2</span><br><span class="line">a[2][0] = 2</span><br><span class="line">a[2][1] = 4</span><br><span class="line">a[3][0] = 3</span><br><span class="line">a[3][1] = 6</span><br><span class="line">a[4][0] = 4</span><br><span class="line">a[4][1] = 8</span><br></pre></td></tr></table></figure><h1 id="字符串（字符数组）"><a href="#字符串（字符数组）" class="headerlink" title="字符串（字符数组）"></a>字符串（字符数组）</h1><p>字符串实际上是使用空字符 <code>\0 </code>结尾的一维字符数组。因此，字符串的实际长度总要多一位，<code>\0</code> 是用于标记字符串的结束。在定义一个字符串时不需要把 <code>\0</code>字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 <code>\0</code> 放在字符串的末尾。</p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>在C语言中，转义字符是以反斜杠<code>\</code>开头，后跟一个字符。它用来表示非打印字符，比如换行<code>\n</code>以及其他一些特殊的字符。</p><p>以下是C语言中常用的转义字符的完整列表：</p><p><code>\\</code>：反斜杠<br><code>\&#39;</code>：单引号<br><code>\&quot;</code>：双引号<br><code>\?</code>：问号<br><code>\a</code>：警报（响铃）<br><code>\b</code>：退格<br><code>\f</code>：换页<br><code>\n</code>：换行<br><code>\r</code>：回车<br><code>\t</code>：制表符（水平制表）<br><code>\v</code>：垂直制表<br><code>\0</code>：空字符<br><code>\ooo</code>：八进制表示的字符（其中 ooo 是一个八进制数，范围为 0-377）<br><code>\xhh</code>：十六进制表示的字符（其中 hh 是一个十六进制数，范围为 00-FF）</p><h2 id="定义与赋值"><a href="#定义与赋值" class="headerlink" title="定义与赋值"></a>定义与赋值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> site[<span class="number">7</span>] = &#123;<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> site[] = <span class="string">&quot;RUNOOB&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>实际上，字符串就是char类型的数组，各种操作都与数组大同小异。</strong></p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>字符串用<code>%s</code>输入输出，且输入时不用加取地址符<code>&amp;</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">char</span> ch[<span class="number">11</span>] = &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">  <span class="type">char</span> ch2[<span class="number">11</span>] = <span class="string">&quot;javatpoint&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Char Array Value is: %s\n&quot;</span>, ch);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;String Literal Value is: %s\n&quot;</span>, ch2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Char Array Value is: javatpoint</span><br><span class="line">String Literal Value is: javatpoint</span><br></pre></td></tr></table></figure><p><strong>注</strong></p><ul><li><code>getchar()</code></li></ul><p>读取一个字符，包括任何字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> a = getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, getchar());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, a);</span><br><span class="line">    </span><br><span class="line">    reutnr <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcdefg</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">a</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>gets()</code></li></ul><p>读取整行输入，直至遇到换行符，然后把换行符，储存其余字符，并在这些字符的末尾添加一个空字符使其成为一个 C 字符串。</p><p>1.<code>gets()</code>函数不安全。<br>2.C11标准委员会已经将其废除，建议能不用尽量不用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    gets(str);  <span class="comment">// 从标准输入流中读取一行字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World！</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World！</span><br></pre></td></tr></table></figure><ul><li><code>%[^\n]</code></li></ul><p><code>%[^\n]</code>是一种输入方法，用到了正则表达式相关用法。它代表输入至换行符时停止。同样的，<code>%[^1]</code>表示输入到1停止，以此类推。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%[^1]&quot;</span>, str);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxxxxxxxxxxx1</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>（能理解多少就理解多少，知道地址与变量的关系就行）</p><p><a href="https://www.runoob.com/cprogramming/c-pointers.html">指针-菜鸟驿站</a></p><p><a href="https://blog.csdn.net/u012060033/article/details/127600005">指针-CSDN</a></p><h2 id="取地址符"><a href="#取地址符" class="headerlink" title="取地址符"></a>取地址符</h2><p>每一个变量都有一个内存位置，每一个内存位置都定义了可使用 <code>&amp;</code> 运算符访问的地址，它表示了在内存中的一个地址。</p><p>下面一个例子输出变量的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p;              <span class="comment">// 定义指针变量</span></span><br><span class="line">    p = &amp;var_runoob;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a 变量的地址： %p\n&quot;</span>, p);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a 变量的地址： 0x7ffeeaae08d8</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_41823495/article/details/133692629">指针与地址</a></p><h2 id="取内容符"><a href="#取内容符" class="headerlink" title="取内容符"></a>取内容符</h2><p>指针变量定义格式：存储类型 数据类型 指针变量名；</p><p><code>int *p</code>: 定义了一个指针变量p,指向的数据是int类型的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="type">char</span> c=<span class="string">&#x27;v&#x27;</span>;</span><br><span class="line"><span class="type">char</span> *q=&amp;c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>, p, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>,q,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,a,*p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c %c\n&quot;</span>,c,*q);</span><br></pre></td></tr></table></figure><p><strong>访问指针所指向空间的内容用取内容运算符<code>*</code></strong></p><p>那么p变量存放的就是a的地址，q变量存放的是c的地址。</p><p>符号<code>*</code>可以访问地址里面的内容。</p><h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><p>在 C 语言中，数组名表示数组的地址，即数组首元素的地址。当我们在声明和定义一个数组时，该数组名就代表着该数组的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br></pre></td></tr></table></figure><p>在这里，<code>myArray</code> 是数组名，它表示整数类型的数组，包含 5 个元素。<code>myArray</code> 也代表着数组的地址，即第一个元素的地址。</p><p>数组名本身是一个常量指针，意味着它的值是不能被改变的，一旦确定，就不能再指向其他地方。</p><p>我们可以使用&amp;运算符来获取数组的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;myArray[<span class="number">0</span>]; <span class="comment">// 或者直接写作 int *ptr = myArray;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>ptr</code> 指针变量被初始化为 <code>myArray</code> 的地址，即数组的第一个元素的地址。</p><p>需要注意的是，虽然数组名表示数组的地址，但在大多数情况下，数组名会自动转换为指向数组首元素的指针。这意味着我们可以直接将数组名用于指针运算，例如在函数传递参数或遍历数组时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]); <span class="comment">// 数组名arr被当作指针使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    printArray(myArray, <span class="number">5</span>); <span class="comment">// 将数组名传递给函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>printArray</code> 函数接受一个整数数组和数组大小作为参数，我们将 <code>myArray</code> 数组名传递给函数，函数内部可以像使用指针一样使用 <code>arr</code> 数组名。</p><h2 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h2><p><strong>传递指针给函数</strong></p><p>C 语言允许传递指针给函数，只需要简单地 <strong>声明函数参数为指针类型</strong> 即可。</p><p>下面的实例中，我们传递一个无符号的 long 型指针给函数，并在函数内改变这个值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">getSeconds</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *par)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> sec;</span><br><span class="line">   getSeconds( &amp;sec );</span><br><span class="line">   <span class="comment">/* 输出实际值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Number of seconds: %ld\n&quot;</span>, sec );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getSeconds</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *par)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 获取当前的秒数 */</span></span><br><span class="line">   *par = time( <span class="literal">NULL</span> );</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number of seconds :1294450468</span><br></pre></td></tr></table></figure><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体（<code>struct</code>）是一种构造类型，它可以将不同的数据类型组合在一起形成一个新的数据类型，这种新的数据类型就是结构体。 </p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>定义和声明结构体的同时创建变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; stu; <span class="comment">// 创建了一个名为stu的结构体变量</span></span><br></pre></td></tr></table></figure><p>先定义结构体，然后声明变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>;</span> <span class="comment">// 创建了一个名为stu的结构体变量</span></span><br></pre></td></tr></table></figure><p>使用typedef定义别名，然后创建变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; Student;</span><br><span class="line"> </span><br><span class="line">Student stu; <span class="comment">// 创建了一个名为stu的结构体变量</span></span><br></pre></td></tr></table></figure><p>在结构体内部不初始化成员，而是在创建结构体变量后初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; stu = &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>, <span class="number">90.5f</span>&#125;; <span class="comment">// 在定义变量的同时进行初始化</span></span><br></pre></td></tr></table></figure><h2 id="访问-1"><a href="#访问-1" class="headerlink" title="访问"></a>访问</h2><p>使用指针访问结构体成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span> =</span> &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>, <span class="number">90.5f</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p</span> =</span> &amp;stu;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (*p).name); <span class="comment">// 使用指针访问结构体成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p-&gt;name); <span class="comment">// 另一种访问结构体成员的方式</span></span><br></pre></td></tr></table></figure><p>在结构体数组中存储数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; stu[<span class="number">3</span>]; <span class="comment">// 创建了一个结构体数组，可以存储3个学生的信息</span></span><br></pre></td></tr></table></figure><p>使用结构体指针访问结构体数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; stu[<span class="number">3</span>], *p;</span><br><span class="line"> </span><br><span class="line">p = stu;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (p+<span class="number">1</span>)-&gt;name); <span class="comment">// 访问第二个学生的名字</span></span><br></pre></td></tr></table></figure><p>在结构体中使用结构体类型成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">birthday</span>;</span></span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span> =</span> &#123;<span class="string">&quot;Tom&quot;</span>, &#123;<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>&#125;, <span class="number">90.5f</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, stu.birthday.year); <span class="comment">// 访问学生的出生年份</span></span><br></pre></td></tr></table></figure><h2 id="链表-结构体指针"><a href="#链表-结构体指针" class="headerlink" title="链表-结构体指针"></a>链表-结构体指针</h2><p><a href="https://blog.csdn.net/Ruaaa_iiiiiiiii/article/details/129499703">结构体链表</a></p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/posts/d95d7e09.html"/>
      <url>/posts/d95d7e09.html</url>
      
        <content type="html"><![CDATA[<p><strong>一天晚上，一个懵懵懂懂的电脑小白决心创建一个自己的博客网页，他找了很多教程，因为什么都不懂，这期间他也遇到了很多困难。但他没有放弃，失败了就删掉文件从头开始，哪里不懂就上网查，终于搞出了自己的第一个博客网站……</strong></p><h3 id="一、自我介绍"><a href="#一、自我介绍" class="headerlink" title="一、自我介绍"></a>一、自我介绍</h3><div class="note info flat"><p><strong>首先允许我郑重的以主人的身份入驻我的博客网站！</strong></p></div><p>想当高手.jpg<br>本人男性取向女，梦想是<mark class="hl-label blue">做游戏</mark>（做很棒很棒的游戏，让所有人都玩我的游戏！），性格<mark class="hl-label green">INFP</mark>，乐观开朗，跟不熟的人有点腼腆，喜欢运动，会踢足球，会打羽毛球乒乓球台球，但是不厉害，喜欢交朋友，喜欢敲代码，学习新知识，喜欢打游戏，什么游戏都玩 但是都很菜，最喜欢的是<mark class="hl-label orange">吃糖</mark>。<br>此时此刻我才是一名刚刚接触计算机与编程的大一学生，在开学之前苦战两个月c语言考进了学校的计科院学生团队，有很多厉害的学长学姐带我学习，带我走进这个神奇的世界，一步步实现自己的梦想。</p><h3 id="二、为什么是博客"><a href="#二、为什么是博客" class="headerlink" title="二、为什么是博客"></a>二、为什么是博客</h3><p>刚开始的时候，编程对我来说只是一个遥远而神秘的词汇。每当看到屏幕上那些密密麻麻的代码，我就像是一个站在高墙之外的旁观者，既好奇又敬畏。但随着时间的推移，我逐渐发现，编程不仅仅是一堆冷冰冰的字符和逻辑，它更是一种创造力和思维方式的展现。每一次编写代码，都是在构建一个属于自己的世界，那种从无到有的过程，让我感受到了前所未有的成就感和满足感。使我更加坚定了我的目标。<br>我眼中的博客，是大佬们记录和分享知识的圣地，记录了学习的点滴进步，分享遇到的挑战和解决方案，以及各种奇闻异事或趁手的工具。在这里我可以写下任何我想写的东西。<br><strong>作为程序员，我们每天都在进行无穷无尽知识输入却很少有机会能够输出。输出的重要性一是在于反思和总结，能让我更加清晰地认识到自己的不足和需要改进的地方，二是太多的知识无法消化便可以先记录下来，学习是一个在实践中不断碰壁的过程，三是一个人的思考不如大家的思考，我可以同他人一起交流我的观点与思路，可以让我结识更多多志同道合的朋友和前辈，他们的经验和建议都能让我受益匪浅。</strong><br>而且我相信，<strong>在撰写博客的过程中，我可以逐渐形成了自己的写作风格和思考方式。可以尝试用通俗易懂的语言解释复杂的技术问题，用生动的例子和贴切的比喻帮助读者更好地理解编程概念。这本身也是对我的表达能力的一种很好的锻炼。同时我也希望通过我的努力，能够让更多的人感受到编程的乐趣和魅力，从而激发他们对编程的兴趣和热情。</strong><br>我相信，知识的力量在于传播和共享。通过分享我的学习心得和项目经验，我不仅能够帮助到那些正在学习编程的朋友，还能够从他们的反馈和建议中汲取新的灵感和思路。这种双向的交流和学习，可以让我感受到智慧的碰撞和传承的力量。</p><p>另外，谁不想拥有一个可以DIY的属于自己的炫酷的网页呢……</p><h3 id="三、未来"><a href="#三、未来" class="headerlink" title="三、未来"></a>三、未来</h3><p>对未来，我充满了期待和憧憬。我希望能够继续深化我的编程技能，特别是在游戏开发领域，因为我始终相信，游戏是传递快乐和创意的最佳载体。我要通过一点一滴的积累来实现我的目标。<br>我也希望能够将我的博客打造成一个更专业、更全面、更有影响力的平台。我会发表很多很多的文章来记录我的成长之路。<br>我相信，只要我们保持对知识的渴望和对梦想的追求，就一定能够在编程的道路上不断前行、不断超越自我，实现自己的理想！</p><p>—end—</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"flashfish777_blog","short_name":"flashfish777_blog","theme_color":"#3b70fc","background_color":"#3b70fc","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/144.png","sizes":"144x144","type":"image/png"},{"src":"/img/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;}div#menus {    font-family: "ZhuZiAYuanJWD";}h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;}a.article-title,a.blog-slider__title,a.categoryBar-list-link,h1.post-title {    font-family: ZhuZiAYuanJWD;}.iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;}/* 时间轴生肖icon *//* svg.icon {    这里定义svg.icon，避免和Butterfly自带的note标签冲突    width: 1em;    height: 1em;    width和height定义图标的默认宽度和高度    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;} */.icon-zhongbiao::before {    color: #f7c768;}/* 解决artitalk的图标问题 */#uploadSource>svg {    width: 1.19em;    height: 1.5em;}/*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 *//* #page-header:not(.not-top-img):before {    background-color: transparent !important;} */:root {    --trans-light: rgba(255, 255, 255, 0.88);    --trans-dark: rgba(25, 25, 25, 0.88);    --border-style: 1px solid rgb(169, 169, 169);    --backdrop-filter: blur(5px) saturate(150%);}/* 首页文章卡片 */#recent-posts>.recent-post-item {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 25px;    border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 18px;    border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive,div#tag,div#category {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border: var(--border-style);    border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {    background: rgba(255, 255, 255, 0.75);    backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {    background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts>.recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page,[data-theme="dark"] div#tag, [data-theme="dark"] div#category {    background: var(--trans-dark);}/* 夜间模式伪类遮罩层透明[data-theme="dark"] #recent-posts>.recent-post-item {    background: #121212;}[data-theme="dark"] .card-widget {    background: #121212 !important;}[data-theme="dark"] div#post {    background: #121212 !important;}[data-theme="dark"] div#tag {    background: #121212 !important;}[data-theme="dark"] div#archive {    background: #121212 !important;}[data-theme="dark"] div#page {    background: #121212 !important;}[data-theme="dark"] div#category {    background: #121212 !important;}[data-theme="dark"] div#category {    background: transparent !important;} */[data-theme="dark"] #footer::before {    background: transparent !important;}/* [data-theme="dark"] #page-header::before {    background: transparent !important;} *//* 阅读模式 */.read-mode #aside-content .card-widget {    background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {    background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;}[data-theme="dark"] .read-mode div#post {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;}/* 页脚透明 */#footer {    background: transparent !important;}/* 头图透明 *//* #page-header {    background: transparent !important;} */#rightside>div>button {    border-radius: 5px;}/* 滚动条 */::-webkit-scrollbar {    width: 10px;    height: 10px;}::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;}::-webkit-scrollbar-corner {    background-color: transparent;}::-moz-selection {    color: #fff;    background-color: #3b70fc;}/* 音乐播放器 *//* .aplayer .aplayer-lrc {  display: none !important;} */.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */}.aplayer.aplayer-fixed {    z-index: 999999 !important;}/* 评论框  */.vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;}/* 设置评论框 */.vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;}/* md网站下划线 */#article-container a:hover {    text-decoration: none !important;}#article-container #hpp_talk p img {    display: inline;}/* 404页面 */#error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);}#error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;}#error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;}#error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;}#error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;}#error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;}#error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);}#body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;}#body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;}#body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;}#body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;}#body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;}#body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;}#body-wrap.error .aside-list .aside-list-item .content time {    display: none;}/* 代码框主题 */#article-container figure.highlight {    border-radius: 10px;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content>.card-widget.card-info {    background: linear-gradient(-45deg,            #e8d8b9,            #eccec5,            #a3e9eb,            #bdbdf0,            #eec1ea);    box-shadow: 0 0 5px rgb(66, 68, 68);    position: relative;    background-size: 400% 400%;    -webkit-animation: Gradient 10s ease infinite;    -moz-animation: Gradient 10s ease infinite;    animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@-moz-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content>.card-widget.card-info {    background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content>.card-widget.card-info>#card-info-btn {    background-color: #3eb8be;    border-radius: 8px;}/* 鼠标样式 */#cursor {    position: fixed;    width: 16px;    height: 16px;    /* 这里改变跟随的底色 */    background: rgb(111, 57, 197);    border-radius: 8px;    opacity: 0.25;    z-index: 10086;    pointer-events: none;    transition: 0.2s ease-in-out;    transition-property: background, opacity, transform;}#cursor.hidden {    opacity: 0;}#cursor.hover {    opacity: 0.1;    transform: scale(2.5);    -webkit-transform: scale(2.5);    -moz-transform: scale(2.5);    -ms-transform: scale(2.5);    -o-transform: scale(2.5);}#cursor.active {    opacity: 0.5;    transform: scale(0.5);    -webkit-transform: scale(0.5);    -moz-transform: scale(0.5);    -ms-transform: scale(0.5);    -o-transform: scale(0.5);}/* 一级菜单居中 */#nav .menus_items {    position: absolute !important;    width: fit-content !important;    left: 50% !important;    transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {    display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(2) .menus_item_child {    left: -90px;}.menus_items .menus_item:nth-child(3) .menus_item_child {    left: -75px;}/* 日间模式不生效 */[data-theme="light"] #site-name,[data-theme="light"] #site-title {    animation: light_15px 10s linear infinite;}[data-theme="light"] #site-subtitle {    animation: light_10px 10s linear infinite;}[data-theme="light"] #post-info {    animation: light_5px 10s linear infinite;}/* 夜间模式生效 */[data-theme="dark"] #site-name,[data-theme="dark"] #site-title {    animation: light_15px 10s linear infinite;}[data-theme="dark"] #site-subtitle {    animation: light_10px 10s linear infinite;}[data-theme="dark"] #post-info {    animation: light_5px 10s linear infinite;}/* 关键帧描述 */@keyframes light_15px {    0% {        text-shadow: #5636ed 0 0 15px;    }    12.5% {        text-shadow: #11ee5e 0 0 15px;    }    25% {        text-shadow: #f14747 0 0 15px;    }    37.5% {        text-shadow: #f1a247 0 0 15px;    }    50% {        text-shadow: #f1ee47 0 0 15px;    }    50% {        text-shadow: #b347f1 0 0 15px;    }    62.5% {        text-shadow: #002afa 0 0 15px;    }    75% {        text-shadow: #ed709b 0 0 15px;    }    87.5% {        text-shadow: #39c5bb 0 0 15px;    }    100% {        text-shadow: #5636ed 0 0 15px;    }}@keyframes light_10px {    0% {        text-shadow: #5636ed 0 0 10px;    }    12.5% {        text-shadow: #11ee5e 0 0 10px;    }    25% {        text-shadow: #f14747 0 0 10px;    }    37.5% {        text-shadow: #f1a247 0 0 10px;    }    50% {        text-shadow: #f1ee47 0 0 10px;    }    50% {        text-shadow: #b347f1 0 0 10px;    }    62.5% {        text-shadow: #002afa 0 0 10px;    }    75% {        text-shadow: #ed709b 0 0 10px;    }    87.5% {        text-shadow: #39c5bb 0 0 10px;    }    100% {        text-shadow: #5636ed 0 0 10px;    }}@keyframes light_5px {    0% {        text-shadow: #5636ed 0 0 5px;    }    12.5% {        text-shadow: #11ee5e 0 0 5px;    }    25% {        text-shadow: #f14747 0 0 5px;    }    37.5% {        text-shadow: #f1a247 0 0 15px;    }    50% {        text-shadow: #f1ee47 0 0 5px;    }    50% {        text-shadow: #b347f1 0 0 5px;    }    62.5% {        text-shadow: #002afa 0 0 5px;    }    75% {        text-shadow: #ed709b 0 0 5px;    }    87.5% {        text-shadow: #39c5bb 0 0 5px;    }    100% {        text-shadow: #5636ed 0 0 5px;    }}/* 背景宇宙星光  */#universe {    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;}body::-webkit-scrollbar {    width: 0;}.neko {    width: 80px;    height: 80px;    background-image: url("https://s2.loli.net/2024/08/20/n1JarOiLfmy9xC3.gif");    position: absolute;    right: 25px;    background-repeat: no-repeat;    background-size: contain;    transform: translateX(50%);    cursor: pointer;    font-family: tzy;    font-weight: 600;    font-size: 16px;    color: #6f42c1;    display: none;}.neko::after {    display: none;    width: 100px;    height: 100px;    background-image: url("https://bu.dusays.com/2022/07/20/62d812d95e6f5.png");    background-size: contain;    z-index: 9999;    position: absolute;    right: 50%;    text-align: center;    line-height: 100px;    top: -115%;}.neko.showMsg::after {    content: attr(data-msg);    display: block;    overflow: hidden;    text-overflow: ellipsis;}.neko:hover::after {    content: attr(data-msg);    display: block;    overflow: hidden;    text-overflow: ellipsis;}.neko.fontColor::after {    color: #333;}/** * @description: 滚动条样式  跟猫二选一 */@media screen and (max-width:992px) {    ::-webkit-scrollbar {        width: 8px !important;        height: 8px !important    }    ::-webkit-scrollbar-track {        border-radius: 2em;    }    ::-webkit-scrollbar-thumb {        background-color: rgb(255 255 255 / .3);        background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent);        border-radius: 2em    }    ::-webkit-scrollbar-corner {        background-color: transparent    }}/* 文章页H1-H6图标样式效果 */h1::before,h2::before,h3::before,h4::before,h5::before,h6::before {    -webkit-animation: ccc 1.6s linear infinite;    animation: ccc 1.6s linear infinite;}@-webkit-keyframes ccc {    0% {        -webkit-transform: rotate(0deg);        transform: rotate(0deg);    }    to {        -webkit-transform: rotate(-1turn);        transform: rotate(-1turn);    }}@keyframes ccc {    0% {        -webkit-transform: rotate(0deg);        transform: rotate(0deg);    }    to {        -webkit-transform: rotate(-1turn);        transform: rotate(-1turn);    }}#content-inner.layout h1::before {    color: #ef50a8;    margin-left: -1.55rem;    font-size: 1.3rem;    margin-top: -0.23rem;}#content-inner.layout h2::before {    color: #fb7061;    margin-left: -1.35rem;    font-size: 1.1rem;    margin-top: -0.12rem;}#content-inner.layout h3::before {    color: #ffbf00;    margin-left: -1.22rem;    font-size: 0.95rem;    margin-top: -0.09rem;}#content-inner.layout h4::before {    color: #a9e000;    margin-left: -1.05rem;    font-size: 0.8rem;    margin-top: -0.09rem;}#content-inner.layout h5::before {    color: #57c850;    margin-left: -0.9rem;    font-size: 0.7rem;    margin-top: 0rem;}#content-inner.layout h6::before {    color: #5ec1e0;    margin-left: -0.9rem;    font-size: 0.66rem;    margin-top: 0rem;}#content-inner.layout h1:hover,#content-inner.layout h2:hover,#content-inner.layout h3:hover,#content-inner.layout h4:hover,#content-inner.layout h5:hover,#content-inner.layout h6:hover {    color: #3b70fc;}#content-inner.layout h1:hover::before,#content-inner.layout h2:hover::before,#content-inner.layout h3:hover::before,#content-inner.layout h4:hover::before,#content-inner.layout h5:hover::before,#content-inner.layout h6:hover::before {    color: #3b70fc;    -webkit-animation: ccc 3.2s linear infinite;    animation: ccc 3.2s linear infinite;}/* 页面设置icon转动速度调整 */#rightside_config i.fas.fa-cog.fa-spin {    animation: fa-spin 1s linear infinite;}/*哔哩哔哩视频适配*/.aspect-ratio {    position: relative;    width: 100%;    height: 0;    padding-bottom: 75%;    margin: 3% auto;    text-align: center;}.aspect-ratio iframe {    position: absolute;    width: 100%;    height: 100%;    left: 0;    top: 0;}.pace {    -webkit-pointer-events: none;    pointer-events: none;    -webkit-user-select: none;    -moz-user-select: none;    user-select: none;    z-index: 2000;    position: fixed;    margin: auto;    top: 10px;    left: 0;    right: 0;    height: 8px;    border-radius: 8px;    width: 4rem;    background: #eaecf2;    border: 1px #e3e8f7;    overflow: hidden;}.pace-inactive .pace-progress {    opacity: 0;    transition: 0.3s ease-in;}.pace .pace-progress {    -webkit-box-sizing: border-box;    -moz-box-sizing: border-box;    -ms-box-sizing: border-box;    -o-box-sizing: border-box;    box-sizing: border-box;    -webkit-transform: translate3d(0, 0, 0);    -moz-transform: translate3d(0, 0, 0);    -ms-transform: translate3d(0, 0, 0);    -o-transform: translate3d(0, 0, 0);    transform: translate3d(0, 0, 0);    max-width: 200px;    position: absolute;    z-index: 2000;    display: block;    top: 0;    right: 100%;    height: 100%;    width: 100%;    background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);    animation: gradient 1.5s ease infinite;    background-size: 200%;}.pace.pace-inactive {    opacity: 0;    transition: 0.3s;    top: -8px;}@keyframes gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}/* 设置文字内容 :nth-child(1)的作用是选择第几个 */.el-input.el-input--small.el-input-group.el-input-group--prepend:nth-child(1):before {    content: '输入QQ号会自动获取昵称和头像🐧';}.el-input.el-input--small.el-input-group.el-input-group--prepend:nth-child(2):before {    content: '收到回复将会发送到您的邮箱📧';}.el-input.el-input--small.el-input-group.el-input-group--prepend:nth-child(3):before {    content: '可以通过昵称访问您的网站🔗';}/* 当用户点击输入框时显示 */.el-input.el-input--small.el-input-group.el-input-group--prepend:focus-within::before,.el-input.el-input--small.el-input-group.el-input-group--prepend:focus-within::after {    display: block;}/* 主内容区 */.el-input.el-input--small.el-input-group.el-input-group--prepend::before {    /* 先隐藏起来 */    display: none;    /* 绝对定位 */    position: absolute;    /* 向上移动60像素 */    top: -60px;    /* 文字强制不换行，防止left:50%导致的文字换行 */    white-space: nowrap;    /* 圆角 */    border-radius: 10px;    /* 距离左边50% */    left: 50%;    /* 然后再向左边挪动自身的一半，即可实现居中 */    transform: translate(-50%);    /* 填充 */    padding: 14px 18px;    background: #444;    color: #fff;}/* 小角标 */.el-input.el-input--small.el-input-group.el-input-group--prepend::after {    display: none;    content: '';    position: absolute;    /* 内容大小（宽高）为0且边框大小不为0的情况下，每一条边（4个边）都是一个三角形，组成一个正方形。    我们先将所有边框透明，再给其中的一条边添加颜色就可以实现小三角图标 */    border: 12px solid transparent;    border-top-color: #444;    left: 50%;    transform: translate(-50%, -48px);} /* 加载样式 */.loading-img {    background: url(/img/wangye.png) no-repeat center center;    background-size: cover;}.card-info-avatar .author-status-box {    position: absolute;    bottom: 0;    left: calc(100% - 28px);    width: 28px;    height: 28px;    border: 1px solid #d0d7de;    border-radius: 2em;    background-color: #f8f8f8f8;    transition: 0.4s;    overflow: hidden;}[data-theme="dark"] .card-info-avatar .author-status-box {    background-color: #222222f2;    border: 1px solid #5c6060;}/* 信息卡片头像状态 */.card-info-avatar .author-status-box .author-status {    display: flex;    align-items: center;    justify-content: center;    height: 28px;    padding: 0 5px;}.card-info-avatar .author-status-box:hover {    width: 105px;}.card-info-avatar .author-status-box:hover .author-status span {    width: 105px;    margin-left: 4px;}.card-info-avatar .author-status-box .author-status span {    width: 0;    font-size: 12px;    height: 100%;    overflow: hidden;    text-overflow: ellipsis;    white-space: nowrap;    transition: 0.4s;}.card-widget .card-info-avatar {    display: inline-block;    position: relative;}/* 头像呼吸灯 *//* 头像呼吸灯 */[data-theme="light"] .avatar-img {    animation: huxi_light 4s ease-in-out infinite;}[data-theme="dark"] .avatar-img {    animation: huxi_dark 4s ease-in-out infinite;}@keyframes huxi_light {    0% {        box-shadow: 0px 0px 1px 1px #d1f8cc;    }    50% {        box-shadow: 0px 0px 5px 5px #6ff984;    }    100% {        box-shadow: 0px 0px 1px 1px #14eb05;    }}@keyframes huxi_dark {    0% {        box-shadow: 0px 0px 1px 1px #39c5bb;    }    50% {        box-shadow: 0px 0px 5px 5px #39c5bb;    }    100% {        box-shadow: 0px 0px 1px 1px #39c5bb;    }}/* 文章页波浪 *//* 波浪css */.main-hero-waves-area {    width: 100%;    position: absolute;    left: 0;    bottom: -11px;    z-index: 5;}.waves-area .waves-svg {    width: 100%;    height: 5rem;}/* Animation */.parallax>use {    animation: move-forever 25s cubic-bezier(0.55, 0.5, 0.45, 0.5) infinite;}.parallax>use:nth-child(1) {    animation-delay: -2s;    animation-duration: 7s;    fill: #f7f9febd;}.parallax>use:nth-child(2) {    animation-delay: -3s;    animation-duration: 10s;    fill: #f7f9fe82;}.parallax>use:nth-child(3) {    animation-delay: -4s;    animation-duration: 13s;    fill: #f7f9fe36;}.parallax>use:nth-child(4) {    animation-delay: -5s;    animation-duration: 20s;    fill: #f7f9fe;}/* 黑色模式背景 */[data-theme="dark"] .parallax>use:nth-child(1) {    animation-delay: -2s;    animation-duration: 7s;    fill: #18171dc8;}[data-theme="dark"] .parallax>use:nth-child(2) {    animation-delay: -3s;    animation-duration: 10s;    fill: #18171d80;}[data-theme="dark"] .parallax>use:nth-child(3) {    animation-delay: -4s;    animation-duration: 13s;    fill: #18171d3e;}[data-theme="dark"] .parallax>use:nth-child(4) {    animation-delay: -5s;    animation-duration: 20s;    fill: #18171d;}@keyframes move-forever {    0% {        transform: translate3d(-90px, 0, 0);    }    100% {        transform: translate3d(85px, 0, 0);    }}/*Shrinking for mobile*/@media (max-width: 768px) {    .waves-area .waves-svg {        height: 40px;        min-height: 40px;    }}/* 滚动条样式 */::-webkit-scrollbar {    width: 8px;    height: 8px;}::-webkit-scrollbar-track {    background-color: rgba(73, 177, 245, 0.2);    border-radius: 2em;}::-webkit-scrollbar-thumb {    background-color: #E06C75;    background-image: -webkit-linear-gradient(45deg,            rgba(255, 255, 255, 0.4) 25%,            transparent 25%,            transparent 50%,            rgba(255, 255, 255, 0.4) 50%,            rgba(255, 255, 255, 0.4) 75%,            transparent 75%,            transparent);    border-radius: 2em;}::-webkit-scrollbar-corner {    background-color: transparent;}::-moz-selection {    color: #fff;    background-color: #E06C75;}/* 颜色 */:root {    --anzhiyu-theme-op: #4259ef23;    --anzhiyu-card-bg-none: rgba(255, 255, 255, 0);    --anzhiyu-main-op-deep: var(--anzhiyu-theme-op-deep) !important;    --anzhiyu-gray-op: #9999992b;    --anzhiyu-theme-top: var(--anzhiyu-theme);    --anzhiyu-white: #fff;    --anzhiyu-white-op: rgba(255, 255, 255, 0.2);    --anzhiyu-black: #000;    --anzhiyu-black-op: rgba(0, 0, 0, 0.2);    --anzhiyu-none: rgba(0, 0, 0, 0);    --anzhiyu-gray: #999999;    --anzhiyu-yellow: #ffc93e;    --anzhiyu-orange: #e38100;    --anzhiyu-border-radius: 8px;    --anzhiyu-main: var(--anzhiyu-theme);    --anzhiyu-main-op: var(--anzhiyu-theme-op);    --anzhiyu-shadow-theme: 0 8px 12px -3px var(--anzhiyu-theme-op);    --anzhiyu-shadow-main: 0 8px 12px -3px var(--anzhiyu-main-op);    --anzhiyu-shadow-blue: 0 8px 12px -3px rgba(40, 109, 234, 0.2);    --anzhiyu-shadow-white: 0 8px 12px -3px rgba(255, 255, 255, 0.2);    --anzhiyu-shadow-black: 0 0 12px 4px rgba(0, 0, 0, 0.05);    --anzhiyu-shadow-yellow: 0px 38px 77px -26px rgba(255, 201, 62, 0.12);    --anzhiyu-shadow-red: 0 8px 12px -3px #ee7d7936;    --anzhiyu-shadow-green: 0 8px 12px -3px #87ee7936;    --anzhiyu-shadow-border: 0 8px 16px -4px #2c2d300c;    --anzhiyu-shadow-blackdeep: 0 2px 16px -3px rgba(0, 0, 0, 0.15);    --anzhiyu-logo-color: linear-gradient(215deg, #4584ff 30%, #ff7676 70%);    --style-border: 1px solid var(--anzhiyu-card-border);    --anzhiyu-blue-main: #3b70fc;    --style-border-hover: 1px solid var(--anzhiyu-main);    --style-border-dashed: 1px dashed var(--anzhiyu-theme-op);    --style-border-avatar: 4px solid var(--anzhiyu-background);    --style-border-always: 1px solid var(--anzhiyu-card-border);    --style-border-none: 1px solid transparent;    --anzhiyu-white-acrylic1: #fefeff !important;    --anzhiyu-white-acrylic2: #fcfdff !important;    --anzhiyu-black-acrylic2: #08080a !important;    --anzhiyu-black-acrylic1: #0b0b0e !important;    --anzhiyu-main-none: #b8b8b800 !important;}[data-theme="light"] {    --anzhiyu-theme-op-deep: #4259efdd;    --global-bg: #f7f9fe;    --anzhiyu-theme: #3b70fc;    --anzhiyu-theme-deep: #1856fb;    --anzhiyu-theme-op: #4259ef23;    --anzhiyu-blue: #3b70fc;    --anzhiyu-red: #d8213c;    --anzhiyu-pink: #ff7c7c;    --anzhiyu-green: #57bd6a;    --anzhiyu-fontcolor: #363636;    --anzhiyu-background: #f7f9fe;    --anzhiyu-reverse: #000;    --anzhiyu-maskbg: rgba(255, 255, 255, 0.6);    --anzhiyu-maskbgdeep: rgba(255, 255, 255, 0.85);    --anzhiyu-hovertext: var(--anzhiyu-theme);    --anzhiyu-ahoverbg: #f7f7fa;    --anzhiyu-lighttext: var(--anzhiyu-main);    --anzhiyu-secondtext: rgba(60, 60, 67, 0.6);    --anzhiyu-scrollbar: rgba(60, 60, 67, 0.4);    --anzhiyu-card-btn-bg: #edf0f7;    --anzhiyu-post-blockquote-bg: #fafcff;    --anzhiyu-post-tabs-bg: #f2f5f8;    --anzhiyu-secondbg: #f1f3f8;    --anzhiyu-shadow-nav: 0 5px 12px -5px rgba(102, 68, 68, 0.05);    --anzhiyu-card-bg: #fff;    --anzhiyu-shadow-lightblack: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-shadow-light2black: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-card-border: #e3e8f7;}[data-theme="dark"] {    --anzhiyu-theme-op-deep: #0084ffdd;    --global-bg: #18171d;    --anzhiyu-theme: #0084ff;    --anzhiyu-theme-deep: #0076e5;    --anzhiyu-theme-op: #0084ff23;    --anzhiyu-blue: #0084ff;    --anzhiyu-red: #ff3842;    --anzhiyu-pink: #ff7c7c;    --anzhiyu-green: #57bd6a;    --anzhiyu-fontcolor: #f7f7fa;    --anzhiyu-background: #18171d;    --anzhiyu-reverse: #fff;    --anzhiyu-maskbg: rgba(0, 0, 0, 0.6);    --anzhiyu-maskbgdeep: rgba(0, 0, 0, 0.85);    --anzhiyu-hovertext: #0a84ff;    --anzhiyu-ahoverbg: #fff;    --anzhiyu-lighttext: #f2b94b;    --anzhiyu-secondtext: #a1a2b8;    --anzhiyu-scrollbar: rgba(200, 200, 223, 0.4);    --anzhiyu-card-btn-bg: #30343f;    --anzhiyu-post-blockquote-bg: #000;    --anzhiyu-post-tabs-bg: #121212;    --anzhiyu-secondbg: #30343f;    --anzhiyu-shadow-nav: 0 5px 20px 0px rgba(28, 28, 28, 0.4);    --anzhiyu-card-bg: #1d1b26;    --anzhiyu-shadow-lightblack: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-shadow-light2black: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-card-border: #42444a;}/* 音乐播放器 */.aplayer.aplayer-narrow .aplayer-body,.aplayer.aplayer-narrow .aplayer-pic {    height: 66px;    width: 66px;}#page:has(.aplayer):has(.aplayer-body):has(.aplayer-list) #post-comment .tk-comments-container>.tk-comment {    border: none;    box-shadow: none;}/* 导航栏音乐 */@media screen and (max-width: 1300px) {    #nav-music {        display: none !important;    }}#nav-music {    display: flex;    align-items: center;    z-index: 9;    position: fixed;    bottom: 20px;    left: 20px;    cursor: pointer;    transition: 0.5s;    transform-origin: left bottom;    box-shadow: var(--anzhiyu-shadow-border);    border-radius: 40px;    overflow: hidden;}#nav-music:active {    transform: scale(0.97);}#nav-music.playing {    box-shadow: 0 0px 12px -3px var(--anzhiyu-none);    animation: playingShadow 5s linear infinite;}@keyframes playingShadow {    0% {        box-shadow: 0 0px 12px -3px var(--anzhiyu-none);    }    50% {        box-shadow: 0 0px 12px 0px var(--anzhiyu-main);    }    100% {        box-shadow: 0 0px 12px -3px var(--anzhiyu-none);    }}#nav-music .aplayer.aplayer-withlrc .aplayer-pic {    height: 25px;    width: 25px;    border-radius: 40px;    z-index: 1;    transition: 0.3s;    transform: rotate(0deg) scale(1);    border: var(--style-border-always);    animation: changeright 24s linear infinite;    animation-play-state: paused;}#nav-music.playing .aplayer.aplayer-withlrc .aplayer-pic {    box-shadow: 0 0 14px #ffffffa6;    transform: rotate(0deg) scale(1.1);    border-color: var(--anzhiyu-white);    animation-play-state: running;}@keyframes changeright {    0% {        transform: rotate(0deg) scale(1.1);        box-shadow: 0 0 2px #ffffff00;    }    25% {        transform: rotate(90deg) scale(1.1);        box-shadow: 0 0 14px #ffffff;    }    50% {        transform: rotate(180deg) scale(1.1);        box-shadow: 0 0 2px #ffffff00;    }    75% {        transform: rotate(270deg) scale(1.1);        box-shadow: 0 0 14px #ffffff;    }    100% {        transform: rotate(360deg) scale(1.1);        box-shadow: 0 0 2px #ffffff00;    }}#nav-music .aplayer.aplayer-withlrc .aplayer-info {    height: 100%;    color: var(--anzhiyu-fontcolor);    margin: 0;    padding: 0;    display: flex;    align-items: center;}#nav-music.playing .aplayer.aplayer-withlrc .aplayer-info {    color: var(--anzhiyu-white);}#nav-music.playing #nav-music-hoverTips {    width: 0;    opacity: 0;}#nav-music #nav-music-hoverTips {    color: var(--anzhiyu-white);    background: var(--anzhiyu-main);    width: 100%;    height: 100%;    position: absolute;    top: 0;    left: 0;    align-items: center;    justify-content: center;    display: flex;    border-radius: 40px;    opacity: 0;    font-size: 12px;    z-index: 2;    transition: 0.3s;}#nav-music:hover:not(.playing) #nav-music-hoverTips {    opacity: 1;}#nav-music .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap:hover .aplayer-bar .aplayer-played .aplayer-thumb {    display: none;}#nav-music .aplayer {    background: var(--card-bg);    border-radius: 60px;    height: 41px;    display: flex;    margin: 0;    transition: 0.3s;    border: var(--style-border);    box-shadow: none;}#nav-music.playing .aplayer {    background: var(--anzhiyu-main-op-deep);    border: var(--style-border-hover);    backdrop-filter: saturate(180%) blur(20px);    backdrop-filter: blur(20px);}#nav-music .aplayer .aplayer-notice {    display: none;}#nav-music .aplayer .aplayer-miniswitcher {    display: none;}#nav-music .aplayer .aplayer-body {    position: relative;    display: flex;    align-items: center;}#nav-music .aplayer-list {    display: none;}#nav-music .aplayer .aplayer-info .aplayer-music {    margin: 0;    display: flex;    align-items: center;    padding: 0 12px 0 8px;    cursor: pointer;    z-index: 1;    height: 100%;}#nav-music .aplayer .aplayer-info .aplayer-controller .aplayer-time {    display: none;}#nav-music .aplayer .aplayer-info .aplayer-music .aplayer-author {    display: none;}#nav-music .aplayer.aplayer-withlist .aplayer-info {    border: none;}#nav-music .aplayer .aplayer-pic .aplayer-button {    bottom: 50%;    right: 50%;    transform: translate(50%, 50%);    margin: 0;    transition: 0.3s;}#nav-music .aplayer .aplayer-pic:has(.aplayer-button.aplayer-play) {    animation-play-state: paused;    transform: rotate(0deg) scale(1) !important;}#nav-music .aplayer.aplayer-withlrc .aplayer-pic {    margin-left: 8px;}#nav-music .aplayer .aplayer-info .aplayer-music .aplayer-title {    cursor: pointer;    line-height: 1;    display: inline-block;    white-space: nowrap;    max-width: 120px;    overflow: hidden;    text-overflow: ellipsis;    transition: 0.3s;    user-select: none;}#nav-music .aplayer .aplayer-info .aplayer-controller {    position: absolute;    width: 100%;    height: 100%;    top: 0;    left: 0;}#nav-music .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap {    margin: 0;    padding: 0;}#nav-music .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar {    height: 100%;    background: none;}#nav-music .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-loaded {    display: none;}#nav-music .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played {    height: 100%;    opacity: 0.1;    background-color: var(--anzhiyu-white) !important;    animation: lightBar 5s ease infinite;    animation-play-state: paused;}#nav-music.playing .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played {    animation-play-state: running;}@keyframes lightBar {    0% {        opacity: 0.1;    }    60% {        opacity: 0.3;    }    100% {        opacity: 0.1;    }}/* 歌词 */#nav-music .aplayer.aplayer-withlrc .aplayer-lrc {    width: 0;    opacity: 0;    transition: 0.3s;    margin-top: -2px;    padding: 5px 0;}#nav-music.stretch .aplayer.aplayer-withlrc .aplayer-lrc {    margin-left: 8px;}#nav-music.stretch .aplayer.aplayer-withlrc .aplayer-lrc {    width: 200px;    margin-bottom: 0;    opacity: 1;}#nav-music .aplayer .aplayer-lrc p.aplayer-lrc-current {    color: var(--anzhiyu-white);    border: none;}#nav-music .aplayer .aplayer-lrc:after,#nav-music .aplayer .aplayer-lrc:before {    display: none;}#nav-music .aplayer .aplayer-lrc p {    color: #ffffffb1;}#nav-music .aplayer .aplayer-pic {    pointer-events: none;}#nav-music .aplayer .aplayer-pic .aplayer-button {    pointer-events: all;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/progress_bar.css"/>
      <url>/css/progress_bar.css</url>
      
        <content type="html"><![CDATA[.pace {    -webkit-pointer-events: none;    pointer-events: none;    -webkit-user-select: none;    -moz-user-select: none;    user-select: none;    z-index: 2000;    position: fixed;    margin: auto;    top: 10px;    left: 0;    right: 0;    height: 8px;    border-radius: 8px;    width: 4rem;    background: #eaecf2;    border: 1px #e3e8f7;    overflow: hidden;}.pace-inactive .pace-progress {    opacity: 0;    transition: 0.3s ease-in;}.pace .pace-progress {    -webkit-box-sizing: border-box;    -moz-box-sizing: border-box;    -ms-box-sizing: border-box;    -o-box-sizing: border-box;    box-sizing: border-box;    -webkit-transform: translate3d(0, 0, 0);    -moz-transform: translate3d(0, 0, 0);    -ms-transform: translate3d(0, 0, 0);    -o-transform: translate3d(0, 0, 0);    transform: translate3d(0, 0, 0);    max-width: 200px;    position: absolute;    z-index: 2000;    display: block;    top: 0;    right: 100%;    height: 100%;    width: 100%;    background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);    animation: gradient 1.5s ease infinite;    background-size: 200%;}.pace.pace-inactive {    opacity: 0;    transition: 0.3s;    top: -8px;}@keyframes gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/anzhiyu.js"/>
      <url>/js/anzhiyu.js</url>
      
        <content type="html"><![CDATA[var navMusicEl = document.getElementById("nav-music");var anzhiyu = {  //切换音乐播放状态  musicToggle: function (changePaly = true) {    if (!anzhiyu_musicFirst) {      musicBindEvent();      anzhiyu_musicFirst = true;    }    let msgPlay = '<i class="fa-solid fa-play"></i><span>播放音乐</span>'; // 此處可以更改為你想要顯示的文字    let msgPause = '<i class="fa-solid fa-pause"></i><span>暂停音乐</span>'; // 同上，但兩處均不建議更改    if (anzhiyu_musicPlaying) {      navMusicEl.classList.remove("playing");      // 修改右键菜单文案为播放      // document.getElementById("menu-music-toggle").innerHTML = msgPlay;      document.getElementById("nav-music-hoverTips").innerHTML = "音乐已暂停";      // document.querySelector("#consoleMusic").classList.remove("on");      anzhiyu_musicPlaying = false;      navMusicEl.classList.remove("stretch");    } else {      navMusicEl.classList.add("playing");      // 修改右键菜单文案为暂停      // document.getElementById("menu-music-toggle").innerHTML = msgPause;      // document.querySelector("#consoleMusic").classList.add("on");      anzhiyu_musicPlaying = true;      navMusicEl.classList.add("stretch");    }    if (changePaly) document.querySelector("#nav-music meting-js").aplayer.toggle();  },  // 音乐伸缩  musicTelescopic: function () {    if (navMusicEl.classList.contains("stretch")) {      navMusicEl.classList.remove("stretch");    } else {      navMusicEl.classList.add("stretch");    }  },  //音乐上一曲  musicSkipBack: function () {    document.querySelector("#nav-music meting-js").aplayer.skipBack();  },  //音乐下一曲  musicSkipForward: function () {    document.querySelector("#nav-music meting-js").aplayer.skipForward();  },  //获取音乐中的名称  musicGetName: function () {    var x = $(".aplayer-title");    var arr = [];    for (var i = x.length - 1; i >= 0; i--) {      arr[i] = x[i].innerText;    }    return arr[0];  },};]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/anzhiyuOnlyOne.js"/>
      <url>/js/anzhiyuOnlyOne.js</url>
      
        <content type="html"><![CDATA[var anzhiyu_musicPlaying = false;var anzhiyu_musicFirst = false;]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/anzhiyufunction.js"/>
      <url>/js/anzhiyufunction.js</url>
      
        <content type="html"><![CDATA[// 音乐绑定事件function musicBindEvent() {  document.querySelector("#nav-music .aplayer-music").addEventListener("click", function () {    anzhiyu.musicTelescopic();  });  document.querySelector("#nav-music .aplayer-button").addEventListener("click", function () {    anzhiyu.musicToggle(false);  });}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cat.js"/>
      <url>/js/cat.js</url>
      
        <content type="html"><![CDATA[if (document.body.clientWidth > 992) {    function getBasicInfo() {        /* 窗口高度 */        var ViewH = $(window).height();        /* document高度 */        var DocH = $("body")[0].scrollHeight;        /* 滚动的高度 */        var ScrollTop = $(window).scrollTop();        /* 可滚动的高度 */        var S_V = DocH - ViewH;        var Band_H = ScrollTop / (DocH - ViewH) * 100;        return {            ViewH: ViewH,            DocH: DocH,            ScrollTop: ScrollTop,            Band_H: Band_H,            S_V: S_V        }    };    function show(basicInfo) {        if (basicInfo.ScrollTop > 0.001) {            $(".neko").css('display', 'block');        } else {            $(".neko").css('display', 'none');        }    }    (function ($) {        $.fn.nekoScroll = function (option) {            var defaultSetting = {                top: '0',                scroWidth: 6 + 'px',                z_index: 9999,                zoom: 0.9,                borderRadius: 5 + 'px',                right: 60 + 'px',                // 这里可以换为你喜欢的图片，例如我就换为了雪人，但是要抠图                nekoImg: "https://s2.loli.net/2024/08/20/n1JarOiLfmy9xC3.gif",                hoverMsg: "精神状态belike",                color: "#6f42c1",                during: 500,                blog_body: "body",            };            var setting = $.extend(defaultSetting, option);            var getThis = this.prop("className") !== "" ? "." + this.prop("className") : this.prop("id") !== "" ? "#" +                this.prop("id") : this.prop("nodeName");            if ($(".neko").length == 0) {                this.after("<div class=\"neko\" id=" + setting.nekoname + " data-msg=\"" + setting.hoverMsg + "\"></div>");            }            let basicInfo = getBasicInfo();            $(getThis)                .css({                    'position': 'fixed',                    'width': setting.scroWidth,                    'top': setting.top,                    'height': basicInfo.Band_H * setting.zoom * basicInfo.ViewH * 0.01 + 'px',                    'z-index': setting.z_index,                    'background-color': setting.bgcolor,                    "border-radius": setting.borderRadius,                    'right': setting.right,                    'background-image': 'url(' + setting.scImg + ')',                    'background-image': '-webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent)', 'border-radius': '2em',                    'background-size': 'contain'                });            $("#" + setting.nekoname)                .css({                    'position': 'fixed',                    'top': basicInfo.Band_H * setting.zoom * basicInfo.ViewH * 0.01 - 50 + 'px',                    'z-index': setting.z_index * 10,                    'right': setting.right,                    'background-image': 'url(' + setting.nekoImg + ')',                });            show(getBasicInfo());            $(window)                .scroll(function () {                    let basicInfo = getBasicInfo();                    show(basicInfo);                    $(getThis)                        .css({                            'position': 'fixed',                            'width': setting.scroWidth,                            'top': setting.top,                            'height': basicInfo.Band_H * setting.zoom * basicInfo.ViewH * 0.01 + 'px',                            'z-index': setting.z_index,                            'background-color': setting.bgcolor,                            "border-radius": setting.borderRadius,                            'right': setting.right,                            'background-image': 'url(' + setting.scImg + ')',                            'background-image': '-webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent)', 'border-radius': '2em',                            'background-size': 'contain'                        });                    $("#" + setting.nekoname)                        .css({                            'position': 'fixed',                            'top': basicInfo.Band_H * setting.zoom * basicInfo.ViewH * 0.01 - 50 + 'px',                            'z-index': setting.z_index * 10,                            'right': setting.right,                            'background-image': 'url(' + setting.nekoImg + ')',                        });                    if (basicInfo.ScrollTop == basicInfo.S_V) {                        $("#" + setting.nekoname)                            .addClass("showMsg")                    } else {                        $("#" + setting.nekoname)                            .removeClass("showMsg");                        $("#" + setting.nekoname)                            .attr("data-msg", setting.hoverMsg);                    }                });            this.click(function (e) {                btf.scrollToDest(0, 500)            });            $("#" + setting.nekoname)                .click(function () {                    btf.scrollToDest(0, 500)                });            return this;        }    })(jQuery);    $(document).ready(function () {        //部分自定义        $("#myscoll").nekoScroll({            bgcolor: 'rgb(0 0 0 / .5)', //背景颜色，没有绳子背景图片时有效            borderRadius: '2em',            zoom: 0.9        }        );        //自定义（去掉以下注释，并注释掉其他的查看效果）        /*        $("#myscoll").nekoScroll({            nekoname:'neko1', //nekoname，相当于id            nekoImg:'img/猫咪.png', //neko的背景图片            scImg:"img/绳1.png", //绳子的背景图片            bgcolor:'#1e90ff', //背景颜色，没有绳子背景图片时有效            zoom:0.9, //绳子长度的缩放值            hoverMsg:'你好~喵', //鼠标浮动到neko上方的对话框信息            right:'100px', //距离页面右边的距离            fontFamily:'楷体', //对话框字体            fontSize:'14px', //对话框字体的大小            color:'#1e90ff', //对话框字体颜色            scroWidth:'8px', //绳子的宽度            z_index:100, //不用解释了吧            during:1200, //从顶部到底部滑动的时长        });        */    })}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) {}    return "";};class Cursor {    constructor() {        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='1.0' fill='rgb(236, 49, 139)'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove("hidden");};        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown  = e => this.cursor.classList.add("active");        document.onmouseup    = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/day.js"/>
      <url>/js/day.js</url>
      
        <content type="html"><![CDATA[var d = new Date();m = d.getMonth() + 1;dd = d.getDate();y = d.getFullYear();// 公祭日if (m == 9 && dd == 18) {    document.getElementsByTagName("html")[0].setAttribute("style", "filter: grayscale(60%);");    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("今天是九一八事变" + (y - 1931).toString() + "周年纪念日\n🪔勿忘国耻，振兴中华🪔");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 7 && dd == 7) {    document.getElementsByTagName("html")[0].setAttribute("style", "filter: grayscale(60%);");    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("今天是卢沟桥事变" + (y - 1937).toString() + "周年纪念日\n🪔勿忘国耻，振兴中华🪔");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 12 && dd == 13) {    document.getElementsByTagName("html")[0].setAttribute("style", "filter: grayscale(60%);");    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("今天是南京大屠杀" + (y - 1937).toString() + "周年纪念日\n🪔勿忘国耻，振兴中华🪔");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 8 && dd == 14) {    document.getElementsByTagName("html")[0].setAttribute("style", "filter: grayscale(60%);");    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("今天是世界慰安妇纪念日\n🪔勿忘国耻，振兴中华🪔");        sessionStorage.setItem("isPopupWindow", "1");    }}// 节假日if (m == 10 && dd <= 3) {//国庆节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("祝祖国" + (y - 1949).toString() + "岁生日快乐！");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 8 && dd == 15) {//搞来玩的，小日子投降    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("小日子已经投降" + (y - 1945).toString() + "年了😃");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 1 && dd == 1) {//元旦节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire(y.toString() + "年元旦快乐！🎉");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 3 && dd == 8) {//妇女节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("各位女神们，妇女节快乐！👩");        sessionStorage.setItem("isPopupWindow", "1");    }}l = ["非常抱歉，因为不可控原因，博客将于明天停止运营！", "好消息，日本没了！", "美国垮了，原因竟然是川普！", "微软垮了！", "你的电脑已经过载，建议立即关机！", "你知道吗？站长很喜欢你哦！", "一分钟有61秒哦", "你喜欢的人跟别人跑了！"]if (m == 4 && dd == 1) {//愚人节，随机谎话    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire(l[Math.floor(Math.random() * l.length)]);        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 5 && dd == 1) {//劳动节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("劳动节快乐\n为各行各业辛勤工作的人们致敬！");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 5 && dd == 4) {//青年节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("青年节快乐\n青春不是回忆逝去,而是把握现在！");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 5 && dd == 20) {//520    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("今年是520情人节\n快和你喜欢的人一起过吧！💑");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 7 && dd == 1) {//建党节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("祝中国共产党" + (y - 1921).toString() + "岁生日快乐！");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 9 && dd == 10) {//教师节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("各位老师们教师节快乐！👩‍🏫");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 12 && dd == 25) {//圣诞节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("圣诞节快乐！🎄");        sessionStorage.setItem("isPopupWindow", "1");    }}//传统节日部分if ((y == 2023 && m == 4 && dd == 5) || (y == 2024 && m == 4 && dd == 4) || (y == 2025 && m == 4 && dd == 4)) {//清明节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("清明时节雨纷纷,一束鲜花祭故人💐");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((y == 2023 && m == 12 && dd == 22) || (y == 2024 && m == 12 && dd == 21) || (y == 2025 && m == 12 && dd == 21)) {//冬至    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("冬至快乐\n快吃上一碗热热的汤圆和饺子吧🧆");        sessionStorage.setItem("isPopupWindow", "1");    }}var lunar = calendarFormatter.solar2lunar();//农历采用汉字计算，防止出现闰月导致问题if ((lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初六") || (lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初五") || (lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初四") || (lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初三") || (lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初二") || (lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初一") || (lunar["IMonthCn"] == "腊月" && lunar["IDayCn"] == "三十") || (lunar["IMonthCn"] == "腊月" && lunar["IDayCn"] == "廿九")) {    //春节，本来只有大年三十到初六，但是有时候除夕是大年二十九，所以也加上了    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire(y.toString() + "年新年快乐\n🎊祝你心想事成，诸事顺利🎊");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "十五")) {    //元宵节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("元宵节快乐\n送你一个大大的灯笼🧅");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((lunar["IMonthCn"] == "五月" && lunar["IDayCn"] == "初五")) {    //端午节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("端午节快乐\n请你吃一条粽子🍙");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((lunar["IMonthCn"] == "七月" && lunar["IDayCn"] == "初七")) {    //七夕节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("七夕节快乐\n黄昏后,柳梢头,牛郎织女来碰头");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((lunar["IMonthCn"] == "八月" && lunar["IDayCn"] == "十五")) {    //中秋节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("中秋节快乐\n请你吃一块月饼🍪");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((lunar["IMonthCn"] == "九月" && lunar["IDayCn"] == "初九")) {    //重阳节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("重阳节快乐\n独在异乡为异客，每逢佳节倍思亲");        sessionStorage.setItem("isPopupWindow", "1");    }}// 切换主题提醒// if (y == 2022 && m == 12 && (dd >= 18 && dd <= 20)) {//     if (sessionStorage.getItem("isPopupWindow") != "1") {//         Swal.fire("网站换成冬日限定主题啦⛄");//         sessionStorage.setItem("isPopupWindow", "1");//     }// }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/lunar.js"/>
      <url>/js/lunar.js</url>
      
        <content type="html"><![CDATA[var lunarInfo=[19416,19168,42352,21717,53856,55632,91476,22176,39632,21970,19168,42422,42192,53840,119381,46400,54944,44450,38320,84343,18800,42160,46261,27216,27968,109396,11104,38256,21234,18800,25958,54432,59984,28309,23248,11104,100067,37600,116951,51536,54432,120998,46416,22176,107956,9680,37584,53938,43344,46423,27808,46416,86869,19872,42416,83315,21168,43432,59728,27296,44710,43856,19296,43748,42352,21088,62051,55632,23383,22176,38608,19925,19152,42192,54484,53840,54616,46400,46752,103846,38320,18864,43380,42160,45690,27216,27968,44870,43872,38256,19189,18800,25776,29859,59984,27480,23232,43872,38613,37600,51552,55636,54432,55888,30034,22176,43959,9680,37584,51893,43344,46240,47780,44368,21977,19360,42416,86390,21168,43312,31060,27296,44368,23378,19296,42726,42208,53856,60005,54576,23200,30371,38608,19195,19152,42192,118966,53840,54560,56645,46496,22224,21938,18864,42359,42160,43600,111189,27936,44448,84835,37744,18936,18800,25776,92326,59984,27424,108228,43744,41696,53987,51552,54615,54432,55888,23893,22176,42704,21972,21200,43448,43344,46240,46758,44368,21920,43940,42416,21168,45683,26928,29495,27296,44368,84821,19296,42352,21732,53600,59752,54560,55968,92838,22224,19168,43476,41680,53584,62034,54560],solarMonth=[31,28,31,30,31,30,31,31,30,31,30,31],Gan=["甲","乙","丙","丁","戊","己","庚","辛","壬","癸"],Zhi=["子","丑","寅","卯","辰","巳","午","未","申","酉","戌","亥"],Animals=["鼠","牛","虎","兔","龙","蛇","马","羊","猴","鸡","狗","猪"],solarTerm=["小寒","大寒","立春","雨水","惊蛰","春分","清明","谷雨","立夏","小满","芒种","夏至","小暑","大暑","立秋","处暑","白露","秋分","寒露","霜降","立冬","小雪","大雪","冬至"],sTermInfo=["9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf97c3598082c95f8c965cc920f","97bd0b06bdb0722c965ce1cfcc920f","b027097bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf97c359801ec95f8c965cc920f","97bd0b06bdb0722c965ce1cfcc920f","b027097bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf97c359801ec95f8c965cc920f","97bd0b06bdb0722c965ce1cfcc920f","b027097bd097c36b0b6fc9274c91aa","9778397bd19801ec9210c965cc920e","97b6b97bd19801ec95f8c965cc920f","97bd09801d98082c95f8e1cfcc920f","97bd097bd097c36b0b6fc9210c8dc2","9778397bd197c36c9210c9274c91aa","97b6b97bd19801ec95f8c965cc920e","97bd09801d98082c95f8e1cfcc920f","97bd097bd097c36b0b6fc9210c8dc2","9778397bd097c36c9210c9274c91aa","97b6b97bd19801ec95f8c965cc920e","97bcf97c3598082c95f8e1cfcc920f","97bd097bd097c36b0b6fc9210c8dc2","9778397bd097c36c9210c9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf97c3598082c95f8c965cc920f","97bd097bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf97c3598082c95f8c965cc920f","97bd097bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf97c359801ec95f8c965cc920f","97bd097bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf97c359801ec95f8c965cc920f","97bd097bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf97c359801ec95f8c965cc920f","97bd097bd07f595b0b6fc920fb0722","9778397bd097c36b0b6fc9210c8dc2","9778397bd19801ec9210c9274c920e","97b6b97bd19801ec95f8c965cc920f","97bd07f5307f595b0b0bc920fb0722","7f0e397bd097c36b0b6fc9210c8dc2","9778397bd097c36c9210c9274c920e","97b6b97bd19801ec95f8c965cc920f","97bd07f5307f595b0b0bc920fb0722","7f0e397bd097c36b0b6fc9210c8dc2","9778397bd097c36c9210c9274c91aa","97b6b97bd19801ec9210c965cc920e","97bd07f1487f595b0b0bc920fb0722","7f0e397bd097c36b0b6fc9210c8dc2","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf7f1487f595b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf7f1487f595b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf7f1487f531b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf7f1487f531b0b0bb0b6fb0722","7f0e397bd07f595b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c9274c920e","97bcf7f0e47f531b0b0bb0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","9778397bd097c36b0b6fc9210c91aa","97b6b97bd197c36c9210c9274c920e","97bcf7f0e47f531b0b0bb0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","9778397bd097c36b0b6fc9210c8dc2","9778397bd097c36c9210c9274c920e","97b6b7f0e47f531b0723b0b6fb0722","7f0e37f5307f595b0b0bc920fb0722","7f0e397bd097c36b0b6fc9210c8dc2","9778397bd097c36b0b70c9274c91aa","97b6b7f0e47f531b0723b0b6fb0721","7f0e37f1487f595b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc9210c8dc2","9778397bd097c36b0b6fc9274c91aa","97b6b7f0e47f531b0723b0b6fb0721","7f0e27f1487f595b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b7f0e47f531b0723b0787b0721","7f0e27f0e47f531b0b0bb0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","9778397bd097c36b0b6fc9210c91aa","97b6b7f0e47f149b0723b0787b0721","7f0e27f0e47f531b0723b0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","9778397bd097c36b0b6fc9210c8dc2","977837f0e37f149b0723b0787b0721","7f07e7f0e47f531b0723b0b6fb0722","7f0e37f5307f595b0b0bc920fb0722","7f0e397bd097c35b0b6fc9210c8dc2","977837f0e37f14998082b0787b0721","7f07e7f0e47f531b0723b0b6fb0721","7f0e37f1487f595b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc9210c8dc2","977837f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc920fb0722","977837f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc920fb0722","977837f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","977837f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","977837f0e37f14998082b0787b06bd","7f07e7f0e47f149b0723b0787b0721","7f0e27f0e47f531b0b0bb0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","977837f0e37f14998082b0723b06bd","7f07e7f0e37f149b0723b0787b0721","7f0e27f0e47f531b0723b0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","977837f0e37f14898082b0723b02d5","7ec967f0e37f14998082b0787b0721","7f07e7f0e47f531b0723b0b6fb0722","7f0e37f1487f595b0b0bb0b6fb0722","7f0e37f0e37f14898082b0723b02d5","7ec967f0e37f14998082b0787b0721","7f07e7f0e47f531b0723b0b6fb0722","7f0e37f1487f531b0b0bb0b6fb0722","7f0e37f0e37f14898082b0723b02d5","7ec967f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e37f1487f531b0b0bb0b6fb0722","7f0e37f0e37f14898082b072297c35","7ec967f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e37f0e37f14898082b072297c35","7ec967f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e37f0e366aa89801eb072297c35","7ec967f0e37f14998082b0787b06bd","7f07e7f0e47f149b0723b0787b0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e37f0e366aa89801eb072297c35","7ec967f0e37f14998082b0723b06bd","7f07e7f0e47f149b0723b0787b0721","7f0e27f0e47f531b0723b0b6fb0722","7f0e37f0e366aa89801eb072297c35","7ec967f0e37f14998082b0723b06bd","7f07e7f0e37f14998083b0787b0721","7f0e27f0e47f531b0723b0b6fb0722","7f0e37f0e366aa89801eb072297c35","7ec967f0e37f14898082b0723b02d5","7f07e7f0e37f14998082b0787b0721","7f07e7f0e47f531b0723b0b6fb0722","7f0e36665b66aa89801e9808297c35","665f67f0e37f14898082b0723b02d5","7ec967f0e37f14998082b0787b0721","7f07e7f0e47f531b0723b0b6fb0722","7f0e36665b66a449801e9808297c35","665f67f0e37f14898082b0723b02d5","7ec967f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e36665b66a449801e9808297c35","665f67f0e37f14898082b072297c35","7ec967f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e26665b66a449801e9808297c35","665f67f0e37f1489801eb072297c35","7ec967f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722"],nStr1=["日","一","二","三","四","五","六","七","八","九","十"],nStr2=["初","十","廿","卅"],nStr3=["正","二","三","四","五","六","七","八","九","十","冬","腊"];function lYearDays(b){var f,c=348;for(f=32768;f>8;f>>=1)c+=lunarInfo[b-1900]&f?1:0;return c+leapDays(b)}function leapMonth(b){return 15&lunarInfo[b-1900]}function leapDays(b){return leapMonth(b)?65536&lunarInfo[b-1900]?30:29:0}function monthDays(b,f){return f>12||f<1?-1:lunarInfo[b-1900]&65536>>f?30:29}function solarDays(b,f){if(f>12||f<1)return-1;var c=f-1;return 1===c?b%4==0&&b%100!=0||b%400==0?29:28:solarMonth[c]}function toGanZhiYear(b){var f=(b-3)%10,c=(b-3)%12;return 0===f&&(f=10),0===c&&(c=12),Gan[f-1]+Zhi[c-1]}function toAstro(b,f){return"魔羯水瓶双鱼白羊金牛双子巨蟹狮子处女天秤天蝎射手魔羯".substr(2*b-(f<[20,19,21,21,21,22,23,23,23,23,22,22][b-1]?2:0),2)+"座"}function toGanZhi(b){return Gan[b%10]+Zhi[b%12]}function getTerm(b,f){if(b<1900||b>2100)return-1;if(f<1||f>24)return-1;var c=sTermInfo[b-1900],e=[parseInt("0x"+c.substr(0,5)).toString(),parseInt("0x"+c.substr(5,5)).toString(),parseInt("0x"+c.substr(10,5)).toString(),parseInt("0x"+c.substr(15,5)).toString(),parseInt("0x"+c.substr(20,5)).toString(),parseInt("0x"+c.substr(25,5)).toString()],a=[e[0].substr(0,1),e[0].substr(1,2),e[0].substr(3,1),e[0].substr(4,2),e[1].substr(0,1),e[1].substr(1,2),e[1].substr(3,1),e[1].substr(4,2),e[2].substr(0,1),e[2].substr(1,2),e[2].substr(3,1),e[2].substr(4,2),e[3].substr(0,1),e[3].substr(1,2),e[3].substr(3,1),e[3].substr(4,2),e[4].substr(0,1),e[4].substr(1,2),e[4].substr(3,1),e[4].substr(4,2),e[5].substr(0,1),e[5].substr(1,2),e[5].substr(3,1),e[5].substr(4,2)];return parseInt(a[f-1])}function toChinaMonth(b){if(b>12||b<1)return-1;var f=nStr3[b-1];return f+="月"}function toChinaDay(b){var f;switch(b){case 10:f="初十";break;case 20:f="二十";break;case 30:f="三十";break;default:f=nStr2[Math.floor(b/10)],f+=nStr1[b%10]}return f}function getAnimal(b){return Animals[(b-4)%12]}function solar2lunar(b,f,c){if(b<1900||b>2100)return-1;if(1900===b&&1===f&&c<31)return-1;var e,a,r=null,t=0;b=(r=b?new Date(b,parseInt(f)-1,c):new Date).getFullYear(),f=r.getMonth()+1,c=r.getDate();var d=(Date.UTC(r.getFullYear(),r.getMonth(),r.getDate())-Date.UTC(1900,0,31))/864e5;for(e=1900;e<2101&&d>0;e++)d-=t=lYearDays(e);d<0&&(d+=t,e--);var n=new Date,s=!1;n.getFullYear()===b&&n.getMonth()+1===f&&n.getDate()===c&&(s=!0);var u=r.getDay(),o=nStr1[u];0===u&&(u=7);var l=e;a=leapMonth(e);var i=!1;for(e=1;e<13&&d>0;e++)a>0&&e===a+1&&!1===i?(--e,i=!0,t=leapDays(l)):t=monthDays(l,e),!0===i&&e===a+1&&(i=!1),d-=t;0===d&&a>0&&e===a+1&&(i?i=!1:(i=!0,--e)),d<0&&(d+=t,--e);var h=e,D=d+1,g=f-1,v=toGanZhiYear(l),y=getTerm(b,2*f-1),m=getTerm(b,2*f),p=toGanZhi(12*(b-1900)+f+11);c>=y&&(p=toGanZhi(12*(b-1900)+f+12));var M=!1,T=null;y===c&&(M=!0,T=solarTerm[2*f-2]),m===c&&(M=!0,T=solarTerm[2*f-1]);var I=toGanZhi(Date.UTC(b,g,1,0,0,0,0)/864e5+25567+10+c-1),C=toAstro(f,c);return{lYear:l,lMonth:h,lDay:D,Animal:getAnimal(l),IMonthCn:(i?"闰":"")+toChinaMonth(h),IDayCn:toChinaDay(D),cYear:b,cMonth:f,cDay:c,gzYear:v,gzMonth:p,gzDay:I,isToday:s,isLeap:i,nWeek:u,ncWeek:"星期"+o,isTerm:M,Term:T,astro:C}}var calendarFormatter={solar2lunar:function(b,f,c){return solar2lunar(b,f,c)},lunar2solar:function(b,f,c,e){if((e=!!e)&&leapMonth!==f)return-1;if(2100===b&&12===f&&c>1||1900===b&&1===f&&c<31)return-1;var a=monthDays(b,f),r=a;if(e&&(r=leapDays(b,f)),b<1900||b>2100||c>r)return-1;for(var t=0,d=1900;d<b;d++)t+=lYearDays(d);var n=0,s=!1;for(d=1;d<f;d++)n=leapMonth(b),s||n<=d&&n>0&&(t+=leapDays(b),s=!0),t+=monthDays(b,d);e&&(t+=a);var u=Date.UTC(1900,1,30,0,0,0),o=new Date(864e5*(t+c-31)+u);return solar2lunar(o.getUTCFullYear(),o.getUTCMonth()+1,o.getUTCDate())}};]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/title.js"/>
      <url>/js/title.js</url>
      
        <content type="html"><![CDATA[//动态标题var OriginTitile = document.title;var titleTime;document.addEventListener("visibilitychange", function () {  if (document.hidden) {    //离开当前页面时标签显示内容    document.title = "w(ﾟДﾟ)w 干嘛去啦！";    clearTimeout(titleTime);  } else {    //返回当前页面时标签显示内容    document.title = "♪(^∇^*)欢迎回来！" + OriginTitile;    //两秒后变回正常标题    titleTime = setTimeout(function () {      document.title = OriginTitile;    }, 2000);  }});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>时间轴</title>
      <link href="/archives/index.html"/>
      <url>/archives/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>随笔 · 说说</title>
      <link href="/shuoshuo/index.html"/>
      <url>/shuoshuo/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/coin/coin.css"/>
      <url>/css/coin/coin.css</url>
      
        <content type="html"><![CDATA[.tip-button {    border: 0;    border-radius: 0.25rem;    cursor: pointer;    font-size: 20px;    font-weight: 600;    height: 2.6rem;    margin-bottom: -4rem;    outline: 0;    position: relative;    top: 0;    transform-origin: 0% 100%;    transition: transform 50ms ease-in-out;    width: auto;    -webkit-tap-highlight-color: transparent;}.tip-button:active {    transform: rotate(4deg);}.tip-button.clicked {    animation: 150ms ease-in-out 1 shake;    pointer-events: none;}.tip-button.clicked .tip-button__text {    opacity: 0;    transition: opacity 100ms linear 200ms;}.tip-button.clicked::before {    height: 0.5rem;    width: 60%;    background: button-hover-color;}.tip-button.clicked .coin {    transition: margin-bottom 1s linear 200ms;    margin-bottom: 0;}.tip-button.shrink-landing::before {    transition: width 200ms ease-in;    width: 0;}.tip-button.coin-landed::after {    opacity: 1;    transform: scale(1);    transform-origin: 50% 100%;}.tip-button.coin-landed .coin-wrapper {    background: radial-gradient(circle at 35% 97%, rgba(3, 16, 50, 0.4) 0.04rem, transparent 0.04rem), radial-gradient(circle at 45% 92%,            rgba(3, 16, 50, 0.4) 0.04rem,            transparent 0.02rem), radial-gradient(circle at 55% 98%, rgba(3, 16, 50, 0.4) 0.04rem, transparent 0.04rem), radial-gradient(circle at 65% 96%, rgba(3, 16, 50, 0.4) 0.06rem, transparent 0.06rem);    background-position: center bottom;    background-size: 100%;    bottom: -1rem;    opacity: 0;    transform: scale(2) translateY(-10px);}.tip-button__text {    color: #fff;    margin-right: 1.8rem;    opacity: 1;    position: relative;    transition: opacity 100ms linear 500ms;    z-index: 3;}.tip-button::before {    border-radius: 0.25rem;    bottom: 0;    content: "";    display: block;    height: 100%;    left: 50%;    position: absolute;    transform: translateX(-50%);    transition: height 250ms ease-in-out 400ms, width 250ms ease-in-out 300ms;    width: 100%;    z-index: 2;}.tip-button::after {    bottom: -1rem;    color: white;    content: "ヾ(≧O≦)〃嗷~";    /*点击后显示的内容*/    height: 110%;    left: 0;    opacity: 0;    position: absolute;    pointer-events: none;    text-align: center;    transform: scale(0);    transform-origin: 50% 20%;    transition: transform 200ms cubic-bezier(0, 0, 0.35, 1.43);    width: 100%;    z-index: 1;}.coin-wrapper {    background: none;    bottom: 0;    height: 18rem;    left: 0;    opacity: 1;    overflow: hidden;    pointer-events: none;    position: absolute;    transform: none;    transform-origin: 50% 100%;    transition: opacity 200ms linear 100ms, transform 300ms ease-out;    width: 100%;}.coin {    --front-y-multiplier: 0;    --back-y-multiplier: 0;    --coin-y-multiplier: 0;    --coin-x-multiplier: 0;    --coin-scale-multiplier: 0;    --coin-rotation-multiplier: 0;    --shine-opacity-multiplier: 0.4;    --shine-bg-multiplier: 50%;    bottom: calc(var(--coin-y-multiplier) * 1rem - 3.5rem);    height: 3.5rem;    margin-bottom: 3.05rem;    position: absolute;    right: calc(var(--coin-x-multiplier) * 34% + 16%);    transform: translateX(50%) scale(calc(0.4 + var(--coin-scale-multiplier))) rotate(calc(var(--coin-rotation-multiplier) * -1deg));    transition: opacity 100ms linear 200ms;    width: 3.5rem;    z-index: 3;}.coin__front,.coin__middle,.coin__back,.coin::before,.coin__front::after,.coin__back::after {    border-radius: 50%;    box-sizing: border-box;    height: 100%;    left: 0;    position: absolute;    width: 100%;    z-index: 3;}.coin__front {    background: radial-gradient(circle at 50% 50%, transparent 50%, rgba(115, 124, 153, 0.4) 54%, #c2cadf 54%),        linear-gradient(210deg, #8590b3 32%, transparent 32%), linear-gradient(150deg, #8590b3 32%, transparent 32%),        linear-gradient(to right, #8590b3 22%, transparent 22%, transparent 78%, #8590b3 78%), linear-gradient(to bottom,            #fcfaf9 44%,            transparent 44%,            transparent 65%,            #fcfaf9 65%,            #fcfaf9 71%,            #8590b3 71%), linear-gradient(to right, transparent 28%, #fcfaf9 28%, #fcfaf9 34%, #8590b3 34%, #8590b3 40%, #fcfaf9 40%, #fcfaf9 47%, #8590b3 47%, #8590b3 53%, #fcfaf9 53%, #fcfaf9 60%, #8590b3 60%, #8590b3 66%, #fcfaf9 66%, #fcfaf9 72%, transparent 72%);    background-color: #8590b3;    background-size: 100% 100%;    transform: translateY(calc(var(--front-y-multiplier) * 0.3181818182rem / 2)) scaleY(var(--front-scale-multiplier));}.coin__front::after {    background: rgba(0, 0, 0, 0.2);    content: "";    opacity: var(--front-y-multiplier);}.coin__middle {    background: #737c99;    transform: translateY(calc(var(--middle-y-multiplier) * 0.3181818182rem / 2)) scaleY(var(--middle-scale-multiplier));}.coin__back {    background: radial-gradient(circle at 50% 50%, transparent 50%, rgba(115, 124, 153, 0.4) 54%, #c2cadf 54%),        radial-gradient(circle at 50% 40%, #fcfaf9 23%, transparent 23%), radial-gradient(circle at 50% 100%, #fcfaf9 35%, transparent 35%);    background-color: #8590b3;    background-size: 100% 100%;    transform: translateY(calc(var(--back-y-multiplier) * 0.3181818182rem / 2)) scaleY(var(--back-scale-multiplier));}.coin__back::after {    background: rgba(0, 0, 0, 0.2);    content: "";    opacity: var(--back-y-multiplier);}.coin::before {    background: radial-gradient(circle at 25% 65%, transparent 50%, rgba(255, 255, 255, 0.9) 90%), linear-gradient(55deg, transparent calc(var(--shine-bg-multiplier) + 0%), #e9f4ff calc(var(--shine-bg-multiplier) + 0%), transparent calc(var(--shine-bg-multiplier) + 50%));    content: "";    opacity: var(--shine-opacity-multiplier);    transform: translateY(calc(var(--middle-y-multiplier) * 0.3181818182rem / -2)) scaleY(var(--middle-scale-multiplier)) rotate(calc(var(--coin-rotation-multiplier) * 1deg));    z-index: 10;}.coin::after {    background: #737c99;    content: "";    height: 0.3181818182rem;    left: 0;    position: absolute;    top: 50%;    transform: translateY(-50%);    width: 100%;    z-index: 2;}@keyframes shake {    0% {        transform: rotate(4deg);    }    66% {        transform: rotate(-4deg);    }    100% {        transform: rotate();    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/coin/coin.js"/>
      <url>/js/coin/coin.js</url>
      
        <content type="html"><![CDATA[var tipButtons = document.querySelectorAll(".tip-button");function coinAudio() {  var coinAudio = document.getElementById("coinAudio");  if (coinAudio) {    coinAudio.play(); //有音频时播放  }}// Loop through all buttons (allows for multiple buttons on page)tipButtons.forEach(button => {  var coin = button.querySelector(".coin");  // The larger the number, the slower the animation  coin.maxMoveLoopCount = 90;  button.addEventListener("click", () => {    if (/Android|webOS|BlackBerry/i.test(navigator.userAgent)) return true; //媒体选择    if (button.clicked) return;    button.classList.add("clicked");    // Wait to start flipping th coin because of the button tilt animation    setTimeout(() => {      // Randomize the flipping speeds just for fun      coin.sideRotationCount = Math.floor(Math.random() * 5) * 90;      coin.maxFlipAngle = (Math.floor(Math.random() * 4) + 3) * Math.PI;      button.clicked = true;      flipCoin();      coinAudio();    }, 50);  });  var flipCoin = () => {    coin.moveLoopCount = 0;    flipCoinLoop();  };  var resetCoin = () => {    coin.style.setProperty("--coin-x-multiplier", 0);    coin.style.setProperty("--coin-scale-multiplier", 0);    coin.style.setProperty("--coin-rotation-multiplier", 0);    coin.style.setProperty("--shine-opacity-multiplier", 0.4);    coin.style.setProperty("--shine-bg-multiplier", "50%");    coin.style.setProperty("opacity", 1);    // Delay to give the reset animation some time before you can click again    setTimeout(() => {      button.clicked = false;    }, 300);  };  var flipCoinLoop = () => {    coin.moveLoopCount++;    var percentageCompleted = coin.moveLoopCount / coin.maxMoveLoopCount;    coin.angle = -coin.maxFlipAngle * Math.pow(percentageCompleted - 1, 2) + coin.maxFlipAngle;    // Calculate the scale and position of the coin moving through the air    coin.style.setProperty("--coin-y-multiplier", -11 * Math.pow(percentageCompleted * 2 - 1, 4) + 11);    coin.style.setProperty("--coin-x-multiplier", percentageCompleted);    coin.style.setProperty("--coin-scale-multiplier", percentageCompleted * 0.6);    coin.style.setProperty("--coin-rotation-multiplier", percentageCompleted * coin.sideRotationCount);    // Calculate the scale and position values for the different coin faces    // The math uses sin/cos wave functions to similate the circular motion of 3D spin    coin.style.setProperty("--front-scale-multiplier", Math.max(Math.cos(coin.angle), 0));    coin.style.setProperty("--front-y-multiplier", Math.sin(coin.angle));    coin.style.setProperty("--middle-scale-multiplier", Math.abs(Math.cos(coin.angle), 0));    coin.style.setProperty("--middle-y-multiplier", Math.cos((coin.angle + Math.PI / 2) % Math.PI));    coin.style.setProperty("--back-scale-multiplier", Math.max(Math.cos(coin.angle - Math.PI), 0));    coin.style.setProperty("--back-y-multiplier", Math.sin(coin.angle - Math.PI));    coin.style.setProperty("--shine-opacity-multiplier", 4 * Math.sin((coin.angle + Math.PI / 2) % Math.PI) - 3.2);    coin.style.setProperty("--shine-bg-multiplier", -40 * (Math.cos((coin.angle + Math.PI / 2) % Math.PI) - 0.5) + "%");    // Repeat animation loop    if (coin.moveLoopCount < coin.maxMoveLoopCount) {      if (coin.moveLoopCount === coin.maxMoveLoopCount - 6) button.classList.add("shrink-landing");      window.requestAnimationFrame(flipCoinLoop);    } else {      button.classList.add("coin-landed");      coin.style.setProperty("opacity", 0);      setTimeout(() => {        button.classList.remove("clicked", "shrink-landing", "coin-landed");        setTimeout(() => {          resetCoin();        }, 300);      }, 1500);    }  };});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/menus/music/index.html"/>
      <url>/menus/music/index.html</url>
      
        <content type="html"><![CDATA[<script>console.error("ReferenceError: value is not defined");</script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>图库</title>
      <link href="/menus/gallery/index.html"/>
      <url>/menus/gallery/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>古诗文</title>
      <link href="/menus/poem/index.html"/>
      <url>/menus/poem/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>商城商品管理系统</title>
      <link href="/pages/ShopManager/index.html"/>
      <url>/pages/ShopManager/index.html</url>
      
        <content type="html"><![CDATA[<a class="btn-beautify outline green larger" href="/posts/961490cd.html#%E5%95%86%E5%9F%8E%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F" title="返回"><i class="far fa-hand-point-right"></i><span>返回</span></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 商城商品管理系统</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Product</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line"><span class="type">float</span> price;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Product &amp;other) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> id == other.id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Product&gt; List, Car;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Product New;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n请输入新商品的id(id不可更改): &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;New.id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">count</span>(List.<span class="built_in">begin</span>(), List.<span class="built_in">end</span>(), Product&#123;New.id&#125;))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\a此id已经被使用!(1-重新输入/0-返回)请选择：&quot;</span>);</span><br><span class="line"><span class="type">int</span> op;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n请输入新商品的id(id不可更改): &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;New.id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\a没有该选项!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输入新商品的名称: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, New.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输入新商品的价格: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;New.price);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输入新商品的库存: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;New.num);</span><br><span class="line"></span><br><span class="line">List.<span class="built_in">push_back</span>(New);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n添加成功!\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输入要删除的商品id: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(List.<span class="built_in">begin</span>(), List.<span class="built_in">end</span>(), Product&#123;id&#125;);</span><br><span class="line"><span class="keyword">if</span> (it != List.<span class="built_in">end</span>())</span><br><span class="line">List.<span class="built_in">erase</span>(it);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\a找不到id为%d的商品!\n\n&quot;</span>, id);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n删除成功!\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printAllProducts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : List)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; ID: %12d, 名称: %20s, 价格: %16.2f, 库存: %13d&quot;</span>, i.id, i.name, i.price, i.num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteCarProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> carid, carnum;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n请输入要删除的商品的id: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;carid);</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(Car.<span class="built_in">begin</span>(), Car.<span class="built_in">end</span>(), Product&#123;carid&#125;);</span><br><span class="line"><span class="type">int</span> i = <span class="built_in">distance</span>(Car.<span class="built_in">begin</span>(), it);</span><br><span class="line"><span class="keyword">if</span> (it != Car.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n请输入要删除的数量: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;carnum);</span><br><span class="line"><span class="keyword">if</span> (carnum &lt; Car[i].num)</span><br><span class="line">Car[i].num -= carnum;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Car.<span class="built_in">erase</span>(it);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n删除成功!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\a购物车里没有id为%d的商品!\n&quot;</span>, carid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">payAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : Car)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(List.<span class="built_in">begin</span>(), List.<span class="built_in">end</span>(), Product&#123;i.id&#125;);</span><br><span class="line"><span class="keyword">if</span> (it-&gt;num &gt; i.num)</span><br><span class="line">List[<span class="built_in">distance</span>(List.<span class="built_in">begin</span>(), it)].num -= i.num;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">List.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line">Car.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n购买成功!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printCarProducts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> op = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (op)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : Car)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; ID: %12d, 名称: %20s, 数量: %13d, 总价：%16.2f&quot;</span>, i.id, i.name, i.num, i.price * i.num);</span><br><span class="line">cnt += i.price * i.num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; 总价: %20.2f                          (1-支付全部/2-清空/3-删除商品/0-返回)&quot;</span>, cnt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n请输入操作：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line"><span class="keyword">switch</span> (op)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">payAll</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">Car.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n已清除全部商品!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">deleteCarProduct</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\a没有该选项！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Product A, Product B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> A.id &lt; B.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortPrintAll</span><span class="params">(vector&lt;Product&gt; A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : A)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; ID: %12d, 名称: %20s, 价格: %16.2f, 库存: %13d&quot;</span>, i.id, i.name, i.price, i.num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkProduct</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> id, n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输入要查询的商品的id: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(List.<span class="built_in">begin</span>(), List.<span class="built_in">end</span>(), Product&#123;id&#125;);</span><br><span class="line"><span class="type">int</span> i = <span class="built_in">distance</span>(List.<span class="built_in">begin</span>(), it);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (it != List.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; ID: %12d, 名称: %20s, 价格: %16.2f, 库存: %13d&quot;</span>, List[i].id, List[i].name, List[i].price, List[i].num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key == <span class="number">1010</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(n-将n件该商品加入购物车/0-返回): &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n)</span><br><span class="line">&#123;</span><br><span class="line">Product buy&#123;List[i].id, <span class="string">&quot;&quot;</span>, List[i].price, n&#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(buy.name, List[i].name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> inCar = <span class="built_in">find</span>(Car.<span class="built_in">begin</span>(), Car.<span class="built_in">end</span>(), Product&#123;id&#125;);</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">distance</span>(Car.<span class="built_in">begin</span>(), inCar);</span><br><span class="line"><span class="keyword">if</span> (inCar != Car.<span class="built_in">end</span>())</span><br><span class="line">Car[j].num += n;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Car.<span class="built_in">push_back</span>(buy);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n添加成功!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\a找不到ID为%d的商品!\n\n&quot;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输入要修改商品的id: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(List.<span class="built_in">begin</span>(), List.<span class="built_in">end</span>(), Product&#123;id&#125;);</span><br><span class="line"><span class="type">int</span> i = <span class="built_in">distance</span>(List.<span class="built_in">begin</span>(), it);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (it != List.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> op;</span><br><span class="line"><span class="type">bool</span> over = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (over)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nID: %d, 名称: %s, 价格: %.2f, 库存: %d\n\n&quot;</span>, List[i].id, List[i].name, List[i].price, List[i].num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要修改什么(名称-1/价格-2/库存-3/完成-0): &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (op)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n请输入修改后的商品名称: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, List[i].name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n修改成功!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n请输入修改后的商品价格: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;List[i].price);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n修改成功!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n请输入修改后的商品库存: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;List[i].num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n修改成功!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">over = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n修改完成!\n\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\a没有该选项!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\a找不到ID为%d的商品!\n\n&quot;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">List.<span class="built_in">push_back</span>(Product&#123;<span class="number">10001</span>, <span class="string">&quot;样品1&quot;</span>, <span class="number">10</span>, <span class="number">100</span>&#125;);</span><br><span class="line">List.<span class="built_in">push_back</span>(Product&#123;<span class="number">10002</span>, <span class="string">&quot;样品2&quot;</span>, <span class="number">2.5</span>, <span class="number">2000</span>&#125;);</span><br><span class="line">List.<span class="built_in">push_back</span>(Product&#123;<span class="number">10003</span>, <span class="string">&quot;样品3&quot;</span>, <span class="number">1024</span>, <span class="number">5</span>&#125;);</span><br><span class="line"><span class="type">int</span> key, op;</span><br><span class="line"><span class="type">bool</span> login;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;登录...\n请输入身份密钥(客户-1010/商家-2020/退出系统-0): &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);</span><br><span class="line"></span><br><span class="line">login = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">switch</span> (key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2020</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n您好！商家:\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (login)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1-添加商品\n2-删除商品\n3-显示所有商品\n4-Id升序显示所有商品\n5-查询单个商品信息\n6-修改商品信息\n0-返回登录界面\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请选择您要进行的操作: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (op)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">addProduct</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">deleteProduct</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printAllProducts</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="built_in">sortPrintAll</span>(List);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="built_in">checkProduct</span>(key);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="built_in">reProduct</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">login = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\a没有该选项!\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1010</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n您好！客户:\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (login)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1-显示所有商品\n2-Id升序显示所有商品\n3-查询单个商品信息\n4-查看购物车\n0-返回登录界面\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请选择您要进行的操作: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (op)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printAllProducts</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">sortPrintAll</span>(List);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">checkProduct</span>(key);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="built_in">printCarProducts</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">login = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\a没有该选项!\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\a请输入正确的密钥!\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>万年历</title>
      <link href="/pages/WanNianLi/index.html"/>
      <url>/pages/WanNianLi/index.html</url>
      
        <content type="html"><![CDATA[<a class="btn-beautify outline green larger" href="/posts/961490cd.html#%E4%B8%87%E5%B9%B4%E5%8E%86" title="返回"><i class="far fa-hand-point-right"></i><span>返回</span></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 万年历</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *MONTH_NAMES[<span class="number">12</span>] = &#123;<span class="string">&quot;                     January&quot;</span>, <span class="string">&quot;                    February&quot;</span>, <span class="string">&quot;                       March&quot;</span>,</span><br><span class="line">   <span class="string">&quot;                       April&quot;</span>, <span class="string">&quot;                         May&quot;</span>, <span class="string">&quot;                        June&quot;</span>,</span><br><span class="line">   <span class="string">&quot;                        July&quot;</span>, <span class="string">&quot;                      August&quot;</span>, <span class="string">&quot;                   September&quot;</span>,</span><br><span class="line">   <span class="string">&quot;                     October&quot;</span>, <span class="string">&quot;                    November&quot;</span>, <span class="string">&quot;                    December&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLeap</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Wweek</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (month &lt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">month += <span class="number">12</span>;</span><br><span class="line">year--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h = (day + <span class="number">2</span> * month + <span class="number">3</span> * (month + <span class="number">1</span>) / <span class="number">5</span> + year + year / <span class="number">4</span> - year / <span class="number">100</span> + year / <span class="number">400</span>) % <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (h &lt; <span class="number">0</span>)</span><br><span class="line">h += <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">h++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pcalendar</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DAYS_IN_MONTH[<span class="number">12</span>] = &#123;<span class="number">31</span>, <span class="built_in">isLeap</span>(year) ? <span class="number">29</span> : <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>,</span><br><span class="line">   <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, MONTH_NAMES[month]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;            -%02d-            \n&quot;</span>, month + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; SUN MON TUE WED THU FRI SAI\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> firstDayOfWeek = <span class="built_in">Wweek</span>(year, month + <span class="number">1</span>, <span class="number">1</span>) % <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; firstDayOfWeek; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> day = <span class="number">1</span>; day &lt;= DAYS_IN_MONTH[month]; ++day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>, day);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((day + firstDayOfWeek) % <span class="number">7</span> == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    if ((DAYS_IN_MONTH[month] + firstDayOfWeek) % 7 != 0)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//        for (int i = (DAYS_IN_MONTH[month] + firstDayOfWeek) % 7; i &lt; 7; ++i)</span></span><br><span class="line"><span class="comment">//            printf(&quot;    &quot;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n============================\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pyear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> year = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the year: &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;year);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calendar                %04d\n&quot;</span>, year);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> month = <span class="number">0</span>; month &lt; <span class="number">12</span>; ++month)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Pcalendar</span>(year, month);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pmonth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> year = <span class="number">0</span>, month = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the month&lt;YYYY-MM&gt;: &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">year = year * <span class="number">10</span> + str[i] - <span class="number">48</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">1</span>)</span><br><span class="line">month = month * <span class="number">10</span> + str[i] - <span class="number">48</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calendar                %04d\n&quot;</span>, year);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Pcalendar</span>(year, month - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1 -This year is leap or not\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2 -This day is which day of the week\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;3 -The Calendar of this year\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;4 -The Calendar of this month of year\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0 -Exit\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please select the options: &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> year = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the year: &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;year);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLeap</span>(year))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The year %d is leap year.\n\n&quot;</span>, year);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The year %d is not leap year.\n\n&quot;</span>, year);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> year = <span class="number">0</span>, month = <span class="number">0</span>, day = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input the date&lt;YYYY-MM-DD&gt;: &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">year = year * <span class="number">10</span> + str[i] - <span class="number">48</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">1</span>)</span><br><span class="line">month = month * <span class="number">10</span> + str[i] - <span class="number">48</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">2</span>)</span><br><span class="line">day = day * <span class="number">10</span> + str[i] - <span class="number">48</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (<span class="built_in">Wweek</span>(year, month, day))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This day %d-%02d-%02d is Monday.\n\n&quot;</span>, year, month, day);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This day %d-%02d-%02d is Tuesday.\n\n&quot;</span>, year, month, day);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This day %d-%02d-%02d is Wednesday.\n\n&quot;</span>, year, month, day);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This day %d-%02d-%02d is Thursday.\n\n&quot;</span>, year, month, day);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This day %d-%02d-%02d is Friday.\n\n&quot;</span>, year, month, day);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This day %d-%02d-%02d is Saturday.\n\n&quot;</span>, year, month, day);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This day %d-%02d-%02d is Sunday.\n\n&quot;</span>, year, month, day);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">Pyear</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="built_in">Pmonth</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;没有该选项，请重新输入！\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
  
</search>
