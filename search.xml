<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker笔记</title>
      <link href="/posts/5c266b64.html"/>
      <url>/posts/5c266b64.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>有没有一种技术能够避免部署对服务器环境的依赖，减少复杂的部署流程呢？<br>答案是肯定的，这就是<strong>Docker</strong>技术。<br>即便对Linux不熟悉，你也能<strong>轻松部署各种常见软件、项目</strong>。</p><h2 id="Docker部署的基本流程"><a href="#Docker部署的基本流程" class="headerlink" title="Docker部署的基本流程"></a>Docker部署的基本流程</h2><p>我们以部署MySQL为例：</p><p>如果是利用传统方式部署MySQL，大概的步骤有：</p><ul><li>搜索并下载MySQL安装包</li><li>上传至Linux环境</li><li>编译和配置环境</li><li>安装</li></ul><p>而使用Docker安装，仅仅需要一步即可，在命令行输入下面的命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>这里下载的不是安装包，而是<strong>镜像。</strong>  镜像中不仅包含了MySQL本身，还包含了其运行所需要的环境、配置、系统级函数库。因此它在运行时就有自己独立的环境，就可以跨系统运行，也不需要手动再次配置环境了。这套独立运行的隔离环境我们称为<strong>容器</strong>。</p><p>Docker会根据命令中的镜像名称自动搜索并下载镜像，<strong>那么问题来了，它是去哪里搜索和下载镜像的呢？这些镜像又是谁制作的呢？</strong></p><p>Docker官方提供了一个专门管理、存储镜像的网站，并对外开放了镜像上传、下载的权利。Docker官方提供了一些基础镜像，然后各大软件公司又在基础镜像基础上，制作了自家软件的镜像，全部都存放在这个网站。这个网站就成了Docker镜像交流的社区：</p><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p>基本上我们常用的各种软件都能在这个网站上找到，我们甚至可以自己制作镜像上传上去。</p><p><strong>总结一下</strong>：<br>Docker本身包含一个后台服务，我们可以利用Docker命令告诉Docker服务，帮助我们快速部署指定的应用。Docker服务部署应用时，首先要去搜索并下载应用对应的镜像，然后根据镜像创建并允许容器，应用就部署完成了。</p><p>用一幅图标示如下：<br><img src="https://image.flashfish777.cn/img/post_27_1.jpg"></p><h2 id="解读部署MySQL的命令"><a href="#解读部署MySQL的命令" class="headerlink" title="解读部署MySQL的命令"></a>解读部署MySQL的命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>docker run -d</code> ：创建并运行一个容器，-d则是让容器以后台进程运行</li><li><code>--name mysql</code> : 给容器起个名字叫mysql，名字唯一，用于区分不同的容器</li><li><code>-p 3306:3306</code> : 设置端口映射。</li><li>容器是隔离环境，外界不可访问。但是可以将宿主机端口映射容器内到端口，当访问宿主机指定端口时，就是在访问容器内的端口了。</li><li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式： <code>-p</code> 宿主机端口:容器内端口，示例中就是将宿主机的3306映射到容器内的3306端口</li><li><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些环境参数（可以在docker官方网站查阅哪些环境参数是必须在下载时指定的）</li><li>格式：<code>-e KEY=VALUE</code>，<code>KEY</code> 和 <code>VALUE</code> 都由容器内进程决定</li><li>案例中，<code>TZ=Asia/Shanghai</code>是设置时区；<code>MYSQL_ROOT_PASSWORD=123</code>是设置MySQL默认密码</li><li><code>mysql</code> : 设置镜像名称，Docker会根据这个名字搜索并下载镜像</li><li>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</li><li>在未指定 <code>TAG</code> 的情况下，默认是最新版本，也就是 <code>mysql:latest</code></li></ul><hr><h1 id="Docker常见命令"><a href="#Docker常见命令" class="headerlink" title="Docker常见命令"></a>Docker常见命令</h1><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>说明</strong></th><th><strong>文档地址</strong></th></tr></thead><tbody><tr><td>docker pull</td><td>拉取镜像</td><td><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td>docker push</td><td>推送镜像到DockerRegistry</td><td><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td>docker images</td><td>查看本地镜像</td><td><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td>docker rmi</td><td>删除本地镜像</td><td><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td>docker run</td><td>创建并运行容器（不能重复创建）</td><td><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td>docker stop</td><td>停止指定容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td>docker start</td><td>启动指定容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td>docker restart</td><td>重新启动容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td>docker rm</td><td>删除指定容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td>docker ps</td><td>查看容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td>docker logs</td><td>查看容器运行日志</td><td><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td>docker exec</td><td>进入容器</td><td><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td>docker save</td><td>保存镜像到本地压缩文件</td><td><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td>docker load</td><td>加载本地压缩文件到镜像</td><td><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td>docker inspect</td><td>查看容器详细信息</td><td><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table><p>用一副图来表示这些命令的关系：<br><img src="https://image.flashfish777.cn/img/post_27_2.jpg"></p><h2 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h2><p>对于一些常用docker命令我们可以为其起一个简单的别名：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改/root/.bashrc文件</span></span><br><span class="line">vi /root/.bashrc</span><br><span class="line">内容如下：</span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br><span class="line"></span><br><span class="line">alias <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span></span><br><span class="line">alias <span class="built_in">cp</span>=<span class="string">&#x27;cp -i&#x27;</span></span><br><span class="line">alias <span class="built_in">mv</span>=<span class="string">&#x27;mv -i&#x27;</span></span><br><span class="line">alias dps=<span class="string">&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span></span><br><span class="line">alias dis=<span class="string">&#x27;docker images&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -<span class="type">f</span> /<span class="type">etc</span>/<span class="type">bashrc</span> ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>然后，执行命令使别名生效</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /root/.bashrc</span><br></pre></td></tr></table></figure><hr><h1 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h1><h2 id="镜像结构"><a href="#镜像结构" class="headerlink" title="镜像结构"></a>镜像结构</h2><p>镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为镜像中包含了程序运行需要的系统函数库、环境、配置、依赖。</p><p>因此，<strong>自定义镜像本质就是依次准备好程序运行的基础环境、依赖、应用本身、运行配置等文件，并且打包而成。</strong></p><p>要从0部署一个Java应用，大概流程是这样：</p><ul><li><p>准备一个linux服务（CentOS或者Ubuntu均可）</p></li><li><p>安装并配置JDK</p></li><li><p>上传Jar包</p></li><li><p>运行jar包</p></li></ul><p>那因此，我们打包镜像也是分成这么几步：</p><ul><li><p>准备Linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可）</p></li><li><p>安装并配置JDK</p></li><li><p>拷贝jar包</p></li><li><p>配置启动脚本</p></li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会<strong>单独打包并标记一个唯一id</strong>，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><p>例如，第一步中需要的Linux运行环境，通用性就很强，所以Docker官方就制作了这样的只包含Linux运行环境的镜像。我们在制作java镜像时，就无需重复制作，直接使用Docker官方提供的CentOS或Ubuntu镜像作为基础镜像。然后再搭建其它层即可，这样逐层搭建，最终整个Java项目的镜像结构如图所示：<br><img src="https://image.flashfish777.cn/img/post_27_3.jpg"></p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。</p><p>而这种记录镜像结构的文件就称为<strong>Dockerfile</strong>。</p><p>其中的语法比较多，比较常用的有：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>FROM</strong></td><td>指定基础镜像</td><td><code>FROM centos:6</code></td></tr><tr><td><strong>ENV</strong></td><td>设置环境变量，可在后面指令使用</td><td><code>ENV key value</code></td></tr><tr><td><strong>COPY</strong></td><td>拷贝本地文件到镜像的指定目录</td><td><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td><strong>RUN</strong></td><td>执行Linux的shell命令，一般是安装过程的命令</td><td><code>RUN yum install gcc</code></td></tr><tr><td><strong>EXPOSE</strong></td><td>指定容器运行时监听的端口，是给镜像使用者看的</td><td>EXPOSE 8080</td></tr><tr><td><strong>ENTRYPOINT</strong></td><td>镜像中应用的启动命令，容器运行时调用</td><td>ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>例如，要基于Ubuntu镜像来构建一个Java应用，其Dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录、容器内时区</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar </span></span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="comment"># 指定项目监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>可以发现这样的操作还是十分复杂且麻烦的，如果我们需要自定义多个JAVA应用的镜像，那么我们每次都需要写这样繁琐的DockerFile吗？</p><p>当然不是！！可以发现，对于不同的JAVA应用，却都需要Linux系统环境、JDK环境这两层，只有上面的3层不同（<strong>因为jar包不同</strong>），所以，就有人提供了基础的系统加JDK环境，我们在此基础上制作java镜像，就可以省去JDK的配置了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>当Dockerfile文件写好以后，就可以利用命令来构建镜像了。<br>我们以一个简单的JAVA应用的镜像构建为例：</p><p>dockerfile具体内容：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>然后，执行命令，构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/demo</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t docker-demo:1.0 .</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>如果 Dockerfile 文件没有命名为 <code>Dockerfile</code>，而是使用了其他名称（例如 <code>Dockerfile.dev</code> 或 <code>myapp.Dockerfile</code>），在构建镜像时，需要使用 <code>-f</code> 或 <code>--file</code> 参数来指定 Dockerfile 的路径。<br>假设你的 Dockerfile 文件名为 <code>Dockerfile.dev</code>，并且位于当前目录下，你可以使用以下命令构建镜像：<br><code>docker build -f Dockerfile.dev -t myapp:1.0 .</code><br>其中：</p><ul><li><code>-f Dockerfile.dev</code>：指定使用 <code>Dockerfile.dev</code> 作为 Dockerfile。</li><li><code>-t myapp:1.0</code>：将构建的镜像命名为 <code>myapp</code>，并打上标签 <code>1.0</code>。</li><li><code>.</code>：指定当前目录为构建上下文。</li></ul><hr><h1 id="数据卷挂载"><a href="#数据卷挂载" class="headerlink" title="数据卷挂载"></a>数据卷挂载</h1><h2 id="为什么需要数据卷挂载"><a href="#为什么需要数据卷挂载" class="headerlink" title="为什么需要数据卷挂载"></a>为什么需要数据卷挂载</h2><p>容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便。</p><ul><li><p>如果要升级MySQL版本，需要销毁旧容器，那么数据岂不是跟着被销毁了？</p></li><li><p>MySQL、Nginx容器运行后，如果我要修改其中的某些配置该怎么办？</p></li><li><p>我想要让Nginx代理我的静态资源怎么办？</p></li></ul><p>因此，容器提供程序的运行环境，但是<strong>程序运行产生的数据、程序运行依赖的配置都应该与容器解耦</strong>。</p><p><strong>此时我们就需要使用数据卷</strong></p><h2 id="什么是数据卷"><a href="#什么是数据卷" class="headerlink" title="什么是数据卷"></a>什么是数据卷</h2><p><strong>数据卷（volume）</strong> 是一个虚拟目录，是<strong>容器内目录</strong>与<strong>宿主机****目录</strong>之间映射的桥梁。</p><p>以Nginx为例，在Nginx中有两个关键的目录：</p><ul><li><p><code>html</code>：放置一些静态资源</p></li><li><p><code>conf</code>：放置配置文件</p></li></ul><p>如果要让Nginx代理我们的静态资源，最好是放到<code>html</code>目录；如果我们要修改Nginx的配置，最好是找到<code>conf</code>下的<code>nginx.conf</code>文件。</p><p>但遗憾的是，容器运行的Nginx所有的文件都在容器内部。所以我们必须利用数据卷将两个目录与宿主机目录关联，方便我们操作。如图：<br><img src="https://image.flashfish777.cn/img/post_27_4.jpg"></p><p>在上图中：</p><ul><li><p>我们创建了两个数据卷：<code>conf</code>、<code>html</code></p></li><li><p>Nginx容器内部的<code>conf</code>目录和<code>html</code>目录分别与两个数据卷关联。</p></li><li><p>而数据卷conf和html分别指向了宿主机的<code>/var/lib/docker/volumes/conf/_data</code>目录和<code>/var/lib/docker/volumes/html/_data</code>目录</p></li></ul><p>这样以来，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机的<code>conf</code>和<code>html</code>目录关联起来，我们称为<strong>挂载</strong>。此时，我们操作宿主机的<code>/var/lib/docker/volumes/html/_data</code>就是在操作容器内的<code>/usr/share/nginx/html/_data</code>目录。只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了（<strong>也就是容器内的目录和宿主机的目录双向绑定</strong>）</p><p><strong>需要注意的是：</strong><br><code>var/lib/docker/volumes/</code> 是 Docker 默认存储<strong>命名数据卷</strong> 的目录。</p><ul><li><p>当你使用 <code>docker volume create</code> 命令创建一个命名数据卷时，Docker 会在 <code>/var/lib/docker/volumes/</code> 目录下为该卷创建一个子目录。</p></li><li><p>例如，创建一个名为 <code>my-volume</code> 的数据卷：<br>  <code>docker volume create my-volume</code><br>  这个卷的实际数据会存储在 <code>/var/lib/docker/volumes/my-volume/_data/</code> 目录下。</p></li></ul><h2 id="数据卷命令"><a href="#数据卷命令" class="headerlink" title="数据卷命令"></a>数据卷命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>说明</strong></th><th><strong>文档地址</strong></th></tr></thead><tbody><tr><td>docker volume create</td><td>创建数据卷</td><td><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td>docker volume ls</td><td>查看所有数据卷</td><td><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td>docker volume rm</td><td>删除指定数据卷</td><td><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td>docker volume inspect</td><td>查看某个数据卷的详情</td><td><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td>docker volume prune</td><td>清除数据卷</td><td><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table><hr><h1 id="本地数据卷挂载"><a href="#本地数据卷挂载" class="headerlink" title="本地数据卷挂载"></a>本地数据卷挂载</h1><p>由于路径过长，且匿名数据卷对应的路径为docker帮我们随机生成的路径名，因此对mysql升级时，当卸载掉旧的容器，重新生成新的容器时，就会造成数据卷中的信息丢失（<strong>Docker会为新的容器随机创建一个新的匿名数据卷</strong>）。<strong>因此，我们就需要使用本地数据卷，将容器目录与宿主机指定目录挂载。</strong></p><h2 id="挂载本地目录或文件"><a href="#挂载本地目录或文件" class="headerlink" title="挂载本地目录或文件"></a>挂载本地目录或文件</h2><p>挂载语法与数据卷类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="comment"># 挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br></pre></td></tr></table></figure><hr><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p><strong>容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接会失败。</strong></p><p>因此我们就需要使用docker自定义网络的功能，当容器接入到我们自定义的网络中时，我们可以不通过容器的ip地址，而是通过容器名直接访问到对应的容器。</p><h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><p>常见命令有：</p><table><thead><tr><th><strong>命令</strong></th><th><strong>说明</strong></th><th><strong>文档地址</strong></th></tr></thead><tbody><tr><td>docker network create</td><td>创建一个网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td></tr><tr><td>docker network ls</td><td>查看所有网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td></tr><tr><td>docker network rm</td><td>删除指定网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td></tr><tr><td>docker network prune</td><td>清除未使用的网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td></tr><tr><td>docker network connect</td><td>使指定容器连接加入某网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td></tr><tr><td>docker network disconnect</td><td>使指定容器连接离开某网络</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td></tr><tr><td>docker network inspect</td><td>查看网络详细信息</td><td><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td></tr></tbody></table><hr><h1 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker compose"></a>Docker compose</h1><h2 id="为什么会使用到DockerCompose"><a href="#为什么会使用到DockerCompose" class="headerlink" title="为什么会使用到DockerCompose"></a>为什么会使用到DockerCompose</h2><p>可以看到，我们部署一个简单的java项目，其中包含3个容器：</p><ul><li>MySQL</li><li>Nginx</li><li>Java项目</li></ul><p>而稍微复杂的项目，其中还会有各种各样的其它中间件，需要部署的东西远不止3个。如果还像之前那样手动的逐一部署，就太麻烦了。</p><p>而Docker Compose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>。<strong>它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器。</strong></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><code>docker-compose</code> 文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于 <code>service</code> 就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数非常相似。</p><p>我们可以比对着<code>docker run</code>的语法来看<code>DockerCompose</code>的语法：<br>用docker run部署MySQL的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network hmall</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>用<code>docker-compose.yml</code>文件来定义，就是这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">new:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure><p>对比如下：</p><table><thead><tr><th><strong>docker run 参数</strong></th><th><strong>docker compose 指令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>–name</td><td>container_name</td><td>容器名称</td></tr><tr><td>-p</td><td>ports</td><td>端口映射</td></tr><tr><td>-e</td><td>environment</td><td>环境变量</td></tr><tr><td>-v</td><td>volumes</td><td>数据卷配置</td></tr><tr><td>–network</td><td>networks</td><td>网络</td></tr></tbody></table><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose [OPTIONS] [COMMAND]</span><br></pre></td></tr></table></figure><p>其中，OPTIONS和COMMAND都是可选参数，比较常见的有：</p><table><thead><tr><th><strong>类型</strong></th><th><strong>参数或指令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Options</td><td></td><td></td></tr><tr><td></td><td>-f</td><td>指定compose文件的路径和名称</td></tr><tr><td></td><td>-p</td><td>指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td></tr><tr><td>Commands</td><td></td><td></td></tr><tr><td></td><td>up</td><td>创建并启动所有service容器</td></tr><tr><td></td><td>down</td><td>停止并移除所有容器、网络</td></tr><tr><td></td><td>ps</td><td>列出所有启动的容器</td></tr><tr><td></td><td>logs</td><td>查看指定容器的日志</td></tr><tr><td></td><td>stop</td><td>停止容器</td></tr><tr><td></td><td>start</td><td>启动容器</td></tr><tr><td></td><td>restart</td><td>重启容器</td></tr><tr><td></td><td>top</td><td>查看运行的进程</td></tr><tr><td></td><td>exec</td><td>在指定的运行中容器中执行命令</td></tr></tbody></table><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua学习笔记</title>
      <link href="/posts/9285b404.html"/>
      <url>/posts/9285b404.html</url>
      
        <content type="html"><![CDATA[<div class="note danger info flat"><p><strong>酝酿中…</strong></p></div>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微派冬令营面试</title>
      <link href="/posts/174932e5.html"/>
      <url>/posts/174932e5.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL语法简记</title>
      <link href="/posts/7c005a55.html"/>
      <url>/posts/7c005a55.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p><strong>记的是MySQL的语法，但是应该大差不差</strong></p></div><h1 id="数据库的规范化"><a href="#数据库的规范化" class="headerlink" title="数据库的规范化"></a>数据库的规范化</h1><h2 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h2><p><strong>第一范式是指数据库的每一列都是不可分割的基本数据项</strong>，而下面这样的就存在可分割的情况：</p><ul><li>学生（姓名，电话号码）</li></ul><p>电话号码实际上包括了<code>家用座机电话</code>和<code>移动电话</code>，因此它可以被拆分为：</p><ul><li>学生（姓名，座机号码，手机号码）</li></ul><p><strong>满足第一范式是关系型数据库最基本的要求！</strong></p><h2 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h2><p><strong>第二范式要求表中必须存在主键，且其他的属性必须完全依赖于主键</strong>，比如：</p><ul><li>学生（学号，姓名，性别）</li></ul><p>学号是每个学生的唯一标识，每个学生都有着不同的学号，因此此表中存在一个主键，并且每个学生的所有属性都依赖于学号，学号发生改变就代表学生发生改变，姓名和性别都会因此发生改变，所有此表满足第二范式。</p><h2 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h2><p><strong>在第二范式的基础上，要求一个数据库表中不包含已在其他表中已包含的非主属性信息，也就是说，非主键列必须直接依赖于主键，不能依赖于其他非主键列</strong></p><ul><li>学生借书情况（借阅编号，学生学号，书籍编号，书籍名称，书籍作者）</li></ul><p>实际上书籍编号依赖于借阅编号，而书籍名称和书籍作者依赖于书籍编号，因此存在传递依赖的情况，我们可以将书籍信息进行单独拆分为另一张表：</p><ul><li>学生借书情况（借阅编号，学生学号，书籍编号）</li><li>书籍（书籍编号，书籍名称，书籍作者）</li></ul><p>这样就消除了传递依赖，从而满足第三范式。</p><h2 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h2><p>BCNF作为第三范式的补充，假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：</p><p>(仓库ID, 存储物品ID) →(管理员ID, 数量)</p><p>(管理员ID, 存储物品ID) → (仓库ID, 数量)</p><p>所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：</p><p>(仓库ID) → (管理员ID)</p><p>(管理员ID) → (仓库ID)</p><p>即存在关键字段决定关键字段的情况，如果修改管理员ID，那么就必须逐一进行修改，所以其不符合BCNF范式。<br>也就是出现了 管理员ID 和 仓库ID 都能够确定一个仓库 即 出现了<strong>两个唯一值</strong>相互确定。</p><hr><h1 id="数据库定义语言（DDL）"><a href="#数据库定义语言（DDL）" class="headerlink" title="数据库定义语言（DDL）"></a>数据库定义语言（DDL）</h1><p><strong>写命令时 要大写就都大写 小写就都小写</strong></p><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><ol><li>创建一个数据库：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database 数据库名</span><br></pre></td></tr></table></figure><p>为了能够支持中文，我们在创建时可以设定编码格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 数据库名称 <span class="keyword">DEFAULT</span> CHARSET utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span><br></pre></td></tr></table></figure><p><code>IF NOT EXISTS</code>表示 只有当<strong>指定的数据库名</strong>不存在时才创建<strong>对应的数据库</strong></p><ol start="2"><li>删除一个数据库：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database 数据库名</span><br></pre></td></tr></table></figure><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><p><strong>[]里的内容代表可以省略</strong></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>（1）以下的数据类型用于字符串存储：</strong></p><ul><li>char(n)可以存储任意字符串，但是是固定长度为n，如果插入的长度小于定义长度时，则用空格填充。</li><li>varchar(n)也可以存储任意数量字符串，长度不固定，但不能超过n，不会用空格填充。</li></ul><p><strong>（2）以下数据类型用于存储数字：</strong></p><ul><li>smallint用于存储小的整数，范围在 (-32768，32767)</li><li>int用于存储一般的整数，范围在 (-2147483648，2147483647)</li><li>bigint用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807)</li><li>float用于存储单精度小数</li><li>double用于存储双精度的小数</li></ul><p><strong>（3）以下数据类型用于存储时间：</strong></p><ul><li>date存储日期</li><li>time存储时间</li><li>year存储年份</li><li>datetime用于混合存储日期+时间</li></ul><h3 id="列级约束条件"><a href="#列级约束条件" class="headerlink" title="列级约束条件"></a>列级约束条件</h3><p><strong>一个列可以有多个约束</strong></p><p>列级约束有六种：主键<code>Primary key</code>、外键<code>foreign key</code> 、唯一 <code>unique</code>、检查 <code>check</code>（CHECK约束用于在数据库中对表的数据进行验证和限制。它允许你定义一个条件，该条件必须在插入或更新数据时满足才能成功执行操作。） 、默认<code>default</code> 、非空&#x2F;空值 <code>not null/ null</code></p><h3 id="表级约束条件"><a href="#表级约束条件" class="headerlink" title="表级约束条件"></a>表级约束条件</h3><p>表级约束有四种：主键、外键、唯一、检查</p><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(列名 数据类型[列级约束条件],</span><br><span class="line">             列名 数据类型[列级约束条件],</span><br><span class="line">             ...</span><br><span class="line">             [,表级约束条件])</span><br></pre></td></tr></table></figure><p>如果需要在创建的时候 添加外键，下面是一个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> Orders (</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_CustomerID] <span class="keyword">FOREIGN KEY</span> (CustomerID) <span class="keyword">REFERENCES</span> Customers (CustomerID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在这个例子中，创建了一个名为”Orders”的表，它有三个列：OrderID、CustomerID和OrderDate。然后，通过FOREIGN KEY约束，将CustomerID列设置为外键，参照了另一个名为”Customers”的表中的CustomerID列作为主键。<br>通过定义外键约束，我们可以确保在”Orders”表中的CustomerID列中的值必须存在于”Customers”表的CustomerID列中，从而维护了表之间的关系完整性。</p><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 表名 <span class="comment">/*添加列*/</span>[<span class="keyword">ADD</span> 新列名 数据类型[列级约束条件]]</span><br><span class="line">                <span class="comment">/*删除列*/</span>[<span class="keyword">DROP</span> <span class="keyword">COLUMN</span> 列名[restrict<span class="operator">|</span>cascade]]</span><br><span class="line">                <span class="comment">/*修改列*/</span>[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> 列名 新数据类型]</span><br></pre></td></tr></table></figure><p>我们可以通过 <code>ADD</code> 来添加一个新的列，通过 <code>DROP</code> 来删除一个列，不过我们可以添加restrict或cascade，默认是restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除，而cascade会强制连带引用此列的约束、视图一起删除。还可以通过 <code>ALTER</code> 来修改此列的属性。</p><h3 id="表创建后-对列追加约束"><a href="#表创建后-对列追加约束" class="headerlink" title="表创建后 对列追加约束"></a>表创建后 对列追加约束</h3><p>你也可以在创建表之后，使用ALTER TABLE语句来添加约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> Employees</span><br><span class="line">MODIFY ID <span class="type">INT</span> <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span>;</span><br></pre></td></tr></table></figure><p>这个语句会修改”Employees”表，使得”ID”列不能有NULL值，并且所有的值必须是唯一的。</p><h3 id="表创建后-对列追加外键约束"><a href="#表创建后-对列追加外键约束" class="headerlink" title="表创建后 对列追加外键约束"></a>表创建后 对列追加外键约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> Orders (</span><br><span class="line">    OrderID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    CustomerID <span class="type">INT</span>,</span><br><span class="line">    OrderDate <span class="type">DATE</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 添加外键约束</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> Orders</span><br><span class="line"><span class="keyword">ADD CONSTRAINT</span> FK_CustomerID <span class="keyword">FOREIGN KEY</span> (CustomerID) <span class="keyword">REFERENCES</span> Customers (CustomerID);</span><br></pre></td></tr></table></figure><h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><p>注意：并非所有的数据库系统都支持RENAME TABLE语句例如MySQL支持</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> <span class="operator">&lt;</span>old_table_name<span class="operator">&gt;</span> <span class="keyword">TO</span> <span class="operator">&lt;</span>new_table_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="删除外键约束"><a href="#删除外键约束" class="headerlink" title="删除外键约束"></a>删除外键约束</h3><p>首先使用DESCRIBE语句查看表的结构，确定要删除外键约束的表和列名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> table_name;</span><br></pre></td></tr></table></figure><p>（将table_name替换为实际的表名）</p><p>使用ALTER TABLE语句和DROP FOREIGN KEY子句删除外键约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">FOREIGN KEY</span> constraint_name;</span><br></pre></td></tr></table></figure><p>（将table_name替换为实际的表名，constraint_name替换为实际的外键约束名称）。</p><hr><h1 id="数据库操纵语言（DML）"><a href="#数据库操纵语言（DML）" class="headerlink" title="数据库操纵语言（DML）"></a>数据库操纵语言（DML）</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>, 值<span class="number">2</span>, 值<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名(列名<span class="number">1</span>, 列名<span class="number">2</span>) <span class="keyword">VALUES</span>(值<span class="number">1</span>, 值<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>我们也可以一次性向数据库中插入多条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> 表名(列名<span class="number">1</span>, 列名<span class="number">2</span>) <span class="keyword">VALUES</span>(值<span class="number">1</span>, 值<span class="number">2</span>), (值<span class="number">1</span>, 值<span class="number">2</span>), (值<span class="number">1</span>, 值<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>我们可以通过<code>update</code>语句来更新表中的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 列名<span class="operator">=</span>值,... <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure><p>注意，SQL语句中的等于判断是<code>=</code></p><p><strong>警告：如果忘记添加<code>WHERE</code>字句来限定条件，将使得整个表中此列的所有数据都被修改！</strong></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>我们可以通过使用<code>delete</code>来删除表中的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名</span><br></pre></td></tr></table></figure><p><strong>不加条件限制会把表中数据全部删除</strong></p><p>通过这种方式，将删除表中全部数据，我们也可以使用<code>where</code>来添加条件，只删除指定的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure><hr><h1 id="数据库查询语言（DQL）"><a href="#数据库查询语言（DQL）" class="headerlink" title="数据库查询语言（DQL）"></a>数据库查询语言（DQL）</h1><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><h3 id="单表查询-1"><a href="#单表查询-1" class="headerlink" title="单表查询"></a>单表查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 指定查询某一列数据</span></span><br><span class="line"><span class="keyword">SELECT</span> 列名[,列名] <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">-- 会以别名显示此列</span></span><br><span class="line"><span class="keyword">SELECT</span> 列名 别名 <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">-- 查询所有的列数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">-- 只查询不重复的值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 列名 <span class="keyword">FROM</span> 表名</span><br></pre></td></tr></table></figure><p>我们也可以添加<code>where</code>字句来限定查询目标：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure><p><strong>常用查询条件</strong>：</p><ul><li>一般的比较运算符，包括<code>=、&gt;、&lt;、&gt;=、&lt;=、!=</code>等。</li><li>是否在集合中：<code>in</code>、<code>not in</code></li><li>字符模糊匹配：<code>like</code>，<code>not like</code></li><li>多重条件连接查询：<code>and</code>、<code>or</code>、<code>not</code></li><li>空值和非空值：<code>is null</code>、<code>is not null</code><br>模糊查询举例：</li></ul><ol><li>匹配以特定字符开头的值：<br> 示例：<code>SELECT * FROM 表名 WHERE 列名 LIKE &#39;abc%&#39;;</code><br> 这将返回以”abc”开头的所有值，如”abc123”、”abcdef”等。</li><li>匹配以特定字符结尾的值：<br> 示例：<code>SELECT * FROM 表名 WHERE 列名 LIKE &#39;%xyz&#39;;</code><br> 这将返回以”xyz”结尾的所有值，如”abcxyz”、”123xyz”等。</li><li>匹配包含特定字符的值：<br> 示例：<code>SELECT * FROM 表名 WHERE 列名 LIKE &#39;%def%&#39;;</code><br> 这将返回包含”def”的所有值，如”abcdef”、”defghi”等。</li><li>匹配任意单个字符：<br> 示例：<code>SELECT * FROM 表名 WHERE 列名 LIKE &#39;_bc&#39;;</code><br> 这将返回第一个字符为任意字符，后面跟着”bc”的值，如”abc”、”1bc”等。</li><li>匹配指定数量的任意字符：<br> 示例：<code>SELECT * FROM 表名 WHERE 列名 LIKE &#39;a__&#39;;</code><br> 这将返回以”a”开头，后面跟着任意两个字符的值，如”abc”、”axy”等。</li><li>使用<strong>IN</strong>条件：<br> 假设您有一个名为”users”的表，其中包含一个名为”country”的列。您想要查询所有来自”美国”和”英国”的用户。您可以使用IN条件来实现这个查询：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> country <span class="keyword">IN</span> (<span class="string">&#x27;美国&#x27;</span>, <span class="string">&#x27;英国&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="7"><li>使用<strong>NOT IN</strong>条件：<br> 假设您有一个名为”products”的表，其中包含一个名为”category”的列。您想要查询不属于”电子产品”和”家居用品”类别的产品。您可以使用NOT IN条件来实现这个查询：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> category <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;电子产品&#x27;</span>, <span class="string">&#x27;家居用品&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p>我们可以通过order by来将查询结果进行排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名 <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><p>使用ASC表示升序排序，使用DESC表示降序排序，默认为升序。</p><p>我们也可以可以同时添加多个排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名<span class="number">1</span> <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>, 列名<span class="number">2</span> <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><p>这样会先按照列名1进行排序，每组列名1相同的数据再按照列名2排序。</p><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>聚集函数一般用作统计，包括：</p><ul><li><code>count([distinct]*)</code>统计所有的行数（distinct表示去重再统计，下同）</li><li><code>count([distinct]列名)</code>统计某列的值总和</li><li><code>sum([distinct]列名)</code>求一列的和（注意必须是数字类型的）</li><li><code>avg([distinct]列名)</code>求一列的平均值（注意必须是数字类型）</li><li><code>max([distinct]列名)</code>求一列的最大值</li><li><code>min([distinct]列名)</code>求一列的最小值</li></ul><p>一般聚集函数是这样使用的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> 列名) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 </span><br></pre></td></tr></table></figure><p>当你使用 <code>COUNT(*)</code> 时，它会计算表中的所有行，无论列值是否为NULL。这包括了所有的记录，无论它们的列值是否为空。<br>换句话说，<code>COUNT(*)</code> 会返回表中的总行数，而不仅仅是那些至少有一列非NULL值的行数<br>如果你想要计算至少有一列非NULL值的行数，你需要指定那一列，像这样：<code>COUNT(列名)</code>。这样，只有当指定列的值非NULL时，那一行才会被计数。</p><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p>通过使用<code>group by</code>来对查询结果进行分组，它需要结合聚合函数一起使用， 聚合函数会对组中的数据进行计算统计：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">sum</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 列名</span><br></pre></td></tr></table></figure><p>我们还可以添加<code>having</code>来限制分组条件：<br><code>HAVING</code>子句主要是用来对聚合函数（如<code>COUNT</code>, <code>SUM</code>, <code>AVG</code>, <code>MAX</code>, <code>MIN</code>等）的结果进行过滤或条件判断。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">sum</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 列名 <span class="keyword">HAVING</span> 约束条件</span><br></pre></td></tr></table></figure><p><strong>分组的依据：在分组查询中，具有相同值的数据会被分到同一组中</strong></p><p><code>group by</code>就是把<strong>一列</strong>通过<strong>某个条件</strong>分成不同的部分进行<strong>聚合函数</strong>计算</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>我们可以逐页获取数据，而不是一次性获取全部数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 LIMIT 起始位置,数量</span><br></pre></td></tr></table></figure><hr><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询"></a>多表查询</h3><p>多表查询是同时查询的两个或两个以上的表，多表查询会提通过连接转换为单表查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span>, 表<span class="number">2</span></span><br></pre></td></tr></table></figure><p>直接这样查询会得到两张表的笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span>, 表<span class="number">2</span> <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure><p>这样，只会从笛卡尔积的结果中得到满足条件的数据。<br><strong>注意： 如果两个表中都带有此属性，需要添加表名前缀来指明是哪一个表的数据。</strong></p><p>以下是一个示例，假设您有两个表： <code>employee</code> 和 <code>departments</code> ，它们都具有一个名为”name”的属性。您想要查询每个员工所属的部门名称以及员工的姓名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.name <span class="keyword">AS</span> employee_name, departments.name <span class="keyword">AS</span> department_name</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们使用AS关键字为每个属性指定别名。<code>employees.name``被重命名为employee_name</code>，<code>departments.name</code>被重命名为<code>department_name</code>。这样，我们可以明确地引用每个属性，并避免冲突。</p><h3 id="自身连接查询"><a href="#自身连接查询" class="headerlink" title="自身连接查询"></a>自身连接查询</h3><p>自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 别名<span class="number">1</span>, 表名 别名<span class="number">2</span></span><br></pre></td></tr></table></figure><p>其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。</p><p>以下是别名的其他应用场景：</p><ol><li>列别名：可以为查询结果中的列指定一个更具描述性的名称。<br> 示例：<code>SELECT 列名 AS 别名 FROM 表名;</code><br> 例如，可以使用别名将”salary”列的名称更改为”工资”：<br> <code>SELECT salary AS 工资 FROM employees;</code></li><li>表别名：可以为查询中的表指定一个简短的别名，以减少重复输入。<br> 示例：<code>SELECT 列名 FROM 表名 AS 别名;</code><br> 例如，可以使用别名将”employees”表的名称更改为”e”：</li></ol><h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><p>外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 左表名 <span class="operator">&lt;</span>连接方式<span class="operator">&gt;</span> 右表名 <span class="keyword">ON</span> 连接条件;</span><br></pre></td></tr></table></figure><ul><li>通过使用<code>inner join</code>进行内连接，只会返回两个表满足条件的交集部分：</li><li>通过使用<code>left join</code>进行左连接，不仅会返回两个表满足条件的交集部分，也会返回左边表中的全部数据，而在右表中缺失的数据会使用<code>null</code>来代替（右连接<code>right join</code>同理，只是反过来而已，这里就不再介绍了）</li><li>我们还可以将三张表（甚至更多外连接到一起）</li></ul><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>我们可以将查询的结果作为另一个查询的条件，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名<span class="number">1</span> <span class="operator">=</span> (<span class="keyword">SELECT</span> 列名<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件)</span><br></pre></td></tr></table></figure><p>也就是 查询到了 列1 和 列2 相等部分的 重合的数据</p><p><strong>使用嵌套查询进行子查询</strong>：<br>假设您有一个名为”orders”的表，其中包含订单信息，包括订单号（order_id）和订单金额（amount）。您想要查询所有订单金额大于平均订单金额的订单。您可以使用嵌套查询来实现这个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id, amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(amount) <span class="keyword">FROM</span> orders);</span><br></pre></td></tr></table></figure><p>在上述示例中，内部查询<code>(SELECT AVG(amount) FROM orders)</code>计算了订单金额的平均值，并将其用于外部查询的筛选条件。</p><p><strong>使用嵌套查询进行连接查询</strong>：<br>假设您有两个表：”customers”和”orders”，其中”customers”表包含客户信息，”orders”表包含订单信息。您想要查询每个客户的订单数量。您可以使用嵌套查询和连接查询来实现这个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.customer_id, c.customer_name, (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> customer_id <span class="operator">=</span> c.customer_id) <span class="keyword">AS</span> order_count</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c;</span><br></pre></td></tr></table></figure><p>在上述示例中，内部查询<code>(SELECT COUNT(*) FROM orders WHERE customer_id = c.customer_id)</code>计算了每个客户的订单数量，并将其作为外部查询的一个列。</p><hr><h1 id="数据库控制语言（DCL）"><a href="#数据库控制语言（DCL）" class="headerlink" title="数据库控制语言（DCL）"></a>数据库控制语言（DCL）</h1><h2 id="创建用户："><a href="#创建用户：" class="headerlink" title="创建用户："></a>创建用户：</h2><p>在MySQL中，你可以使用以下语法来创建一个用户并为其设置密码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;username&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这个命令将创建一个名为 ‘username’ 的用户，并将其密码设置为 ‘password’。</p><p>如果你希望用户能够从任何主机连接到MySQL服务器，可以将 <code>&#39;localhost&#39;</code> 替换为 <code>&#39;%&#39;</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure><p>我们也可以在创建时不设置密码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> 用户名;</span><br></pre></td></tr></table></figure><h2 id="登陆用户"><a href="#登陆用户" class="headerlink" title="登陆用户"></a>登陆用户</h2><p>首先需要添加一个环境变量，然后我们通过cmd去登陆mysql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">login <span class="operator">-</span>u 用户名 <span class="operator">-</span>p</span><br></pre></td></tr></table></figure><p>输入密码后即可登陆此用户</p><h2 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h2><p>我们可以通过使用<code>grant</code>来为一个数据库用户进行授权：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">all</span> [权限<span class="number">1</span>,权限<span class="number">2.</span>..(列<span class="number">1</span>,...)] <span class="keyword">on</span> 数据库.表 <span class="keyword">to</span> 用户 [<span class="keyword">with</span> <span class="keyword">grant</span> option]</span><br></pre></td></tr></table></figure><p>其中all代表授予所有权限，当数据库和表为<code>*</code>，代表为所有的数据库和表都授权。如果在最后添加了<code>with grant option</code>，那么被授权的用户还能将已获得的授权继续授权给其他用户。</p><p>授予权限的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privileges <span class="keyword">ON</span> database.table <span class="keyword">TO</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;host&#x27;</span>;</span><br></pre></td></tr></table></figure><p>其中，’privileges’是你要授予的权限，可以是单个权限或多个权限的组合，用逗号分隔。’database.table’指定了你要授予权限的数据库和表。‘username‘@’host’指定了你要授予权限的用户和主机。</p><p>例如，如果要将SELECT和INSERT权限授予用户’john’，并且限制他只能在数据库’exampledb’中的表’table1’上执行这些操作，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> exampledb.table1 <span class="keyword">TO</span> <span class="string">&#x27;john&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li>ALL PRIVILEGES：授予用户对指定数据库或表的所有权限，包括 <code>SELECT</code> 、 <code>INSERT</code> 、 <code>UPDATE</code> 、 <code>DELETE</code> 、 <code>CREATE</code> 、 <code>DROP</code> 等。</li><li><code>SELECT</code>：授予用户对指定表的SELECT权限，允许其查询表中的数据。</li><li><code>INSERT</code>：授予用户对指定表的INSERT权限，允许其向表中插入新的数据。</li><li><code>UPDATE</code>：授予用户对指定表的UPDATE权限，允许其修改表中已有的数据。</li><li><code>DELETE</code>：授予用户对指定表的DELETE权限，允许其删除表中的数据。</li><li><code>CREATE</code>：授予用户创建新表、数据库或索引的权限。</li><li><code>DROP</code>：授予用户删除表、数据库或索引的权限。</li><li><code>ALTER</code>：授予用户修改表结构的权限，包括添加、修改和删除表的列。</li><li><code>GRANT OPTION</code>：授予用户将自己拥有的权限授予其他用户的权限。</li></ol><p>我们可以使用<code>revoke</code>来收回一个权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">all</span> [权限<span class="number">1</span>,权限<span class="number">2.</span>..(列<span class="number">1</span>,...)] <span class="keyword">on</span> 数据库.表 <span class="keyword">from</span> 用户</span><br></pre></td></tr></table></figure><hr><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><h3 id="创建单列索引"><a href="#创建单列索引" class="headerlink" title="创建单列索引"></a>创建单列索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (column_name);</span><br></pre></td></tr></table></figure><h3 id="创建多列索引"><a href="#创建多列索引" class="headerlink" title="创建多列索引"></a>创建多列索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (column1, column2, ...);</span><br></pre></td></tr></table></figure><h3 id="创建唯一索引"><a href="#创建唯一索引" class="headerlink" title="创建唯一索引"></a>创建唯一索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name <span class="keyword">ON</span> table_name (column_name);</span><br></pre></td></tr></table></figure><h3 id="创建全文索引"><a href="#创建全文索引" class="headerlink" title="创建全文索引"></a>创建全文索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX index_name <span class="keyword">ON</span> table_name (column_name);</span><br></pre></td></tr></table></figure><h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h2><h3 id="查看表的索引"><a href="#查看表的索引" class="headerlink" title="查看表的索引"></a>查看表的索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="查看索引的定义"><a href="#查看索引的定义" class="headerlink" title="查看索引的定义"></a>查看索引的定义</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE TABLE</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><h4 id="删除表的索引"><a href="#删除表的索引" class="headerlink" title="删除表的索引"></a>删除表的索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure><h4 id="删除表的所有索引"><a href="#删除表的所有索引" class="headerlink" title="删除表的所有索引"></a>删除表的所有索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> table_name <span class="keyword">DROP</span> INDEX <span class="keyword">ALL</span>;</span><br></pre></td></tr></table></figure><p>请注意，创建索引可以提高查询效率，但也会增加插入、更新和删除操作的开销。因此，在创建索引时需要权衡查询性能和修改性能之间的平衡。</p><p><strong>无论是否使用索引，最终都能查询到相应的内容</strong>。索引只是一种优化技术，<strong>它可以加快查询的速度，但并不影响查询结果的准确性</strong>。</p><p>在没有索引的情况下，数据库会对整个表进行全表扫描，逐行比对查询条件，最终找到符合条件的数据。这种方式可以保证查询结果的准确性，但在大型表或者有大量数据的情况下，查询可能会较慢。</p><p>而使用索引后，数据库可以利用索引的数据结构，直接定位到符合查询条件的数据行，避免了全表扫描的开销，从而提高了查询的速度。索引可以加快查询的效率，但不会改变查询结果。</p><p><strong>需要注意的是</strong>，索引的创建和维护也会带来一定的开销，特别是在频繁进行插入、更新和删除操作的情况下。因此，在设计数据库时，需要根据具体的查询需求和数据特点，选择合适的列创建索引，以获得最佳的查询性能。</p><hr><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图本质就是一个查询的结果，不过我们每次都可以通过打开视图来按照我们想要的样子查看数据。既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。</p><h2 id="如何创建视图"><a href="#如何创建视图" class="headerlink" title="如何创建视图"></a>如何创建视图</h2><p>我们可以通过<code>create view</code>来创建视图;</p><p><strong>我们可以把 创建出的视图 理解为是对原表部分列的引用 因此当我们对某个可修改的视图进行修改时 原表对应的部分也会被修改</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称(列名) <span class="keyword">as</span> 子查询语句 [<span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION];</span><br></pre></td></tr></table></figure><p>（<code>WITH CHECK OPTION</code>是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用<code>select</code>语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。）</p><h2 id="视图需要遵守的规则"><a href="#视图需要遵守的规则" class="headerlink" title="视图需要遵守的规则"></a>视图需要遵守的规则</h2><ul><li><p>若视图是<strong>由两个以上基本表导出的</strong>，则此视图<strong>不允许更新</strong>。</p></li><li><p>若视图的字段<strong>来自字段表达式或常数</strong>，则<strong>不允许</strong>对此视图执行INSERT和UPDATE操作，<strong>但允许</strong>执行DELETE操作。</p></li><li><p>若视图的字段来自<strong>集函数</strong>，则此视图<strong>不允许更新</strong>。</p></li><li><p>若视图定义中含有<strong>GROUP BY子句</strong>，则此视图<strong>不允许更新</strong>。</p></li><li><p>若视图定义中含有<strong>DISTINCT短语</strong>，则此视图<strong>不允许更新</strong>。</p></li><li><p>若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC：<br>  <code>CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade &gt; (SELECT AVG(Grade) FROM SC);</code> 　　<br>  导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。</p></li><li><p>一个不允许更新的视图上定义的视图也不允许更新</p></li></ul><h3 id="如何删除一个视图："><a href="#如何删除一个视图：" class="headerlink" title="如何删除一个视图："></a>如何删除一个视图：</h3><p>通过<code>drop</code>来删除一个视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> apptest</span><br></pre></td></tr></table></figure><hr><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的SQL语句来完成，这些数据库操作语句就可以构成一个事务！只有Innodb引擎支持事务</p><p>我们通过以下例子来探究以下事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;   #开始事务</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span>;  #回滚事务</span><br><span class="line"><span class="keyword">savepoint</span> 回滚点;  #添加回滚点</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> 回滚点; #回滚到指定回滚点</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>; #提交事务</span><br><span class="line"><span class="comment">-- 一旦提交，就无法再进行回滚了！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>如果事务中的所有操作都执行成功，可以使用<code>COMMIT</code>提交事务，将结果永久保存到数据库中。</li><li>如果事务中的任何操作失败或出现错误，可以使用<code>ROLLBACK</code>回滚事务，将所有操作都撤销到事务开始之前的状态。</li></ul><hr><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器就像其名字一样，在某种条件下会自动触发，在<code>select</code>&#x2F;<code>update</code>&#x2F;<code>delete</code>时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。</p><ul><li><code>insert</code>操作时，新的内容会被插入到new表中；</li><li>在<code>delete</code>操作时，旧的内容会被移到old表中，我们仍可在old表中拿到被删除的数据；</li><li>在<code>update</code>操作时，旧的内容会被移到old表中，新的内容会出现在new表中。</li></ul><h2 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">&#123;BEFORE <span class="operator">|</span> AFTER&#125; &#123;<span class="keyword">INSERT</span> <span class="operator">|</span> <span class="keyword">UPDATE</span> <span class="operator">|</span> <span class="keyword">DELETE</span>&#125; <span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">   </span><br><span class="line"># 触发器的操作逻辑</span><br><span class="line">   </span><br></pre></td></tr></table></figure><h2 id="修改触发器"><a href="#修改触发器" class="headerlink" title="修改触发器"></a>修改触发器</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">&#123;BEFORE <span class="operator">|</span> AFTER&#125; &#123;<span class="keyword">INSERT</span> <span class="operator">|</span> <span class="keyword">UPDATE</span> <span class="operator">|</span> <span class="keyword">DELETE</span>&#125; <span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">   </span><br><span class="line"># 修改后的触发器的操作逻辑</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>触发器的操作逻辑：是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</p><h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [IF <span class="keyword">EXISTS</span>] trigger_name;</span><br></pre></td></tr></table></figure><h2 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS</span><br></pre></td></tr></table></figure><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语法简记</title>
      <link href="/posts/a57fb7e2.html"/>
      <url>/posts/a57fb7e2.html</url>
      
        <content type="html"><![CDATA[<p><strong>笔记较为简单，主要记录了一些Java与C#某些地方的相似与区别，适合简单浏览速通，不细致不深入。</strong></p><p><img src="https://image.flashfish777.cn/img/post_23_1.jpg"></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// final定义常量</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在Java中，整数类型包括以下几个：</p><table><thead><tr><th>类型</th><th>大小</th><th>范围</th></tr></thead><tbody><tr><td>byte 字节型</td><td>8个bit，也就是1个字节</td><td>-128~+127</td></tr><tr><td>short 短整形</td><td>16个bit，也就是2个字节</td><td>-32768~+32767</td></tr><tr><td>int 整形</td><td>32个bit，也就是4个字节</td><td>-2147483648 ~ +2147483647</td></tr><tr><td>long 长整形（+L&#x2F;l）</td><td>64个bit，也就是8个字节</td><td>9223372036854775808 ~ +9223372036854775807</td></tr><tr><td>float 单精度浮点型（+F&#x2F;f）</td><td>32个bit，也就是4个字节</td><td></td></tr><tr><td>double 双精度浮点型</td><td>64个bit，也就是8个字节</td><td></td></tr><tr><td>char 字符型</td><td>16个bit，也就是2字节，它不带符号</td><td>0 ~ 65535</td></tr><tr><td>boolen 布尔类型</td><td></td><td>true，false</td></tr></tbody></table><h2 id="隐式类型转换：小转大，大不转小"><a href="#隐式类型转换：小转大，大不转小" class="headerlink" title="隐式类型转换：小转大，大不转小"></a>隐式类型转换：小转大，大不转小</h2><h2 id="强转与C一样：（数据类型）变量"><a href="#强转与C一样：（数据类型）变量" class="headerlink" title="强转与C一样：（数据类型）变量"></a>强转与C一样：（数据类型）变量</h2><h2 id="字符串支持“-”拼接"><a href="#字符串支持“-”拼接" class="headerlink" title="字符串支持“+”拼接"></a>字符串支持“+”拼接</h2><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>相同名称的方法可以定义多次，传入不同类型的参数和返回类型，在使用时会自动匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sum</span><span class="params">(String a, String b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XX.sum(<span class="number">1.5</span>, <span class="number">2.2</span>); <span class="comment">// 使用时会自动匹配方法</span></span><br><span class="line">XX.sum(<span class="number">6</span>, <span class="number">9</span>);</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    Person()&#123;    <span class="comment">//构造方法不需要指定返回值，并且方法名称与类名相同</span></span><br><span class="line">        name = <span class="string">&quot;小明&quot;</span>;   <span class="comment">//构造方法会在对象创建时执行，我们可以将各种需要初始化的操作都在这里进行处理</span></span><br><span class="line">        age = <span class="number">18</span>;</span><br><span class="line">        sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不写构造方法就会有一个默认的什么也没有的构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法可以重构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="type">int</span> age, String sex)&#123;   <span class="comment">//跟普通方法是一样的</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Person()&#123;</span><br><span class="line">        name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法会在new的时候自动执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();   <span class="comment">//这里的new Person()其实就是在调用无参构造方法</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小红&quot;</span>, <span class="number">15</span>, <span class="string">&quot;女&quot;</span>); <span class="comment">// 这里使用有参的构造方法</span></span><br><span class="line">    System.out.println(p.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h2><p>一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。在静态方法中，无法获取成员变量的值，但是静态方法可以访问到静态变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line">    <span class="keyword">static</span> String info;    <span class="comment">//这里我们定义一个info静态变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包-namespace"><a href="#包-namespace" class="headerlink" title="包 &#x3D; namespace"></a>包 &#x3D; namespace</h2><p>packa，import</p><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><table><thead><tr><th></th><th>当前类</th><th>同一个包下的类</th><th>不同包下的子类</th><th>不同包下的类</th></tr></thead><tbody><tr><td>public</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>protected</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>默认</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>private</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table><h2 id="继承：extends"><a href="#继承：extends" class="headerlink" title="继承：extends"></a>继承：extends</h2><p>（如果父类没有使用默认构造函数，子类需要调用super父类构造方法（super代表这个子类的父类））</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;    <span class="comment">//因为学生职业已经确定，所以说学生直接填写就可以了</span></span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;学生&quot;</span>);   <span class="comment">//使用super代表父类，父类的构造方法就是super()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的名字是 &quot;</span>+name+<span class="string">&quot;，我在学习！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断一个对象是什么类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(person <span class="keyword">instanceof</span> Student) &#123;   <span class="comment">//我们可以使用instanceof关键字来对类型进行判断</span></span><br><span class="line">        System.out.println(<span class="string">&quot;对象是 Student 类型的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(person <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象是 Person 类型的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>注意，方法的重写不同于之前的方法重载，不要搞混了，方法的重载是为某个方法提供更多种类，而方法的重写是覆盖原有的方法实现，比如我们现在不希望使用Object类中提供的equals方法，那么我们就可以将其重写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//重写方法可以添加 @Override 注解，有关注解我们会在最后一章进行介绍，这个注解默认情况下可以省略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;   <span class="comment">//重写方法要求与父类的定义完全一致</span></span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//如果传入的对象为null，那肯定不相等</span></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person) &#123;     <span class="comment">//只有是当前类型的对象，才能进行比较，要是都不是这个类型还比什么</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) obj;   <span class="comment">//先转换为当前类型，接着我们对三个属性挨个进行比较</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(person.name) &amp;&amp;    <span class="comment">//字符串内容的比较，不能使用==，必须使用equals方法</span></span><br><span class="line">                    <span class="built_in">this</span>.age == person.age &amp;&amp;       <span class="comment">//基本类型的比较跟之前一样，直接==</span></span><br><span class="line">                    <span class="built_in">this</span>.sex.equals(person.sex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;   <span class="comment">//通过添加abstract关键字，表示这个类是一个抽象类</span></span><br><span class="line">    <span class="keyword">protected</span> String name;   <span class="comment">//大体内容其实普通类差不多</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">protected</span> String sex;</span><br><span class="line">    <span class="keyword">protected</span> String profession;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, String sex, String profession)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.profession = profession;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span>;   <span class="comment">//抽象类中可以具有抽象方法，也就是说这个方法只有定义，没有方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类的子类必须要实现抽象类中所有抽象方法，除非抽象类的子类也是抽象类。</p><p>抽象类无法直接实例化。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>interface定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Study</span> &#123;    <span class="comment">//使用interface表示这是一个接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>;    <span class="comment">//接口中只能定义访问权限为public抽象方法，其中public和abstract关键字可以省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>implements实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Study</span> &#123;   <span class="comment">//使用implements关键字来实现接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;学生&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;    <span class="comment">//实现接口时，同样需要将接口中所有的抽象方法全部实现</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我会学习！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口可以多继承</strong></p><p><strong>接口可以设置默认实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;   <span class="comment">//使用default关键字为接口中的方法添加默认实现</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我是默认实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口可以继承自其他接口</strong></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举类也可以添加成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    RUNNING(<span class="string">&quot;睡觉&quot;</span>), STUDY(<span class="string">&quot;学习&quot;</span>), SLEEP(<span class="string">&quot;睡觉&quot;</span>);   <span class="comment">//无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;    <span class="comment">//枚举的成员变量</span></span><br><span class="line">    Status(String name)&#123;    <span class="comment">//覆盖原有构造方法（默认private，只能内部使用！）</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;   <span class="comment">//获取封装的成员变量</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包装类与特殊包装类"><a href="#包装类与特殊包装类" class="headerlink" title="包装类与特殊包装类"></a>包装类与特殊包装类</h2><p><code>BigInteger</code> ， 超大整数类型，没有限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> BigInteger.valueOf(Long.MAX_VALUE);    <span class="comment">//表示Long的最大值，轻轻松松</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BigDecimal</code> ， 更高精度浮点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">i</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">10</span>);</span><br><span class="line">    i = i.divide(BigDecimal.valueOf(<span class="number">3</span>), <span class="number">100</span>, RoundingMode.CEILING);</span><br><span class="line">      <span class="comment">//计算10/3的结果，精确到小数点后100位</span></span><br><span class="line">      <span class="comment">//RoundingMode是舍入模式，就是精确到最后一位时，该怎么处理，这里CEILING表示向上取整</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h2><p>定义函数参数时加三个‘.’</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String... strings)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用时可以传任意数量的实参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    person.test(<span class="string">&quot;1！&quot;</span>, <span class="string">&quot;5！&quot;</span>, <span class="string">&quot;哥们在这跟你说唱&quot;</span>); <span class="comment">//这里我们可以自由传入任意数量的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时strings为数组</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>如果我们仅仅是想要判断两个字符串的内容是否相同，不要使用<code>==</code>，String类重载了equals方法用于判断和比较内容是否相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    System.out.println(str1.equals(str2));   <span class="comment">//字符串的内容比较，一定要用equals</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>这个类型是专门用于构造字符串的，我们可以使用它来对字符串进行拼接、裁剪等操作，它就像一个字符串编辑器，弥补了字符串不能修改的不足：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();   <span class="comment">//一开始创建时，内部什么都没有</span></span><br><span class="line">    builder.append(<span class="string">&quot;AAA&quot;</span>);   <span class="comment">//我们可以使用append方法来讲字符串拼接到后面</span></span><br><span class="line">    builder.append(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">    System.out.println(builder.toString());   <span class="comment">//当我们字符串编辑完成之后，就可以使用toString转换为字符串了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuilder类的编辑操作也非常多，这里就不一一列出了。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span>&lt;T&gt; &#123;   <span class="comment">//泛型类需要使用&lt;&gt;，我们需要在里面添加1 - N个类型变量</span></span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    T value;   <span class="comment">//T会根据使用时提供的类型自动变成对应类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, T value)</span> &#123;   </span><br><span class="line">    <span class="comment">//这里T可以是任何类型，但是一旦确定，那么就不能修改了</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要让某个变量支持引用确定了任意类型的泛型，那么可以使用 <code>?</code> 通配符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Test&lt;?&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;Integer&gt;();</span><br><span class="line">    test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;String&gt;();</span><br><span class="line">      <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> test.value;    </span><br><span class="line">      <span class="comment">//但是注意，如果使用通配符，那么由于类型不确定，所以说具体类型同样会变成Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型只能确定为一个引用类型，基本类型是不支持的</strong></p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> test(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">test</span><span class="params">(T t)</span>&#123;   <span class="comment">//在返回值类型前添加&lt;&gt;并填写泛型变量表示这个是一个泛型方法</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;   <span class="comment">//设定类型参数上界，必须是Number或是Number的子类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>缓冲字节流：</p><ul><li><code>BufferedInputStream</code>:<br>要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)))&#123;   <span class="comment">//传入FileInputStream</span></span><br><span class="line">        System.out.println((<span class="type">char</span>) bufferedInputStream.read());   </span><br><span class="line">        <span class="comment">//操作和原来的流是一样的</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BufferedInputStream</code><strong>操作和原来的<code>FileInputStream</code>流是一样的</strong></p><ul><li><code>BufferedOutputStream</code>:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)))&#123;</span><br><span class="line">        outputStream.write(<span class="string">&quot;lbwnb&quot;</span>.getBytes());</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程的实现方式：</p><h3 id="继承Thread类："><a href="#继承Thread类：" class="headerlink" title="继承Thread类："></a>继承Thread类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t03</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;线程03&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//开启线程</span></span><br><span class="line">        t01.run();</span><br><span class="line">        t02.run();</span><br><span class="line">        t03.run();</span><br><span class="line">        <span class="comment">// 不会启动线程，不会分配新的分支栈。（这种方式就是单线程。）</span></span><br><span class="line">        <span class="comment">// start()方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码任务完成之后，瞬间就结束了。</span></span><br><span class="line">        <span class="comment">// 这段代码的任务只是为了开启一个新的栈空间，只要新的栈空间开出来，start()方法就结束了。线程就启动成功了。</span></span><br><span class="line">        <span class="comment">// 启动成功的线程会自动调用run方法，并且run方法在分支栈的栈底部（压栈）。</span></span><br><span class="line">        <span class="comment">// run方法在分支栈的栈底部，main方法在主栈的栈底部。run和main是平级的。</span></span><br><span class="line">        t01.start();</span><br><span class="line">        t02.start();</span><br><span class="line">        t03.start();</span><br><span class="line">        <span class="comment">//设置线程名（补救的设置线程名的方式）</span></span><br><span class="line">        t01.setName(<span class="string">&quot;线程01&quot;</span>);</span><br><span class="line">        t02.setName(<span class="string">&quot;线程02&quot;</span>);</span><br><span class="line">        <span class="comment">//设置主线程名称</span></span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Thread.currentThread() 获取当前正在执行线程的对象</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//run方法是每个线程运行过程中都必须执行的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Runnable接口："><a href="#实现Runnable接口：" class="headerlink" title="实现Runnable接口："></a>实现Runnable接口：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">myRun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();<span class="comment">//将一个任务提取出来，让多个线程共同去执行</span></span><br><span class="line">        <span class="comment">//封装线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRun, <span class="string">&quot;线程01&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRun, <span class="string">&quot;线程02&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t03</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRun, <span class="string">&quot;线程03&quot;</span>);</span><br><span class="line">        <span class="comment">//开启线程</span></span><br><span class="line">        t01.start();</span><br><span class="line">        t02.start();</span><br><span class="line">        t03.start();</span><br><span class="line">        <span class="comment">//通过匿名内部类的方式创建线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="comment">//可以使用lambda表达式简化</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;线程04&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义线程类，实现Runnable接口</span></span><br><span class="line"><span class="comment">//这并不是一个线程类，是一个可运行的类，它还不是一个线程。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="线程锁和线程同步"><a href="#线程锁和线程同步" class="headerlink" title="线程锁和线程同步"></a>线程锁和线程同步</h3><p>synchronized关键字也可以作用于方法上，调用此方法时也会获取锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) add();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) add();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);  <span class="comment">//主线程停止1秒，保证两个线程执行完成</span></span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解-特性"><a href="#注解-特性" class="headerlink" title="注解 &#x3D; 特性"></a>注解 &#x3D; 特性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span> <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123; </span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java大作业-车辆租赁系统</title>
      <link href="/posts/b15d19f.html"/>
      <url>/posts/b15d19f.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 非游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> OOP </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode插件推荐2</title>
      <link href="/posts/20a54dfa.html"/>
      <url>/posts/20a54dfa.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>众所可能不周知，经过了很长时间的磨合，我已经变成了<mark class="hl-label blue">VSCode</mark>的形状。<br>这玩意儿用起来实在是太爽，<strong>轻量级</strong>、<strong>速度快</strong>，<strong>插件多到爆炸</strong>，想干什么都能找到对应的工具。而且界面还特别清爽，<strong>主题随便换</strong>，实在不满意甚至能DIY，想怎么折腾就怎么折腾，完全符合我的审美。<br>拿我自己来说，作为一名计算机专业的大学牲，我有无数的专业课需要实操，<code>Cpp</code>、<code>Java</code>、<code>Python</code>、<code>Web前端</code>、<code>数据库</code>、<code>计网</code>，除此之外，我自己还在学习<code>C#</code>。虽然对我来说都不难，但多的让人头大。<br>很多人学<code>Cpp</code>时下载<code>DevC++</code>、<code>Clion</code>，学<code>Java</code>时下载<code>IDEA</code>，学<code>Python</code>时又下<code>PyCharm</code>，学数据库时又下<code>SqlServer</code>、下<code>navicat</code>，学前端时又下<code>WebStorm</code>，想写<code>C#</code>还要下<code>Visual Studio</code>。先不说运行时的效率，就光这些“大块头”就要把存储空间占满了，动辄十几几十个G，没一个省油的灯，况且对于我们学习学校的课程来说，完全用不到这么专业的IDE。<br>我从大学刚刚开始就接触了VSCode，之后也一直在用（中途用过一次VS2022，每次打开都要把我的内存占满，最后直接卸载了）。学习C语言和算法时我安装C&#x2F;Cpp的插件，学Java时我安装Java语言的插件，学数据库时我安装数据库插件用VSCode连接数据库，学习使用git时我用VSCode的终端就能打开bash，还能通过插件连接github储存库进行一键式的版本管理，什么东西都是即安即用，最多配个环境。<br>有同学要问了老师老师你安这么多插件VSCode不也会超负荷的吗？当然不会。VSCode独特的配置文件可以将不同配置文件中的插件与设置隔离起来，哪个文件夹用哪个配置文件，就会加载对应的插件，完全不用担心插件太多太杂。</p><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1em421j7wZ&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><p><img src="https://image.flashfish777.cn/img/post_21_1.jpg" alt="配置文件"></p><p>总之，真的十分推荐VSCode！这次将再次推荐一些好用的插件 -&gt;&gt;&gt;</p><hr><h1 id="功能篇"><a href="#功能篇" class="headerlink" title="功能篇"></a>功能篇</h1><h2 id="any-rule"><a href="#any-rule" class="headerlink" title="any-rule"></a>any-rule</h2><p>你要的“正则”都在这！</p><p><img src="https://image.flashfish777.cn/img/post_21_2.jpg" alt="any-rule"></p><p><strong>Any-rule</strong> 是一款正则表达式插件，旨在帮助开发者快速生成和使用正则表达式。它内置了大量常用的正则表达式模板，覆盖了多种常见场景，如匹配邮箱、URL、手机号等。</p><p><strong>主要功能</strong></p><ol><li><strong>常用正则表达式模板</strong>：<ul><li>提供丰富的正则表达式模板，涵盖邮箱、URL、IP地址、手机号、身份证号等常见需求。</li></ul></li><li><strong>快速生成正则表达式</strong>：<ul><li>通过快捷键或命令面板，快速生成所需的正则表达式。</li></ul></li><li><strong>自定义正则表达式</strong>：<ul><li>支持自定义正则表达式模板，满足个性化需求。</li></ul></li><li><strong>实时测试</strong>：<ul><li>提供实时测试功能，可在编辑器中直接测试正则表达式的匹配效果。</li></ul></li></ol><p><strong>使用方法</strong></p><ol><li><strong>通过命令面板</strong>：<ul><li>打开命令面板（快捷键 <code>Ctrl+Shift+P</code>）。    </li><li>输入 “Any-rule” 并选择相应模板。</li></ul></li><li><strong>通过快捷键</strong>：<ul><li>使用快捷键 <code>Ctrl+Alt+R</code> 打开 Any-rule 菜单，选择所需正则表达式。</li></ul></li><li><strong>自定义模板</strong>：<ul><li>在设置中配置自定义正则表达式模板。</li></ul></li></ol><p>Any-rule 插件简化了正则表达式的生成和使用，适合需要频繁处理正则表达式的开发者。通过内置模板和自定义功能，能显著提升开发效率。</p><h2 id="var-translate-en"><a href="#var-translate-en" class="headerlink" title="var-translate-en"></a>var-translate-en</h2><p>中文一键翻译为英文并转换成驼峰命名,提效神器🚀</p><p><img src="https://image.flashfish777.cn/img/post_21_3.jpg" alt="var-translate-en"></p><p><strong>Var-Translate-EN</strong> 是一款变量命名辅助工具 + 翻译工具，主要用于将中文变量名翻译为英文，且支持中英互译，帮助开发者编写更规范的代码并解决不认识的生词。它特别适合在需要中英互相转换的场景中使用，比如处理英文注释或中文命名的遗留代码。</p><p><strong>主要功能</strong></p><ol><li><strong>中文变量名翻译</strong>：<ul><li>将中文变量名自动翻译为英文，支持驼峰命名、下划线命名等多种格式。</li></ul></li><li><strong>多种命名风格</strong>：<ul><li>支持多种命名风格，如驼峰式（camelCase）、下划线式（snake_case）、常量式（UPPER_CASE）等。</li></ul></li><li><strong>批量翻译</strong>：<ul><li>支持批量翻译选中的多个变量名，提升效率。</li></ul></li><li><strong>自定义词典</strong>：<ul><li>允许用户添加自定义翻译词典，满足特定领域或项目的需求。</li></ul></li><li><strong>实时预览</strong>：<ul><li>在翻译时提供实时预览功能，方便开发者确认翻译结果。</li></ul></li></ol><p><strong>使用方法</strong></p><ol><li><strong>选中变量名</strong>：<ul><li>在代码中选中需要翻译的中文变量名。</li></ul></li><li><strong>调用插件</strong>：<ul><li>右键点击选中的变量名，选择 <strong>Var-Translate-EN</strong> 选项。</li><li>或者使用快捷键（默认快捷键为 <code>Ctrl+Alt+T</code>）。</li></ul></li><li><strong>选择命名风格</strong>：<ul><li>在弹出的选项中选择所需的命名风格（如驼峰式、下划线式等）。</li></ul></li><li><strong>确认翻译</strong>：<ul><li>插件会自动将中文变量名翻译为英文，并替换到代码中。</li></ul></li></ol><p><strong>自定义词典</strong></p><ol><li>打开 VSCode 设置（<code>Ctrl+,</code>）。</li><li>搜索 “Var-Translate-EN”。</li><li>在配置中添加自定义词典，例如：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;var-translate-en.customDictionary&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;用户名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;accountName&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;订单编号&quot;</span><span class="punctuation">:</span> <span class="string">&quot;orderId&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Todo-Tree"><a href="#Todo-Tree" class="headerlink" title="Todo Tree"></a>Todo Tree</h2><p>方便的查找与修改TODO、BUG、TEST等指令</p><p><img src="https://image.flashfish777.cn/img/post_21_4.jpg" alt="Todo Tree"></p><p><strong>Todo Tree</strong> 是一款任务管理插件，用于快速查找和整理代码中的注释标签（如 <code>TODO</code>、<code>FIXME</code> 等）。它能够将散落在代码中的任务注释集中展示在一个树形结构中，方便开发者管理和跟踪任务进度。</p><p><strong>主要功能</strong></p><ol><li><strong>注释标签高亮</strong>：<ul><li>自动高亮代码中的注释标签（如 <code>TODO</code>、<code>FIXME</code>、<code>NOTE</code> 等）。</li></ul></li><li><strong>任务树形结构</strong>：<ul><li>将代码中的所有任务注释以树形结构展示在侧边栏中，方便查看和管理。</li></ul></li><li><strong>快速跳转</strong>：<ul><li>点击树形结构中的任务，可以快速跳转到对应的代码位置。</li></ul></li><li><strong>自定义标签</strong>：<ul><li>支持自定义注释标签，满足不同项目的需求。</li></ul></li><li><strong>过滤和搜索</strong>：<ul><li>支持按标签、文件路径等条件过滤任务，快速定位目标。</li></ul></li><li><strong>多工作区支持</strong>：<ul><li>支持同时管理多个工作区中的任务注释。</li></ul></li></ol><p><strong>使用方法</strong></p><ol><li><strong>查看任务树</strong>：<ul><li>安装插件后，左侧活动栏会显示一个树形图标，点击即可打开 Todo Tree 面板。</li></ul></li><li><strong>添加注释标签</strong>：<ul><li>在代码中添加注释标签，例如：</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// TODO: 优化性能</span><br><span class="line">// FIXME: 修复空指针异常</span><br><span class="line">// NOTE: 需要进一步测试</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>高亮显示</strong>：<ul><li>插件会自动高亮这些注释标签，并在 Todo Tree 面板中展示。</li></ul></li><li><strong>快速跳转</strong>：<ul><li>点击 Todo Tree 面板中的任务，可以直接跳转到对应的代码位置。</li></ul></li><li><strong>自定义标签</strong>：<ul><li>在设置中配置自定义标签，例如：</li></ul></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;todo-tree.general.tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;TODO&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;FIXME&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;NOTE&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;CUSTOM&quot;</span></span><br><span class="line"><span class="punctuation">]</span>   </span><br></pre></td></tr></table></figure><ol start="6"><li><strong>过滤任务</strong>：<ul><li>在 Todo Tree 面板的搜索框中输入关键字，可以按标签、文件路径等条件过滤任务。</li></ul></li></ol><p><strong>Todo Tree</strong> 是一款非常实用的任务管理插件，特别适合需要跟踪和管理代码中任务注释的开发者。它通过树形结构集中展示任务，支持自定义标签和高亮颜色，能够显著提升代码维护效率。如果你经常使用 <code>TODO</code>、<code>FIXME</code> 等注释标签，这款插件会是一个很好的助手。</p><h2 id="数据库天团："><a href="#数据库天团：" class="headerlink" title="数据库天团："></a>数据库天团：</h2><p><strong>vscode-database &amp; Prettier SQL VSCode &amp; MySQL</strong></p><p><img src="https://image.flashfish777.cn/img/post_21_5.jpg" alt="database"></p><p>当你看到别人用他们的IDEA、VS轻松地连接到数据库并随意操作也不用羡慕！VSCode也有独特的数据库插件：</p><h3 id="vscode-database"><a href="#vscode-database" class="headerlink" title="vscode-database"></a>vscode-database</h3><p><strong>vscode-database</strong> 是一款数据库管理插件，支持直接在 <code>VSCode</code> 中连接、查询和管理多种数据库（如 <code>MySQL</code>、<code>PostgreSQL</code>、<code>SQLite</code>、<code>Redis</code> 等）。它集成了数据库连接、SQL 查询、数据编辑、表结构管理等功能，适合开发者在编写代码的同时直接操作数据库。</p><p><strong>主要功能</strong></p><ol><li><strong>多数据库支持</strong>：<ul><li>支持多种常见数据库，包括 <code>MySQL</code>、<code>PostgreSQL</code>、<code>SQLite</code>、<code>Redis</code>、<code>MongoDB</code> 等。</li></ul></li><li><strong>数据库连接管理</strong>：<ul><li>提供直观的界面管理数据库连接，支持保存连接配置。</li></ul></li><li><strong>SQL 查询与执行</strong>：<ul><li>支持编写和执行 SQL 查询，并查看查询结果。</li></ul></li><li><strong>数据编辑</strong>：<ul><li>可以直接在插件中编辑数据库表中的数据。</li></ul></li><li><strong>表结构管理</strong>：<ul><li>支持查看和修改表结构（如添加、删除、修改字段）。</li></ul></li><li><strong>查询历史</strong>：<ul><li>自动保存 SQL 查询历史，方便快速复用。</li></ul></li><li><strong>数据导出</strong>：<ul><li>支持将查询结果导出为 CSV、JSON 等格式。</li></ul></li><li><strong>智能提示</strong>：<ul><li>提供 SQL 语法高亮和智能提示，提升编写效率。</li></ul></li></ol><h3 id="Prettier-SQL-VSCode"><a href="#Prettier-SQL-VSCode" class="headerlink" title="Prettier SQL VSCode"></a>Prettier SQL VSCode</h3><p><strong>Prettier SQL</strong> 是一款 SQL 语言格式化工具，基于 <a href="https://prettier.io/">Prettier</a> 生态开发。它专注于对 SQL 代码进行自动格式化，帮助开发者保持代码风格的一致性，提升代码的可读性和维护性。</p><p><strong>主要功能</strong></p><ol><li><strong>SQL 代码格式化</strong>：<ul><li>自动格式化 SQL 代码，支持常见的 SQL 语法（如 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等）。</li></ul></li><li><strong>支持多种 SQL 方言</strong>：<ul><li>支持多种 SQL 方言，包括 MySQL、PostgreSQL、SQL Server、SQLite 等。</li></ul></li><li><strong>与 Prettier 集成</strong>：<ul><li>作为 Prettier 的插件，可以与 Prettier 的其他功能（如 JavaScript、TypeScript 格式化）无缝集成。</li></ul></li><li><strong>配置文件支持</strong>：<ul><li>支持通过 <code>.prettierrc</code> 配置文件自定义格式化规则。</li></ul></li><li><strong>快捷键格式化</strong>：<ul><li>支持通过快捷键快速格式化 SQL 代码。</li></ul></li><li><strong>保存时自动格式化</strong>：<ul><li>支持在保存文件时自动格式化 SQL 代码。</li></ul></li></ol><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p><strong>MySQL</strong> 插件是一款数据库管理工具，专门用于连接、查询和管理 MySQL 数据库。它提供了直观的界面和强大的功能，使开发者能够直接在 VSCode 中操作数据库，而无需切换到其他数据库管理工具。</p><p><strong>主要功能</strong></p><ol><li><strong>数据库连接管理</strong>：<ul><li>支持连接本地或远程的 MySQL 数据库。</li><li>支持多数据库连接配置。</li></ul></li><li><strong>SQL 查询与执行</strong>：<ul><li>提供 SQL 编辑器，支持语法高亮、自动补全和代码格式化。</li><li>可以直接在 VSCode 中编写和执行 SQL 查询。</li></ul></li><li><strong>数据表管理</strong>：<ul><li>查看和编辑数据库中的表结构。</li><li>支持表数据的增删改查（CRUD）操作。</li></ul></li><li><strong>查询结果展示</strong>：<ul><li>以表格形式展示查询结果，支持排序、筛选和导出数据。</li></ul></li><li><strong>数据库对象浏览</strong>：<ul><li>浏览数据库中的表、视图、存储过程、函数等对象。</li></ul></li><li><strong>事务支持</strong>：<ul><li>支持事务操作，可以提交或回滚事务。</li></ul></li><li><strong>导出与导入</strong>：<ul><li>支持将查询结果或表数据导出为 CSV、JSON 等格式。</li><li>支持导入外部数据到数据库中。</li></ul></li></ol><p><img src="https://image.flashfish777.cn/img/post_21_6.jpg" alt="MySQL"></p><p>当然，不止<code>MySQL</code>，如果你用到如<code>Redis</code>、<code>MogoDB</code>等其他数据库，也可以下载对应的插件使用。</p><p><img src="https://image.flashfish777.cn/img/post_21_7.jpg" alt="数据库天团"></p><hr><h1 id="美化篇"><a href="#美化篇" class="headerlink" title="美化篇"></a>美化篇</h1><h2 id="Ayu"><a href="#Ayu" class="headerlink" title="Ayu"></a>Ayu</h2><p>巨好看的深色主题</p><p><img src="https://image.flashfish777.cn/img/post_21_8.jpg" alt="Ayu"></p><p><strong>Ayu</strong> 是一款非常受欢迎的代码编辑器主题插件，以其简洁、现代的设计风格和舒适的视觉体验而闻名。Ayu 提供了多种配色方案（如亮色、暗色和幻影色），适合不同开发者的审美偏好和工作环境。<br>（ps：个人觉得<code>Ayu Dark</code>最好看！）</p><h2 id="Gradient-Theme"><a href="#Gradient-Theme" class="headerlink" title="Gradient Theme"></a>Gradient Theme</h2><p>无敌好看的渐变代码主题</p><p><img src="https://image.flashfish777.cn/img/post_21_9.jpg" alt="Gradient Theme"></p><p><strong>Gradient Theme</strong> 是一款主题插件，以其渐变色设计和现代风格著称。它为代码编辑器提供了独特的视觉体验，通过柔和的渐变色背景和精心设计的语法高亮，使代码更加美观且易于阅读。<br><strong>Gradient Theme</strong> 的渐变色真的超级好看！是我现在仍在用的一款主题，每一种风格都很漂亮，还可以自定义渐变色！使用后别忘了在命令中心打开 <code>Gradient Theme: Enable Gradient</code> 配置！不然不会显示渐变哦。</p><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1EWtjezEYn&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><h2 id="vscode-teriri-custom-style"><a href="#vscode-teriri-custom-style" class="headerlink" title="vscode-teriri-custom-style"></a>vscode-teriri-custom-style</h2><p>不计效率地为 vscode 添加样式与动画</p><p><img src="https://image.flashfish777.cn/img/post_21_10.jpg" alt="vscode-teriri-custom-style"></p><p><a href="https://github.com/TeR1R1/vscode-teriri-custom-style">-&gt; GitHub仓库</a></p><p><strong>重头戏来了！</strong><br>超级超级棒，超级推荐的一个项目！如果你不局限于主题、背景、特效插件这样的美化，想让你的VSCode变得更加 下炫酷， <code>vscode-teriri-custom-style</code> 可以做到这些！</p><p><code>vscode-teriri-custom-style</code> 是一个为VSCode开发的的自定义样式项目，为开发者提供个性化的编辑器界面和代码高亮方案。该项目通过自定义 CSS 和配置文件，允许用户根据自己的喜好调整 VSCode 的外观和功能，从而提升开发体验。</p><p>非线性移动动画与进入动画、毛玻璃与圆角效果、高亮动画、发光字体、光标动画、炫酷的RGB光效、提示窗口动画、资源管理器动画……各种炫酷的效果随意添加，只需要安装 CSS 加载器，例如 <code>Apc Customize UI++</code> 插件, <code>Custom CSS and JS Loader</code> 等，能加载 CSS 文件就行。</p><p><img src="https://image.flashfish777.cn/img/post_21_11.jpg" alt="Custom CSS and JS Loader"></p><p>安装好插件后将项目中对应的 CSS 文件导入即可。具体的教程与演示在项目仓库中写的很详细，感兴趣的朋友可以自行查看。</p><p>当然，<code>vscode-teriri-custom-style</code> 只是项目作者自行研究的动画效果合辑。只要通过 CSS 加载器插件加载需要的 CSS 文件就可以通过 CSS 做到更多的效果。</p><hr><h1 id="JetBrains-Rider"><a href="#JetBrains-Rider" class="headerlink" title="JetBrains Rider"></a>JetBrains Rider</h1><p>就在前段时间，公认的全球最受喜爱，最佳游戏开发IDE <code>JetBrains Rider</code> 对非商业用途的用户开放了免费使用，这无疑是一个超级大的好消息。众所周知 <code>JetBrains</code> 家的IDE无论是 <code>IDEA</code> 、 <code>PyCharm</code> 、 <code>CLion</code> 、 <code>WebStorm</code> 等都受到了广泛开发者的喜爱，虽然并没有用过 <code>JetBrains</code> 的产品，但我相信好评是有目共睹的，于是在了解了 <code>Rider</code> 非商业化免费之后，我也立马下载下来体验了一番。</p><p><strong>Rider</strong> 是由 JetBrains 开发的一款跨平台集成开发环境（IDE），专为 <code>.NET</code>、<code>C#</code> 和 <code>Unity</code> 开发而设计。它基于 <code>IntelliJ</code> 平台和 <code>ReSharper</code> 技术，提供了强大的代码编辑、调试和重构功能，支持多种 <code>.NET</code> 项目类型，包括 <code>.NET Framework</code>、<code>.NET Core</code>、<code>Mono</code> 和 <code>Unity</code> 项目。</p><h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><ol><li><strong>跨平台支持</strong>：<ul><li>Rider 支持 <code>Windows</code>、<code>macOS</code> 和 <code>Linux</code> 操作系统，开发者可以在不同平台上无缝切换。</li></ul></li><li><strong>强大的代码编辑功能</strong>：<ul><li>提供语法高亮、代码自动补全、实时错误检测和代码重构功能，帮助开发者高效编写代码。</li><li>支持超过 2200 种实时代码检查，并提供快速修复建议。。</li></ul></li><li><strong>Unity 开发支持</strong>：<ul><li>作为一个游戏开发者，Rider 对 Unity 的支持让我印象深刻。它能够直接识别 Unity 项目中的脚本，并提供智能提示和调试功能。</li><li>在 Unity 中编写 C# 脚本时，Rider 的代码补全和重构功能极大地提升了开发效率。此外，它还支持 Unity 的 API 文档快速查看，方便随时查阅。</li></ul></li><li><strong>调试与测试</strong>：<ul><li>Rider 内置的调试器非常强大，支持断点、变量监视、表达式评估等功能。调试 Unity 项目时，它能够与 Unity 编辑器无缝衔接，实时查看游戏状态。</li></ul></li><li><strong>丰富的插件生态系统</strong>：<ul><li>支持多种插件扩展，包括 Git 版本控制、数据库工具、AI工具等等。</li></ul></li></ol><p>一开始我还觉得编辑器可能对我的开发影响不大，毕竟我已经习惯了用 VSCode 做任何事情。可是用了一段时间 Rider 我才发现它的专业性确实要更加更加强大，无论是代码补全还是对Unity的完美支持都完全秒杀 VSCode 插件的组合式开发环境，更别说 Rider还能完美的支持Unity Shader 的语法了。<br>相比之下 VSCode 倒像是可以支持各种语言环境的文本编辑器，它的涉猎广泛，但不够深入。 Rider 相比之下至少在 Unity 开发上更加专业。况且 Rider 也有插件系统不是嘛。<br>所以我觉得我应该重新对待 VSCode ，我不能再过度的依赖它。对于我来说，Unity 开发是我的主要工作，所以我选择使用 Rider 。在学习其他语言或进行其他不需要我涉猎很深的工作时 VSCode 可能仍是最好的选择。</p><h2 id="配置推荐"><a href="#配置推荐" class="headerlink" title="配置推荐"></a>配置推荐</h2><p>在 Rider 的使用上我或许不是很熟练与专业，但我可以给出我的一些建议。<br>首先快捷键配置我选择 VSCode 的，毕竟用习惯了。主题我选择用 <code>VSCode Theme</code> 插件，代码字体选用 <code>Consolas</code> ，哪里不像 VSCode 我用着都很别扭哈哈哈。</p><p><img src="https://image.flashfish777.cn/img/post_21_12.jpg"></p><p>提示级别是这样的，因为我觉得尽管正确的命名与拼写是必要的，但总会有一些特殊情况，编辑器一直提示的话我会觉得很烦，至于规范化的事情自己注意就好了。还有性能检查也是我觉得很棒的一个功能，它可以提示你那些方法或操作的开销比较大或其他，在开发时很有参考意义。</p><p>至于其他不错的功能就一起探索吧！</p><hr><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>以上就是我的一些推荐和想说的话，希望能为你带来帮助。如果你有任何推荐的VSCode插件或者独特的使用心得，欢迎在评论区留言分享，让我们一起学习，共同进步！期待在未来的编程道路上，与更多的你相遇，共同书写属于我们的精彩篇章。</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
            <tag> Rider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity插件之Localization</title>
      <link href="/posts/f35bbb42.html"/>
      <url>/posts/f35bbb42.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> Unity插件 </tag>
            
            <tag> 本地化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Crazy Web GameJam 2024</title>
      <link href="/posts/76f0264f.html"/>
      <url>/posts/76f0264f.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 游戏 </category>
          
          <category> GameJam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GameJam </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity插件之QuikOutline与shader</title>
      <link href="/posts/2255085f.html"/>
      <url>/posts/2255085f.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="QuikOutLine"><a href="#QuikOutLine" class="headerlink" title="QuikOutLine"></a>QuikOutLine</h1><h1 id="简单Shader实现"><a href="#简单Shader实现" class="headerlink" title="简单Shader实现"></a>简单Shader实现</h1><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1>]]></content>
      
      
      <categories>
          
          <category> 推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> Unity插件 </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity插件之DOTween</title>
      <link href="/posts/9e0ed965.html"/>
      <url>/posts/9e0ed965.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在边做比赛项目边学习的过程中，我不仅了解到<strong>设计模式</strong>那般优雅的解决方案，还了解了另一种精致的工具——Unity的插件。像我们最常用的 <code>TMPro</code> 就是Unity插件的一种。Unity众多的插件不光可以节省我们的开发时间，还可以为我们提供出乎意料的神秘技能，本文将推荐一款好用的动画插件——<strong>DOTween</strong>。</p><hr><h1 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h1><h2 id="DOTween-概述"><a href="#DOTween-概述" class="headerlink" title="DOTween 概述"></a>DOTween 概述</h2><p><code>DOTween</code> 是 Unity 中最受欢迎的补间动画(<code>Tweening</code>)插件之一，它提供了一个高效、灵活且易于使用的动画系统。作为 <code>HOTween</code> 的继承者，<code>DOTween</code> 在性能、功能和易用性方面都有显著提升。</p><h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><ul><li>零分配内存操作（Zero-allocation）</li><li>高度优化的代码结构</li><li>比 Unity 原生动画系统更高效</li></ul><h3 id="丰富的功能集"><a href="#丰富的功能集" class="headerlink" title="丰富的功能集"></a>丰富的功能集</h3><ul><li>支持 <code>Transform</code>、<code>Material</code>、<code>Camera</code>、<code>UI</code> 等多种对象动画</li><li>路径动画功能</li><li>序列动画系统</li><li>回调函数支持</li><li>物理模拟动画</li></ul><h3 id="3-简洁的-API-设计"><a href="#3-简洁的-API-设计" class="headerlink" title="3. 简洁的 API 设计"></a>3. 简洁的 API 设计</h3><ul><li>链式调用语法</li><li>直观的命名规则</li><li>丰富的扩展方法</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="安装与设置"><a href="#安装与设置" class="headerlink" title="安装与设置"></a>安装与设置</h3><p>通过 <code>Unity Asset Store</code> 或 <code>GitHub</code> 获取 <code>DOTween</code>，导入后需初始化：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> DG.Tweening;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化DOTween（自动完成）</span></span><br><span class="line">    DOTween.Init(autoKillMode, useSafeMode, logBehaviour);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本补间动画"><a href="#基本补间动画" class="headerlink" title="基本补间动画"></a>基本补间动画</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动物体</span></span><br><span class="line">transform.DOMove(<span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), <span class="number">1f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩放物体</span></span><br><span class="line">transform.DOScale(<span class="keyword">new</span> Vector3(<span class="number">1.5f</span>, <span class="number">1.5f</span>, <span class="number">1.5f</span>), <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旋转物体</span></span><br><span class="line">transform.DORotate(<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">90</span>, <span class="number">0</span>), <span class="number">1f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 颜色渐变</span></span><br><span class="line">material.DOColor(Color.red, <span class="number">1f</span>);</span><br></pre></td></tr></table></figure><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transform.DOMoveX(<span class="number">5</span>, <span class="number">1f</span>)</span><br><span class="line">         .SetEase(Ease.OutBounce)</span><br><span class="line">         .OnComplete(() =&gt; Debug.Log(<span class="string">&quot;移动完成!&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="动画序列（Sequences）"><a href="#动画序列（Sequences）" class="headerlink" title="动画序列（Sequences）"></a>动画序列（Sequences）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sequence mySequence = DOTween.Sequence();</span><br><span class="line">mySequence.Append(transform.DOMoveX(<span class="number">5</span>, <span class="number">1f</span>));</span><br><span class="line">mySequence.AppendInterval(<span class="number">0.5f</span>);</span><br><span class="line">mySequence.Append(transform.DOScale(<span class="number">2</span>, <span class="number">0.5f</span>));</span><br><span class="line">mySequence.Play();</span><br></pre></td></tr></table></figure><h3 id="路径动画"><a href="#路径动画" class="headerlink" title="路径动画"></a>路径动画</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector3[] path = <span class="keyword">new</span> Vector3[] &#123; <span class="comment">/* 路径点 */</span> &#125;;</span><br><span class="line">transform.DOPath(path, <span class="number">5f</span>, PathType.CatmullRom)</span><br><span class="line">         .SetLookAt(<span class="number">0.01f</span>);</span><br></pre></td></tr></table></figure><h3 id="回调系统"><a href="#回调系统" class="headerlink" title="回调系统"></a>回调系统</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transform.DOMoveX(<span class="number">5</span>, <span class="number">1f</span>)</span><br><span class="line">         .OnStart(() =&gt; Debug.Log(<span class="string">&quot;动画开始&quot;</span>))</span><br><span class="line">         .OnUpdate(() =&gt; Debug.Log(<span class="string">&quot;动画进行中&quot;</span>))</span><br><span class="line">         .OnComplete(() =&gt; Debug.Log(<span class="string">&quot;动画完成&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="动画控制"><a href="#动画控制" class="headerlink" title="动画控制"></a>动画控制</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Tween myTween = transform.DOMoveX(<span class="number">5</span>, <span class="number">1f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂停/继续</span></span><br><span class="line">myTween.Pause();</span><br><span class="line">myTween.Play();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重设动画</span></span><br><span class="line">myTween.Rewind();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成动画</span></span><br><span class="line">myTween.Complete();</span><br></pre></td></tr></table></figure><h2 id="UI-动画支持"><a href="#UI-动画支持" class="headerlink" title="UI 动画支持"></a>UI 动画支持</h2><p><code>DOTween</code> 对 Unity UI 有特别优化：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文本动画</span></span><br><span class="line">text.DOText(<span class="string">&quot;新文本&quot;</span>, <span class="number">1f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 颜色渐变</span></span><br><span class="line">image.DOColor(Color.blue, <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 淡入淡出</span></span><br><span class="line">canvasGroup.DOFade(<span class="number">0</span>, <span class="number">1f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// UI 元素移动</span></span><br><span class="line">rectTransform.DOAnchorPos(<span class="keyword">new</span> Vector2(<span class="number">100</span>, <span class="number">100</span>), <span class="number">1f</span>);</span><br></pre></td></tr></table></figure><h2 id="性能优化技巧"><a href="#性能优化技巧" class="headerlink" title="性能优化技巧"></a>性能优化技巧</h2><ol><li><strong>对象池</strong>：<code>DOTween</code> 自动管理补间对象池</li><li><strong>重用补间</strong>：避免频繁创建新补间</li><li><strong>批量控制</strong>：使用 <code>DOTween.To()</code> 批量处理</li><li><strong>合理设置 Update 类型</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myTween.SetUpdate(UpdateType.Normal); <span class="comment">// 默认</span></span><br><span class="line">myTween.SetUpdate(UpdateType.Late);  <span class="comment">// LateUpdate</span></span><br><span class="line">myTween.SetUpdate(UpdateType.Fixed); <span class="comment">// FixedUpdate</span></span><br><span class="line">myTween.SetUpdate(<span class="literal">true</span>); <span class="comment">// 使用独立时间不受Time.timeScale影响</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol><li><p><strong>使用静态扩展方法</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOTween.To(() =&gt; myValue, x =&gt; myValue = x, <span class="number">10</span>, <span class="number">1f</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>组合动画</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.DOMoveX(<span class="number">5</span>, <span class="number">1f</span>).Join(transform.DORotate(<span class="keyword">new</span> Vector3(<span class="number">0</span>,<span class="number">180</span>,<span class="number">0</span>), <span class="number">1f</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>自定义缓动函数</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myTween.SetEase(Ease.InOutQuad);</span><br><span class="line"><span class="comment">// 或使用动画曲线</span></span><br><span class="line">myTween.SetEase(myAnimationCurve);</span><br></pre></td></tr></table></figure></li><li><p><strong>性能监控</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DOTween.SetTweensCapacity(<span class="number">200</span>, <span class="number">50</span>); <span class="comment">// 设置最大补间数</span></span><br><span class="line">Debug.Log(DOTween.TotalPlayingTweens); <span class="comment">// 监控当前补间数</span></span><br></pre></td></tr></table></figure></li></ol><p><code>DOTween</code> 的强大之处在于它的灵活性和高性能，掌握这些功能可以显著提升 Unity 项目的动画效果和开发效率。</p><p>文章只列出了 <code>DOTWeen</code> 大致的函数调用，想了解具体函数的调用规则与细节，或者对插件感兴趣可以访问 <a href="https://dotween.demigiant.com/">DOTween官网</a></p><hr><h1 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h1><p>因为这段时间一直在写2D游戏，所以用在UI上比较多，下面分享一些我的用法：</p><h2 id="卡牌动画"><a href="#卡牌动画" class="headerlink" title="卡牌动画"></a>卡牌动画</h2><p>在TapTap的GameJam上做的卡牌之光游戏的卡牌效果就用到了DOTween，包括鼠标进入与离开的反馈、抽牌和使用的动画等。因为动画逻辑写的比较杂，就不放代码了。</p><h2 id="按钮效果"><a href="#按钮效果" class="headerlink" title="按钮效果"></a>按钮效果</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerClick</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 缩小按钮</span></span><br><span class="line">    transform.DOScale(<span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * <span class="number">0.9f</span>, <span class="number">0.1f</span>)</span><br><span class="line">        .OnComplete(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 播放音效</span></span><br><span class="line">            AudioManager.Instance.PlayEffect();</span><br><span class="line">            <span class="comment">// 恢复按钮大小</span></span><br><span class="line">            transform.DOScale(<span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="number">0.1f</span>)</span><br><span class="line">            .OnComplete(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                onClick?.Invoke(gameObject, eventData);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得UI的EventTrigger吗？ <a class="btn-beautify green larger" href="/posts/e1d7977f.html#UI%E7%9A%84%E6%9E%84%E5%BB%BA" title="UI的构建"><i class="far fa-hand-point-right"></i><span>UI的构建</span></a><br>在鼠标点击方法中，我在执行事件函数之前添加了缩小和恢复两段动画，就实现了弹性的按钮啦。</p><p><img src="https://image.flashfish777.cn/img/post_17_3.gif" alt="按钮效果"></p><h2 id="Tips提示"><a href="#Tips提示" class="headerlink" title="Tips提示"></a>Tips提示</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowTip</span>(<span class="params"><span class="built_in">string</span> msg, Color color, System.Action callback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GameObject obj = Instantiate(Resources.Load(<span class="string">&quot;UI/Tips&quot;</span>), canvasTf) <span class="keyword">as</span> GameObject;</span><br><span class="line">    Text text = obj.transform.Find(<span class="string">&quot;bg/Text&quot;</span>).GetComponent&lt;Text&gt;();</span><br><span class="line">    text.color = color;</span><br><span class="line">    text.text = msg;</span><br><span class="line">    Tween scale1 = obj.transform.Find(<span class="string">&quot;bg&quot;</span>).DOScaleY(<span class="number">1</span>, <span class="number">0.4f</span>);</span><br><span class="line">    Tween scale2 = obj.transform.Find(<span class="string">&quot;bg&quot;</span>).DOScaleY(<span class="number">0</span>, <span class="number">0.4f</span>);</span><br><span class="line"></span><br><span class="line">    Sequence seq = DOTween.Sequence();</span><br><span class="line">    seq.Append(scale1);</span><br><span class="line">    seq.AppendInterval(<span class="number">0.5f</span>);</span><br><span class="line">    seq.Append(scale2);</span><br><span class="line">    seq.AppendCallback(<span class="built_in">delegate</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    MonoBehaviour.Destroy(obj, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我让一张图片生成时渐渐变宽，就形成了Tips效果。</p><p><img src="https://image.flashfish777.cn/img/post_17_2.gif" alt="Tips"></p><h2 id="翻页效果"><a href="#翻页效果" class="headerlink" title="翻页效果"></a>翻页效果</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 翻页动画（左）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FilpPageEffectLeft</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    transform.Find(<span class="string">&quot;bgmask&quot;</span>).gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    transform.SetAsLastSibling();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向左位移</span></span><br><span class="line">    ((RectTransform)transform).DOAnchorPosX(-Screen.width, <span class="number">1f</span>)</span><br><span class="line">        .SetEase(Ease.InOutQuad)</span><br><span class="line">        .OnComplete(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Close();</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过改变上一级UI的关闭动画实现了翻页效果。</p><p><img src="https://image.flashfish777.cn/img/post_17_1.gif" alt="翻页效果"></p><p>我用了几天的时间闲的没事做了一个抽奖玩法的手机小游戏，将这一系列动画效果集成在了这个小游戏中，使UI”活蹦乱跳”，我将连接放在这里了啦：<br><a href="https://github.com/flashfish777/GambleSimulator">GitHub仓库 -&gt; 读博模拟器</a><br>感兴趣可以体验一下。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>在Unity开发中，强大的插件生态能极大提升开发效率与游戏表现。<strong>DOTween</strong>作为动画系统的标杆，以它简洁的API、卓越的性能和丰富的功能，让复杂的动画效果变得触手可及。无论是UI交互、角色动作还是场景过渡，DOTween都能轻松胜任，成为开发者工具箱中不可或缺的利器。</p><p>当然，Unity的插件宇宙远不止于此。Unity众多的插件如同游戏开发的”加速器”，帮助开发者将创意快速转化为现实。但切记：<strong>插件是工具而非依赖</strong>，合理选择、适度使用才是关键。理解底层原理，结合项目需求，才能让插件真正发挥价值。</p><p>希望本文的推荐能为你的Unity开发之旅提供灵感。如果你有其他优秀的插件推荐，或对DOTween的使用有独到见解，欢迎在评论区分享交流！</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> Unity插件 </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity日记：UGUI与单例模式</title>
      <link href="/posts/e1d7977f.html"/>
      <url>/posts/e1d7977f.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>那段时间为了 GameJam 项目的开发，我到处学习一些Demo与教学，学到了很多我看一万种理论视频也学不来的知识，其中最令我收益匪浅的就是一个Up主的教程中，他对于UI系统的管理。</p><p>他没有麻烦地将需要的UI全部拖进场景中，而是使用了一个 <code>UIManager</code> 脚本去管理一堆 <code>UIBase</code> 的子类，并在需要的时候生成预制体。</p><p>我惊叹于竟然可以将对于UI的管理完全封装到一个类中，然后这个类只提供一个静态成员来存储这个类本身！这种方法既减免了很多对象被实例化的性能占用，更让UI的管理变得简单轻松——你只需要在任何需要的地方调用这个静态成员，就能使用 <code>UIMnager</code> 中的所有方法。</p><p>了解过之后才知道，这种巧妙的方法有很多，它们是<strong>面向对象的设计模式</strong>，而我了解到的这种叫做<strong>单例模式</strong>。</p><hr><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h2><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><p><strong>设计模式（Design Pattern）</strong> 是软件设计中针对常见问题的可重用解决方案。它们不是可以直接转化为代码的完整设计，而是解决特定问题的模板或指导方针，是众多软件工程师经过长期实践总结出来的最佳实践方案。</p><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><p>设计模式通常分为三大类：</p><h4 id="创建型模式（5种）"><a href="#创建型模式（5种）" class="headerlink" title="创建型模式（5种）"></a>创建型模式（5种）</h4><ul><li>单例模式（Singleton）</li><li>工厂方法模式（Factory Method）</li><li>抽象工厂模式（Abstract Factory）</li><li>建造者模式（Builder）</li><li>原型模式（Prototype）</li></ul><h4 id="结构型模式（7种）"><a href="#结构型模式（7种）" class="headerlink" title="结构型模式（7种）"></a>结构型模式（7种）</h4><ul><li>适配器模式（Adapter）</li><li>装饰器模式（Decorator）</li><li>代理模式（Proxy）</li><li>外观模式（Facade）</li><li>桥接模式（Bridge）</li><li>组合模式（Composite）</li><li>享元模式（Flyweight）</li></ul><h4 id="行为型模式（11种）"><a href="#行为型模式（11种）" class="headerlink" title="行为型模式（11种）"></a>行为型模式（11种）</h4><ul><li>策略模式（Strategy）</li><li>模板方法模式（Template Method）</li><li>观察者模式（Observer）</li><li>迭代器模式（Iterator）</li><li>责任链模式（Chain of Responsibility）</li><li>命令模式（Command）</li><li>备忘录模式（Memento）</li><li>状态模式（State）</li><li>访问者模式（Visitor）</li><li>中介者模式（Mediator）</li><li>解释器模式（Interpreter）</li></ul><h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><ol><li><strong>开闭原则</strong>：对扩展开放，对修改关闭</li><li><strong>单一职责原则</strong>：一个类只负责一个功能领域</li><li><strong>里氏替换原则</strong>：子类必须能够替换其父类</li><li><strong>依赖倒置原则</strong>：依赖于抽象而非具体实现</li><li><strong>接口隔离原则</strong>：使用多个专用接口而非一个总接口</li><li><strong>迪米特法则</strong>：最少知识原则，降低耦合度</li></ol><h3 id="设计模式的意义"><a href="#设计模式的意义" class="headerlink" title="设计模式的意义"></a>设计模式的意义</h3><p>设计模式的核心目的是<strong>提高软件的可维护性、可扩展性和复用性</strong>，同时保证代码的灵活性和可靠性。<br>简单来说，设计模式的目标可以从以下几个维度理解：</p><ul><li><strong>解决常见设计问题，避免重复造轮子</strong></li><li><strong>提升代码的可维护性</strong></li><li><strong>增强可扩展性</strong></li><li><strong>促进团队协作</strong></li><li><strong>优化性能与资源管理</strong></li><li><strong>平衡灵活性与复杂度</strong></li><li><strong>传承最佳实践</strong></li></ul><h2 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h3><p>单例模式确保一个类只有一个实例，并提供一个全局访问点。这种模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>当类只能有一个实例且客户可以从一个众所周知的访问点访问它时</li><li>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时</li><li>需要严格控制全局变量的场景</li><li>频繁创建和销毁的对象</li><li>重量级对象，需要共享的资源（如数据库连接池、线程池、配置对象等）</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="饿汉式（线程安全）"><a href="#饿汉式（线程安全）" class="headerlink" title="饿汉式（线程安全）"></a>饿汉式（线程安全）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> instance; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>类加载时就初始化，浪费内存</li><li>没有加锁，执行效率高</li><li>线程安全</li></ul><h4 id="懒汉式（非线程安全）"><a href="#懒汉式（非线程安全）" class="headerlink" title="懒汉式（非线程安全）"></a>懒汉式（非线程安全）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>懒加载，内存利用率高</li><li>线程不安全</li><li>不推荐使用</li></ul><h4 id="懒汉式（线程安全）"><a href="#懒汉式（线程安全）" class="headerlink" title="懒汉式（线程安全）"></a>懒汉式（线程安全）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> lockObj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (lockObj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>懒加载</li><li>线程安全</li><li>效率低（每次获取实例都要同步）</li></ul><h4 id="双重检查锁（DCL）"><a href="#双重检查锁（DCL）" class="headerlink" title="双重检查锁（DCL）"></a>双重检查锁（DCL）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> lockObj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">lock</span> (lockObj)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>懒加载</li><li>线程安全</li><li>效率较高（只有第一次创建时需要同步）</li></ul><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类（C# 中称为嵌套类）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SingletonHolder</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> SingletonHolder.Instance; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>懒加载（只有调用getInstance时才会加载SingletonHolder类）</li><li>线程安全</li><li>效率高</li><li>推荐使用</li></ul><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 显式静态构造函数告诉编译器不要标记为beforefieldinit</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数防止外部实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 业务方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>简洁</li><li>自动支持序列化机制</li><li>绝对防止多次实例化</li></ul><h3 id="单例模式的优缺点"><a href="#单例模式的优缺点" class="headerlink" title="单例模式的优缺点"></a>单例模式的优缺点</h3><p><strong>优点</strong>：</p><ul><li>提供了对唯一实例的受控访问</li><li>节约系统资源（避免频繁创建和销毁对象）</li><li>允许可变数目的实例（可以通过设计扩展）</li></ul><p><strong>缺点</strong>：</p><ul><li>没有抽象层，难以扩展</li><li>职责过重，在一定程度上违背了”单一职责原则”</li><li>不适用于变化的对象</li><li>滥用单例会导致代码耦合度高，难以测试</li></ul><h3 id="单例模式的注意事项"><a href="#单例模式的注意事项" class="headerlink" title="单例模式的注意事项"></a>单例模式的注意事项</h3><ol><li><strong>线程安全</strong>：多线程环境下要确保只创建一个实例</li><li><strong>序列化问题</strong>：如果单例类使用了Serializable特性，反序列化时会创建新实例</li><li><strong>反射攻击</strong>：通过反射可以调用私有构造器创建新实例</li><li><strong>类加载器问题</strong>：不同的类加载器可能会创建多个实例</li><li><strong>内存泄漏</strong>：长时间不用的单例对象可能导致内存泄漏</li></ol><h2 id="设计模式与单例模式的实践建议"><a href="#设计模式与单例模式的实践建议" class="headerlink" title="设计模式与单例模式的实践建议"></a>设计模式与单例模式的实践建议</h2><ol><li><strong>不要过度使用单例模式</strong>：单例模式本质上是全局变量，过度使用会导致代码难以维护和测试</li><li><strong>考虑依赖注入</strong>：对于需要单例的对象，可以考虑使用依赖注入框架（如Spring）来管理</li><li><strong>优先选择枚举实现</strong>：枚举实现简单且能防止反射和序列化问题</li><li><strong>注意生命周期管理</strong>：明确单例对象的创建和销毁时机</li><li><strong>考虑替代方案</strong>：对于某些场景，静态工具类可能是更好的选择</li></ol><hr><h1 id="Unity-UI的管理"><a href="#Unity-UI的管理" class="headerlink" title="Unity UI的管理"></a>Unity UI的管理</h1><p>在我的项目中，我融汇并使用了这种设计模式。尽管可能并不是很完美与规范，但还是为我的开发带来了不少的便捷与优化。</p><h2 id="UI的构建"><a href="#UI的构建" class="headerlink" title="UI的构建"></a>UI的构建</h2><p><strong>UIBase: UI基类</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> UI基类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIBase</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UIEventTrigger <span class="title">Register</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Transform tf = transform.Find(name);</span><br><span class="line">        <span class="keyword">return</span> UIEventTrigger.Get(tf.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 显示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Hide</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭（销毁）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Close</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIManager.Instance.CloseUI(gameObject.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UIEventTrigger: UI事件类</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> UI事件</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIEventTrigger</span> : <span class="title">MonoBehaviour</span>, <span class="title">IPointerClickHandler</span>, <span class="title">IPointerEnterHandler</span>, <span class="title">IPointerExitHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Action&lt;GameObject, PointerEventData&gt; onClick; <span class="comment">// 鼠标点击</span></span><br><span class="line">    <span class="keyword">public</span> Action&lt;GameObject, PointerEventData&gt; onEnter; <span class="comment">// 鼠标进入</span></span><br><span class="line">    <span class="keyword">public</span> Action&lt;GameObject, PointerEventData&gt; onExit; <span class="comment">// 鼠标离开</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UIEventTrigger <span class="title">Get</span>(<span class="params">GameObject obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIEventTrigger trigger = obj.GetComponent&lt;UIEventTrigger&gt;();</span><br><span class="line">        <span class="keyword">if</span> (trigger == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            trigger = obj.AddComponent&lt;UIEventTrigger&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> trigger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerClick</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 执行事件</span></span><br><span class="line">        onClick?.Invoke(gameObject, eventData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerEnter</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        onEnter?.Invoke(gameObject, eventData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerExit</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        onExit?.Invoke(gameObject, eventData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 UIBase 中，我封装了包括打开关闭与UI事件的基本逻辑。然后将UI事件扩展成一个类，在改类中使用 <code>Action</code> 事件来存储UI被触发时的逻辑，并实现了需要的鼠标事件接口，在对应的鼠标事件函数中调用对应的UI事件，扩展了UI的事件多样性。</p><h2 id="UI的管理"><a href="#UI的管理" class="headerlink" title="UI的管理"></a>UI的管理</h2><p><strong>UIManager: 管理UI的单例类</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> UI管理器</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UIManager Instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Transform canvasTf; <span class="comment">// 画布的变换组件</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UIBase&gt; uiList; <span class="comment">// 存储加载过的界面的集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不对外开方构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UIManager</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态初始化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实例化对象</span></span><br><span class="line">        Instance = <span class="keyword">this</span>();</span><br><span class="line">        <span class="comment">// 找世界中的画布</span></span><br><span class="line">        canvasTf = GameObject.Find(<span class="string">&quot;Canvas&quot;</span>).transform;</span><br><span class="line">        <span class="comment">// 初始化集合</span></span><br><span class="line">        uiList = <span class="keyword">new</span> List&lt;UIBase&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 显示UI</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UIBase <span class="title">ShowUI</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> uiName</span>) <span class="keyword">where</span> T : UIBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIBase ui = Find(uiName);</span><br><span class="line">        <span class="keyword">if</span> (ui == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 集合中没有就需要从其他地方（如 Resources/UI 文件夹中）加载</span></span><br><span class="line">            GameObject obj = Instantiate(Resources.Load(<span class="string">&quot;UI/&quot;</span> + uiName), canvasTf) <span class="keyword">as</span> GameObject;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 改名字</span></span><br><span class="line">            obj.name = uiName;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加需要的脚本</span></span><br><span class="line">            ui = obj.AddComponent&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加到集合进行存储</span></span><br><span class="line">            uiList.Add(ui);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 显示</span></span><br><span class="line">            ui.Show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ui;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏UI</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HideUI</span>(<span class="params"><span class="built_in">string</span> uiName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIBase ui = Find(uiName);</span><br><span class="line">        <span class="keyword">if</span> (ui != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ui.Hide();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭所有界面</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CloseAllUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = uiList.Count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(uiList[i].gameObject);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uiList.Clear(); <span class="comment">// 清空集合</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭某个界面</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CloseUI</span>(<span class="params"><span class="built_in">string</span> uiName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIBase ui = Find(uiName);</span><br><span class="line">        <span class="keyword">if</span> (ui != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            uiList.Remove(ui);</span><br><span class="line">            Destroy(ui.gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从集合中找到名字对应的界面脚本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UIBase <span class="title">Find</span>(<span class="params"><span class="built_in">string</span> uiName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> t <span class="keyword">in</span> uiList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.name == uiName)</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得某个界面的脚本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetUI</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> uiName</span>) <span class="keyword">where</span> T : UIBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIBase ui = Find(uiName);</span><br><span class="line">        <span class="keyword">if</span> (ui != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ui.GetComponent&lt;T&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在UIManager中，我提供了一个公共的 <code>Instance</code> 属性作为“窗口”，使得所有脚本都可以调用 <code>UIManager</code> 的方法，然后关闭构造函数，提供一个静态的初始化函数，使Instance只能通过初始化函数实例化自身。最后再加上对UI进行管理的相关方法，一个专业的管理者就诞生了。</p><h2 id="UI的实例"><a href="#UI的实例" class="headerlink" title="UI的实例"></a>UI的实例</h2><p>再之后，分别写出需要的UI实例类，继承UIBase，使它们获得UI的基本逻辑，如：<br><strong>LoginUI: 登录界面</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 登录界面</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoginUI</span> : <span class="title">UIBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 开始游戏</span></span><br><span class="line">        Register(<span class="string">&quot;start&quot;</span>).onClick = onStartGameBtn;</span><br><span class="line">        <span class="comment">// 设置</span></span><br><span class="line">        Register(<span class="string">&quot;settings&quot;</span>).onClick = onSettingsBtn;</span><br><span class="line">        <span class="comment">// 退出游戏</span></span><br><span class="line">        Register(<span class="string">&quot;quit&quot;</span>).onClick = onQuitBtn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onStartGameBtn</span>(<span class="params">GameObject @<span class="built_in">object</span>, PointerEventData data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 开始游戏的逻辑，</span></span><br><span class="line">        <span class="comment">// 如加载场景、调用UI</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// UIManager将预制体实例化到场景中</span></span><br><span class="line">        UIManager.Instance.ShowUI&lt;GameUI&gt;(<span class="string">&quot;GameUI&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Close(); <span class="comment">// 关闭LoginUI</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onSettingsBtn</span>(<span class="params">GameObject @<span class="built_in">object</span>, PointerEventData data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIManager.Instance.ShowUI&lt;SettingsUI&gt;(<span class="string">&quot;SettingsUI&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onQuitBtn</span>(<span class="params">GameObject @<span class="built_in">object</span>, PointerEventData data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">        UnityEditor.EditorApplication.isPlaying = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        Application.Quit();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SettingsUI: 设置界面</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 设置UI</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SettingsUI</span> : <span class="title">UIBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        Register(<span class="string">&quot;close&quot;</span>).onClick = onCloseBtn;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回主菜单</span></span><br><span class="line">        Register(<span class="string">&quot;backTOmenu&quot;</span>).onClick = onBackBtn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onCloseBtn</span>(<span class="params">GameObject @<span class="built_in">object</span>, PointerEventData data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onBackBtn</span>(<span class="params">GameObject @<span class="built_in">object</span>, PointerEventData data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Close();</span><br><span class="line"></span><br><span class="line">        UIManager.Instance.ShowUI&lt;LoginUI&gt;(<span class="string">&quot;LoginUI&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在具体的UI类中，需要根据UI的功能在最开始（Awake）的时候将对应的函数事件添加到相应的UI事件中。还记得吗？注册函数 <code>Register</code> 返回的是 <code>UIEventTrigger</code> 类。这时，我们在对UI进行操作时，便会调用对应的函数事件，执行UI的逻辑了。<br>同时，我们可以在例子中的具体UI事件中看到对于 <code>UIManager</code> 的调用，轻松的管理了UI界面的生成。</p><p><strong>注意</strong>：<code>UIManager</code> 生成UI的方法是在资源文件中寻找相应名称的UI预制体，并将对应的脚本挂载到预制体上，所以，ShowUI&lt; <code>T</code> &gt;( <code>&quot;&quot;</code> ) 的两个参数一定不能写错。</p><hr><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>单例模式是一种简单却强大的设计模式，它确保一个类只有一个实例，并提供了全局访问点。无论是管理配置信息、数据库连接，还是共享资源，单例模式都能帮助我们避免不必要的资源浪费，同时保证数据的一致性。</p><p>设计模式的世界远不止于此。除了单例模式，还有更多巧妙的设计模式，它们各自解决特定场景下的问题，让代码更具扩展性和可维护性。</p><p>设计模式的核心思想是“解决问题”，而非“套用规则”。希望本文能帮助你理解单例模式的精髓，并在实际开发中灵活运用。如果你对其他设计模式感兴趣，或者有更多想法与疑问，欢迎在评论区交流讨论！</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
            <tag> OOP </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青年谓世辞》的故事</title>
      <link href="/posts/8c9cff07.html"/>
      <url>/posts/8c9cff07.html</url>
      
        <content type="html"><![CDATA[<h1 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h1><p><strong>回忆的开始</strong></p><p>没事翻看相册的时候偶然翻到这张图片：</p><p><img src="https://image.flashfish777.cn/img/post_15_1.jpg"></p><p>这是一张高考前二模的时候我的作文的阅卷图片，当时得了52分，在全校数一数二。<br>这张图片模模糊糊的，却勾起了我很多回忆。</p><p>高中的时候很喜欢古诗文，现在也是，这种浓缩的、有情感、有韵律的文字，我觉得美极了。当时不仅背过很多很多的古诗文，也经常写一些诗词拿来消遣。<br>那时候正是最紧张的复习阶段，可是越到这个时候我越是学不进去，那时候晚自习根本写不进去作业，除了偷偷看小说，写一写诗词便成了唯一的乐趣。可以写日常的生活、无聊的复习、同学的黑历史很多很多。<br>然后说语文。我的语文成绩一直是个谜。六科里面我唯一一点东西都不学的就是语文。别人学六科，我学五科。这可是高三啊，可和大学不一样，有一科一点不学真的不敢想。可是我就是这样的，而且最神奇的是，我的语文成绩还一直都是第一第二（我是真的不学啊）。但因为我不学习跟语文老师闹得很僵，因为我上课从不会听讲，作业也不写。高三的时候有一次语文老师让我们上课写作文，我不但不写还拿出化学作业来写，导致他直接大发雷霆，抢走了我的化学作业，我也没服软（因为我觉得真没什么好服软的，经过我长时间的不学语文分数却一直这么高导致我真的不想再把时间浪费在做那些作业上，再提升也提升不了多少（那时候基本上模拟都是125&#x2F;150，对于语文来说已经很高了），不如多提升一下其他科目），我又抢回来了，老师就说再也不管我，还说我以后要是交作业我就是🐶，我俩就开始冷战了。结局就是以后的考试语文还是第一第二，高考也没掉链子。我不知道老师一直都是怎么想，我后面也再没揣测过，我觉得后悔和对老师有意见都不是什么好事.</p><p>好了回归正题，有一次我发现写这种偏文言的作文得的分会高很多，可能是显得比较有文采，虽然也都是照猫画虎，写的当然不是真正的文言文。于是我就开始都写这种文章，每次也都是拿很高很高的分，甚至我高考也是写的这种。<br>我写过很多很多的诗、词和这种文章，但记录下来的只有这个应该。虽然对于我自己来说肯定是觉得每篇都很好，但我总是记得有一篇特别特别好，可是应该找不到了，我记得是高考完扔掉了，不是这篇。今天突然翻到了，就想对照着照片和记忆把文章拷下来，虽然图片有的字都看不清，但毕竟是自己写的，也能记起个大概。</p><h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><details class="toggle" ><summary class="toggle-button" style="">青年谓世辞</summary><div class="toggle-content"><pre><code>青年谓世辞</code></pre><p>明时而立，新世而属。致学不艰，勤业不苦。时开放之局，今世界一浦。年方青壮，生于黄土。遗世而生 ，志存鸿鹄。世界生我，问我以何志而锄；我谓世界，答之以变之为笃。</p><p>立心于天地，立命于生民。继绝学于往圣，开太平于万世。大国汤汤，其韵绵长。吾辈青年，与国无疆。观察世界，志在四方。融入世界，敢拼敢当。影响世界，遗世留香。当以此志，扬帆远航！</p><p>观察世界，志以修身。睹古今之兴变，明智理之遗存。视当今之格局，立长志以修身。观世之所需兮，先吾辈乎立志。代长梦以快马兮，莫负时之韶韶；觑困拘于迩达兮，莫畏路之迢迢！渺长征之天路兮，见军未有色挠。明长志以立世兮，终行吾之所道。观世之遗蕴兮，品其意之可昭。下远洋以寻陆，治乱世于明条。开疆拓土，以谓创造。吾辈青年，立世之礁，观世之蕴，行己之道。</p><p>融入世界，以勤志心；为梦为志，以奋志体。欲成志以容世兮，当吾辈乎勤坚。非梦桃之桃梦兮，梦荣光之一取。忍疼痛之锥骨兮，终跪地而旗举。添鞍辔于梦骏兮，虽万险而莫惧！以若所坚，求若所欲。困坚毅于金石兮，虽殒身而不恤！行坚而睹己，省前日而回已。学日新以时习兮，自孔夫而谈起；成吾辈之身修兮，虽千年而未已！行此之坚毅兮，问以何而身修？欲融志于世界，行冬夏而春秋。</p><p>影响世界，当任以己。己欲立乎立人，己欲达乎达人。夫吾立之地，实为吾疆。吾心所向，乃国显彰。吾德如阳，则邦生光；吾志若玉，其道弥昌；吾怀明德，天下同芳。君可见也，芳龄村官返家乡，排难渡险致富地；君可见也，埋名隐姓黄土里，家国利剑扶摇起；君可见也，敢问吾书为何读，一人一志国崛起。泱泱华夏，名仕四地；大千世界，志士四起。影响世界，当需由己！行己之道，坚己之意。颤举世之格局，终因吾而已矣。</p><p>世界育我，我心明德。吾辈青年，应以我则。世界问我，我谓其说：吾辈青年，当立当歌！一苇以航，修身立德行志；振翅以翔，观世融世惊世。吾辈青年，当以此仿。知深洋谷，德曜星芒。为梦为志，当奋当狂。前承千古，后亦流芳！</p></div></details><p>（copy下来感觉好少啊哈哈）</p><p>我还把文章喂给了AI，让他解析以下，我感觉还不错。</p><details class="toggle" ><summary class="toggle-button" style="">AI翻译及解析</summary><div class="toggle-content"><p>以下是逐段翻译与解析，确保覆盖全文每个段落：</p><hr><p><strong>青年谓世辞</strong></p><p><em><strong>原文第一段</strong></em></p><p><strong>明时而立，新世而属。致学不艰，勤业不苦。时开放之局，今世界一浦。年方青壮，生于黄土。遗世而生 ，志存鸿鹄。世界生我，问我以何志而锄；我谓世界，答之以变之为笃。</strong></p><p><strong>翻译：</strong><br>青年向世界宣言：<br>我们生在开明的时代，属于崭新的世界。求学不再艰难，奋斗不再痛苦。面对开放的格局，世界已连成一片。正值青春年华，扎根于祖国大地，虽身处平凡却心怀超越的鸿鹄之志。世界问我们“以何种志向耕耘人生”，我们回答：“改变世界是永恒的信念！”</p><p><strong>解析：</strong></p><ul><li><p><strong>核心意象</strong>：以“明时”“新世”强调时代特征，“黄土”象征中华大地，“鸿鹄”喻远大志向。</p></li><li><p><strong>问答结构</strong>：通过“世界问我—我答世界”的对话，点明青年使命。</p></li><li><p><strong>语言特色</strong>：“锄”字双关，既指耕耘土地，又喻人生奋斗。</p></li></ul><hr><p><em><strong>原文第二段</strong></em></p><p><strong>立心于天地，立命于生民。继绝学于往圣，开太平于万世。大国汤汤，其韵绵长。吾辈青年，与国无疆。观察世界，志在四方。融入世界，敢拼敢当。影响世界，遗世留香。当以此志，扬帆远航！</strong></p><p><strong>翻译：</strong><br>（此段为总纲，后文展开部分已拆分解析，此处保留完整翻译）<br>我们立志于天地，献身于人民。传承先贤的智慧，开创万世的太平。大国气象恢宏，文明生生不息。我们青年与祖国共成长，永无止境。观察世界，胸怀天下；融入世界，勇于担当；影响世界，留下不朽印记。带着这样的志向，启程远航！</p><p><strong>解析：</strong></p><ul><li><p><strong>思想源流</strong>：化用张载“横渠四句”（为天地立心，为生民立命，为往圣继绝学，为万世开太平），体现儒家担当。</p></li><li><p><strong>结构功能</strong>：总领全文，提出“观察-融入-影响”三重境界。</p></li></ul><hr><p><em><strong>原文第三段（观察世界部分）</strong></em></p><p><strong>观察世界，志以修身。睹古今之兴变，明智理之遗存。视当今之格局，立长志以修身。观世之所需兮，先吾辈乎立志。代长梦以快马兮，莫负时之韶韶；觑困拘于迩达兮，莫畏路之迢迢！</strong></p><p><strong>翻译：</strong><br>观察世界，以志向修身。看古今兴衰变迁，明悟智慧传承；观当今世界格局，树立长远志向。根据时代需要，青年首先要确立理想。以快马追逐长远梦想，不辜负美好青春；莫被眼前利益束缚，别畏惧路途遥远！</p><p><strong>解析：</strong></p><ul><li><p><strong>方法论</strong>：提出“观察-明理-立志”的修身路径。</p></li><li><p><strong>警示对照</strong>：“迩达”（眼前成就）与“迢迢”（长远目标）形成对比。</p></li></ul><hr><p><em><strong>原文第三段（观察世界例证）</strong></em></p><p><strong>渺长征之天路兮，见军未有色挠。明长志以立世兮，终行吾之所道。观世之遗蕴兮，品其意之可昭。下远洋以寻陆，治乱世于明条。开疆拓土，以谓创造。吾辈青年，立世之礁，观世之蕴，行己之道。</strong></p><p><strong>翻译：</strong><br>遥望长征险途，先烈面不改色；坚定远大志向，终将走自己的道路。观察文明积淀，领悟其中深意。如同航海家探索新大陆，像改革家重建秩序。开拓创新，这才是真正的创造。我们这一代青年，如礁石屹立于世，观察世界的深意，践行自己的道路。</p><p><strong>解析：</strong></p><ul><li><p><strong>历史回响</strong>：以长征精神激励当代，实现精神谱系传承。</p></li><li><p><strong>历史事件</strong>：“下远洋”指郑和航海。</p></li><li><p><strong>重新定义</strong>：将“开疆拓土”从地理概念转化为创新维度。</p></li><li><p><strong>象征</strong>：“礁石”象征坚定，突出青年在时代中的锚定作用。</p></li></ul><hr><p><em><strong>原文第四段（融入世界核心论述和例证）</strong></em></p><p><strong>融入世界，以勤志心；为梦为志，以奋志体。欲成志以容世兮，当吾辈乎勤坚。非梦桃之桃梦兮，梦荣光之一取。忍疼痛之锥骨兮，终跪地而旗举。</strong>  </p><p><strong>翻译：</strong><br>融入世界，追逐梦想，需以勤奋坚定心志与行动。若想实现理想、立足世间，我们必须勤勉坚韧。徐梦桃的梦想并不是虚幻的空想（<em>“桃梦”指不切实际的幻想</em>），而是真正的荣耀。即便忍受锥心刺骨的痛苦，最终举起胜利的旗帜！</p><p><strong>解析：</strong></p><ul><li><p><strong>引用真人真事</strong>：用徐梦桃在奥运会的故事来论证勤奋与梦想</p></li><li><p><strong>目标导向</strong>：强调“荣光”需通过实际奋斗获取。</p></li></ul><hr><p><em><strong>原文第四段（融入世界方法论）</strong></em></p><p><strong>添鞍辔于梦骏兮，虽万险而莫惧！以若所坚，求若所欲。困坚毅于金石兮，虽殒身而不恤！行坚而睹己，省前日而回已。学日新以时习兮，自孔夫而谈起；成吾辈之身修兮，虽千年而未已！行此之坚毅兮，问以何而身修？欲融志于世界，行冬夏而春秋。</strong>  </p><p><strong>翻译：</strong><br>为梦想的骏马备好鞍辔，纵使万般艰险也绝不退缩！以这样的坚定，追求这样的理想。将毅力熔铸成金石般的意志，哪怕牺牲生命也毫不迟疑！行动中审视自我，反思过往修正自身。学习要日日常新、时时践行，这是从孔子时代便传承的真理；我们修身养性的追求，纵使千年也不会停息！践行这样的坚毅时，如何修身？要将志向融入世界，历经四季轮回。</p><p><strong>解析：</strong></p><ul><li><p><strong>生死观</strong>：“殒身不恤”化用林觉民《与妻书》，彰显献身精神。</p></li><li><p><strong>古今贯通</strong>：将《论语》“学而时习之”与当代“终身学习”理念结合。</p></li><li><p><strong>时间维度</strong>：通过“千年”强调修身的永恒性，破除急功近利思维，“冬夏春秋”喻指长期坚持，不惧时间考验。</p></li></ul><hr><p><em><strong>原文第五段（影响世界总论）</strong></em></p><p><strong>影响世界，当任以己。己欲立乎立人，己欲达乎达人。夫吾立之地，实为吾疆。吾心所向，乃国显彰。吾德如阳，则邦生光；吾志若玉，其道弥昌；吾怀明德，天下同芳。</strong><br><strong>翻译：</strong><br>影响世界，需从自身担当开始。自己要立身立业，也要助他人立身立业；自己追求通达，也要助他人通达。我们站立的地方，就是责任的疆土；我们心志所指的方向，便是国家的荣光。若我们的德行如太阳般光辉，国家便充满光明；若我们的志向如美玉般高洁，民族复兴之路将更加通畅；若我们心怀美德，天下将共享芬芳。</p><p><strong>解析：</strong></p><ul><li><p><strong>儒家伦理</strong>：直接引用《论语》“己欲立而立人”，强调推己及人的担当。</p></li><li><p><strong>化用名句</strong>：化用崔卫平《光明与黑暗》中的名句“你所站立的地方，正是你的中国；你怎么样，中国便怎么样；你是什么，中国便是什么；你有光明，中国便不黑暗”。</p></li><li><p><strong>因果关系</strong>：个人品德直接决定国家命运，体现“修身→治国”的传统逻辑。</p></li></ul><hr><p><em><strong>原文第五段（影响世界现实例证）</strong></em></p><p><strong>君可见也，芳龄村官返家乡，排难渡险致富地；君可见也，埋名隐姓黄土里，家国利剑扶摇起；君可见也，敢问吾书为何读，一人一志国崛起。</strong>  </p><p><strong>翻译：</strong><br>你看！年轻村官返回家乡，攻坚克难带领乡亲致富；你看！隐姓埋名的奉献者扎根荒漠，铸就护国重器直上云霄；你看！万千学子追问“为何而读书”，用个人志向推动国家崛起。</p><p><strong>解析：</strong></p><ul><li><p><strong>现实映射</strong>：</p><ul><li><p>“芳龄村官”指向黄文秀等扶贫干部；</p></li><li><p>“埋名隐姓”对应邓稼先等“两弹一星”元勋；</p></li><li><p>“书为何读”化用周恩来“为中华之崛起而读书”。</p></li></ul></li><li><p><strong>镜头语言</strong>：三个“君可见也”如电影蒙太奇，展现不同领域的青年担当。</p></li></ul><hr><p><em><strong>原文第五段（影响世界总结）</strong></em></p><p><strong>泱泱华夏，名仕四地；大千世界，志士四起。影响世界，当需由己！行己之道，坚己之意。颤举世之格局，终因吾而已矣。</strong>  </p><p><strong>翻译：</strong><br>华夏大地英才辈出，世界各处志士云集。改变世界必须从自身做起！坚持自己的道路，坚定自己的信念。撼动世界格局的力量，终将因我们而诞生！</p><p><strong>解析：</strong></p><ul><li><p><strong>空间拓展</strong>：从“华夏”到“大千世界”，构建人类命运共同体视角。</p></li><li><p><strong>动词炼字</strong>：“颤”字既含“震撼”之力，又带“改变”之渐进性，精准表达量变到质变的过程。</p></li></ul><hr><p><em><strong>原文结尾段（全文升华）</strong></em></p><p><strong>世界育我，我心明德。吾辈青年，应以我则。世界问我，我谓其说：吾辈青年，当立当歌！一苇以航，修身立德行志；振翅以翔，观世融世惊世。吾辈青年，当以此仿。知深洋谷，德曜星芒。为梦为志，当奋当狂。前承千古，后亦流芳！</strong>  </p><p><strong>翻译：</strong><br>世界培育我们，我们心怀光明德行。新时代青年应以自身为准则，回应世界的叩问：我们必将顶天立地，高歌前行！像芦苇般坚韧远航，修身立德践行理想；如雄鹰振翅高飞，观察世界、融入时代、震撼寰宇！青年们应当以此为榜样，让学识比大洋和峡谷还深，让德行如星辰光芒般闪耀。为梦想与志向，就应这般行动！继承千古文明，开创万世流芳！</p><p><strong>解析：</strong></p><ul><li><p><strong>文化符号</strong>：</p><ul><li><p>“一苇以航”出自《诗经·卫风·河广》“谁谓河广？一苇杭之”，喻微小而坚韧的力量；</p></li><li><p>“振翅以翔”呼应《庄子·逍遥游》鲲鹏意象，象征超越性追求。</p></li></ul></li><li><p><strong>时空对话</strong>：“前承千古”与“后亦流芳”形成历史纵深感，将青年置于文明传承者位置。</p></li><li><p><strong>动词体系</strong>：“观-融-惊”三字浓缩全文三大篇章，与开篇“观察-融入-影响”形成闭环。</p></li></ul><hr></div></details><p>真是每一句都说出了我写时想说的！ </p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>现在想来高中的真的满是回忆啊，真的是最美好的时光，可惜已经回不去了，不可惜的是高中时候的好朋友都还在。祝所有人都事事顺心、不留遗憾。</p><p>—end—</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TapTap聚光灯GameJam</title>
      <link href="/posts/249f88d5.html"/>
      <url>/posts/249f88d5.html</url>
      
        <content type="html"><![CDATA[<div class="note danger info flat"><p><strong>酝酿中</strong></p></div><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 游戏 </category>
          
          <category> GameJam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GameJam </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Inno Setup 安装包制作教程</title>
      <link href="/posts/54db36cb.html"/>
      <url>/posts/54db36cb.html</url>
      
        <content type="html"><![CDATA[<h1> Inno Setup 打包教程 </h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对计算机相对熟悉之后，我们发现大部分应用都是一整个文件，里面可能会有 <code>exe</code> 可执行文件及其他素材文件、库文件、依赖等等。比如我的 LecSnake ，windows平台打包之后是一个这样的文件夹：</p><p><img src="https://image.flashfish777.cn/img/post_13_1.jpg" alt="&#x2F;LecSnake&#x2F;"></p><p>以后我们可能还会做更多的游戏以及其他的项目。那么我们想发给朋友玩的时候难道只能压缩成压缩包然后发给别人解压吗？<br>我们一般在网上下载东西时都是下载安装程序。再通过安装程序将应用文件夹下载至磁盘中。那么我们自己的应用是否也可以打包成 方便 快捷 高级 的安装程序呢？<br>本文将介绍 <code>Inno Setup</code> 及使用 <code>Inno Setup</code> 快捷方便的将应用文件夹打包成安装程序的方法。</p><h1 id="Inno-Setup"><a href="#Inno-Setup" class="headerlink" title="Inno Setup"></a>Inno Setup</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Inno Setup</code> 是一个免费的 Windows 安装程序制作工具，具有以下特点：</p><ul><li>小巧高效（单EXE即可运行）</li><li>支持所有现代Windows版本</li><li>内置多语言支持</li><li>支持脚本扩展功能</li></ul><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>访问 <a href="http://www.jrsoftware.org/isdl.php">官方下载页面</a> 下载最新版本（当前推荐版本：6.4.2）</p><p><img src="https://image.flashfish777.cn/img/post_13_2.jpg" alt="download"></p><p>下面那个 <code>Netherlands</code> 要快一些。</p><h3 id="安装选项"><a href="#安装选项" class="headerlink" title="安装选项"></a>安装选项</h3><p>建议：</p><ul><li>记得安到D盘哦</li><li>剩下全部默认就可以了</li></ul><h2 id="基础打包步骤"><a href="#基础打包步骤" class="headerlink" title="基础打包步骤"></a>基础打包步骤</h2><h3 id="使用脚本向导创建基础脚本"><a href="#使用脚本向导创建基础脚本" class="headerlink" title="使用脚本向导创建基础脚本"></a>使用脚本向导创建基础脚本</h3><p>（推荐）</p><p>通过开始菜单或桌面快捷方式启动 <code>Inno Setup Compiler</code> ，打开之后会有一个 <code>Welcome</code> 窗口:</p><p><img src="https://image.flashfish777.cn/img/post_13_3.png" alt="welcome"></p><p>选择 “<code>Create a new script using the Script Wizard</code>“，点击 <code>OK</code> 。</p><p>也可以通过主程序左上角 <code>File/New</code> 来创建一个新的脚本文件向导。</p><p><code>Inno Setup</code> 的运行原理简单来说就是通过一组脚本规则来创建对应的安装程序，脚本规则中主要包括安装路径、文件夹位置、应用程序配置、语言等等规则，我们要做的就是配置好这些规则，然后运行脚本文件生成安装程序。同时还可以将脚本文件保存下来，打包具有相似配置的应用时直接使用即可。</p><p>接下来直接点击 <code>Next</code> 来到 <code>Application Information</code> (应用信息)界面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Application name : Myproject // 此处填写最终生成的应用名称，及 Myproject.exe</span><br><span class="line">Application version : 1.0 // 此处填写应用的版本</span><br><span class="line">Application publisher : yourname // 发布者信息，什么都可以，非必要</span><br><span class="line">Application website : // 网站网址，非必要</span><br><span class="line"></span><br><span class="line">-&gt; Next</span><br></pre></td></tr></table></figure><p>来到 <code>Application Folder</code> ，这里设定安装完成后的文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Application destination base folder : 默认安装路径，不用动，也可以自定义</span><br><span class="line">Application folder Name : 生成的文件夹名称</span><br><span class="line">允许用户更改安装路径一般为true</span><br><span class="line">第四个不用管</span><br><span class="line"></span><br><span class="line">-&gt; Next</span><br></pre></td></tr></table></figure><p>来到 <code>Application Files</code> ，设定源文件：</p><p><img src="https://image.flashfish777.cn/img/post_13_4.jpg" alt="Application Files"></p><p>点击 <code>Browse</code> 选择要打包应用的可执行文件 (<code>exe</code>)，然后在下方点击 <code>Add folder</code> 将应用文件夹全部添加上去即可 Next 。</p><p>下一步 <code>Application File Association</code> 不需要，勾掉（<code>false</code>）就可以了。</p><p>下一步 <code>Application Shortcuts</code> 默认。</p><p>下一步 <code>Application Documentation</code> 跳过。</p><p>下一步 <code>Setup Install Mode</code> 默认。</p><p>下一步 <code>Application Registry Keys And Values</code> 跳过。</p><p>下一步语言选择英语即可。</p><p>下一步 <code>Compiler Settings</code> 配置安装包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Custom compiler output folder: // 运行脚本文件后安装包生成的目录</span><br><span class="line">Compiler output base file name: LecSnake_Setup // 安装包名称</span><br><span class="line">Custom Setup icon file: // 安装包icon文件，非必要</span><br><span class="line">Setup password: // 安装密码，非必要</span><br><span class="line"></span><br><span class="line">-&gt; Next</span><br></pre></td></tr></table></figure><p>下一步 <code>Inno Setup Preprocessor</code> 保持默认即可。</p><p>点击 Finish 后即可看到生成的脚本文件，在自动弹出的弹窗点击“是”将开始执行脚本，或者在主程序左上角 <code>Run/Run</code> 随时执行脚本文件。等待一段时间执行完成后，在之前填写的 <code>Custom compiler output folder</code> 目录中即可找到安装程序。随后你可以选择保存脚本文件等待下一次的使用。</p><p>BiliBili教程-&gt;</p><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1MZQ8YTEeg&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><hr><h3 id="直接配置脚本文件"><a href="#直接配置脚本文件" class="headerlink" title="直接配置脚本文件"></a>直接配置脚本文件</h3><p>如果你已经了解了创建安装程序的基本规则，并相对熟悉了脚本文件的大致配置你可以直接修改脚本文件来配置规则，这样不仅自由度更高也更加方便修改。</p><p>以下展示大致脚本代码介绍与步骤：</p><h4 id="填写基本信息"><a href="#填写基本信息" class="headerlink" title="填写基本信息"></a>填写基本信息</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Setup]</span><br><span class="line">AppName=My Application</span><br><span class="line">AppVersion=<span class="number">1.0</span></span><br><span class="line">DefaultDirName=<span class="comment">&#123;pf&#125;</span>\MyApp</span><br><span class="line">DefaultGroupName=MyApp</span><br><span class="line">OutputDir=userdocs:Inno Setup Examples Output</span><br></pre></td></tr></table></figure><h4 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h4><p>在脚本的<code>[Files]</code>段添加：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Files]</span><br><span class="line">Source: &quot;C:\MyApp\*&quot;; DestDir: &quot;<span class="comment">&#123;app&#125;</span>&quot;; Flags: ignoreversion recursesubdirs</span><br></pre></td></tr></table></figure><h4 id="创建开始菜单项"><a href="#创建开始菜单项" class="headerlink" title="创建开始菜单项"></a>创建开始菜单项</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Icons]</span><br><span class="line"><span class="keyword">Name</span>: &quot;<span class="comment">&#123;group&#125;</span>\My <span class="keyword">Program</span>&quot;; Filename: &quot;<span class="comment">&#123;app&#125;</span>\MyApp.exe&quot;</span><br></pre></td></tr></table></figure><h4 id="编译脚本"><a href="#编译脚本" class="headerlink" title="编译脚本"></a>编译脚本</h4><p>点击工具栏的”Compile”按钮（或按F9），生成的安装包默认在<code>Output</code>目录</p><h3 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h3><h4 id="添加卸载程序"><a href="#添加卸载程序" class="headerlink" title="添加卸载程序"></a>添加卸载程序</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Setup]</span><br><span class="line">Uninstallable=yes</span><br><span class="line">UninstallFilesDir=<span class="comment">&#123;app&#125;</span>\uninstall</span><br><span class="line"></span><br><span class="line">[UninstallDelete]</span><br><span class="line"><span class="keyword">Type</span>: files; <span class="keyword">Name</span>: &quot;<span class="comment">&#123;app&#125;</span>\config.ini&quot;</span><br></pre></td></tr></table></figure><h4 id="注册表操作"><a href="#注册表操作" class="headerlink" title="注册表操作"></a>注册表操作</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Registry]</span><br><span class="line">Root: HKLM; Subkey: &quot;Software\MyApp&quot;; ValueType: <span class="keyword">string</span>; ValueName: &quot;InstallPath&quot;; ValueData: &quot;<span class="comment">&#123;app&#125;</span>&quot;</span><br></pre></td></tr></table></figure><h4 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Languages]</span><br><span class="line"><span class="keyword">Name</span>: &quot;english&quot;; MessagesFile: &quot;compiler:<span class="keyword">Default</span>.isl&quot;</span><br><span class="line"><span class="keyword">Name</span>: &quot;chinesesimplified&quot;; MessagesFile: &quot;compiler:Languages\ChineseSimplified.isl&quot;</span><br></pre></td></tr></table></figure><h4 id="自定义安装页面"><a href="#自定义安装页面" class="headerlink" title="自定义安装页面"></a>自定义安装页面</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Code]</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">InitializeWizard</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="comment">// 创建自定义页面示例</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>BiliBili:更美化的安装程序 -&gt; </p><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1jQ4y1o7zX&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>好啦，现在你不仅可以将应用程序打包成安装包，更方便的分享给朋友下载，还可以打包出更好看、更高级的安装程序。相信 <code>Inno Setup</code> 会为你带来帮助，我以后也会分享更多有趣、有用的东西，谢谢观看！</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装包 </tag>
            
            <tag> InnoSetup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity进阶学习笔记</title>
      <link href="/posts/bdafbbe3.html"/>
      <url>/posts/bdafbbe3.html</url>
      
        <content type="html"><![CDATA[<div class="note danger info flat"><p><strong>别急。</strong></p></div><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LecSnake - 3d贪吃蛇</title>
      <link href="/posts/5a49393d.html"/>
      <url>/posts/5a49393d.html</url>
      
        <content type="html"><![CDATA[<h1 id="一个Unity新手的3D贪吃蛇开发历程"><a href="#一个Unity新手的3D贪吃蛇开发历程" class="headerlink" title="一个Unity新手的3D贪吃蛇开发历程"></a>一个Unity新手的3D贪吃蛇开发历程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚好放寒假的时候，在大致进行了系统的Unity与C#的学习之后，我觉得我是时候做出一款游戏出来了。尽管之前跟随网上的教程完成过一两个简单的小项目，可那时候毕竟只能算是照猫画虎，学习了这么多知识之后也有必要通过一些项目来把这些知识巩固在脑海中，所以我就打算从头开始，自己做一款小游戏，不管是怎样的，至少先做出来再说吧！<br>我打算从相对简单的开始，不能急于求成。于是我打算做一种3D的贪吃蛇小游戏。因为我认为我这个项目的目的不是做的有多精美，多好玩，而是加强我的基本程序能力、熟练的使用unity编辑器的基础功能，在我需要的时候我能自己学会用什么、点什么、在哪里写些什么，而不是像最初稀里糊涂的跟着教程有样学样。<br>我打算在一个大场景中生成各种障碍物和食物，让贪吃蛇在场景中吃到食物来增加身体长度。在经过一段时间的研究与学习，经历了很多困难的解决与想法的改变后，最终我如愿完成了<strong>LecSnake（我们是卷王）-3D贪吃蛇小游戏</strong>。<br>在这个项目中，我不再是教程的模仿者，而是真正成为了系统的设计者。每一个技术决策背后，都是对Unity编辑器的深入探索和C#编程思维的锤炼。</p><p><img src="https://image.flashfish777.cn/img/post_11_1.jpg" alt="Login"></p><p><img src="https://image.flashfish777.cn/img/post_11_2.jpg" alt="游戏截图"></p><p><a href="https://github.com/flashfish777/LecSnake">项目链接</a></p><hr><h2 id="开发历程"><a href="#开发历程" class="headerlink" title="开发历程"></a>开发历程</h2><h3 id="🐍-贪吃蛇的进化"><a href="#🐍-贪吃蛇的进化" class="headerlink" title="🐍 贪吃蛇的进化"></a>🐍 贪吃蛇的进化</h3><p><strong>第一阶段：物理系统</strong>  </p><p>理想：</p><ul><li>用Rigidbody实现头部运动控制</li><li>通过Joint连接身体部件</li><li>期待呈现自然的物理摆动效果</li></ul><p>现实：</p><ul><li>刚体的摩擦力和重力导致速度不稳定</li><li>多节身体相互碰撞产生”卡顿链式反应”</li><li>惯性作用使转弯时身体完全失控</li></ul><p>一开始，我用刚体圆球来代表蛇的身体，用<code>WASD</code>控制蛇头的前后左右移动，然后用<code>Joint</code>组件来连接身体与身体，需要增加长度时，就在蛇尾部生成一个body球，然后连接到最后。我本想以此模拟顺滑的物理效果，可我发现并非如此。我发现刚体是有摩擦力和重力的，随着身体越来越多移动会越来越困难，这导致速度不平均。于是我花了很长时间磨合摩擦力与重力的数值，想通过调节数值来解决这个问题，最后我发现即使不使用重力不使用摩擦力都不能解决这个问题，于是我又将蛇头的移动方式从按下按键施加力变为简单的每帧改变坐标，我甚至锁定了所有身体的y轴使它们不再接触地面，但即使解决了速度问题依然还有其他问题，例如身体总会不规则的旋转，用线连接的身体也会有惯性导致蛇的身体乱动，而且最终也并没有很好的实现转弯时平滑的物理效果。所以我放弃了使用刚体来模拟物理效果，再次经过了一段时间的探索后，我找到了足够实现我需求的理想方法：</p><p><strong>第二阶段：返璞归真的坐标追踪法</strong>  </p><p>经过两周的反复试验，终于找到优雅的解决方案：</p><ul><li>改用立方体消除不规则旋转</li><li>创建历史坐标队列记录头部轨迹</li><li>身体部件按固定间隔跟随对应坐标</li></ul><p>我将球形身体改为方形，这样连起来更美观且能解决很多问题，然后在蛇的移动上，我使用了一个<code>historyPosition</code>列表存储蛇头走过的位置，然后将身体的坐标逐帧改为对应的坐标，而蛇头则是自动向前，由<code>AD</code>键控制左转和右转，空格加速。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 向前移动</span></span><br><span class="line">    transform.position += transform.forward * moveSpeed * Time.deltaTime;</span><br><span class="line">    <span class="comment">// 加速</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKey(KeyCode.Space))</span><br><span class="line">    &#123;</span><br><span class="line">        moveSpeed = <span class="number">40</span>;</span><br><span class="line">        bodySpeed = <span class="number">40</span>;</span><br><span class="line">        fastCount += Time.deltaTime;</span><br><span class="line">        <span class="keyword">if</span> (fastCount &gt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (score &gt; <span class="number">0</span>) score--;</span><br><span class="line">            fastCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        moveSpeed = <span class="number">20</span>;</span><br><span class="line">        bodySpeed = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方向操控</span></span><br><span class="line">    <span class="built_in">float</span> steerDirection = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">    transform.Rotate(Vector3.up * steerDirection * steerSpeed * Time.deltaTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存位置移动史</span></span><br><span class="line">    positionHistory.Insert(<span class="number">0</span>, transform.position);</span><br><span class="line">    <span class="keyword">while</span> (positionHistory.Count &gt; bodyList.Count * Gap)</span><br><span class="line">        positionHistory.RemoveAt(positionHistory.Count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动身体</span></span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> body <span class="keyword">in</span> bodyList)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 point = positionHistory[Mathf.Clamp(index * Gap, <span class="number">0</span>, positionHistory.Count - <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让贪吃蛇的身体沿头部轨迹运动</span></span><br><span class="line">        Vector3 moveDirection = point - body.transform.position;</span><br><span class="line">        body.transform.position += moveDirection * bodySpeed * Time.deltaTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让身体朝向头部移动的方向</span></span><br><span class="line">        body.transform.LookAt(point);</span><br><span class="line"></span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方案不仅实现了顺滑的蛇体运动，更让我深刻理解了<strong>数据驱动</strong>的设计哲学。当放弃对物理引擎的执念后，问题反而迎刃而解。<br>这样就实现了贪吃蛇的平滑移动了。这是我认为最耗脑筋的一个点，也是用了最长时间的一个点。</p><hr><h3 id="🍎-食物与障碍物"><a href="#🍎-食物与障碍物" class="headerlink" title="🍎 食物与障碍物"></a>🍎 食物与障碍物</h3><p>老实说这个地方没什么好讲的，当时做的时候也是简单完成，唯一值得思考的点就是在随机生成的时候要考虑到重叠生成，比如一个食物生成到一个树（障碍物）里面去了，于是我还思考了一下，考虑将场景分成很多格子来生成物体，随机格子的位置即可：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (num &lt; <span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> x = Random.Range(<span class="number">1</span>, <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">int</span> z = Random.Range(<span class="number">1</span>, <span class="number">32</span>);</span><br><span class="line">    Quaternion spawnRotation = Quaternion.Euler(<span class="number">0</span>, Random.Range(<span class="number">0</span>, <span class="number">360</span>), <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!map[z, x])</span><br><span class="line">    &#123;</span><br><span class="line">        map[z, x] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        x = x &lt;= <span class="number">16</span> ? ((x - <span class="number">17</span>) * <span class="number">2</span> + <span class="number">1</span>) : ((x - <span class="number">16</span>) * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">        z = z &lt;= <span class="number">16</span> ? ((<span class="number">17</span> - z) * <span class="number">2</span> - <span class="number">1</span>) : ((<span class="number">16</span> - z) * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Vector3 spawnPosition = <span class="keyword">new</span> Vector3(x * <span class="number">25</span>, <span class="number">0.5f</span>, z * <span class="number">25</span>);</span><br><span class="line">        Instantiate(Treelist[<span class="number">0</span>], spawnPosition, spawnRotation);</span><br><span class="line"></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用后才发现按这样生成出来的位置都太有规律性了，有时候太整齐不是什么好事。如果贪吃蛇只能四向移动的话这样的生成方法明显更优。</p><p>在贪吃蛇碰到食物或障碍物后会将该物体销毁并执行对应的加分减分操作，然后再在场景一个一个随机位置生成一个对应物体使之不会越来越少。但后来我发现，其实可以在碰到物体时直接随机更改一下物体的坐标就可以了，而不用销毁再生成，省去了不必要的步骤与消费。</p><hr><h3 id="🗺️-小地图的实现"><a href="#🗺️-小地图的实现" class="headerlink" title="🗺️ 小地图的实现"></a>🗺️ 小地图的实现</h3><p>之后我想到在左上角放一个缩略地图的功能，可以更方便玩家查看附近的情况。具体步骤在之前的文章介绍过：<br> <a class="btn-beautify green larger" href="/posts/bf08e6b6.html" title="Unity日记：小地图"><i class="far fa-hand-point-right"></i><span>Unity日记：小地图</span></a></p><p>这个功能的实现，让我对Unity的多摄像机协作有了更深理解。</p><hr><h3 id="⚙️-暂停与设置"><a href="#⚙️-暂停与设置" class="headerlink" title="⚙️ 暂停与设置"></a>⚙️ 暂停与设置</h3><p>我添加了暂停按钮，通过<code>Time.timeScale</code>调整游戏的时间状态，并添加了一些选项设置。通过调节摄像机与音频给玩家带来不同的体验。</p><p><img src="https://image.flashfish777.cn/img/post_11_3.jpg" alt="暂停的设置界面"></p><p>这个模块的开发，让我体会到<strong>系统隔离</strong>的重要性。</p><hr><h3 id="🔄-主界面场景切换"><a href="#🔄-主界面场景切换" class="headerlink" title="🔄 主界面场景切换"></a>🔄 主界面场景切换</h3><p>做到这里主要的功能基本就完成了，最后我想给游戏添加一个开始界面与背景，于是便在游戏启动时默认播放一个描述背景故事的视频，点击可以跳过，随后便进入开始界面。<br><img src="https://image.flashfish777.cn/img/post_11_1.jpg" alt="开始界面"></p><p>我将它放在了一个独立的场景里，在场景中房里几颗树木烘托氛围。当玩家点击开始后就会跳转到游戏的主场景了。关于场景切换，在之前的文章亦有记载：</p><a class="btn-beautify red larger" href="/posts/fdbe57b8.html#%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD" title="Unity日记：场景切换与并发编程-异步加载"><i class="far fa-hand-point-right"></i><span>Unity日记：场景切换与并发编程-异步加载</span></a><p>在这个过程中，我真正理解了游戏状态管理的艺术。</p><hr><h3 id="💾-存档系统"><a href="#💾-存档系统" class="headerlink" title="💾 存档系统"></a>💾 存档系统</h3><p>在最后的最后，一款能让人玩下去的游戏一定离不开存档，于是我了解并学习了有关数据持久化的相关知识，并为我的贪吃蛇游戏添加了存档。存档实现的详情见以下文章：</p><a class="btn-beautify yellow larger" href="/posts/posts/a985624f.html#%E7%A4%BA%E4%BE%8B-1" title="Unity日记：存档系统-JSON-示例"><i class="far fa-hand-point-right"></i><span>Unity日记：存档系统-JSON-示例</span></a><p>我存储了食物和障碍物的坐标列表、<code>historyPosition</code>列表以及得分等数据简单实现了贪吃蛇游戏的存档系统。</p><p>2024年12月续：值得一提的是，我在面试微派的时候，面试官曾问我有没有想过不存食物和障碍物的坐标且仍能实现存档，当时我还云里雾里，知道面试官提了随机数种子的概念，我才想到可以用相同的随机数种子，生成的随机坐标就是和上一次一样的坐标了，障碍物和食物也会在原先的位置，这样只需要存以下种子，就依然可以实现存档。妙哉！</p><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个项目最宝贵的收获，是让我建立起<strong>独立解决问题</strong>的自信。当看到自己构思的系统通过自己的努力真正运转起来时，那种喜悦远超复制十个教程项目。期待在下一个项目中挑战更复杂的游戏程序设计，相信我的程序水平会越来越成熟！</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 游戏 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习笔记</title>
      <link href="/posts/9526375f.html"/>
      <url>/posts/9526375f.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p><strong>CSharp知识点</strong></p></div><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><table><thead><tr><th align="left">类型</th><th align="left">描述</th><th align="left">范围</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">bool</td><td align="left">布尔值</td><td align="left">True 或 False</td><td align="left">False</td></tr><tr><td align="left">byte</td><td align="left">8 位无符号整数</td><td align="left">0 到 255</td><td align="left">0</td></tr><tr><td align="left">char</td><td align="left">16 位 Unicode 字符</td><td align="left">U +0000 到 U +ffff</td><td align="left">‘\0’</td></tr><tr><td align="left">decimal</td><td align="left">128 位精确的十进制值，28-29 有效位数</td><td align="left">(-7.9 x 1028 到 7.9 x 1028) &#x2F; 100 到 28</td><td align="left">0.0M</td></tr><tr><td align="left">double</td><td align="left">64 位双精度浮点型</td><td align="left">(+&#x2F;-)5.0 x 10-324 到 (+&#x2F;-)1.7 x 10308</td><td align="left">0.0D</td></tr><tr><td align="left">float</td><td align="left">32 位单精度浮点型</td><td align="left">-3.4 x 1038 到 + 3.4 x 1038</td><td align="left">0.0F</td></tr><tr><td align="left">int</td><td align="left">32 位有符号整数类型</td><td align="left">-2,147,483,648 到 2,147,483,647</td><td align="left">0</td></tr><tr><td align="left">long</td><td align="left">64 位有符号整数类型</td><td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td><td align="left">0L</td></tr><tr><td align="left">sbyte</td><td align="left">8 位有符号整数类型</td><td align="left">-128 到 127</td><td align="left">0</td></tr><tr><td align="left">short</td><td align="left">16 位有符号整数类型</td><td align="left">-32,768 到 32,767</td><td align="left">0</td></tr><tr><td align="left">uint</td><td align="left">32 位无符号整数类型</td><td align="left">0 到 4,294,967,295</td><td align="left">0</td></tr><tr><td align="left">ulong</td><td align="left">64 位无符号整数类型</td><td align="left">0 到 18,446,744,073,709,551,615</td><td align="left">0</td></tr><tr><td align="left">ushort</td><td align="left">16 位无符号整数类型</td><td align="left">0 到 65,535</td><td align="left">0</td></tr></tbody></table><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。</p><p>换句话说，它们指的是一个内存位置。使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是由一个变量改变的，其他变量会自动反映这种值的变化。<strong>内置的</strong> 引用类型有：<strong>object</strong>、<strong>dynamic</strong> 和 <strong>string</strong>。</p><h3 id="对象（Object）类型"><a href="#对象（Object）类型" class="headerlink" title="对象（Object）类型"></a>对象（Object）类型</h3><p><strong>对象（Object）类型</strong> 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 <code>System.Object</code> 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。</p><p>当一个值类型转换为对象类型时，则被称为 <strong>装箱</strong>；另一方面，当一个对象类型转换为值类型时，则被称为 <strong>拆箱</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> obj;</span><br><span class="line">obj = <span class="number">100</span>; <span class="comment">// 这是装箱</span></span><br></pre></td></tr></table></figure><h3 id="动态（Dynamic）类型"><a href="#动态（Dynamic）类型" class="headerlink" title="动态（Dynamic）类型"></a>动态（Dynamic）类型</h3><p>您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。</p><p>声明动态类型的语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> &lt;variable_name&gt; = <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> d = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。</p><h3 id="字符串（String）类型"><a href="#字符串（String）类型" class="headerlink" title="字符串（String）类型"></a>字符串（String）类型</h3><p><strong>字符串（String）类型</strong> 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：引号和 @引号。</p><p>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;runoob.com&quot;</span>;</span><br></pre></td></tr></table></figure><p>一个 @引号字符串：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">@&quot;runoob.com&quot;</span>;</span><br></pre></td></tr></table></figure><p>C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\）当作普通字符对待，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">@&quot;C:\Windows&quot;</span>;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;C:\\Windows&quot;</span>;</span><br></pre></td></tr></table></figure><p>@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">@&quot;&lt;script type=&quot;&quot;text/javascript&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;!--</span></span><br><span class="line"><span class="string">    --&gt;</span></span><br><span class="line"><span class="string">&lt;/script&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>用户自定义引用类型有：class（类）、interface（接口） 或 delegate（委托）。我们将在以后的章节中讨论这些类型。</p><h2 id="指针类型（不安全代码）"><a href="#指针类型（不安全代码）" class="headerlink" title="指针类型（不安全代码）"></a>指针类型（不安全代码）</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。</p><p>声明指针类型的语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type* identifier;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span>* cptr;</span><br><span class="line"><span class="built_in">int</span>* p1, p2, p3;</span><br><span class="line"><span class="built_in">int</span>*[] p4; <span class="comment">// p4是 指针的数组 而不是 数组的指针</span></span><br><span class="line"><span class="keyword">void</span>* p5; <span class="comment">// 指向未知类型的指针</span></span><br><span class="line"><span class="built_in">int</span>** p6; <span class="comment">// 指针的指针</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>当一个代码块使用 <strong>unsafe</strong> 修饰符标记时，C# 允许在函数中使用指针变量。<strong>不安全代码</strong>或非托管代码是指使用了<strong>指针</strong>变量的代码块</p><p>您可以使用 <strong>ToString()</strong> 方法检索存储在指针变量所引用位置的数据。下面的实例演示了这点：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UnsafeCodeApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">unsafe</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> <span class="keyword">var</span> = <span class="number">20</span>;</span><br><span class="line">                <span class="built_in">int</span>* p = &amp;<span class="keyword">var</span>;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Data is: &#123;0&#125; &quot;</span> , <span class="keyword">var</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Data is: &#123;0&#125; &quot;</span> , p-&gt;ToString());</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Address is: &#123;0&#125; &quot;</span> , (<span class="built_in">int</span>)p);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Data is: 20</span><br><span class="line">Data is: 20</span><br><span class="line">Address is: 77128984</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>为了编译不安全代码，您必须切换到命令行编译器指定 <strong>&#x2F;unsafe</strong> 命令行。</p><p>例如，为了编译包含不安全代码的名为 prog1.cs 的程序，需在命令行中输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csc /unsafe prog1.cs</span><br></pre></td></tr></table></figure><hr><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul><li>在namespace语句块中声明枚举（常用）</li><li>在class、struct语句块中也可以声明枚举</li><li><strong>枚举不能在函数语句块中声明！</strong></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Enum_practise</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">enum</span> Day &#123;</span><br><span class="line">        Sun,</span><br><span class="line">        Mon,</span><br><span class="line">        Tue,</span><br><span class="line">        Wed,</span><br><span class="line">        Thu,</span><br><span class="line">        Fri,</span><br><span class="line">        Sat</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnumTest</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Day today = Day.Sun;</span><br><span class="line">            <span class="keyword">switch</span> (today)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> Day.Sun:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期日&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Mon:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期一&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Tue:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期二&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Wed:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期三&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Thu:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;V我50&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Fri:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期五&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Day.Sat:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;今天星期六&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量类型可以是所有变量类型</span></span><br><span class="line"><span class="built_in">int</span>[] arr1;</span><br><span class="line"><span class="built_in">int</span>[] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">int</span>[] arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] arr4 = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] arr5 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[,] arr;</span><br><span class="line"><span class="built_in">int</span>[,] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">int</span>[,] arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>, <span class="number">3</span>] &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                              &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">                              &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">int</span>[,] arr4 = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                              &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">                              &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">int</span>[,] arr5 = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">                &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><h2 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h2><p><strong>真正的数组的数组。与二维数组的区别：每个一维数组的长度可以不一样。</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[][] arr;</span><br><span class="line"><span class="built_in">int</span>[][] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][];</span><br><span class="line"><span class="built_in">int</span>[][] arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][] &#123; <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                              <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">5</span> &#125;,</span><br><span class="line">                              <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">6</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">int</span>[][] arr4 = <span class="keyword">new</span> <span class="built_in">int</span>[][] &#123; <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                              <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">5</span> &#125;,</span><br><span class="line">                              <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">6</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">int</span>[][] arr5 = &#123; <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">                 <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">4</span>, <span class="number">5</span> &#125;,</span><br><span class="line">                 <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">6</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h1><h2 id="ref-和-out"><a href="#ref-和-out" class="headerlink" title="ref 和 out"></a>ref 和 out</h2><h3 id="按引用传递参数（ref）"><a href="#按引用传递参数（ref）" class="headerlink" title="按引用传递参数（ref）"></a>按引用传递参数（ref）</h3><p>引用参数是一个对变量的<strong>内存位置的引用</strong>。当按引用传递参数时，与值参数不同的是，它不会为这些参数创建一个新的存储位置。引用参数表示与提供给方法的实际参数具有相同的内存位置。</p><p>在 C# 中，使用 <strong>ref</strong> 关键字声明引用参数。下面的实例演示了这点：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> x, <span class="keyword">ref</span> <span class="built_in">int</span> y</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">int</span> temp;</span><br><span class="line"></span><br><span class="line">         temp = x; <span class="comment">/* 保存 x 的值 */</span></span><br><span class="line">         x = y;    <span class="comment">/* 把 y 赋值给 x */</span></span><br><span class="line">         y = temp; <span class="comment">/* 把 temp 赋值给 y */</span></span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         NumberManipulator n = <span class="keyword">new</span> NumberManipulator();</span><br><span class="line">         <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">         <span class="built_in">int</span> a = <span class="number">100</span>;</span><br><span class="line">         <span class="built_in">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在交换之前，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在交换之前，b 的值： &#123;0&#125;&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 调用函数来交换值 */</span></span><br><span class="line">         n.swap(<span class="keyword">ref</span> a, <span class="keyword">ref</span> b);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在交换之后，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在交换之后，b 的值： &#123;0&#125;&quot;</span>, b);</span><br><span class="line"> </span><br><span class="line">         Console.ReadLine();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在交换之前，a 的值：100</span><br><span class="line">在交换之前，b 的值：200</span><br><span class="line">在交换之后，a 的值：200</span><br><span class="line">在交换之后，b 的值：100</span><br></pre></td></tr></table></figure><p>结果表明，<em>swap</em> 函数内的值改变了，且这个改变可以在 <em>Main</em> 函数中反映出来。</p><h3 id="按输出传递参数（out）"><a href="#按输出传递参数（out）" class="headerlink" title="按输出传递参数（out）"></a>按输出传递参数（out）</h3><p>return 语句可用于只从函数中返回一个值。但是，可以使用 <strong>输出参数</strong> 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。</p><p>下面的实例演示了这点：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> x </span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">int</span> temp = <span class="number">5</span>;</span><br><span class="line">         x = temp;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         NumberManipulator n = <span class="keyword">new</span> NumberManipulator();</span><br><span class="line">         <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">         <span class="built_in">int</span> a = <span class="number">100</span>;</span><br><span class="line">         </span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在方法调用之前，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">/* 调用函数来获取值 */</span></span><br><span class="line">         n.getValue(<span class="keyword">out</span> a);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在方法调用之后，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在方法调用之前，a 的值： 100</span><br><span class="line">在方法调用之后，a 的值： 5</span><br></pre></td></tr></table></figure><p>提供给输出参数的变量不需要赋值。当需要从一个参数没有指定初始值的方法中返回值时，输出参数特别有用。请看下面的实例，来理解这一点：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValues</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> x, <span class="keyword">out</span> <span class="built_in">int</span> y </span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;请输入第一个值： &quot;</span>);</span><br><span class="line">          x = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;请输入第二个值： &quot;</span>);</span><br><span class="line">          y = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         NumberManipulator n = <span class="keyword">new</span> NumberManipulator();</span><br><span class="line">         <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">         <span class="built_in">int</span> a , b;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">/* 调用函数来获取值 */</span></span><br><span class="line">         n.getValues(<span class="keyword">out</span> a, <span class="keyword">out</span> b);</span><br><span class="line"></span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在方法调用之后，a 的值： &#123;0&#125;&quot;</span>, a);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;在方法调用之后，b 的值： &#123;0&#125;&quot;</span>, b);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果（取决于用户输入）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请输入第一个值：</span><br><span class="line">7</span><br><span class="line">请输入第二个值：</span><br><span class="line">8</span><br><span class="line">在方法调用之后，a 的值： 7</span><br><span class="line">在方法调用之后，b 的值： 8</span><br></pre></td></tr></table></figure><h3 id="ref-和-out的区别"><a href="#ref-和-out的区别" class="headerlink" title="ref 和 out的区别"></a>ref 和 out的区别</h3><ul><li>ref 传入的变量必须初始化，out 不用 （买票上车）</li><li>out 传入的变量必须在内部赋值，ref 不用 （买票下车）</li></ul><h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><p>变长参数允许在调用方法时传入不定长度的参数。变长参数是一个语法糖，本质上还是基于数组的实现</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>使用 params 关键字可以指定被params修饰的参数在传参时数目可变：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseParams</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">object</span>[] list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(list[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>调用方式主要有三种，第一种是传一个数组，第二种是传n个参数，第三种是不传入参数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UseParams(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="string">&quot;test&quot;</span>&#125;); <span class="comment">// 传入数组</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UseParams(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">// 传入多个参数</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UseParams(); <span class="comment">// 不传参</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>params关键字后面必为数组</li><li>数组类型可以是任意的类型</li><li>函数参数可以有别的参数和params关键字修饰的参数</li><li>函数参数中只能最多出现一个params关键字并且一定是在最后一组参数，前面可以有n个其他参数</li></ul><h2 id="命名实参"><a href="#命名实参" class="headerlink" title="命名实参"></a>命名实参</h2><p>通过命名实参，你可以为形参指定实参，方法是将实参与该形参的名称匹配，而不是与形参在形参列表中的位置匹配。有了命名实参，将不再需要将实参的顺序与所调用方法的形参列表中的形参顺序相匹配。 每个形参的实参都可按形参名称进行指定。 例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintOrderDetails(<span class="string">&quot;Gift Shop&quot;</span>, <span class="number">31</span>, <span class="string">&quot;Red Mug&quot;</span>);</span><br><span class="line"><span class="comment">// 卖家姓名、订单号和产品名称</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用命名实参调用</span></span><br><span class="line">PrintOrderDetails(orderNum: <span class="number">31</span>, productName: <span class="string">&quot;Red Mug&quot;</span>, sellerName: <span class="string">&quot;Gift Shop&quot;</span>);</span><br><span class="line">PrintOrderDetails(productName: <span class="string">&quot;Red Mug&quot;</span>, sellerName: <span class="string">&quot;Gift Shop&quot;</span>, orderNum: <span class="number">31</span>);</span><br></pre></td></tr></table></figure><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>有<strong>参数默认值</strong>的参数，一般称为可选参数。当调用函数时可以不传入该参数，不传就会使用默认值作为参数的值。</p><p>例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExampleMethod</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">required</span>, <span class="built_in">string</span> optionalstr = <span class="string">&quot;default string&quot;</span>, <span class="built_in">int</span> optionalint = <span class="number">10</span></span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line">anExample.ExampleMethod(<span class="number">3</span>); <span class="comment">// 后两个参数为默认值</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li><p>支持多参数默认值，每个参数都可以有默认值</p></li><li><p>如果要混用，可选参数必须写在普通参数后面</p></li><li><p>默认值必须是以下类型的表达式之一：</p><ul><li>常量表达式</li><li><code>new ValType() </code>形式的表达式，其中 <code>ValType</code> 是值类型，例如 <code>enum</code> 或 <code>struct</code></li><li><code>default(ValType)</code> 形式的表达式，其中 <code>ValType</code> 是值类型</li></ul></li><li><p>如果调用方为一系列可选形参中的任意一个形参提供了实参，则它必须为前面的所有可选形参提供实参，实参列表中不支持使用逗号分隔的间隔，如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//anExample.ExampleMethod(3, ,4);</span></span><br></pre></td></tr></table></figure><p>如果想要选择性提供实参，可以使用命名实参来实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anExample.ExampleMethod(<span class="number">3</span>, optionalint: <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>重载允许在<strong>同一作用域内定义多个同名函数</strong>，但这些函数<strong>必须在参数类型、个数或顺序上存在区别</strong>，以便编译器可以根据传递给函数的参数来确定调用哪个函数。在C#中，函数的重载是通过函数签名（函数名称和参数类型、数目以及顺序）来确定的，并不包括返回类型。可以定义相同函数名的函数，只要它们的参数有所不同即可。如果有多个函数符合调用条件，则编译器会选择最匹配的函数。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>命名一组功能相似的函数，减少函数名的数量，避免命名空间的污染</li><li>提升代码复用性与可读性</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ClassOverload CO = <span class="keyword">new</span> ClassOverload();</span><br><span class="line">        CO.GetInfo();</span><br><span class="line">        CO.GetInfo(<span class="number">2</span>);</span><br><span class="line">        CO.GetInfo(<span class="string">&quot;我是第3个重载方法&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        CO.GetInfo(<span class="number">2</span>, <span class="string">&quot;我是第4个重载方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ClassOverload</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是第1个重载方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo</span>(<span class="params"><span class="built_in">int</span> Num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;我是第<span class="subst">&#123;Num&#125;</span>个重载方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo</span>(<span class="params"><span class="built_in">string</span> Name, <span class="built_in">int</span> Num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Name&#125;</span>我有<span class="subst">&#123;Num&#125;</span>个参数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo</span>(<span class="params"><span class="built_in">int</span> Num, <span class="built_in">string</span> Name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Name&#125;</span>我有<span class="subst">&#123;Num&#125;</span>个参数,我的参数顺序与第3个方法不同&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol><li><p>在使用重载时只能通过不同的参数样式</p></li><li><p>不能通过访问权限、返回类型进行重新加载</p></li><li><p>方法的数目不会对重新加载造成影响</p></li><li><p>对于继承来说，如果某一方法在父类中是访问权限是private，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果</p></li><li><p>接口不能重载</p></li></ol><hr><h1 id="结构体（与类的区别）"><a href="#结构体（与类的区别）" class="headerlink" title="结构体（与类的区别）"></a>结构体（与类的区别）</h1><p>结构体提供了一种轻量级的数据类型，适用于表示简单的数据结构，具有较好的性能特性和值语义。</p><p><strong>与类的区别</strong></p><p>类和结构体在设计和使用时有不同的考虑因素，类适合表示复杂的对象和行为，支持继承和多态性，而结构体则更适合表示轻量级数据和值类型，以提高性能并避免引用的管理开销。</p><p>类和结构体有以下几个基本的不同点：</p><p><strong>数据类型：</strong></p><ul><li><strong>结构体是值类型（Value Type）：</strong> 结构体是值类型，它们在栈上分配内存，而不是在堆上。当将结构体实例传递给方法或赋值给另一个变量时，将复制整个结构体的内容。</li><li><strong>类是引用类型（Reference Type）：</strong> 类是引用类型，它们在堆上分配内存。当将类实例传递给方法或赋值给另一个变量时，实际上是传递引用（内存地址）而不是整个对象的副本。</li></ul><p><strong>变量：</strong></p><ul><li>结构体中声明的变量不能直接初始化。</li><li>类可以在声明时对变量初始化。</li></ul><p><strong>继承和多态性：</strong></p><ul><li><strong>结构体不能继承：</strong> 结构体不能继承其他结构体或类，也不能作为其他结构体或类的基类。结构体成员不能指定为 abstract、virtual 或 protected。</li><li><strong>类支持继承：</strong> 类支持继承和多态性，可以通过派生新类来扩展现有类的功能。</li></ul><p><strong>默认构造函数：</strong></p><ul><li><strong>结构体不能有无参数的构造函数、不能定义析构函数：</strong> 结构体不能包含无参数的构造函数。每个结构体都必须有至少一个有参数的构造函数。不能定义析构函数。</li><li><strong>类可以有无参数的构造函数：</strong> 类可以包含无参数的构造函数，如果没有提供构造函数，系统会提供默认的无参数构造函数。</li></ul><p><strong>实例：</strong></p><ul><li>类必须使用 New 操作符才能被实例化。</li><li>结构体可以不使用 New 操作符即可被实例化。如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。</li></ul><p><strong>赋值行为：</strong></p><ul><li>类型为类的变量在赋值时存储的是引用，因此两个变量指向同一个对象。</li><li>结构体变量在赋值时会复制整个结构，因此每个变量都有自己的独立副本。</li></ul><p><strong>传递方式：</strong></p><ul><li>类型为类的对象在方法调用时通过引用传递，这意味着在方法中对对象所做的更改会影响到原始对象。</li><li>结构体对象通常通过值传递，这意味着传递的是结构体的副本，而不是原始结构体对象本身。因此，在方法中对结构体所做的更改不会影响到原始对象。</li></ul><p><strong>可空性：</strong></p><ul><li><strong>结构体是值类型，不能直接设置为 null：</strong> 因为 <strong>null</strong> 是引用类型的默认值，而不是值类型的默认值。如果你需要表示结构体变量的缺失或无效状态，可以使用 <code>Nullable&lt;T&gt;</code> 或称为 <strong>T?</strong> 的可空类型。</li><li><strong>类默认可为null：</strong> 类的实例默认可以为 <code>null</code>，因为它们是引用类型。</li></ul><p><strong>性能和内存分配：</strong></p><ul><li><strong>结构体通常更轻量：</strong> 由于结构体是值类型且在栈上分配内存，它们通常比类更轻量，适用于简单的数据表示。</li><li><strong>类可能有更多开销：</strong> 由于类是引用类型，可能涉及更多的内存开销和管理。</li></ul><hr><h1 id="面向对象理论"><a href="#面向对象理论" class="headerlink" title="面向对象理论"></a>面向对象理论</h1><h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><p><strong>类中一般包含：</strong></p><ul><li>特征——成员变量</li><li>行为——成员方法</li><li>保护特征——成员属性</li><li>构造函数和析构函数</li><li>索引器</li><li>运算符重载</li><li>静态成员</li></ul><p><strong>对象</strong>是类创建出来的，相当于申明一个指定类的变量，类创建对象的过程一般称为实例化对象，类对象都是引用类型的。</p><p><strong>实例化</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p;</span><br><span class="line">Person p2 = <span class="literal">null</span>; <span class="comment">// 与上面相同，没有分配堆内存，栈中为null</span></span><br><span class="line">Person p3 = <span class="keyword">new</span> Person(); <span class="comment">// 分配了堆内存</span></span><br></pre></td></tr></table></figure><h4 id="成员变量和访问修饰符"><a href="#成员变量和访问修饰符" class="headerlink" title="成员变量和访问修饰符"></a>成员变量和访问修饰符</h4><p><strong>成员变量基本规则</strong></p><ul><li>申明在类语句块中</li><li>用来描述对象的特征</li><li>可以是任意变量类型</li><li>数量不作限制</li><li>可以初始化</li><li>是否赋值根据需求来定</li></ul><p><strong>访问修饰符</strong></p><table><thead><tr><th></th><th>当前类</th><th>当前程序集下的类</th><th>其他程序集下的子类</th><th>其他程序集下的类</th></tr></thead><tbody><tr><td>public</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>protected</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>internal（默认）</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>private</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table><p><code>protected internal</code>: 成员可以由当前程序集或子类中的代码访问。</p><p><code>private protected</code>: 成员可以在其定义的类及子类中被访问，但仅当这些子类在同一个程序集中时。</p><p><strong>注意：</strong> 如果没有指定，则使用默认的访问标识符。类的默认访问标识符是 <strong>internal</strong>，成员的默认访问标识符是 <strong>private</strong>。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><strong>基本概念：</strong> 类的 <strong>构造函数</strong> 是类的一个特殊的成员函数，当创建类的新对象时执行。在实例化对象时，会调用的用于初始化的函数。</p><p><strong>写法：</strong> </p><ul><li><strong>构造函数的名称与类的名称完全相同</strong>，它没有任何返回类型。</li><li><strong>默认的构造函数</strong>没有任何参数。但是如果你需要一个带有参数的构造函数可以有参数，这种构造函数叫做<strong>参数化构造函数</strong>。</li><li>没有特殊需求时一般都是public的</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>构造函数可以被重载</li><li><code>this</code>关键字代表当前调用该函数的对象自己，数据类型为当前对象</li><li>如果不自己实现无参构造函数而实现了有参构造函数，会失去默认的无参构造</li></ul><p><strong>特殊写法：</strong></p><p>可以通过 <code>:</code> 运算符重用其他构造函数代码，例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Manager</span> : <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span>(<span class="params"><span class="built_in">int</span> annualSalary</span>) : <span class="title">base</span>(<span class="params">annualSalary</span>) <span class="comment">// 使用基类构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Add further instructions here.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">int</span> weeklySalary, <span class="built_in">int</span> numberOfWeeks</span>) : <span class="title">this</span>(<span class="params">weeklySalary * numberOfWeeks</span>) <span class="comment">// 使用当前类其他构造函数</span></span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做时，当使用此构造函数，函数会先调用 <code>:</code> 之后的构造函数，再执行当前构造函数的代码。</p><h4 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h4><p>主构造函数是 C# 12 中的一项新功能，可用于直接在构造函数参数列表中定义和初始化属性。此功能消除了对重复代码的需要，并使代码更加简洁和可读。</p><p><strong>概念：</strong> 主构造函数是一种简洁的语法，用于声明一个构造函数，其参数在类型的主体中的任何位置都可用。</p><p><strong>注意：</strong> 主构造函数的参数在整个类定义的范围内，因此可以使用它们来初始化属性、字段或其他成员。但是，默认情况下，它们不会存储为字段或属性，除非您显式将它们分配给一个字段或属性。它们也不能作为 或 访问，因为它们不是类的成员。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">string</span> firstName, <span class="built_in">string</span> lastName, DateTime hireDate, <span class="built_in">decimal</span> salary</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; = firstName;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; = lastName;  </span><br><span class="line">    <span class="keyword">public</span> DateTime HireDate &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; = hireDate;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Salary &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; = salary;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码等效于以下没有主构造函数的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> DateTime HireDate &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Salary &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">string</span> firstName, <span class="built_in">string</span> lastName, DateTime hireDate, <span class="built_in">decimal</span> salary</span>)</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        FirstName = firstName;  </span><br><span class="line">        LastName = lastName;  </span><br><span class="line">        HireDate = hireDate;  </span><br><span class="line">        Salary = salary;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特殊写法：</strong> 使用主构造参数时仍可使用 <code>this</code> 或 <code>base</code> 关键字，使用特殊写法调用其他构造函数。</p><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p><strong>基本概念：</strong> 类的 <strong>析构函数</strong> 是类的一个特殊的成员函数，当类的对象超出范围时执行。当引用类型的堆内存被回收时，会调用该函数</p><p><strong>写法</strong>： 析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。</p><p><strong>注意：</strong></p><ul><li>析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载</li><li>对于需要手动管理内存的语言（比如c++），需要在析构函数中做一些内存回收处理，但是c#中存在自动垃圾回收机制GC，所以几乎不会这怎么使用析构函数，除非你想在某一个对象被垃圾回收时，做一些特殊处理</li><li>在Unity开发中析构函数几乎不会使用，所以该知识点只做了解即可</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Person() &#123;&#125; <span class="comment">// 析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="垃圾回收机制（GC）"><a href="#垃圾回收机制（GC）" class="headerlink" title="垃圾回收机制（GC）"></a>垃圾回收机制（GC）</h4><p><strong>概念：</strong></p><p>在编写程序时，会产生很多的数据 比如:int string 变量，这些数据都存储在内存里，如果不合理的管理他们，就会内存溢出导致程序崩溃。C#内置了自动垃圾回收GC，在编写代码时可以不需要担心内存溢出的问题 变量失去引用后 GC会帮我们自动回收，但不包括数据流，和一些数据库的连接，这就需要我们手动的释放资源</p><p><strong>垃圾回收</strong>，英文简写<strong>GC</strong>（<code>Garbage Collector</code>）。垃圾回收的过程是在遍历堆（Heap）上动态分配的所有对象，通过识别它们是否被引用来确定哪些对象是垃圾，哪些对象仍要被使用。所谓的垃圾就是没有被任何变量、对象引用的内容，垃圾就需要被回收释放。</p><p>垃圾回收有很多种算法，比如引用计数（Reference Counting）、标记清除（Mark Sweep）、标记整理（Mark Compact）、复制整合（Copy Collection）等。</p><p><strong>机制：</strong></p><p>代的概念：代是垃圾回收机制使用的一种算法（分代算法），新分配的对象都会被配置在弟0代内存中，每次分配都可能会进行垃圾回收以释放内存（0代内存满时），大对象总被认为是第二代内存，不会对大对象进行搬迁压缩，目的是减少性能损耗，85000字节（83kb）以上的对象为大对象。</p><p>过程：垃圾回收共分3代，每次创建对象的时候 都是在第0代分配内存，并且每一代都配有初始内存空间。假设现在程序已经跑了一段时间了，而第0代分配的空间已经满了，<strong>这时候就会进行垃圾回收，把失去引用的对象释放</strong>，此时未使用完的对象将进入到第1代。垃圾回收后，第0代就已经空了，后面创建的对象就会重新放入第0代，以此类推。0代满后，又会重新垃圾回收，还在使用的对象又会放入第1代，此后运行一段时间 1代也已经满了，而0代还在使用的对象也会移动到1代，这时候已经不够放了，又会进行垃圾回收，1代的将移动到2代，0代的将移动到1代（即1代进行垃圾回收时0代也会同时进行垃圾回收），以此类推。假如代数都满了，但对象都还在使用，并没有回收多少，这时GC就会自动的把初始内存给扩大，比如原来2MB扩大到4MB，还不够使用的情况下内存就满了，就会抛出异常。</p><p>**注意：**GC只负责堆内存的垃圾回收，引用类型都是存在堆中的，所以它们的分配和释放都通过垃圾回收机制来管理。栈上的内存是由系统自动管理的，值类型是在栈中分配内存的，它们有自己的生命周期，不用对他们进行管理，会自动分配和释放。</p><p><strong>手动执行垃圾回收：</strong></p><p>垃圾回收一般情况下是自动执行，如果想要手动执行垃圾回收，需要调动此行代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GC.Collect();</span><br></pre></td></tr></table></figure><p>一般情况下不会频繁进行垃圾回收，因为垃圾回收过程比较复杂耗时，可能会造成程序卡顿，通常在Loading界面时顺便进行一次垃圾回收。</p><h4 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h4><p><strong>概念：</strong></p><p>用于保护成员变量，为成员变量的获取和赋值添加逻辑处理。解决访问修饰符的局限性。属性可以让成员变量在外部只能获取不能修改或者只能修改不能获取。</p><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符  属性类型  属性名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span>&#123;&#125; <span class="comment">//get需要返回值，没有返回值就会报错</span></span><br><span class="line">    <span class="keyword">set</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 可以在设置之前添加一些逻辑规则</span></span><br><span class="line">            <span class="comment">// 实现加密等操作</span></span><br><span class="line">            name = <span class="keyword">value</span>; </span><br><span class="line">            <span class="comment">// value关键字，表示外部传入的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 可以在返回之前添加一些逻辑规则</span></span><br><span class="line">            <span class="comment">// 实现解密等操作</span></span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">            <span class="comment">// 这个属性可以获取内容</span></span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">p.Name = <span class="string">&quot;LiMing&quot;</span>; <span class="comment">// &#x27;=&#x27; 默认调用set</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(p.Name); <span class="comment">// 直接使用默认调用get</span></span><br></pre></td></tr></table></figure><p><strong>成员属性中get和set前可以加访问修饰符：</strong> 默认不加会使用属性声明时的权限，加的访问修饰符要低于属性的访问权限，不能让set和get的访问权限都低于属性权限。</p><p><strong>自动属性</strong><br>类似于自动的成员变量，set和get会自动生成成员变量将他们包裹起来。</p><p>作用：外部能得不能改的特征，如果类中有一个特征是只希望外部能得不能改的，又没有什么特殊处理，就可以直接使用自动属性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> Height</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//没有在set,get中写逻辑的需求或者想法</span></span><br><span class="line">    <span class="keyword">get</span>;</span><br><span class="line">    <span class="keyword">set</span>;</span><br><span class="line">    <span class="comment">//可以添加访问修饰符</span></span><br><span class="line">    <span class="comment">//如：private set;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> Sex &#123; <span class="keyword">set</span>; <span class="keyword">get</span>; &#125; = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h4><p><strong>概念：</strong> 索引器允许通过类实例的索引来访问该类的实例成员。它的声明类似于属性，但具有参数。通常情况下，索引器用于允许类的实例像数组一样通过索引进行访问。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Person[] friends;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Person <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> friends[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// value代表传入的值</span></span><br><span class="line">            friends[index] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">p[<span class="number">0</span>] = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>索引器支持多维索引</li><li>C#允许对索引器进行重载</li><li>索引器可以具有多个参数，但每个参数的类型必须唯一</li><li>索引器的参数可以是值类型或引用类型</li><li>可以根据需要只声明 get 或 set 访问器，但至少必须实现其中一个</li></ul><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p><strong>概念：</strong></p><p>静态关键字：<code>static</code>，用static修饰的成员变量，方法，属性等称为静态成员。静态成员可以直接用类名点出来使用。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//静态成员变量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">float</span> PI=<span class="number">3.1415926f</span>;</span><br><span class="line">   <span class="comment">//成员变量</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> testInt=<span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//静态成员方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">CalcCircle</span>(<span class="params"><span class="built_in">float</span> r</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> PI*r*r;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//成员方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">     Console.WriteLine(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(Test.PI);</span><br><span class="line">Console.WriteLine（Test.CalcCircle(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p><strong>原理：</strong></p><p>为什么可以点出来使用：静态成员会有一片静态存储空间，与程序同生共死，一般不参与垃圾回收机制（除非静态引用变量定义为Null,才会参与垃圾回收）</p><p>程序不是无中生有的，我们要使用对象，变量，函数都是要在内存中分配内存空间，在程序中产生一个抽象的对象。</p><p>静态成员的特点：程序开始运行时就分配内存空间，所以我们可以直接使用。静态成员与程序同生共死，只要使用了它，直到程序结束才会被释放，一个静态成员有唯一的小房间，静态成员就有了唯一性。</p><p><strong>注意：</strong></p><ul><li>静态函数不能使用非静态成员，非静态函数可以使用静态成员</li><li>const常量和静态变量都可以通过类名点出来使用，但const常量必须初始化，不能修改，static没有这个规则，static可以修饰很多。const常量一定是写在访问修饰符后面，而static没有这个要求。</li></ul><h4 id="静态类和静态构造函数"><a href="#静态类和静态构造函数" class="headerlink" title="静态类和静态构造函数"></a>静态类和静态构造函数</h4><p><strong>静态类：</strong> 用<code>static</code>关键字修饰的类称作静态类，静态类只能包含静态成员且不能被实例化。例如<strong>Console</strong>就是一个静态类。</p><p><strong>作用：</strong> 将常用的静态成员写在静态类中，方便使用。静态类不能被实例化，更能体现工具类的唯一性。</p><p><strong>静态构造函数：</strong> 用<code>static</code>关键字修饰的构造函数为静态构造函数，静态类和普通类都可以有静态构造函数。静态构造函数不能使用访问修饰符、不能有参数且只会自动调用一次。</p><p><strong>作用：</strong> 静态构造函数用于初始化静态变量。</p><p>静态构造函数不可继承、不可被直接调用，当创建类实例或引用任何静态成员之前，静态构造函数被自动执行，并且只执行一次。</p><h4 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h4><p><strong>概念：</strong> 为现有的非静态变量类型添加新方法。</p><p><strong>作用：</strong></p><ul><li>提升程序拓展性</li><li>不需要在对象中重新写方法</li><li>不需要继承来添加方法</li><li>为别人封装的类型写额外的方法</li></ul><p><strong>特点：</strong></p><ul><li>一定是写在静态类中</li><li>一定是个静态函数</li><li>第一个参数为拓展目标</li><li>第一个参数用this修饰</li></ul><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 返回值 函数名(<span class="keyword">this</span> 拓展类名 参数名, 参数类型 参数名, 参数类型 参数名, ...)</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为int拓展了一个成员方法</span></span><br><span class="line">    <span class="comment">//成员方法是需要实例化对象后才能使用的</span></span><br><span class="line">    <span class="comment">//value代表使用该方法的实例化对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpeakValue</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拓展的方法的逻辑</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;为int的拓展方法&quot;</span> + <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpeakStringInfo</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> str, <span class="built_in">string</span> str2, <span class="built_in">string</span> str3</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;为string拓展的方法&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;调用方法的对象&quot;</span> + str);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;传的参数&quot;</span> + str2 + str3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun2</span>(<span class="params"><span class="keyword">this</span> Test t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是为Test类拓展的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是自带的成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">i.SpeakValue();</span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;000&quot;</span>;</span><br><span class="line">str.SpeakStringInfo(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line">t.Fun2();</span><br></pre></td></tr></table></figure><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p><strong>概念：</strong> 让自定义类和结构体能够使用运算符。</p><p><strong>关键字：</strong> <code>operator</code></p><p><strong>特点：</strong></p><ul><li>一定是一个公共的静态方法</li><li>返回值写在operator前</li><li>逻辑处理自定义</li></ul><p><strong>作用：</strong> 让自定义类和结构体对象可以进行运算。</p><p><strong>注意：</strong></p><ul><li><p>二元运算符需要成对实现</p><ul><li><p><code>==</code>（相等）对应 <code>!=</code>（不等）</p></li><li><p><code>&gt;</code>（大于）对应 <code>&lt;</code>（小于）</p></li><li><p><code>&gt;=</code>（大于等于）对应 <code>&lt;=</code>（小于等于）</p></li></ul></li><li><p>一个符号可以多个重载</p></li><li><p>不能使用 ref 和 out </p></li><li><p>参数列表至少要有一个当前类（或结构体）类型的参数</p></li></ul><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回类型 <span class="keyword">operator</span> 运算符( 参数列表 )</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> x;</span><br><span class="line">    <span class="built_in">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span>+(Point p1, Point p2)</span><br><span class="line">    &#123;</span><br><span class="line">        Point p = <span class="keyword">new</span> Point();</span><br><span class="line">        p.x = p1.x + p2.x;</span><br><span class="line">        p.y = p1.y + p2.y;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point();</span><br><span class="line">p.x = <span class="number">1</span>;</span><br><span class="line">p.y = <span class="number">1</span>;</span><br><span class="line">Point p2 = <span class="keyword">new</span> Point();</span><br><span class="line">p2.x = <span class="number">2</span>;</span><br><span class="line">p2.y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">Point p3 = p + p2;</span><br></pre></td></tr></table></figure><h4 id="内部类和分部类"><a href="#内部类和分部类" class="headerlink" title="内部类和分部类"></a>内部类和分部类</h4><p><strong>内部类：</strong> 在一个类中声明的类。</p><p><strong>特点：</strong> 使用时要用包裹者点出自己。</p><p><strong>作用：</strong> 亲密关系的变现 。</p><p><strong>注意：</strong> 访问修饰符作用很大。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> Body body;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Body</span></span><br><span class="line">    &#123;</span><br><span class="line">        Arm leftArm;</span><br><span class="line">        Arm rightArm;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">class</span> <span class="title">Arm</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person.Body body = <span class="keyword">new</span> Person.Body();</span><br></pre></td></tr></table></figure><p><strong>分部类：</strong> 把一个类分成几部分声明（关键字：<code>partial</code>）。</p><p><strong>作用：</strong> 增加程序的拓展性。</p><p><strong>注意：</strong></p><ul><li>分部类可以写在不同的脚本文件中</li><li>分部类的访问修饰符要一致</li><li>分部类中不能有重复成员</li></ul><p><strong>分部方法：</strong> 将方法的声明和实现分离（局限性大，了解即可）。</p><p><strong>特点：</strong></p><ul><li>不能加访问修饰符，默认私有</li><li>只能在分部类中声明</li><li>返回值只能是void</li><li>可以有参数但不能用 out 关键字</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> number;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"><span class="built_in">int</span> speed</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetHeight</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"><span class="built_in">int</span> speed</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承的基本原则"><a href="#继承的基本原则" class="headerlink" title="继承的基本原则"></a>继承的基本原则</h4><p><strong>基本概念：</strong> 当一个类A继承一个类B时，类A将会继承类B的所有成员，A类将拥有B类的所有特征和行为。被继承的类称为父类、基类、超类，继承的类称为子类、派生类。子类可以有自己的特征和行为。</p><p><strong>特点：</strong></p><ul><li>单根性：子类只能有一个父类（单继承）</li><li>传递性：子类可以间接继承父类的父类</li></ul><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 : 被继承的类名</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同名成员：</strong> 在子类中出现与父类同名的成员，默认将父类的成员覆盖，也可以使用<code>new</code>关键字表示覆盖，但极其不建议使用同名成员。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">new</span> <span class="built_in">string</span> name;</span><br></pre></td></tr></table></figure><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><p>里氏替换原则是面向对象七大原则中最重要的原则</p><p><strong>基本概念：</strong> 任何父类出现的地方，子类都可替代。</p><p><strong>重点：</strong> 语法表现——父类容器装子类对象，因为子类对象包含了父类的所有内容。</p><p><strong>作用：</strong> 方便进行对象存储和管理。</p><p><strong>基本实现：</strong> 用父类容器装载子类对象</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Monster</span> : <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Boss</span> : <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">GameObject player = <span class="keyword">new</span> Player();</span><br><span class="line">GameObject[] objects = <span class="keyword">new</span> GameObject[] &#123; <span class="keyword">new</span> Player(), <span class="keyword">new</span> Monster(), <span class="keyword">new</span> Boss() &#125;;</span><br></pre></td></tr></table></figure><p><strong>is 和 as 关键字：</strong></p><ol><li><p><code>is</code>：判断一个类对象是否是指定类对象，返回值为<code>bool</code>，是为真，不是为假</p></li><li><p><code>as</code>：将一个对象转换为指定类对象，返回值为指定类型对象，成功返回指定类型对象，失败返回<code>null</code></p></li><li><p>基本语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 书接上回</span></span><br><span class="line"><span class="keyword">if</span> (player <span class="keyword">is</span> Player)</span><br><span class="line">&#123;</span><br><span class="line">    Player p = player <span class="keyword">as</span> Player;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注：不能用子类容器装父类对象</strong></p><h4 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h4><p><strong>特点：</strong> 当声明一个子类对象时，先执行父类的构造函数，再执行子类的构造函数。</p><p><strong>注意：</strong> 父类的无参构造很重要。子类可以通过base关键字代表父类，调用父类构造。</p><p><strong>继承中构造函数的执行顺序：</strong> 父类的父类的构造 -&gt; 父类构造 -&gt; 子类构造。子类实例化时，默认自动调用的是父类的无参构造，所以如果父类的无参构造被顶掉，会出错。</p><p><strong>通过base调用指定的父类构造：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Son</span> : <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span>(<span class="params"><span class="built_in">int</span> i</span>) : <span class="title">base</span>(<span class="params">i</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="万物之父和装箱拆箱"><a href="#万物之父和装箱拆箱" class="headerlink" title="万物之父和装箱拆箱"></a>万物之父和装箱拆箱</h4><p><strong>万物之父：</strong> <code>object</code> 是所有类型的基类，它是一个类（引用类型）。</p><p><strong>作用：</strong> 可以利用里氏替换原则，用 <code>object</code> 容器装所有对象。可以用来表示不确定类型，作为函数参数类型。</p><p><strong>装箱拆箱：</strong></p><ul><li>装箱：把值类型用引用类型存储（栈内存会迁移到堆内存中）</li><li>拆箱：把引用类型存储的值取出来（堆内存会迁移到栈内存中）</li><li>好处：不确定类型时可以方便参数的存储和传递</li><li>坏处：存在内存迁移，增加性能消耗</li></ul><h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><p><strong>概念：</strong> 密封类是使用 <code>sealed</code> 密封关键字修饰的类。密封类无法被继承。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Son</span> : <span class="title">Father</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p><strong>作用：</strong> 在面向对象程序设计中，密封类的主要作用就是不允许最底层子类被继承，可以保证程序的规范性，安全性。</p><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="Vob"><a href="#Vob" class="headerlink" title="Vob"></a>Vob</h4><p><strong>多态的概念：</strong> 多态按字面的意思就是“多种状态”，让继承同一父类的子类们 在执行相同方法时有不同的表现（状态）。</p><p><strong>多态的实现：</strong></p><ul><li>编译时多态——函数重载</li><li>运行时多态：Vob、抽象函数、接口</li></ul><p><strong>Vob：</strong></p><ul><li>v： <code>virtual</code>（虚函数）</li><li>o： <code>override</code> （重写）</li><li>b： <code>base</code> （父类）</li><li>（n）： <code>new</code> （覆盖）</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GameObject</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//虚函数 可以被子类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;游戏对象进行攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//重写虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//base的作用</span></span><br><span class="line">        <span class="comment">//代表父类 可以通过base来保留父类的行为</span></span><br><span class="line">        <span class="keyword">base</span>.Atk();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;玩家对象进行攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Monster</span> : <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monster</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;怪物对象进行攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要目的：</strong> 同一父类的对象 执行相同行为（方法）有不同的表现。</p><p><strong>解决的问题：</strong> 让同一个对象有唯一行为的特征。</p><h4 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h4><p><strong>概念：</strong> 被抽象关键字 <code>abstract</code> 修饰的类为抽象类，方法称为抽象方法。</p><p><strong>特点：</strong></p><ul><li>抽象类不能被实例化，但仍可以使用里氏替换原则装它的子类</li><li>抽象方法只能在抽象类中声明，抽象方法没有方法体且不能是私有的</li><li>继承抽象类必须重写其抽象方法</li></ul><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The dog barks.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The cat meows.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p><strong>概念：</strong> 接口是行为的抽象规范，它也是一种自定义类型。关键字： <code>interface</code> 。</p><p><strong>接口声明的规范：</strong></p><ol><li>不能包含成员变量</li><li>只能包含方法、属性、索引器、事件</li><li>成员不能被实现</li><li>成员不能是私有的，但可以不写访问修饰符，默认是公共的</li><li>接口不能继承类，但可以继承另一个接口</li></ol><p><strong>接口的使用规范：</strong></p><ol><li>类可以继承多个接口</li><li>类继承接口后，必须实现接口中所有成员</li></ol><p><strong>特点：</strong></p><ol><li>和类的声明类似</li><li>接口只能用来继承，不能被实例化，但可以作为容器存储对象（里氏替换原则）</li><li>接口名称通常以大写字母 “I” 开头，表示接口（Interface）的含义，然后跟随具体的接口名称</li></ol><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;攻击&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IExampleInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Method1</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method2</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IExampleInterface2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method4</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IExampleInterfaceSon</span> : <span class="title">IExampleInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Method3</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Book</span> : <span class="title">GameObject</span>, <span class="title">IExampleInterfaceSon</span>, <span class="title">IExampleInterface2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method2</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method3</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method4</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显式实现接口：</strong></p><p>当一个类继承多个接口，但接口中存在同名方法时，可以使用显式实现接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Atk</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ISuperAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Atk</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">IAtk</span>, <span class="title">ISuperAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> IAtk.Atk() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> ISuperAtk.Atk() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong> 显式实现接口不能写访问修饰符。</p><h4 id="密封方法"><a href="#密封方法" class="headerlink" title="密封方法"></a>密封方法</h4><p><strong>概念：</strong> 密封方法是使用 <code>sealed</code> 密封关键字修饰的重写方法，让虚方法或抽象方法在之后不能再被重写。</p><p><strong>特点：</strong> 和 <code>override</code> 一起出现。</p><p><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="面向对象七大原则"><a href="#面向对象七大原则" class="headerlink" title="面向对象七大原则"></a>面向对象七大原则</h2><h3 id="开闭原则OCP"><a href="#开闭原则OCP" class="headerlink" title="开闭原则OCP"></a>开闭原则OCP</h3><p>开闭原则是设计原则基础的基础，是面向对象的核心原则，其它原则均围绕开闭原则进行展开。 </p><p><strong>开闭原则指的是一个软件实体应对对扩展开放，对修改关闭(Software entities should be open for extension, but closed for modification)。</strong> 这个原则是说在设计一个模块的时候，应对使这个模块可以在不被修改的前提下被扩展，换言之，应对可以不必修改源代码的情况下改变这个模块的行为。 </p><p><strong>满足开闭原则的软件系统的优越性：</strong> </p><ul><li><p>通过扩展已有的软件系统，可以提供新的行为，以满足对软件的新需求，使变化中的软件系统有一定的适应性和灵活性</p></li><li><p>已有的软件模块，特别是最重要的抽象层模块不能再修改，这就使变化中的软件系统有一定的稳定性和延续性</p></li></ul><p><strong>实现开闭原则的关键：</strong></p><p>抽象化是解决问题的关键，在面向对象的编程语言里，可以给系统定义出一套相对较为固定的抽象设计，此设计允许无穷无尽的行为在实现层被实现。在语言里，可以给出一个或多个抽象类或者接口，规定出所有的具体类必须提供的方法的特征作为系统设计的抽象层。这个抽象层预见了所有的可扩展性，因此，在任何扩展情况下都不会改变。这就使得系统的抽象不需要修改，从而满足了开闭原则的第二条，对修改关闭。 </p><p>同时，由于从抽象层导出一个或多个新的具体类可以改变系统的行为，因此系统的设计对扩展是开放的，这就满足了开闭原则的第一条。 </p><p><strong>对可变性的封装原则：</strong> </p><p><strong>把变化的东西封装起来，把不变的抽象出来。</strong> 这是对开闭原则的另外一种描述，它讲的是找到一个系统的可变因素，将之封装起来。该原则意味着两点: </p><ul><li><p>一种可变性不应当散落在代码的很多角落，而应当封装到一个对象里面。继承应当被看做是封装变化的方法，而不应该被认为是一种从一般对象生成特殊对象的方法</p></li><li><p>一种可变性不应当与另外一种可变性混合在一起。这意味着一般的继承层次不会超过两层</p></li></ul><h3 id="里氏替换原则LSP"><a href="#里氏替换原则LSP" class="headerlink" title="里氏替换原则LSP"></a>里氏替换原则LSP</h3><p>任何基类可以出现的地方，子类一定可以出现。<strong>即父类存在的地方，子类是可以替换的。</strong> 替换后行为不变，结果会变化。调用子类行为。 子类和父类必须有相同行为才能完全地实现替换。 </p><p>实现开闭原则的关键是抽象化，而里氏代换原则中的基类和子类的继承关系正是抽象化的具体体现，所以里氏代换原则是对实现抽象化的具体步骤的规范。违反里氏代换原则一个最经典的例子便是把正方形设计成长方形的子类。</p><h3 id="依赖倒置原则DIP"><a href="#依赖倒置原则DIP" class="headerlink" title="依赖倒置原则DIP"></a>依赖倒置原则DIP</h3><p><strong>要依赖于抽象，不要依赖于实现。</strong> 说的白一点就是要依赖于抽象类和接口不要依赖具体类，具体类也就是我们可以用new关键字实例化的类。依赖倒转原则是实现开闭原则的一个手段。</p><h3 id="单一职责原则SRP（体现高内聚）"><a href="#单一职责原则SRP（体现高内聚）" class="headerlink" title="单一职责原则SRP（体现高内聚）"></a>单一职责原则SRP（体现高内聚）</h3><p><strong>每一个类应该专注于做一件事情。</strong></p><h3 id="接口隔离原则ISP"><a href="#接口隔离原则ISP" class="headerlink" title="接口隔离原则ISP"></a>接口隔离原则ISP</h3><p><strong>应当为客户端提供尽可能小的单独接口，而不要提供大的总接口。</strong> 暴露行为让后面的实现类知道的越少越好。</p><h3 id="迪米特法则（体现松偶合）"><a href="#迪米特法则（体现松偶合）" class="headerlink" title="迪米特法则（体现松偶合）"></a>迪米特法则（体现松偶合）</h3><p><strong>又叫最少知识原则，一个对象对另一个对象知道的越少越好，即一个软件实体应当尽可能少的与其他实体发生相互作用。</strong></p><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p><strong>要尽量使用合成&#x2F;聚合达到复用，而不是继承关系达到复用的目的。尽量少用继承。</strong> 就如我们前面说的，如果为了复用，便使用继承的方式将两个不相干的类联系在一起，这样的方式是违反合成&#x2F;聚合复用原则的，更进一步的后果那便是违反里氏代换原则。合成&#x2F;聚合复用和里氏代换原则相辅相成，合成&#x2F;聚合复用原则要求我们在复用时首先考虑合成&#x2F;聚合关系，而里氏代换原则是要求我们在使用继承时，必须满足一定的条件。 </p><p><strong>原则：一个类中有另一个类的对象。</strong></p><hr><h2 id="面向对象设计模式"><a href="#面向对象设计模式" class="headerlink" title="面向对象设计模式"></a>面向对象设计模式</h2><p><a href="https://blog.csdn.net/JSANXWT/article/details/126479362">面向对象设计的23种设计模式</a></p><hr><h2 id="面向对象相关"><a href="#面向对象相关" class="headerlink" title="面向对象相关"></a>面向对象相关</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>命名空间是用来组织和重用代码的，就像是一个工具包，类就像是一件一件的工具，都是声明在命名空间中的。命名空间的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。</p><p><strong>定义：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">namespace_name</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>命名空间可以分开声明且可以嵌套：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyGame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyGame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">GameObject</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">UI</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">TestUI</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">Image</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">TestImage</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同一命名空间下不能含有同名类，不同命名空间下可以含有同名类：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Run</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Move</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Fly</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Move</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>1.使用 <code>using</code> 关键字引用其他命名空间使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MyGame; <span class="comment">// 只如此引用仍要通过指明出处才能引用该命名空间下的命名空间的类</span></span><br><span class="line"><span class="keyword">using</span> MyGame.UI; <span class="comment">// 如此引用只能使用UI命名空间的类，可以与MyGame同时引用</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Now</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameObject gameobject = <span class="keyword">new</span> GameObject();</span><br><span class="line">        Player player = <span class="keyword">new</span> Player();</span><br><span class="line">        TestUI testUI = <span class="keyword">new</span> TestUI();</span><br><span class="line">        </span><br><span class="line">        MyGame.Image.TestImage testImage = <span class="keyword">new</span> MyGame.Image.TestImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.指明出处使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Now</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.Console.WriteLine(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        MyGame.GameObject gameObject = <span class="keyword">new</span> MyGame.GameObject();</span><br><span class="line">        MyGame.Player player = <span class="keyword">new</span> MyGame.Player();</span><br><span class="line">        MyGame.Image.TestImage testImage = <span class="keyword">new</span> MyGame.Image.TestImage();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同名类只能通过指明出处使用</span></span><br><span class="line">        Run.Move move1 = <span class="keyword">new</span> Run.Move();</span><br><span class="line">        Fly.Move move2 = <span class="keyword">new</span> Fly.Move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（引用命名空间后也可指明出处使用）</p><p><strong>注：命名空间中的类默认为 internal 。</strong></p><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><h4 id="object中的静态方法"><a href="#object中的静态方法" class="headerlink" title="object中的静态方法"></a>object中的静态方法</h4><p><strong>静态方法 <code>Equals</code> ：</strong></p><p>判断两个对象是否相等。最终的判断权交给左侧对象的 Equals 成员方法，不管值类型还是引用类型都会按照左侧对象的 Equals 成员方法的规则来进行比较。</p><p><strong>静态方法 <code>ReferenceEquals</code> ：</strong></p><p>比较两个对象是否是相同的引用，主要是用来比较引用类型的对象，值类型对象返回值始终是 false 。</p><h4 id="object中的成员方法"><a href="#object中的成员方法" class="headerlink" title="object中的成员方法"></a>object中的成员方法</h4><p><strong>普通方法 <code>GetType</code> ：</strong></p><p>该方法的主要作用是获取对象运行时的类型 Type ，通过 Type 结合反射相关知识点可以做很多关于对象的操作。该方法在反射相关知识点中是非常重要的方法。</p><p><strong>普通方法 <code>MemberwiseClone</code>  ：</strong></p><p>该方法用于获取对象的浅拷贝对象，意思就是会返回一个新的对象，但是新对象中的引用变量会和老对象中的一致。</p><h4 id="object中的虚方法"><a href="#object中的虚方法" class="headerlink" title="object中的虚方法"></a>object中的虚方法</h4><p><strong>虚方法 <code>Equals</code> ：</strong></p><p>默认实现还是比较两者是否为同一个引用，即相当于 <code>ReferenceEquals</code> 。但是微软在所有类型值的基类 <code>System.ValueType</code> 中重写了该方法，用来比较值相等。我们也可以重写该方法，定义自己的比较规则。</p><p><strong>虚方法 <code>GetHashCode</code> ：</strong></p><p>该方法时获取对象的哈希码（一种通过算法算出的，表示对象的唯一编码，不同对象的哈希码有可能一样，具体值根据哈希算法决定），我们可以通过重写该函数来自己定义对象的哈希码算法，正常情况下，基本不用。</p><p><strong>虚方法 <code>ToString</code> ：</strong></p><p>该方法用于返回当前对象代表的字符串，我们可以重写它定义我们自己的对象转字符串规则，该方法非常常用。当我们调用打印方法时，默认使用的就是对象的 <code>ToString</code> 方法后打印出来的内容。</p><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>, <span class="number">1</span>, <span class="number">3333</span>);</span><br><span class="line">Console.Write(str);</span><br><span class="line"><span class="comment">// 输出 13333</span></span><br></pre></td></tr></table></figure><h4 id="正向查找字符位置"><a href="#正向查找字符位置" class="headerlink" title="正向查找字符位置"></a>正向查找字符位置</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> index = str.IndexOf(<span class="string">&quot;好&quot;</span>); <span class="comment">// 找不到返回-1</span></span><br><span class="line">Console.Write(index);</span><br><span class="line"><span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><h4 id="反向查找指定字符串位置"><a href="#反向查找指定字符串位置" class="headerlink" title="反向查找指定字符串位置"></a>反向查找指定字符串位置</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> index = str.LastIndexOf(<span class="string">&quot;哈哈&quot;</span>); <span class="comment">// 找不到返回-1</span></span><br><span class="line">Console.Write(index);</span><br><span class="line"><span class="comment">// 输出 4</span></span><br></pre></td></tr></table></figure><h4 id="移除指定位置后的字符（包括指定位置）"><a href="#移除指定位置后的字符（包括指定位置）" class="headerlink" title="移除指定位置后的字符（包括指定位置）"></a>移除指定位置后的字符（包括指定位置）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Remove(<span class="number">3</span>); <span class="comment">// 只会返回新字符串，不会修改原字符串</span></span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 你好哈</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Remove(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">// 第二个参数决定移除的字符个数</span></span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 你好哈哈哈</span></span><br></pre></td></tr></table></figure><h4 id="替换指定字符串"><a href="#替换指定字符串" class="headerlink" title="替换指定字符串"></a>替换指定字符串</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Replace(<span class="string">&quot;哈哈&quot;</span>, <span class="string">&quot;嘻嘻&quot;</span>);</span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 你好嘻嘻哈哈</span></span><br></pre></td></tr></table></figure><h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;jhsdgfhsdgfs&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.ToUpper(); <span class="comment">// 转大写</span></span><br><span class="line">newstr = str.ToLower(); <span class="comment">// 转小写</span></span><br></pre></td></tr></table></figure><h4 id="字符串截取（包含指定位置）"><a href="#字符串截取（包含指定位置）" class="headerlink" title="字符串截取（包含指定位置）"></a>字符串截取（包含指定位置）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Substring(<span class="number">2</span>); <span class="comment">// 截取从指定位置开始之后的字符串</span></span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 哈哈哈哈</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;你好哈哈哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> newstr = str.Substring(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 第二个参数表示截取指定个数</span></span><br><span class="line">Console.Write(newstr);</span><br><span class="line"><span class="comment">// 输出 哈哈</span></span><br></pre></td></tr></table></figure><h4 id="字符串切割"><a href="#字符串切割" class="headerlink" title="字符串切割"></a>字符串切割</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;1,2,3,4,5,6,7,8&quot;</span>;</span><br><span class="line"><span class="built_in">string</span>[] strs = str.Split(<span class="string">&#x27;,&#x27;</span>); <span class="comment">// 以逗号切割</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; strs.Length; i ++)</span><br><span class="line">    Console.Write(strs[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">// 输出 1 2 3 4 5 6 7 8</span></span><br></pre></td></tr></table></figure><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p><code>string</code> 是特殊的引用，每次重新赋值或者拼接时会分配新的内存空间，如果一个字符串经常改变会非常浪费空间。</p><p><code>StringBuilder</code> 是c#提供的一个用于处理字符串的公共类，主要解决的问题是：直接修改字符串而不创建新的对象，需要频繁修改和拼接的字符串可以使用它，可以提升性能。</p><p><strong>注意使用时需要引用命名空间</strong></p><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;12213123123&quot;</span>, <span class="number">50</span>); <span class="comment">// 初始化与指定容量（可选）</span></span><br><span class="line"><span class="comment">// StringBuilder始终会有空余容量，超过会自动扩容，每次自动扩容容量翻一倍</span></span><br><span class="line">Console.WriteLine(str.Capacity); <span class="comment">// 获取容量</span></span><br><span class="line">Console.WriteLine(str.Length); <span class="comment">// 获取字符串长度</span></span><br></pre></td></tr></table></figure><p><strong>方法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加</span></span><br><span class="line">str.Append(<span class="string">&quot;8888&quot;</span>); <span class="comment">// 加到字符串末尾</span></span><br><span class="line">str.AppendFormat(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>, <span class="number">444</span>, <span class="number">666</span>); <span class="comment">// 通过拼接的形式添加</span></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">str.Insert(<span class="number">0</span>, <span class="string">&quot;2784356&quot;</span>); <span class="comment">// 插入位置 插入内容</span></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">str.Remove(<span class="number">0</span>, <span class="number">10</span>); <span class="comment">// 起始位置 删除个数</span></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">str.Clear();</span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="comment">// str[1] 直接索引</span></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 直接修改</span></span><br><span class="line"><span class="comment">// 替换</span></span><br><span class="line">str.Replace(<span class="string">&quot;34&quot;</span>, <span class="string">&quot;283645&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>StringBuilder</code> 的所有方法执行后都会直接修改原字符串，不需要重新定义。</p><hr><h1 id="数据结构类"><a href="#数据结构类" class="headerlink" title="数据结构类"></a>数据结构类</h1><h2 id="ArrayList类（可变数组）"><a href="#ArrayList类（可变数组）" class="headerlink" title="ArrayList类（可变数组）"></a>ArrayList类（可变数组）</h2><p><strong>概念：</strong> <code>ArrayList</code> 本质是一个 <code>object</code>类型的数组，实现了很多方法。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引用命名空间 System.Collections</span></span><br><span class="line">ArrayList array = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个增加</span></span><br><span class="line">array.Add(<span class="number">1</span>);</span><br><span class="line">array.Add(<span class="string">&quot;3424&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量增加（把另一个List容器里面的内容全部加到后面）</span></span><br><span class="line">array.AddRange(array2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">array.Insert(<span class="number">1</span>, <span class="string">&quot;12345&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.Remove(<span class="string">&quot;ghfjk&quot;</span>); <span class="comment">// 删除第一个指定元素</span></span><br><span class="line">array.RemoveAt(<span class="number">0</span>); <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">array.Clear(); <span class="comment">// 清空</span></span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到指定位置的元素</span></span><br><span class="line">Console.WriteLine(array[<span class="number">0</span>]); <span class="comment">// 直接读取下标</span></span><br><span class="line"><span class="comment">// 查看元素是否存在</span></span><br><span class="line">array.Contains(<span class="string">&quot;123&quot;</span>); <span class="comment">// 返回bool类型，有就返回true，没有返回false</span></span><br><span class="line"><span class="comment">// 正向查找元素位置</span></span><br><span class="line"><span class="built_in">int</span> index = array.IndexOf(<span class="string">&quot;gfh&quot;</span>); <span class="comment">// 返回元素下标，没有返回-1</span></span><br><span class="line"><span class="comment">// 反向查找元素位置</span></span><br><span class="line">index = array.LastIndexOf(<span class="string">&quot;111&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">0</span>] = <span class="string">&quot;3334&quot;</span>; <span class="comment">// 直接修改</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>装箱拆箱：</strong></p><p><code>ArrayList</code> 本质上是一个可以自动扩容的 <code>object</code> 数组，当往其中进行值类型存储时就是在装箱，当值类型对象取出来转换使用时就是在拆箱，所以 <code>ArrayList</code> 尽量少用，有更好的数据容器。</p><p><strong>注：</strong> <code>ArrayList</code> 同样具有容量，原理和作用与 <code>StringBuilder</code> 相同。</p><h2 id="Stack类（栈）"><a href="#Stack类（栈）" class="headerlink" title="Stack类（栈）"></a>Stack类（栈）</h2><p><strong>概念：</strong> <code>Stack</code> 的本质也是 <code>object</code> 数组，封装了栈的存储规则，栈是一种先进后出的数据结构。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引用命名空间 System.Collections</span></span><br><span class="line">stack stack = <span class="keyword">new</span> Stack();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压栈</span></span><br><span class="line">stack.Push(<span class="number">0</span>);</span><br><span class="line">stack.Push(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>取出</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弹栈</span></span><br><span class="line"><span class="built_in">object</span> v = stack.Pop();</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈无法查看指定位置的元素，只能查看栈顶的内容</span></span><br><span class="line">v = stack.Peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看元素是否存在于栈中</span></span><br><span class="line">stack.Contains(<span class="string">&quot;123&quot;</span>); <span class="comment">// true / false</span></span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈无法改变其中的元素，只能压和弹，实在要改，只有清空</span></span><br><span class="line">stack.Clear();</span><br></pre></td></tr></table></figure></li></ul><h2 id="Queue类（队列）"><a href="#Queue类（队列）" class="headerlink" title="Queue类（队列）"></a>Queue类（队列）</h2><p><strong>概念：</strong> <code>Queue</code> 的本质也是 <code>object</code> 数组，封装了队列的存储规则，队列是一种先进先出的数据结构。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引用命名空间 System.Collections</span></span><br><span class="line">Queue queue = <span class="keyword">new</span> Queue();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.Enqueue(<span class="number">1</span>);</span><br><span class="line">queue.Enqueue(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>取出</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> v = queue.Dequeue();</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看队列头部元素</span></span><br><span class="line">v = queue.Peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看元素是否在队列中</span></span><br><span class="line">queue.Contains(<span class="string">&quot;123&quot;</span>); <span class="comment">// true / false</span></span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列无法改变其中的元素，只能进和出，实在要改，只有清空</span></span><br><span class="line">queue.Clear();</span><br></pre></td></tr></table></figure></li></ul><h2 id="Hashtable类（哈希表）"><a href="#Hashtable类（哈希表）" class="headerlink" title="Hashtable类（哈希表）"></a>Hashtable类（哈希表）</h2><p><strong>概念：</strong> <code>Hashtable</code> （又称散列表）是基于键的哈希代码组织起来的键值对集合，它的主要作用是提高数据查询的效率，使用键来访问集合中的元素。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引用命名空间 System.Collections</span></span><br><span class="line">Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：不能出现相同键</span></span><br><span class="line">hashtable.Add(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">hashtable.Add(<span class="number">2</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">hashtable.Add(<span class="string">&quot;123&quot;</span>, <span class="number">2</span>); <span class="comment">// 第一个参数是key</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接通过键删除</span></span><br><span class="line">hashtable.Remove(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">hashtable.Clear();</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过键查找值 找不到会返回空</span></span><br><span class="line">Console.WriteLine(hashtable[<span class="string">&quot;key&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看是否存在</span></span><br><span class="line"><span class="comment">// 根据键检测</span></span><br><span class="line">hashtable.Contains(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">hashtable.ContainsKey(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="comment">// 根据值检测</span></span><br><span class="line">hashtable.Contains.ContainsValue(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能改键对应的内容，无法修改键</span></span><br><span class="line">hashtable[<span class="string">&quot;123&quot;</span>] = <span class="number">100.5f</span>;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型-1"><a href="#泛型-1" class="headerlink" title="泛型"></a>泛型</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>泛型实现了类型参数化，达到代码重用的目的，通过类型参数化来实现同一份代码上操作多种类型。</p><p>泛型相当于类型占位符，定义类或方法时使用替代符代表变量类型，当真正使用类或者方法时再具体指定类型。</p><h3 id="泛型类和接口"><a href="#泛型类和接口" class="headerlink" title="泛型类和接口"></a>泛型类和接口</h3><p><strong>基本语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestClass1</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestClass1</span> &#123; &#125; </span><br><span class="line"><span class="comment">// 泛型属于类名的一部分，即使它们名字相同，如果泛型不同（是否引用泛型、泛型引用个数），它们也不是同一个类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ITest</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型占位字母可以有多个，用逗号分开</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestClass2</span>&lt;<span class="title">T</span>, <span class="title">E</span>, <span class="title">M</span>, <span class="title">XXX</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T value1;</span><br><span class="line">    <span class="keyword">public</span> E value2;</span><br><span class="line">    <span class="keyword">public</span> XXX value3;</span><br><span class="line">    <span class="keyword">public</span> M value4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TestClass1&lt;<span class="built_in">int</span>&gt; t1 = <span class="keyword">new</span> TestClass1&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">t1.<span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line">TestClass1&lt;<span class="built_in">string</span>&gt; t2 = <span class="keyword">new</span> TestClass1&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">t2.<span class="keyword">value</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line">TestClass2&lt;<span class="built_in">int</span>, <span class="built_in">string</span>, <span class="built_in">float</span>, <span class="built_in">bool</span>&gt; t3 = <span class="keyword">new</span> TestClass2&lt;<span class="built_in">int</span>, <span class="built_in">string</span>, <span class="built_in">float</span>, <span class="built_in">bool</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>继承：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承时实现指定</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span> : <span class="title">ITest</span>&lt;<span class="title">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p><strong>普通类中的泛型方法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun1</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span> &#123; <span class="comment">/* 函数逻辑 */</span> &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 泛型可以有多个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun2</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt;()</span></span><br><span class="line">    &#123;</span><br><span class="line">        T t = <span class="literal">default</span>(T);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 可以用泛型类型做一些逻辑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 泛型作返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">TestFun3</span>&lt;<span class="title">T</span>&gt;()</span></span><br><span class="line">    &#123;</span><br><span class="line">        T Value;</span><br><span class="line">        <span class="keyword">return</span> Value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Test1 t1 = <span class="keyword">new</span> Test2();</span><br><span class="line"></span><br><span class="line">t1.TestFun1&lt;<span class="built_in">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">t1.TestFun1&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;12321312&quot;</span>);</span><br><span class="line"></span><br><span class="line">t1.TestFun2&lt;<span class="built_in">bool</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = t1.TestFun3&lt;<span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>泛型类中的泛型方法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T Value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这种不是泛型方法，T是类的泛型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">T t</span>)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这种才算泛型方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">E</span>&gt;(<span class="params">E e</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test2&lt;<span class="built_in">int</span>&gt; t2 = <span class="keyword">new</span> Test2&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">t2.TestFun&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;123213&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h3><ul><li>不同类型对象的相同逻辑处理就可以用泛型</li><li>使用泛型可以一定程度上避免装箱拆箱</li></ul><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><h3 id="什么是泛型约束"><a href="#什么是泛型约束" class="headerlink" title="什么是泛型约束"></a>什么是泛型约束</h3><p><strong>概念：</strong> 让泛型的类型有一定的限制。</p><p><strong>关键字：</strong> <code>where</code></p><p><strong>泛型约束一共有6种：</strong></p><ol><li>值类型： <code>where 泛型字母 : struct</code></li><li>引用类型： <code>where 泛型字母 : class</code></li><li>存在无参公共构造函数： <code>where 泛型字母 : new()</code></li><li>某个类本身或其派生类： <code>where 泛型字母 : 类名</code></li><li>某个接口的派生类型： <code>where 泛型字母 : 接口名</code></li><li>另一个泛型类型本身或者派生类型： <code>where 泛型字母 : 另一个泛型字母</code></li></ol><h3 id="约束的组合使用"><a href="#约束的组合使用" class="headerlink" title="约束的组合使用"></a>约束的组合使用</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span>, <span class="title">new</span>() &#123; &#125;</span><br><span class="line"><span class="comment">// 可以通过逗号组合使用</span></span><br></pre></td></tr></table></figure><h3 id="多个泛型有约束"><a href="#多个泛型有约束" class="headerlink" title="多个泛型有约束"></a>多个泛型有约束</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>, <span class="title">M</span>, <span class="title">E</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span>, <span class="title">new</span>() <span class="keyword">where</span> <span class="title">M</span> : <span class="title">new</span>() <span class="keyword">where</span> <span class="title">E</span> : <span class="title">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="泛型数据结构类"><a href="#泛型数据结构类" class="headerlink" title="泛型数据结构类"></a>泛型数据结构类</h1><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p><strong>概念：</strong> <code>List</code> 本质是一个可变类型的泛型数组，实现了很多方法。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入命名空间 System.Collections.Generic</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.Add(<span class="number">1</span>); <span class="comment">// 单加</span></span><br><span class="line">list.AddRange(list2); <span class="comment">// 批量加</span></span><br><span class="line">list.Insert(<span class="number">0</span>, <span class="number">999</span>); <span class="comment">// 插入</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.Remove(<span class="number">1</span>); <span class="comment">// 删除指定元素</span></span><br><span class="line">list.RemoveAt(<span class="number">0</span>); <span class="comment">// 删除指定位置元素</span></span><br><span class="line">list.Clear(); <span class="comment">// 清空</span></span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list[0] // 直接通过下标查找指定位置元素</span></span><br><span class="line">list.Contains(<span class="number">1</span>); <span class="comment">// 查看元素是否存在</span></span><br><span class="line">list.IndexOf(<span class="number">2</span>); <span class="comment">// 正向查找元素位置</span></span><br><span class="line">list.LastIndexOf(<span class="number">2</span>); <span class="comment">// 反向查找元素位置</span></span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list[<span class="number">0</span>] = <span class="number">99</span>; <span class="comment">// 直接修改</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>List排序</strong></p><ul><li><p>List自带的排序方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">list.Sort(); <span class="comment">// 默认升序</span></span><br></pre></td></tr></table></figure></li><li><p>自定义类的排序</p><p>继承并实现 <code>ICompareble</code> 接口或 <code>ICompareble&lt;T&gt;</code> 接口中的 <code>CompareTo</code> 方法，自定义排序规则，再使用 <code>Sort</code> 方法。</p></li><li><p>通过委托函数进行排序</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Fun</span>(<span class="params">自定义类名 a, 自定义类名 b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 传入的两个对象为列表中的两个对象</span></span><br><span class="line">    <span class="comment">// 进行两两比较</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现排序规则（返回值规则与CompareTo一样）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.Sort(Fun); <span class="comment">// 将排序函数传入Sort执行</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h2><p><strong>概念：</strong> 可以将 <code>Dictionary</code> 理解为拥有泛型的 <code>Hashtable</code> ，它也是基于键的哈希代码组织起来的键值对，键值对类型从 <code>object</code> 变为了可以自己制定的泛型。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入命名空间 System.Collections.Generic</span></span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意不能出现相同键</span></span><br><span class="line">dictionary.Add();</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能通过键删除</span></span><br><span class="line">dictionary.Remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">dictionary.Clear();</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dictionary[4] // 通过键查看值，找不到会返回空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看是否存在</span></span><br><span class="line"><span class="comment">// 根据键检测</span></span><br><span class="line">dictionary.ContainsKey(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 根据值检测</span></span><br><span class="line">dictionary.ContainsValue(<span class="string">&quot;23874&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary[<span class="number">1</span>] = <span class="string">&quot;555&quot;</span>; <span class="comment">// 直接修改</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="LinkedList（链表）"><a href="#LinkedList（链表）" class="headerlink" title="LinkedList（链表）"></a>LinkedList（链表）</h2><p><strong>概念：</strong>  <code>LinkedList</code> 本质是一个可变类型的泛型双向链表</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入命名空间 System.Collections.Generic</span></span><br><span class="line">LinkedList&lt;<span class="built_in">int</span>&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li><p>增加</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表尾部添加元素</span></span><br><span class="line">linkedList.AddLast(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 在链表头部添加元素</span></span><br><span class="line">linkedList.AddFirst(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 在某一个节点之后添加一个节点</span></span><br><span class="line">linkedList.AddAfter(node, <span class="number">15</span>);</span><br><span class="line"><span class="comment">// 在某一个节点之前添加一个节点</span></span><br><span class="line">linkedList.AddBefore(node, <span class="number">20</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除头节点</span></span><br><span class="line">linkedList.RemoveFirst();</span><br><span class="line"><span class="comment">// 移除尾节点</span></span><br><span class="line">linkedList.RemoveLast();</span><br><span class="line"><span class="comment">// 移除指定元素（不是指定位置的元素）</span></span><br><span class="line">linkedList.Remove(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">linkedList.Clear();</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头节点</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; first = linkedList.First;</span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; last = linkedList.Last;</span><br><span class="line"><span class="comment">// 找到指定值的节点,找不到返回空</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; node = linkedList.Find(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 判断是否存在</span></span><br><span class="line">linkedList.Contains(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先得到节点，再修改值</span></span><br><span class="line">node.Value = <span class="number">8</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="泛型栈和队列"><a href="#泛型栈和队列" class="headerlink" title="泛型栈和队列"></a>泛型栈和队列</h2><p><strong>使用：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要引入命名空间 System.Collections.Generic</span></span><br><span class="line"><span class="comment">// 名称不变，加上泛型即可</span></span><br><span class="line">Stack&lt;<span class="built_in">int</span>&gt; stack = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">Queue&lt;<span class="built_in">string</span>&gt; queue = <span class="keyword">new</span> Queue&lt;<span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>使用上与普通栈和队列基本没有区别。</strong></p><hr><h1 id="委托和事件"><a href="#委托和事件" class="headerlink" title="委托和事件"></a>委托和事件</h1><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><strong>委托是函数的容器。</strong> 可以理解为表示函数的变量类型，用来存储和传递函数。委托的本质是一个类，用来定义函数的类型（返回值和参数的类型），不同的函数必须对应和各自“格式”一致的委托。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><strong>关键字：</strong> <code>delegate</code></p><p><strong>语法：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="built_in">delegate</span> 返回值 委托名(参数列表);</span><br></pre></td></tr></table></figure><p><strong>可以声明在namespace和class语句块中，更多的写在namespace中，访问修饰符默认为public。</strong></p><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyFun1</span>()</span>; <span class="comment">// 声明了一个可以用来存储无参无返回值的函数的容器</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyFun2</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span>()</span> &#123; &#125; <span class="comment">// 无参无返回</span></span><br><span class="line"></span><br><span class="line">MyFun1 f1 = <span class="keyword">new</span> MyFun(Fun); <span class="comment">//装载Fun函数</span></span><br><span class="line">MyFun1 f2 = Fun; <span class="comment">// 另一种实现方法</span></span><br><span class="line"></span><br><span class="line">f1.Invoke(); <span class="comment">// 调用委托</span></span><br><span class="line">f2(); <span class="comment">// 另一种调用方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Fun2</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123; <span class="keyword">return</span> x; &#125; <span class="comment">// 有参有返回</span></span><br><span class="line"></span><br><span class="line">MyFun2 ff1 = Fun2;</span><br><span class="line">ff1(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>委托常用在：</p><ul><li>作为类的成员</li><li>作为函数的参数</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MyFun1 fun1;</span><br><span class="line">    <span class="keyword">public</span> MyFun2 fun2;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">MyFun1 fun1, MyFun2 Fun2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        fun1();</span><br><span class="line">        fun2(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多播委托（存储多个函数）"><a href="#多播委托（存储多个函数）" class="headerlink" title="多播委托（存储多个函数）"></a>多播委托（存储多个函数）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyFun1 f1 = Fun;</span><br><span class="line"></span><br><span class="line">f1 += Fun; <span class="comment">// 存了两个Fun函数</span></span><br><span class="line">f1 += Funa;</span><br><span class="line">f1 += Funb; <span class="comment">// 存储多个函数</span></span><br><span class="line"></span><br><span class="line">f1(); <span class="comment">// 调用委托时全部执行（按添加顺序）</span></span><br><span class="line"></span><br><span class="line">f1 -= FUn; <span class="comment">// 从f1委托中移除Fun函数</span></span><br><span class="line"></span><br><span class="line">f1 = <span class="literal">null</span>; <span class="comment">// 相当于清空委托 </span></span><br></pre></td></tr></table></figure><h3 id="系统定义好的委托"><a href="#系统定义好的委托" class="headerlink" title="系统定义好的委托"></a>系统定义好的委托</h3><p>使用系统自带委托，需要引用 <code>System</code> 命名空间。</p><p><strong>Action</strong></p><p>一个无参无返回的委托。</p><p><strong>Func&lt;out&gt;</strong></p><p>可以指定返回值类型的泛型委托。</p><p><strong>Action&lt;in…&gt;</strong></p><p>可以传n个参数的委托，系统提供了1到16个参数的委托。</p><p><strong>Func&lt;in…, out&gt;</strong></p><p>可以传n个参数的有返回值的委托，系统也提供了1到16个参数的写法。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>事件是一种特殊的变量类型。事件是基于委托的存在，是委托的安全包裹，让委托的使用更有安全性。</p><h3 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h3><p>委托怎么用，事件就怎么用。</p><p><strong>声明：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">event</span> 委托类型 时间名;</span><br></pre></td></tr></table></figure><p><strong>与委托的区别：</strong></p><ul><li>事件只能作为成员存在于类和接口以及结构体中</li><li>事件不能在类的外部赋值</li><li>事件不能在类的外部调用</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 委托成员变量</span></span><br><span class="line">    <span class="keyword">public</span> Action myFun;</span><br><span class="line">    <span class="comment">// 事件成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action myEvent;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 事件的使用与委托一样</span></span><br><span class="line">        myFun = TestFun;</span><br><span class="line">        myFun += TestFun;</span><br><span class="line">        myFun();</span><br><span class="line">        myFun.Invoke();</span><br><span class="line">        </span><br><span class="line">        myEvent = TestFun;</span><br><span class="line">        myEvent += TestFun;</span><br><span class="line">        myEvent();</span><br><span class="line">        myEvent.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托可以在外部赋值</span></span><br><span class="line">t.myFun = <span class="literal">null</span>;</span><br><span class="line">t.myFun = TestFun;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件不能在外部赋值，但可以添加和移除记录的函数</span></span><br><span class="line"><span class="comment">// t.myEvent = TestFun;</span></span><br><span class="line">t.myEvent += TestFun;</span><br><span class="line">t.myEvent -= TestFun;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托可以在外部调用，事件不能在外面调用</span></span><br><span class="line">t.myFun();</span><br></pre></td></tr></table></figure><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ol><li>防止外部随意置空委托</li><li>防止外部随意调用委托</li><li>事件相当于对委托进行了一次封装，让其更加安全</li></ol><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>匿名函数，就是没有名字的函数。匿名函数的使用主要是配合委托和事件进行使用，脱离委托和事件一般不会用到匿名函数。</p><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delegate</span> (参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 函数逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h3><p>在函数中传递委托参数时和委托或事件赋值时使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Action a = <span class="built_in">delegate</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我是匿名函数&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">a += <span class="built_in">delegate</span> () &#123; <span class="comment">/* 函数逻辑 */</span> &#125;;</span><br><span class="line"></span><br><span class="line">Action&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; b = <span class="built_in">delegate</span> (<span class="built_in">int</span> x, <span class="built_in">string</span> str) &#123; <span class="comment">/* 函数逻辑 */</span> &#125;; <span class="comment">// 有参</span></span><br><span class="line"></span><br><span class="line">Func&lt;<span class="built_in">string</span>&gt; c = <span class="built_in">delegate</span> () &#123; <span class="keyword">return</span> <span class="string">&quot;123&quot;</span> &#125;; <span class="comment">// 有返回</span></span><br></pre></td></tr></table></figure><p>作为函数参数传递或作为函数返回值使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Action action;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 作为参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun1</span>(<span class="params"><span class="built_in">int</span> a, Action fun</span>)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 作为返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">Fun2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">delegate</span> () &#123;</span><br><span class="line">            <span class="comment">// 函数逻辑</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数传递</span></span><br><span class="line">t.Fun1(<span class="number">20</span>, <span class="built_in">delegate</span> () &#123;</span><br><span class="line">    <span class="comment">// 函数逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line">Action ac = t.Fun2(); <span class="comment">// 存起来</span></span><br><span class="line">t.Fun2()(); <span class="comment">// 直接调用</span></span><br></pre></td></tr></table></figure><h3 id="匿名函数的缺点"><a href="#匿名函数的缺点" class="headerlink" title="匿名函数的缺点"></a>匿名函数的缺点</h3><p>因为没有名字，所以添加到委托或事件中后不记录无法单独移除。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p>lambda表达式可以理解为匿名函数的简写，它除了写法不同外，使用上和匿名函数一模一样，都是配合委托或事件使用的。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用-6"><a href="#使用-6" class="headerlink" title="使用"></a>使用</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Action a = () =&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line">Action&lt;<span class="built_in">int</span>&gt; b = (<span class="built_in">int</span> x) =&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>参数类型也可省略，与委托和事件一致</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; a = <span class="literal">null</span>;</span><br><span class="line">a += (str, x) =&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>大括号和小括号也可省略，省略大括号默认是返回值且只有一行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; a = (x) =&gt; &#123; <span class="keyword">return</span> x * <span class="number">5</span>; &#125;; <span class="comment">// 有返回值</span></span><br><span class="line">a += x =&gt; x * <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>内层的函数可以引用包含在它外层的函数的变量，即使外层函数的执行已经终止。</p><p>注：该变量提供的值并非变量创建时的值，而是在父函数范围内的最终值。 </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action action;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里就形成了闭包</span></span><br><span class="line">        <span class="comment">// 因为当构造函数执行完毕时，其中声明的临时变量value的生命周期被改变了</span></span><br><span class="line">        action = () =&gt; &#123;</span><br><span class="line">            Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="协变逆变"><a href="#协变逆变" class="headerlink" title="协变逆变"></a>协变逆变</h1><h2 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h2><p><strong>协变：</strong> 和谐的变化，自然的变化。例如因为里氏替换原则，所以子类变父类是和谐的。</p><p><strong>逆变：</strong> 逆常规的变化，不正常的变化。例如父类变子类是不和谐的。</p><p>逆变和协变是用来修饰泛型的，关键字：</p><ul><li>协变： <code>out</code></li><li>逆变： <code>in</code></li></ul><p>是用于在泛型中修饰泛型字母的，只有泛型接口和泛型委托能使用。</p><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p><strong>返回值和参数：</strong></p><p>用 <code>out</code> 修饰的泛型只能作为返回值，用 <code>in</code> 修饰的泛型只能作为参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">TestOut</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TestIn</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;()</span>;</span><br></pre></td></tr></table></figure><p><strong>结合里氏替换原则：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协变 父类总是能被子类替换</span></span><br><span class="line">TestOut&lt;Son&gt; os = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Son();</span><br><span class="line">&#125;;</span><br><span class="line">TestOut&lt;Father&gt; of = os;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆变 父类总是能被子类替换</span></span><br><span class="line">TestIn&lt;Father&gt; iF = <span class="keyword">value</span> =&gt; &#123; &#125;;</span><br><span class="line">TestIn&lt;Son&gt; iS = iF;</span><br><span class="line">iS(<span class="keyword">new</span> Son()); <span class="comment">// 实际上调用的是iF</span></span><br></pre></td></tr></table></figure><hr><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><a href="https://www.flashfish777.cn/posts/fdbe57b8.html#%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">blog</a></p><h2 id="相关语法"><a href="#相关语法" class="headerlink" title="相关语法"></a>相关语法</h2><p>C#提供了线程类 <code>Tread</code> ，需要引用命名空间 <code>System.Threading</code> 使用。</p><p><strong>声明一个线程：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread类重载了四种构造函数，最常用的需要传入一个无参无返回委托（或函数）</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(NewThreadFun);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NewThreadFun</span>()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p><strong>启动线程：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.Start();</span><br></pre></td></tr></table></figure><p><strong>设置为后台线程：</strong></p><p>声明的线程默认为前台线程，当前台线程都结束的时候整个程序才会结束，即使还有后台线程正在运行。后台线程不会防止应用程序的进程被终止掉，因此如果有线程没有设置为后台线程，此线程还未结束的话，可能导致进程无法正常关闭。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.IsBackground = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><strong>关闭释放一个线程：</strong></p><p>如果开启的线程不是死循环，是能够结束的逻辑，那么不用刻意的去关闭它。</p><p>如果想要终止一个线程，可以通过线程提供的方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.Abort(); <span class="comment">// 终止线程</span></span><br><span class="line">t = <span class="literal">null</span>; <span class="comment">// 置空（GC自动回收）</span></span><br></pre></td></tr></table></figure><p><strong>线程休眠：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tread.Sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 线程类的静态函数，让线程休眠n毫秒再继续执行</span></span><br><span class="line"><span class="comment">// 在哪个线程内部执行休眠的就是哪个线程</span></span><br></pre></td></tr></table></figure><h2 id="线程之间共享数据"><a href="#线程之间共享数据" class="headerlink" title="线程之间共享数据"></a>线程之间共享数据</h2><p>多个线程使用的内存是共享的，都属于该应用程序（进程），所以要注意，当多线程同时操作同一片内存区域时可能会出现问题，可以通过加锁的形式避免问题。</p><p>关键字： <code>lock</code></p><p>原理：当我们在多个线程当中想要访问同样的东西进行逻辑处理时，为了避免不必要的逻辑顺序执行的差错，可以使用 <code>lock</code> 锁避免同时执行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="keyword">lock</span>( obj ) <span class="comment">// 需要传入一个引用类型变量，这里以obj为例</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 语句...</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    Console.WriteLine(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">lock</span>( obj )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 语句...</span></span><br><span class="line">    a = <span class="number">99</span>;</span><br><span class="line">    Console.WriteLine(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当程序执行到 <code>lock</code> 语句块时，会先检测传入的引用类型变量，如果该变量（ <code>obj</code> ）被锁住了，程序就会一直等到 <code>obj</code> 解锁之后再运行 <code>lock</code> 语句块中的逻辑；相反，如果 <code>obj</code> 没被锁，程序就会执行 <code>lock</code> 语句块中的逻辑，同时将 <code>obj</code> 锁住，在逻辑执行完毕后解锁 <code>obj</code> 。</p><h2 id="多线程的意义"><a href="#多线程的意义" class="headerlink" title="多线程的意义"></a>多线程的意义</h2><p>多线程可以用来处理一些复杂耗时的逻辑，比如寻路、网络通信等等，可以专门开一个线程异步处理逻辑，避免卡顿。</p><hr><h1 id="预处理器指令"><a href="#预处理器指令" class="headerlink" title="预处理器指令"></a>预处理器指令</h1><h2 id="什么是预处理器指令"><a href="#什么是预处理器指令" class="headerlink" title="什么是预处理器指令"></a>什么是预处理器指令</h2><p><strong>预处理器指令是指导编译器在实际编译开始之前对信息进行预处理的指令。</strong> 预处理器指令都是以 <code>‘#’</code> 开始，且因为它们不是语句，所以不以分号结束。</p><h2 id="常见的预处理器指令"><a href="#常见的预处理器指令" class="headerlink" title="常见的预处理器指令"></a>常见的预处理器指令</h2><table><thead><tr><th align="left">指令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>#define</code></td><td align="left">定义一个符号，可以用于条件编译。</td></tr><tr><td align="left"><code>#undef</code></td><td align="left">取消定义一个符号。</td></tr><tr><td align="left"><code>#if</code></td><td align="left">开始一个条件编译块，如果符号被定义则包含代码块。</td></tr><tr><td align="left"><code>#elif</code></td><td align="left">如果前面的 <code>#if</code> 或 <code>#elif</code> 条件不满足，且当前条件满足，则包含代码块。</td></tr><tr><td align="left"><code>#else</code></td><td align="left">如果前面的 <code>#if</code> 或 <code>#elif</code> 条件不满足，则包含代码块。</td></tr><tr><td align="left"><code>#endif</code></td><td align="left">结束一个条件编译块。</td></tr><tr><td align="left"><code>#warning</code></td><td align="left">生成编译器警告信息。</td></tr><tr><td align="left"><code>#error</code></td><td align="left">生成编译器错误信息。</td></tr><tr><td align="left"><code>#region</code></td><td align="left">标记一段代码区域，可以在IDE中折叠和展开这段代码，便于代码的组织和阅读。</td></tr><tr><td align="left"><code>#endregion</code></td><td align="left">结束一个代码区域。</td></tr><tr><td align="left"><code>#line</code></td><td align="left">更改编译器输出中的行号和文件名，可以用于调试或生成工具的代码。</td></tr><tr><td align="left"><code>#pragma</code></td><td align="left">用于给编译器发送特殊指令，例如禁用或恢复特定的警告。</td></tr><tr><td align="left"><code>#nullable</code></td><td align="left">控制可空性上下文和注释，允许启用或禁用对可空引用类型的编译器检查。</td></tr></tbody></table><hr><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="程序集"><a href="#程序集" class="headerlink" title="程序集"></a>程序集</h2><p>程序集是经由编译器编译得到的，供进一步编译执行的中间产物，在windows系统中，它一般表现为 <code>.dll（代码库文件）</code> 或 <code>.exe（可执行文件）</code> 的格式。 </p><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>元数据就是用来描述数据的数据。</p><p>例如程序中的类，类中的函数、变量等信息就是程序的元数据。有关程序以及类型的数据被称为元数据，它们保存在程序集中。</p><h2 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h2><p>程序正在运行时，可以查看其他程序集或者自身的元数据。一个运行的程序查看本身或者其他程序的元数据的行为就叫做反射。</p><h2 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h2><p>因为反射可以在程序编译后获得信息，所以它提高了程序的拓展性和灵活性。</p><ol><li>程序运行时得到所有元数据，包括元数据的特性</li><li>程序运行时实例化对象，操作对象</li><li>程序运行时创建对象，用这些对象执行任务</li></ol><h2 id="相关语法-1"><a href="#相关语法-1" class="headerlink" title="相关语法"></a>相关语法</h2><p>这里先放一个例子类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">string</span> str</span>) : <span class="title">this</span>(<span class="params">i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">string</span> str</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Type类"><a href="#Type类" class="headerlink" title="Type类"></a>Type类</h3><p><code>Type（类的信息类）</code> 是反射功能的基础，它是访问元数据的主要方式。使用 <code>Type</code> 的成员获取有关类型声明的信息，有关类型的成员（如构造函数、方法、字段、属性和类的事件）。</p><p><strong>获取Type：</strong></p><ol><li><p><code>object</code> 类中的 <code>GetType()</code> 方法可以获取对象的Type：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">42</span>;</span><br><span class="line">Type type = a.GetType();</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>typeof</code> 关键字传入类名，也可以等到对象的Type：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type type = <span class="keyword">typeof</span>(Test);</span><br></pre></td></tr></table></figure></li><li><p>通过类的名字也可以获取类型（注意类名必须包含命名空间，不然找不到）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type type = Type.GetType(<span class="string">&quot;System.Int32&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p><strong>得到类的程序集信息：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(type.Assembly);</span><br></pre></td></tr></table></figure><p><strong>获取类中的所有公共成员：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先得到Type</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span><br><span class="line"><span class="comment">// 然后得到所有公共成员</span></span><br><span class="line"><span class="comment">// 需要引用命名空间 System.Reflection</span></span><br><span class="line">MemberInfo[] infos = t.GetMembers();</span><br></pre></td></tr></table></figure><p><strong>获取类的公共构造函数并调用：</strong></p><ol><li><p>获取所有构造函数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConstructorInfo[] ctors = t.GetConstructors();</span><br></pre></td></tr></table></figure></li><li><p>获取其中一个构造函数并执行</p><p>得构造函数传入Type数组，数组中内容按顺序是参数类型；</p><p>执行构造函数传入object数组，表示按顺序传入的参数。</p><ol><li><p>得到无参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConstructorInfo info = t.GetConstructor(<span class="keyword">new</span> Type[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>执行无参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造没有参数需要传null，该方法会返回object对象</span></span><br><span class="line">Test test = info.Invoke(<span class="literal">null</span>) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure></li><li><p>得到有参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConstructorInfo info = t.GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br><span class="line"><span class="comment">// 获取只有一个int类型参数的构造函数</span></span><br><span class="line">ConstructorInfo info = t.GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">typeof</span>(<span class="built_in">string</span>) &#125;);</span><br><span class="line"><span class="comment">// 获取两个参数的构造函数</span></span><br></pre></td></tr></table></figure><p>执行有参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test test1 = info.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">88</span> &#125;) <span class="keyword">as</span> Test;</span><br><span class="line">Test test2 = info.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">88</span>, <span class="string">&quot;Hello&quot;</span>&#125;) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><strong>获取类的公共成员变量：</strong></p><ol><li><p>得到所有成员变量：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FieldInfo[] fieldInfos = t.GetFields();</span><br></pre></td></tr></table></figure></li><li><p>得到指定名称的公共成员变量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FieldInfo infoJ = t.GetField(<span class="string">&quot;j&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过反射获取和设置对象的值</p><ol><li><p>通过反射获取对象的某个变量的值</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line">test.j = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(infoJ.GetValue(test));</span><br></pre></td></tr></table></figure></li><li><p>通过反射设置指定对象的某个变量的值</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infoJ.SetValue(test, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><strong>获取类的公共成员方法：</strong></p><ol><li><p>得到所有成员方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodInfo[] methods = t.GetMethods();</span><br></pre></td></tr></table></figure></li><li><p>获取一个成员方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果存在方法重载，用Type数组表示参数类型</span></span><br><span class="line">MethodInfo method1 = t.GetMethod(<span class="string">&quot;Speak&quot;</span>, <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">typeof</span>(<span class="built_in">string</span>) &#125;);</span><br><span class="line">MethodInfo method2 = t.GetMethod(<span class="string">&quot;Speak&quot;</span>, <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br></pre></td></tr></table></figure></li><li><p>调用方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数相当于是那个对象要执行这个成员方法</span></span><br><span class="line"><span class="comment">// 如果是静态方法，第一个参数传null即可</span></span><br><span class="line">method1.Invoke(test, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">1</span>, <span class="string">&quot;123&quot;</span> &#125;);</span><br><span class="line">method2.Invoke(test, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure></li></ol><p><strong>其他：</strong></p><ul><li>得枚举： <code>GetEnumName</code> 、 <code>GetEnumNames</code></li><li>得事件： <code>GetEvent</code> 、 <code>GetEvents</code></li><li>得接口： <code>GetInterface</code> 、 <code>GetInterfaces</code></li><li>得属性： <code>GetProperty</code> 、 <code>GetPropertys</code></li></ul><h3 id="Assembly类"><a href="#Assembly类" class="headerlink" title="Assembly类"></a>Assembly类</h3><p>程序集类。主要用来加载其他程序集，加载后才能用Type来使用其他程序集的信息，如果想要使用不是当前程序集的内容，需要先加载程序集。比如 <code>dll（库文件）</code> ，简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。</p><p>三种加载程序集的函数：</p><ul><li><p>一般用来加载在同一文件下的其他程序集</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assembly assembly1 = Assembly.Load(<span class="string">&quot;程序集名称&quot;</span>)；</span><br></pre></td></tr></table></figure></li><li><p>一般用来加载不在同一文件下的其他程序集</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Assembly assembly2 = Assembly.LoadFrom(<span class="string">&quot;包含程序集清单的文件的名称或路径&quot;</span>);</span><br><span class="line">Assembly assembly3 = Assembly.LoadFile(<span class="string">&quot;要加载的文件的完全限定路径&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先加载一个指定程序集</span></span><br><span class="line">Assembly assembly Assembly.LoadFrom(<span class="string">&quot;...&quot;</span>);</span><br><span class="line"><span class="comment">// 获取所有Type</span></span><br><span class="line">Type[] types = assembly.GetTypes();</span><br><span class="line"><span class="comment">// 加载程序集中的一个类对象，之后才能使用反射</span></span><br><span class="line">Type icon = assembly.GetType(<span class="string">&quot;...&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Activator类"><a href="#Activator类" class="headerlink" title="Activator类"></a>Activator类</h3><p>实例化对象的类，用于将Type对象快捷实例化为对象。</p><ol><li><p>无参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span><br><span class="line">Test testObj = Activator.CreateInstance(t) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure></li><li><p>有参构造：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testObj = Activator.CreateInstance(t, <span class="number">99</span>) <span class="keyword">as</span> Test; <span class="comment">// 一个参数的</span></span><br><span class="line">testObj = Activator.CreateInstance(t, <span class="number">99</span>, <span class="string">&quot;123&quot;</span>) <span class="keyword">as</span> Test; <span class="comment">// 两个参数的</span></span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h2><p>特性是允许我们向程序的程序集添加元数据的语言结构，它是用于保存程序结构信息的某种特殊类型的类。特性提供功能强大的方法以将声明信息与C#代码（类型、方法、属性等）相关联。特性与程序实体关联后，即可在运行时使用反射查询特性信息。特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集中，它可以放置在几乎所有的声明中（类、变量、函数等等）。</p><p><strong>简而言之：特性本质上是个类，我们可以利用特性类为元数据添加额外信息。比如一个类、成员变量、成员方法等等为它们添加更多的额外信息，之后可以通过反射来获取这些额外信息。</strong></p><h2 id="自定义特性"><a href="#自定义特性" class="headerlink" title="自定义特性"></a>自定义特性</h2><p>声明一个类继承特性基类 <code>Attribute</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyTestAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 根据需求来写特性中的成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> info;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestAttribute</span>(<span class="params"><span class="built_in">string</span> info</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用特性"><a href="#使用特性" class="headerlink" title="使用特性"></a>使用特性</h2><p>基本语法： <code>[特性名(参数列表)]</code> </p><p>本质上就是在调用特性类的构造函数，写在类、函数、变量上一行，表示它们具有该特性信息。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MyTest(<span class="string">&quot;这是一个类&quot;</span>)</span>] <span class="comment">// 特性名中的Attribute系统会默认省略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可以加到成员变量前</span></span><br><span class="line">    [<span class="meta">MyTest(<span class="string">&quot;这是一个成员变量&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以加到函数前</span></span><br><span class="line">    [<span class="meta">MyTest(<span class="string">&quot;这是一个函数&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 甚至可以加到函数参数前</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun2</span>(<span class="params"> [MyTest(<span class="string">&quot;这是一个函数参数&quot;</span></span>)]<span class="built_in">int</span> x )</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限制特性使用范围"><a href="#限制特性使用范围" class="headerlink" title="限制特性使用范围"></a>限制特性使用范围</h2><p>通过为特性类加特性限制其使用范围</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)</span>]</span><br><span class="line"><span class="comment">// 参数一：AttributeTargets —— 特性能够用在哪些地方</span></span><br><span class="line"><span class="comment">// 参数二：AllowMultiple —— 是否允许多个特性实例用在同一个目标上</span></span><br><span class="line"><span class="comment">// 参数三：Inherited —— 特性是否能被派生类和重写成员继承</span></span><br></pre></td></tr></table></figure><h2 id="系统自带特性"><a href="#系统自带特性" class="headerlink" title="系统自带特性"></a>系统自带特性</h2><h3 id="过时特性"><a href="#过时特性" class="headerlink" title="过时特性"></a>过时特性</h3><p><strong>关键字：</strong> <code>Obsolete</code> 特性</p><p>用于提示用户使用的方法等成员已经过时，建议使用新方法。一般加在函数前的特性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数一：调用过时方法时提示的内容</span></span><br><span class="line"><span class="comment">// 参数二：是否禁止调用该方法（true：报错 false：仅警告）</span></span><br><span class="line">[<span class="meta">Obsolete(<span class="string">&quot;Speak方法过时了，建议使用新的方法&quot;</span>， false)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用者信息特性"><a href="#调用者信息特性" class="headerlink" title="调用者信息特性"></a>调用者信息特性</h3><p>使用时需要引用命名空间 <code>System.Runtime.CompilerServices</code> ，一般作为参数的特性。</p><ul><li>获取哪个文件调用： <code>CallerFilePath</code> 特性</li><li>获取哪一行调用： <code>CallerLineNumber</code> 特性</li><li>获取哪个函数调用： <code>CallerMemberName</code> 特性</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpeakCaller</span>(<span class="params"><span class="built_in">string</span> str, [CallerFilePath]<span class="built_in">string</span> fileName = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       [CallerLineNumber]<span class="built_in">int</span> line = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                                    [CallerMemberName]<span class="built_in">string</span> memberName = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(str);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用的文件是&quot;</span> + fileName);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用的行数是&quot;</span> + line);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用的方法名是&quot;</span> + memberName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件编译特性"><a href="#条件编译特性" class="headerlink" title="条件编译特性"></a>条件编译特性</h3><p><strong>关键字：</strong> <code>Conditional</code> 特性</p><p>它会和预处理指令 <code>#define</code> 配合使用，需要引用命名空间 <code>System.Diagnostics</code> ，主要可以用在一些调试代码上（有时想执行有时不想执行的代码）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#defiine Fun</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">Conditional(<span class="string">&quot;Fun&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">Fun(); <span class="comment">// 加了这个特性函数才会执行</span></span><br></pre></td></tr></table></figure><h3 id="外部dll包函数特性"><a href="#外部dll包函数特性" class="headerlink" title="外部dll包函数特性"></a>外部dll包函数特性</h3><p><strong>关键字：</strong> <code>DllImport</code> 特性</p><p>用来标记非 <code>.Net（C#）</code> 的函数，表明该函数在一个外部的DLL中定义。一般用来调用 C 或 C++ 的DLL包写好的方法。使用时需要引用命名空间 <code>System.Runtime.InteropServices</code> 。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">&quot;Test.dll&quot;</span>)</span>] <span class="comment">// 假如用一个Test包中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h2><p><strong>迭代器（iterator）</strong> 又称光标（cursor）是程序设计的软件设计模式。迭代器模式提供一个方法顺序访问一个聚合对象中的各个元素而又不暴露其内部的标识。</p><p>从表面效果上看，迭代器是可以在容器对象（例如链表或数组）上遍历访问的接口，设计人员无需关心容器对象的内存分配的实现细节，可以用 <code>foreach</code> 遍历的类，都是实现了迭代器的。</p><h2 id="标准迭代器的实现方法"><a href="#标准迭代器的实现方法" class="headerlink" title="标准迭代器的实现方法"></a>标准迭代器的实现方法</h2><p><strong>关键接口：</strong> <code>IEnumerator</code> ， <code>IEnumerable</code></p><p><strong>命名空间：</strong> <code>System.Collections</code></p><p>可以通过同时继承 <code>IEnumerator</code> 和 <code>IEnumerable</code> 实现其中的方法。</p><h2 id="用-yield-return-语法糖实现迭代器"><a href="#用-yield-return-语法糖实现迭代器" class="headerlink" title="用 yield return 语法糖实现迭代器"></a>用 yield return 语法糖实现迭代器</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] list;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomList</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// yield 关键字 配合迭代器使用</span></span><br><span class="line">            <span class="comment">// 可以理解为 暂时返回 保留当前状态</span></span><br><span class="line">            <span class="comment">// 一会还会再回来</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用-yield-return-语法糖为泛型类实现迭代器"><a href="#用-yield-return-语法糖为泛型类实现迭代器" class="headerlink" title="用 yield return 语法糖为泛型类实现迭代器"></a>用 yield return 语法糖为泛型类实现迭代器</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span>&lt;<span class="title">T</span>&gt; : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="特殊语法"><a href="#特殊语法" class="headerlink" title="特殊语法"></a>特殊语法</h1><h2 id="var隐式类型"><a href="#var隐式类型" class="headerlink" title="var隐式类型"></a>var隐式类型</h2><p>概念： <code>var</code> 是一种特殊的变量类型，它可以用来表示任意类型的变量。</p><p>注意：</p><ul><li><code>var</code> 不能作为类的成员，只能用于临时变量声明</li><li><code>var</code> 变量必须初始化</li></ul><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><h2 id="设置对象初始值"><a href="#设置对象初始值" class="headerlink" title="设置对象初始值"></a>设置对象初始值</h2><p>概念：声明对象时，可以直接写大括号的形式初始化公共成员变量和属性。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test t1 = <span class="keyword">new</span> Test() &#123; x = <span class="number">1</span>, str = <span class="string">&quot;123&quot;</span>, Name = <span class="string">&quot;xxx&quot;</span> &#125;;</span><br><span class="line">Test t2 = <span class="keyword">new</span> Test() &#123; Name = <span class="string">&quot;yyy&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 先执行构造函数再执行初始化的内容</span></span><br></pre></td></tr></table></figure><h2 id="设置集合初始值"><a href="#设置集合初始值" class="headerlink" title="设置集合初始值"></a>设置集合初始值</h2><p>概念：声明集合对象时也可以通过大括号直接初始化内部属性。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] array1 = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list1 = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">List&lt;Test&gt; list2 = <span class="keyword">new</span> List&lt;Test&gt;() &#123;</span><br><span class="line">    <span class="keyword">new</span> Test(),</span><br><span class="line">    <span class="keyword">new</span> Test() &#123; Name = <span class="string">&quot;xxx&quot;</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Test() &#123; x = <span class="number">1</span>, str = <span class="string">&quot;123&quot;</span>, Name = <span class="string">&quot;yyy&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;() &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="string">&quot;123&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">2</span>, <span class="string">&quot;34655&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">3</span>, <span class="string">&quot;45676&quot;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h2><p>概念：变量可以使用 <code>var</code> 声明为自定义的匿名类型。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> &#123; age = <span class="number">10</span>, money = <span class="number">11</span>, name = <span class="string">&quot;小明&quot;</span> &#125;;</span><br><span class="line">COnsole.WriteLine(v.age);</span><br><span class="line"><span class="comment">// 匿名类型无法声明成员方法</span></span><br></pre></td></tr></table></figure><h2 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h2><p>概念：值类型不能赋值为空，但再声明时在值类型后面加 <code>?</code> 表示这是一个可空类型，就可以赋值为空了。</p><p>示例;</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? c = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="keyword">if</span> (c.HasValue)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全获取可空类型值</span></span><br><span class="line">COnsole.WriteLine(Value.GetValueOrDefault(<span class="number">100</span>));</span><br><span class="line"><span class="comment">// 有值就返回值，空的就返回括号里的参数，无参默认返回该类型的默认值</span></span><br></pre></td></tr></table></figure><p><code>?</code> 还可判断一个对象是否为空：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> o = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (o != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    o.Tostring();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于以上代码 能帮我们自动判断o是否为空</span></span><br><span class="line"><span class="comment">// 如果是null就不会执行，也不会报错</span></span><br><span class="line">o?.Tostring();</span><br></pre></td></tr></table></figure><h2 id="空合并操作符"><a href="#空合并操作符" class="headerlink" title="空合并操作符"></a>空合并操作符</h2><p>概念：空合并操作符 <code>??</code> ，如果左边值为空，就返回右边值，否则返回左边值，只要是可以为空的类型都能使用。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? v = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>? i = v == <span class="literal">null</span> ? <span class="number">100</span> : v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于以上代码</span></span><br><span class="line">i = v ?? <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h2 id="内插字符串"><a href="#内插字符串" class="headerlink" title="内插字符串"></a>内插字符串</h2><p>概念：用 <code>$</code> 来构造字符串，让字符串可以拼接变量。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;你好，<span class="subst">&#123;name&#125;</span>，年龄<span class="subst">&#123;age&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="单句逻辑简略写法"><a href="#单句逻辑简略写法" class="headerlink" title="单句逻辑简略写法"></a>单句逻辑简略写法</h2><p>概念：使用 <code>=&gt;</code> 省略大括号，需要返回值则同时省略 <code>return</code> ，只要是只有一句代码都可以这样用。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        <span class="keyword">set</span> =&gt; sex = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> =&gt; a + b; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;12312321&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>end</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity日记：存档系统</title>
      <link href="/posts/a985624f.html"/>
      <url>/posts/a985624f.html</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在游戏开发的世界中，存档系统是不可或缺的一部分，它让玩家的游戏进度得以保存，增强了游戏的可玩性和用户体验。今天分享一下如何在Unity中实现游戏存档的功能，特别是<strong>PlayerPrefs</strong>和<strong>JSON存档</strong>这两种常见方式，帮助开发者理解它们的适用场景、优缺点以及如何有效使用它们来构建强大的存档机制。</p><p>随着游戏复杂度的提升，存档系统的设计和实现变得尤为重要。合理的存档策略能够显著提升玩家的满意度和忠诚度。然而，Unity自带的PlayerPrefs虽然简单易用，但在处理复杂数据或大量数据时显得力不从心。而JSON作为一种轻量级的数据交换格式，因其易于人阅读和编写，以及良好的跨平台特性，在游戏存档中得到了广泛应用。因此，本文将简单介绍这两种方法，帮助开发者根据项目需求做出最佳选择。</p><p><strong>Unity存档系统的用途</strong>：</p><ul><li><strong>保存游戏进度</strong>：让玩家能够在退出游戏后重新加载之前的游戏状态。</li><li><strong>设置和配置保存</strong>：存储玩家的游戏设置，如音量、难度等。</li><li><strong>成就和解锁内容</strong>：记录玩家的成就和已解锁的内容，作为游戏进度的一部分。</li><li><strong>跨平台同步</strong>：在支持云存档的情况下，实现不同设备间的游戏进度同步。</li></ul><h1 id="PlayerPrefs"><a href="#PlayerPrefs" class="headerlink" title="PlayerPrefs"></a>PlayerPrefs</h1><h2 id="PlayerPrefs存储数据"><a href="#PlayerPrefs存储数据" class="headerlink" title="PlayerPrefs存储数据"></a>PlayerPrefs存储数据</h2><p><code>PlayerPrefs</code>是Unity提供的一个简单的数据持久化系统，用于保存和加载玩家偏好设置和游戏数据。它仅支持存储和检索<code>整型（int）</code>、<code>浮点型（float）</code>和<code>字符串（string）</code>数据。</p><p>Unity的<code>PlayerPrefs</code>是Unity引擎提供的一个用于存储和检索玩家偏好设置和游戏状态数据的简单数据持久化系统。它允许开发者跨会话（即游戏运行之间）保存和加载简单的数据类型，如整型（<code>int</code>）、浮点型（<code>float</code>）和字符串（<code>string</code>）。这些数据通常存储在设备的本地存储中，如注册表（在Windows上）或偏好设置文件（在macOS和iOS上）等，具体取决于目标平台。</p><h2 id="PlayerPrefs的特点"><a href="#PlayerPrefs的特点" class="headerlink" title="PlayerPrefs的特点"></a>PlayerPrefs的特点</h2><ol><li><strong>简单易用</strong>：<code>PlayerPrefs</code> API 非常直观，易于上手。只需几行代码就可以实现数据的保存和加载。</li><li><strong>跨平台</strong>：<code>PlayerPrefs</code> 数据在不同的Unity支持平台上具有高度的可移植性。无论游戏在哪个平台上运行，<code>PlayerPrefs</code> 都能以相同的方式工作。</li><li><strong>限制</strong>：尽管<code>PlayerPrefs</code> 非常方便，但它也有一些限制。首先，它只支持整型、浮点型和字符串数据类型。其次，由于数据存储在一个统一的命名空间中，不同游戏或应用可能会无意中覆盖彼此的<code>PlayerPrefs</code> 数据（尽管这可以通过在键名中包含唯一标识符来避免）。最后，<code>PlayerPrefs</code> 数据的存储量也有限制，虽然这个限制对于大多数用途来说都足够大，但在处理大量数据时可能会成为问题。</li></ol><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>使用简单，无需额外配置。</td><td>数据类型有限，不支持复杂数据结构（如数组、列表、字典等）。</td></tr><tr><td>跨平台兼容性好，适用于大多数Unity支持的平台。</td><td>存储容量有限，不适合存储大量数据。</td></tr><tr><td></td><td>安全性较低，数据容易被用户修改。</td></tr></tbody></table><h2 id="PlayerPrefs的基本用法"><a href="#PlayerPrefs的基本用法" class="headerlink" title="PlayerPrefs的基本用法"></a>PlayerPrefs的基本用法</h2><h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>使用<code>PlayerPrefs.SetInt</code>、<code>PlayerPrefs.SetFloat</code>和<code>PlayerPrefs.SetString</code>等静态方法将数据保存到<code>PlayerPrefs</code>中。调用<code>PlayerPrefs.Save()</code>可以手动保存更改，但通常这不是必需的，因为Unity会在游戏结束时自动保存<code>PlayerPrefs</code>数据。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetInt</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span>; <span class="comment">// key 键 value 值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetFloat</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">float</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.SetInt(<span class="string">&quot;score&quot;</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><h3 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h3><p>使用<code>PlayerPrefs.GetInt</code>、<code>PlayerPrefs.GetFloat</code>和<code>PlayerPrefs.GetString</code>等静态方法从<code>PlayerPrefs</code>中检索数据。这些方法需要一个键名作为参数，并返回与该键名关联的数据。如果指定的键名不存在，则可以提供一个默认值作为第二个参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetInt</span>(<span class="params"><span class="built_in">string</span> key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">GetFloat</span>(<span class="params"><span class="built_in">string</span> key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetString</span>(<span class="params"><span class="built_in">string</span> key</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> highScore = PlayerPrefs.GetInt(<span class="string">&quot;HighScore&quot;</span>, <span class="number">0</span>); <span class="comment">// 如果HighScore不存在，则返回0</span></span><br><span class="line"><span class="built_in">string</span> username = PlayerPrefs.GetString(<span class="string">&quot;Username&quot;</span>, <span class="string">&quot;Guest&quot;</span>); <span class="comment">// 如果Username不存在，则返回&quot;Guest&quot;</span></span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>使用<code>PlayerPrefs.DeleteKey</code>方法可以删除<code>PlayerPrefs</code>中的单个键值对。<code>PlayerPrefs.DeleteAll</code>方法会删除<code>PlayerPrefs</code>中的所有数据。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.DeleteKey(<span class="string">&quot;HighScore&quot;</span>); <span class="comment">// 删除HighScore键值对</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">PlayerPrefs.DeleteAll(); <span class="comment">// 删除所有PlayerPrefs数据，慎用！</span></span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerData</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> playerName; <span class="comment">// 角色名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> playerHealth; <span class="comment">// 角色血量</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 playerPosition; <span class="comment">// 角色位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Score; <span class="comment">// 得分</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        LoadFromPlayerPrefs(); <span class="comment">// 游戏开始时加载调用存储的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当保存并退出按钮被触发时执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveAndBack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        SaveByPlayerPrefs(); <span class="comment">// 保存数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveByPlayerPrefs</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PlayerPrefs.SetString(<span class="string">&quot;PlayerName&quot;</span>, playerName);</span><br><span class="line">        PlayerPrefs.SetFloat(<span class="string">&quot;PlayerHealth&quot;</span>, playerHealth);</span><br><span class="line">        PlayerPrefs.Setint(<span class="string">&quot;Score&quot;</span>, Score);</span><br><span class="line">        PlayerPrefs.SetFloat(<span class="string">&quot;PlayerPo_x&quot;</span>, playerPosition.x);</span><br><span class="line">        PlayerPrefs.SetFloat(<span class="string">&quot;PlayerPo_y&quot;</span>, playerPosition.y);</span><br><span class="line">        PlayerPrefs.SetFloat(<span class="string">&quot;PlayerPo_z&quot;</span>, playerPosition.z);</span><br><span class="line">        PlayerPrefs.Save();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadFromPlayerPrefs</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        playerName = PlayerPrefs.GetString(<span class="string">&quot;PlayerName&quot;</span>, <span class="string">&quot;None&quot;</span>);</span><br><span class="line">        playerHealth = PlayerPrefs.GetFloat(<span class="string">&quot;PlayerHealth&quot;</span>, <span class="number">100f</span>);</span><br><span class="line">        Score = PlayerPrefs.Getint(<span class="string">&quot;Score&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        playerPosition = <span class="keyword">new</span>(PlayerPrefs.GetFloat(<span class="string">&quot;PlayerPo_x&quot;</span>, <span class="number">0f</span>),</span><br><span class="line">                             PlayerPrefs.GetFloat(<span class="string">&quot;PlayerPo_y&quot;</span>, <span class="number">0f</span>), </span><br><span class="line">                             PlayerPrefs.GetFloat(<span class="string">&quot;PlayerPo_z&quot;</span>, <span class="number">0f</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>由于<code>PlayerPrefs</code>数据存储在设备的本地存储中，因此它可能受到设备存储空间或用户隐私设置的影响。</li><li>在使用<code>PlayerPrefs</code>时，建议为键名添加前缀或后缀，以确保它们在不同游戏或应用之间保持唯一性。</li><li>虽然<code>PlayerPrefs</code>提供了基本的数据持久化功能，但对于需要处理复杂数据结构或大量数据的游戏来说，可能需要考虑使用更高级的数据存储解决方案，如数据库或文件系统。</li></ul><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p><strong>PlayerPrefs适合用来存储暂时性数据，如：</strong></p><ul><li>玩家设定偏好</li><li>简单的数据</li><li>游戏原型制作时暂时的存储方案</li></ul><mark class="hl-label orange">总之，PlayerPrefs设计的初衷就不是为了真正的玩家存档而服务的，但它有其存在的理由，如何使用好这个工具，才是我们作为游戏制作者应该掌握的关键。</mark><p><strong>相关资料 -&gt;</strong> <a href="https://docs.unity3d.com/ScriptReference/PlayerPrefs.html">https://docs.unity3d.com/ScriptReference/PlayerPrefs.html</a></p><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p><code>JSON</code>是<code>JavaScript Object Notation（JavaScript对象注释/表示法）</code>的简称，是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成。在Unity中，我们可以通过序列化&#x2F;反序列化对象到JSON字符串的方式来实现存档功能。</p><p><strong>参考资料 -&gt;</strong> <a href="https://www.json.org/json-zh.html">https://www.json.org/json-zh.html</a></p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>JSON是一种基于文本的格式，用于表示数据。它使用键值对来表示对象，使用数组来表示一组值。例如，一个表示玩家的JSON对象可能如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;gold&quot;</span><span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;equipment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;剑&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;武器&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;盾&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;防具&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>支持复杂数据结构，如数组、列表、字典等。</li><li>数据量大小无限制（受限于系统存储空间）。</li><li>安全性较高，可通过加密等手段保护数据。</li><li>跨平台兼容性好，JSON是标准的文本格式，易于在不同平台间交换数据。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>需要编写额外的序列化&#x2F;反序列化代码。</li><li>相对于PlayerPrefs，使用上稍显复杂。</li></ul><h3 id="与PlayerPrefs对比"><a href="#与PlayerPrefs对比" class="headerlink" title="与PlayerPrefs对比"></a>与PlayerPrefs对比</h3><ul><li>JSON更适合存储复杂数据结构和大量数据。</li><li>JSON提供了更高的灵活性和可扩展性。</li><li>在处理简单数据类型和少量数据时，PlayerPrefs可能更便捷。</li></ul><h2 id="JsonUtility"><a href="#JsonUtility" class="headerlink" title="JsonUtility"></a>JsonUtility</h2><p>在Unity中，要将对象保存为JSON字符串，需要对其进行序列化；同样，要从JSON字符串恢复对象，需要对其进行反序列化。Unity提供了<code>JsonUtility</code>类来简化这一过程。</p><ul><li><strong>序列化</strong>：使用<code>JsonUtility.ToJson()</code>方法将对象转换为JSON字符串。</li><li><strong>反序列化</strong>：使用<code>JsonUtility.FromJson&lt;T&gt;()</code>方法将JSON字符串转换回对象。</li></ul><p><img src="https://image.flashfish777.cn/img/post_9_1.jpg"></p><h2 id="使用JsonUtility进行存档"><a href="#使用JsonUtility进行存档" class="headerlink" title="使用JsonUtility进行存档"></a>使用JsonUtility进行存档</h2><h3 id="定义可序列化的类"><a href="#定义可序列化的类" class="headerlink" title="定义可序列化的类"></a>定义可序列化的类</h3><p>在Unity中，只有标记为<code>[Serializable]</code>的类才能被<code>JsonUtility</code>序列化。因此，需要为要存档的数据定义可序列化的类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> level;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> gold;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Equipment&gt; equipment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Equipment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意，并不是所有数据都可以被正常的序列化：</p><p><img src="https://image.flashfish777.cn/img/post_9_2.jpg"></p><p><img src="https://image.flashfish777.cn/img/post_9_3.jpg"></p><p><img src="https://image.flashfish777.cn/img/post_9_4.jpg"></p><h3 id="序列化并保存数据"><a href="#序列化并保存数据" class="headerlink" title="序列化并保存数据"></a>序列化并保存数据</h3><p>在Unity中，可以通过以下步骤将<code>PlayerData</code>对象序列化为JSON字符串，并保存到文件中：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SavePlayerData</span>(<span class="params">PlayerData playerData, <span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将数据序列化</span></span><br><span class="line">    <span class="built_in">string</span> json = JsonUtility.ToJson(playerData);</span><br><span class="line">    <span class="comment">// 获取存储文件地址</span></span><br><span class="line">    <span class="built_in">string</span> filePath = Path.Combine(Application.persistentDataPath, fileName + <span class="string">&quot;.json&quot;</span>);</span><br><span class="line">    <span class="comment">// 将JSON写入文件中</span></span><br><span class="line">    File.WriteAllText(filePath, json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取并反序列化数据"><a href="#读取并反序列化数据" class="headerlink" title="读取并反序列化数据"></a>读取并反序列化数据</h3><p>当需要加载存档时，可以从文件中读取JSON字符串，并使用<code>JsonUtility.FromJson&lt;T&gt;()</code>方法将其反序列化为<code>PlayerData</code>对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PlayerData <span class="title">LoadPlayerData</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取存储文件地址</span></span><br><span class="line">    <span class="built_in">string</span> filePath = Path.Combine(Application.persistentDataPath, fileName + <span class="string">&quot;.json&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断是否有对应文件</span></span><br><span class="line">    <span class="keyword">if</span> (File.Exists(filePath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取JSON字符串</span></span><br><span class="line">        <span class="built_in">string</span> json = File.ReadAllText(filePath);</span><br><span class="line">        <span class="comment">// 将JSON反序列化</span></span><br><span class="line">        PlayerData playerData = JsonUtility.FromJson&lt;PlayerData&gt;(json);</span><br><span class="line">        <span class="keyword">return</span> playerData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有文件打印提示</span></span><br><span class="line">        Debug.LogError(<span class="string">$&quot;File <span class="subst">&#123;filePath&#125;</span> not found!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>首先创建一个公有的静态类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SaveSystemTutorial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SaveSystem</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 存档</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveByJson</span>(<span class="params"><span class="built_in">string</span> saveFileName, <span class="built_in">object</span> data</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> json = JsonUtility.ToJson(data);</span><br><span class="line">            <span class="keyword">var</span> path = Path.Combine(Application.persistentDataPath, saveFileName);</span><br><span class="line">            <span class="comment">/* Application.persistentDataPath用来提供一个存储永久数据的路径，并且</span></span><br><span class="line"><span class="comment">             当我们将游戏打包发布在不同平台上时，这个路径会随着我们发布的平台自动变更 */</span></span><br><span class="line">            </span><br><span class="line">            Debug.Log(<span class="string">$&quot;save data to <span class="subst">&#123;path&#125;</span>.&quot;</span>); <span class="comment">// 这里我们可以输出这个路径找到文件</span></span><br><span class="line"></span><br><span class="line">            File.WriteAllText(path, json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读档</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">LoadFromJson</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> saveFileName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> path = Path.Combine(Application.persistentDataPath, saveFileName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> json = File.ReadAllText(path);</span><br><span class="line">            <span class="keyword">var</span> data = JsonUtility.FromJson&lt;T&gt;(json);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteSaveFile</span>(<span class="params"><span class="built_in">string</span> saveFileName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> path = Path.Combine(Application.persistentDataPath, saveFileName);</span><br><span class="line"></span><br><span class="line">            File.Delete(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再其他脚本中使用<code>SaveSystemTutorial</code>命名空间并实现存储数据函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> SaveSystemTutorial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name; <span class="comment">// 角色名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> health; <span class="comment">// 角色血量</span></span><br><span class="line">       <span class="keyword">public</span> Vector3 position; <span class="comment">// 角色位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> score; <span class="comment">// 得分</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;GameObject&gt; enermy; <span class="comment">// 敌人列表</span></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">System.Serializable</span>]</span><br><span class="line">    <span class="keyword">class</span> <span class="title">SaveData</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> playerName; <span class="comment">// 角色名称</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> playerHealth; <span class="comment">// 角色血量</span></span><br><span class="line">           <span class="keyword">public</span> Vector3 playerPosition; <span class="comment">// 角色位置</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Score; <span class="comment">// 得分</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;GameObject&gt; Enermy; <span class="comment">// 敌人列表</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveAndBack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SaveData data = <span class="keyword">new</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            playerName = name;</span><br><span class="line">            playerHealth = health;</span><br><span class="line">               playerPosition = position;</span><br><span class="line">            Score = score;</span><br><span class="line">            Enermy = enermy;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        SaveSystem.SaveByJson(<span class="string">&quot;player.save&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadData</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取文件地址判断文件是否存在</span></span><br><span class="line">        <span class="keyword">var</span> Path = Application.persistentDataPath + <span class="string">&quot;\\player.save&quot;</span>;</span><br><span class="line">        SaveData data;</span><br><span class="line">        <span class="keyword">if</span> (File.Exists(HistoryPath))</span><br><span class="line">        &#123;</span><br><span class="line">            data = SaveSystem.LoadFromJson&lt;SaveData&gt;(<span class="string">&quot;player.save&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将数据赋回</span></span><br><span class="line">            name = data.playerName;</span><br><span class="line">            health = data.playerHealth;</span><br><span class="line">            position = data.playerPosition;</span><br><span class="line">            score = data.Score;</span><br><span class="line">            enermy = data.Enermy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> Debug.Log(<span class="string">&quot;Not Found!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后通过输出的文件路径就可以找到我们的存档啦：</p><p><img src="https://image.flashfish777.cn/img/post_9_5.jpg"></p><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><strong>数据安全性</strong>：直接以明文形式保存JSON文件可能会带来数据泄露的风险。在需要保护用户数据的情况下，应考虑对JSON数据进行加密。</li><li><strong>跨平台兼容性</strong>：<code>Application.persistentDataPath</code>会自动处理不同平台上的文件路径差异，使得存档系统能够跨平台工作。</li><li><strong>性能考虑</strong>：对于大型游戏或频繁存档的场景，需要关注序列化&#x2F;反序列化操作对性能的影响。</li><li><strong>错误处理</strong>：在文件读写过程中，应添加适当的错误处理逻辑，以应对文件不存在、磁盘空间不足等异常情况。</li></ol><h2 id="使用JSON文件而不是PlayerPrefs的原因"><a href="#使用JSON文件而不是PlayerPrefs的原因" class="headerlink" title="使用JSON文件而不是PlayerPrefs的原因"></a>使用JSON文件而不是PlayerPrefs的原因</h2><p>前面提到过<strong>PlayerPrefs</strong>可以存储字符串类型的数据，而JSON数据实际上就是字符串，所以PlayerPrefs实际上也可以存储JSON数据。</p><p>不建议用PlayerPrefs存JSON的原因主要有以下几点：</p><h3 id="存储效率与灵活性"><a href="#存储效率与灵活性" class="headerlink" title="存储效率与灵活性"></a>存储效率与灵活性</h3><p>PlayerPrefs的存储方式相对简单直接，但这也限制了其存储效率和灵活性。当需要存储大量数据时，PlayerPrefs可能会因为频繁地读写磁盘而导致性能下降。此外，由于PlayerPrefs只支持简单的数据类型，因此在处理复杂数据结构时，往往需要将数据转换为字符串进行存储，这在读取时又需要反序列化回原始数据结构，增加了额外的处理步骤和可能的性能开销。相比之下，直接使用JSON文件或其他数据库系统存储复杂数据，可以更加高效和灵活地管理数据。</p><h3 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h3><p>虽然PlayerPrefs本身在数据安全方面并没有直接的漏洞，但由于其存储的数据类型简单且易于访问，因此如果游戏或应用程序中涉及敏感信息（如用户密码、支付信息等），则不建议使用PlayerPrefs进行存储。此外，由于PlayerPrefs的数据通常存储在用户设备的文件系统中，因此如果设备被恶意软件攻击或用户拥有足够的权限，那么存储在PlayerPrefs中的数据就有可能被非法读取或篡改。对于需要保护用户数据安全的场景，建议使用更加安全的数据存储方案。</p><h3 id="可扩展性和可维护性"><a href="#可扩展性和可维护性" class="headerlink" title="可扩展性和可维护性"></a>可扩展性和可维护性</h3><p>随着游戏或应用程序的不断发展，可能需要存储的数据量也会不断增加，数据结构也会变得更加复杂。如果一直使用PlayerPrefs来存储这些数据，那么随着数据的增加和数据结构的复杂化，代码的可读性、可维护性和可扩展性都会受到影响。相比之下，使用JSON文件或其他数据库系统来存储数据，可以更加方便地管理数据结构和数据变更，提高代码的可读性、可维护性和可扩展性。</p><p>所以，虽然PlayerPrefs在存储简单数据方面具有一定的优势，但在需要处理复杂数据结构、大量数据或敏感信息时，建议使用更加高效、灵活和安全的数据存储方案。对于JSON数据的存储和读取，建议使用Unity内置的JsonUtility类或其他第三方JSON库来实现序列化和反序列化操作，并将数据存储在文件系统或数据库中以便后续管理和使用。</p><h2 id="适用范围-1"><a href="#适用范围-1" class="headerlink" title="适用范围"></a>适用范围</h2><p><strong>联网</strong></p><ul><li>优秀的网络数据交换载体</li><li>云存档</li></ul><p><strong>本地存储</strong></p><ul><li>非敏感而需要大量读取的数据，如：Mod数据</li><li>玩家的偏好设置等</li></ul><p><strong>相关资料 -&gt;</strong> <a href="https://docs.unity3d.com/ScriptReference/JsonUtility.html">https://docs.unity3d.com/ScriptReference/JsonUtility.html</a></p><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>通过本文章的介绍，我们深入了解了Unity中的两种主要存档方式——PlayerPrefs和JSON存档。每种方法都有其独特的优势和适用场景。开发者应根据项目的具体需求、数据复杂度以及目标平台的特性来选择最合适的存档策略。无论是追求简单快捷的PlayerPrefs，还是注重数据复杂性和安全性的JSON存档，都能在Unity中找到实现方法，为玩家带来更加流畅和丰富的游戏体验。</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
            <tag> 数据持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity日记：场景切换与并发编程</title>
      <link href="/posts/fdbe57b8.html"/>
      <url>/posts/fdbe57b8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Unity场景切换"><a href="#Unity场景切换" class="headerlink" title="Unity场景切换"></a>Unity场景切换</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在游戏开发中，场景切换，这一看似简单的操作，实则蕴含着提升游戏体验、增强故事叙述能力的无限潜力。今天，就让我们一同踏上这场Unity中场景切换的魔法之旅，揭开那些让游戏世界流畅衔接、引人入胜的秘密。</p><p>在快节奏的游戏开发中，场景切换往往被视为一个“必经之路”，而非核心功能。然而，正是这些看似不起眼的环节，构成了玩家游戏体验的重要组成部分。一个精心设计的场景切换不仅能有效减少加载时间带来的等待感，还能通过视觉和情感的引导，加深玩家对游戏世界的沉浸感。更重要的是，它还能作为游戏叙事的一部分，引导玩家逐步揭开故事的真相，体验更加丰富和深刻的游戏内容。想象一下，你的玩家正在紧张刺激的战斗后，通过一段华丽的过渡动画，瞬间穿越到宁静祥和的村庄；或者是在解开谜题后，随着一阵悠扬的音乐，眼前的景象逐渐模糊，再清晰时已是另一个充满挑战的关卡。这样的场景切换，不仅让玩家感受到游戏的连贯性和惊喜，更激发了他们对未知世界的好奇心和探索欲。而这，正是我们今天要探讨的——如何在Unity中利用场景切换的魔法，为你的游戏增添无限魅力。</p><p>撰写一篇关于在Unity中进行场景切换的博客文章是一个很好的主意，因为这对于开发任何类型的游戏或应用来说都是一项基础且重要的技能。以下是一个结构化的博客文章大纲，以及一些关键内容的建议，帮助你撰写这篇博客。</p><h2 id="什么是场景（Scene）？"><a href="#什么是场景（Scene）？" class="headerlink" title="什么是场景（Scene）？"></a>什么是场景（Scene）？</h2><p>在Unity中，**场景（Scene）**是构建游戏世界的基石。所有GameObject都在场景中，它包含了游戏运行时所需的所有元素，如3D模型、灯光、摄像机、UI界面、音效以及脚本逻辑等。每个场景都代表了一个独立的游戏环境或关卡，玩家在其中进行互动和探索。Unity编辑器提供了直观的工具来创建、编辑和管理多个场景。开发者可以轻松地添加、删除或修改场景中的元素，并通过场景管理器来组织和管理这些场景文件。游戏通常由多个场景组成，这些场景通过场景切换相互连接，共同构成了完整的游戏流程。场景切换不仅是技术上的实现，更是游戏叙事和玩家体验的重要组成部分。</p><p><img src="https://image.flashfish777.cn/img/post_8_1.jpg"></p><h2 id="如何切换场景"><a href="#如何切换场景" class="headerlink" title="如何切换场景"></a>如何切换场景</h2><h3 id="SceneManager类"><a href="#SceneManager类" class="headerlink" title="SceneManager类"></a>SceneManager类</h3><p><code>SceneManager</code>是Unity提供的一个用于<strong>管理场景加载、卸载和切换</strong>的类。它提供了丰富的API来支持场景的各种操作。</p><p>1.首先打开菜单栏的<code>File</code>-&gt; <code>Build Settings</code>，确保你的场景已经添加到这里，记住对应场景的序号。</p><p><img src="https://image.flashfish777.cn/img/post_8_2.jpg"></p><p>2.<code>SceneManager</code>类提供了<code>SceneManager.LoadScene</code>方法实现场景的加载与切换，以下是代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;  </span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement; <span class="comment">// 确保使用了UnityEngine.SceneManagement命名空间</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneSwitcher</span> : <span class="title">MonoBehaviour</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 场景切换函数，该函数可以通过按钮或在任何需要的情况下被调用，实现场景转换  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SceneChange</span>()</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 使用SceneManager的LoadScene方法来加载新场景  </span></span><br><span class="line">        <span class="comment">// 第一个参数是场景名称</span></span><br><span class="line">        <span class="comment">// 第二个参数是加载模式</span></span><br><span class="line">        SceneManager.LoadScene(<span class="string">&quot;nextScene&quot;</span>, LoadSceneMode.Single);</span><br><span class="line">        <span class="comment">// SceneManager.LoadScene(1); // 第一个参数可直接使用场景名称，也可使用对应的场景序号</span></span><br><span class="line">        <span class="comment">// 无论使用的是场景名称还是序号，场景都必须要被添加在Build中</span></span><br><span class="line">        <span class="comment">// 第二个参数一般情况下省略</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.函数被调用时，游戏会<strong>暂停当前场景的所有操作</strong>，等待新场景完全加载到内存中并激活后，再继续执行后续操作。这个过程是<strong>阻塞的</strong>，即<strong>直到新场景加载完成，游戏才会继续运行</strong>。这个过程，也被称为同步加载。</p><h3 id="同步加载"><a href="#同步加载" class="headerlink" title="同步加载"></a>同步加载</h3><p><strong>过程：</strong></p><ol><li><strong>触发加载</strong>：通过调用场景加载的方法，并传入要加载的场景名称或索引作为参数，来触发场景的加载过程。</li><li><strong>等待加载</strong>：在加载过程中，游戏会暂停当前场景的所有操作（如渲染、物理计算、用户输入响应等），直到新场景完全加载到内存中。</li><li><strong>场景切换</strong>：当新场景加载完成后，Unity会销毁当前场景（如果加载模式为Single），并激活新场景，然后游戏继续执行后续操作。</li></ol><p>可如果我们的目标场景数据十分庞大呢？这意味着我们在<strong>等待加载</strong>的过程中就会出现我们都遇到过的事情，那就是卡顿。我们需要等很长时间来加载目标场景的数据。这时如果我们使用同步加载，在这期间游戏处于暂停中，玩家很可能以为自己卡了，大大降低体验度。<strong>使用异步加载就可以解决这个问题。</strong></p><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p><strong>异步加载</strong>中加载新场景的行为是在<strong>后台线程</strong>中进行的，不影响主线程（即游戏当前场景）的运行。它的过程为<code>触发加载</code> -&gt; <code>后台加载</code> -&gt;  <code>场景切换</code> </p><p>使用了异步加载，我们就可以在等待加载的过程中播放一些其他操作，如待机画面、加载进度条等。</p><p>以下是使用异步加载进行场景切换并添加加载进度条与点击继续的操作示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;  </span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI; <span class="comment">// 引用UI相关命名空间</span></span><br><span class="line"><span class="keyword">using</span> TMPro;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneLoader</span> : <span class="title">MonoBehaviour</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> GameObject loadScreen; <span class="comment">// 加载界面Panel</span></span><br><span class="line">    <span class="keyword">public</span> Slider slider; <span class="comment">// 加载界面进度条</span></span><br><span class="line">    <span class="keyword">public</span> TextMeshProUGUI text; <span class="comment">// 进度文本</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadScene</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(Loadlevel()); <span class="comment">// 使用协程</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 异步加载场景，控制进度条</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Loadlevel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        loadScreen.SetActive(<span class="literal">true</span>); <span class="comment">// 显示加载界面</span></span><br><span class="line"></span><br><span class="line">        AsyncOperation operation = SceneManager.LoadSceneAsync(<span class="string">&quot;MainScene&quot;</span>);</span><br><span class="line">        <span class="comment">// SceneManager.LoadSceneAsync方法返回一个AsyncOperation对象，</span></span><br><span class="line">        <span class="comment">// 在加载过程中，你可以通过返回的AsyncOperation对象来获取加载进度、检查是否加载完成等。</span></span><br><span class="line"></span><br><span class="line">        operation.allowSceneActivation = <span class="literal">false</span>; <span class="comment">// 默认加载完成不切换场景</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!operation.isDone)</span><br><span class="line">        &#123;</span><br><span class="line">            slider.<span class="keyword">value</span> = operation.progress; <span class="comment">// 让进度条的值等于加载进度（slider与加载进度的值都是0~1的浮点数）</span></span><br><span class="line"></span><br><span class="line">            text.text = (<span class="built_in">int</span>)(operation.progress * <span class="number">100</span>) + <span class="string">&quot;%&quot;</span>; <span class="comment">// 显示加载进度百分数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (operation.progress &gt;= <span class="number">0.9f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                slider.<span class="keyword">value</span> = <span class="number">1</span>; <span class="comment">// 场景加载完成后，progress返回的值不是1，所以要单独设定进度条的值</span></span><br><span class="line">                text.text = <span class="string">&quot;点击任意位置继续&quot;</span>; <span class="comment">// 加载完成后百分比进度变为提示</span></span><br><span class="line">                <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    operation.allowSceneActivation = <span class="literal">true</span>; <span class="comment">// 切换场景</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了很大型的游戏项目之外，大部分情况下，场景的加载总是一瞬间完成的，如果仍然想要做出像大型游戏加载那样的加载界面效果，可以尝试使用异步加载制作伪加载进度条，即进度条的进度与播放时间由开发者设定，实际上与加载时间无关，实现过渡界面的效果。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table><thead><tr><th></th><th>同步加载</th><th>异步加载</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>加载新场景时，游戏会暂停当前场景的所有操作，等待新场景完全加载并激活后继续执行。</td><td>加载新场景的行为是在后台线程中进行的，不影响主线程（即游戏当前场景）的运行。</td></tr><tr><td><strong>过程</strong></td><td>1. 触发加载<br>2. 等待加载（游戏暂停）<br>3. 场景切换（加载完成后继续）</td><td>1. 触发加载<br>2. 后台加载（游戏继续运行）<br>3. 场景切换（加载完成后通过回调或检查状态继续）</td></tr></tbody></table><p><strong>对游戏流畅度的影响</strong>：</p><ul><li><strong>同步加载</strong>：由于加载过程中游戏会暂停，因此当加载的场景较大或资源较多时，会导致明显的卡顿或延迟，影响用户体验。</li><li><strong>异步加载</strong>：加载过程在后台进行，不影响游戏当前场景的运行，因此即使加载大型场景也不会造成游戏卡顿，提升了游戏的流畅度和用户体验。</li></ul><p><strong>使用场景</strong>：</p><ul><li><strong>同步加载</strong>：适用于场景较小、资源较少，或对加载时间要求不高的场合。</li><li><strong>异步加载</strong>：更适用于场景较大、资源较多，或对加载时间有较高要求的场合，如制作场景切换过程中的过渡界面、实现无缝加载等。</li></ul><p><strong>实现方式</strong>：</p><ul><li><strong>同步加载</strong>：直接调用加载场景的方法，并等待加载完成。</li><li><strong>异步加载</strong>：调用加载场景的方法时，需要处理返回的异步对象（如<code>AsyncOperation</code>），以便在加载过程中进行进度监控、加载完成后的回调等。</li></ul><p>同步加载和异步加载在Unity中各有其适用场景和优缺点。在实际开发中，应根据游戏的具体需求和资源情况来选择合适的加载方式。</p><h2 id="场景间的数据传递"><a href="#场景间的数据传递" class="headerlink" title="场景间的数据传递"></a>场景间的数据传递</h2><ul><li><strong>全局变量</strong>：使用静态类或单例模式存储全局数据，以便在不同场景之间共享信息。</li><li><strong>PlayerPrefs</strong>：适用于存储少量非敏感数据，如玩家设置。 <a class="btn-beautify green larger" href="/posts/a985624f.html#PlayerPrefs" title="Unity日记：存档系统-PlayerPrefs"><i class="far fa-hand-point-right"></i><span>Unity日记：存档系统-PlayerPrefs</span></a></li><li><strong>SceneManager的<code>DontDestroyOnLoad</code>方法</strong>：用于在场景切换时保留某些对象，如游戏管理器或UI系统。</li></ul><hr><h1 id="关于并发编程"><a href="#关于并发编程" class="headerlink" title="关于并发编程"></a>关于并发编程</h1><p>在Unity中，我们刚刚探讨了场景切换的两种方式：同步加载与异步加载。特别是异步加载，通过<code>SceneManager.LoadSceneAsync</code>方法，我们能够在<strong>不阻塞主线程</strong>的情况下加载新场景，这种非阻塞的特性极大地提升了游戏的流畅度和用户体验。而实现这种异步加载背后，Unity的<code>协程（Coroutine）</code>机制扮演了至关重要的角色。<strong>协程</strong>允许我们在Unity的主线程上**“伪并行”**地执行代码块，每个协程在每次迭代后都会暂停，直到下一次主线程循环中再次被唤醒。这种机制虽然并非传统意义上的并行处理，但它有效地利用了Unity的单一更新循环，模拟了并发执行的效果。</p><p>那么，当我们谈论到并发编程时，我们实际上是在探讨如何在多个处理单元（如CPU核心）上同时执行多个任务，以充分利用硬件资源，提高程序的整体执行效率。在Unity这样的游戏开发环境中，并发编程不仅限于简单的协程使用，它还包括多线程编程、任务并行库（TPL）的使用（在Unity中不直接支持，但可通过C#的<code>System.Threading</code>和<code>System.Threading.Tasks</code>命名空间实现跨平台兼容性处理）、以及针对特定硬件优化的并行计算API（如Compute Shaders、Job System和Burst Compiler等Unity 2018及以后版本中引入的高级功能）。</p><p>从异步加载和协程的视角过渡到并发编程，我们可以理解为：**协程为我们提供了一种在游戏主循环内管理复杂流程和异步操作的有效方式，而并发编程则是将这种思想扩展到了更广泛的层面，即跨越多个处理单元来并行执行多个任务。**在Unity中，合理利用并发编程技术，可以显著减少游戏运行时的延迟，提升游戏性能，特别是在处理大量数据计算、物理模拟、AI决策等计算密集型任务时。</p><p>然而，并发编程也伴随着复杂性增加和潜在的资源竞争、死锁等问题。因此，在设计并发系统时，开发者需要仔细规划任务之间的依赖关系，合理使用同步机制，确保数据的一致性和系统的稳定性。在Unity的上下文中，这意味着要深入理解<a href="https://blog.csdn.net/xiaoyaoACi/article/details/119324146?spm=1001.2014.3001.5502">Unity的生命周期</a>、线程安全以及如何利用Unity提供的并发工具和最佳实践来优化游戏性能。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>并发编程</strong>是一种程序设计方法，‌它由若干个可同时执行的程序模块组成，‌这些模块被称为进程。‌这些进程可以同时在多台处理器上并行执行，‌也可以在一台处理器上交替执行。‌采用并发程序设计可以使外围设备和处理器并行工作，‌从而缩短程序执行时间，‌提高计算机系统效率。‌</p><p>在并发编程中，‌有几个核心概念需要理解：‌</p><ul><li><strong>进程与线程</strong>：‌进程是执行过程中分配和管理资源的基本单位，‌而线程是进程的一个执行单元，‌是进程内可调度的实体。‌线程也可以被称为轻量级进程，‌它是比进程更小的独立运行的基本单位。‌多个线程可以存在于一个进程中，‌并发执行并共享资源（‌如内存）‌，‌而不同的进程不共享这些资源。‌</li><li><strong>同步和异步</strong>：‌同步和异步通常用来形容一次方法调用。‌同步方法调用需要调用者等待方法调用返回后才能继续后续的行为，‌而异步方法调用一旦开始，‌方法调用就会立即返回，‌允许调用者继续执行其他操作，‌而异步方法在另一个线程中“真实”地执行。</li><li><strong>并发和并行</strong>：‌并发和并行都可以用来表示两个或多个任务一起执行，‌但侧重点不同。‌并发强调任务可以交替执行，‌而并行则强调真正的同时执行。‌在单核CPU下，‌通过任务调度器将CPU的时间片分配给不同的程序使用，‌由于CPU在时间片之间快速切换，‌人类感觉是同时运行的，‌这被称为并发。‌而在多核CPU下，‌多个核心可以同时处理多个线程，‌这才是真正的并行执行。</li><li><strong>临界区</strong>：‌临界区通常指共享数据，‌可以被多个线程使用。‌当有线程进入临界区时，‌其他线程或进程必须等待。‌例如，‌当一个线程正在修改共享变量时，‌其他试图访问该变量的线程必须等待直到第一个线程完成操作。‌</li></ul><h2 id="进程、线程与协程的关系"><a href="#进程、线程与协程的关系" class="headerlink" title="进程、线程与协程的关系"></a>进程、线程与协程的关系</h2><p><img src="https://image.flashfish777.cn/img/post_8_3.jpg" alt="进程、线程与协程的关系"></p><p>线程和协程都是进程的子集，一个进程可以有多个协程，一线程也可以有多个协程，进程基于程序主体。</p><p><strong>IO密集型一般使用多线程或多进程</strong>。<strong>CPU密集型一般使用多进程</strong>。<strong>强调非阻塞异步并发的一般都用协程</strong>。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是系统分配资源和调度资源的一个独立单位，<strong>每个进程都有自己的独立内存空间</strong>，<strong>不同进程间可以进行进程间通信</strong>。进程<strong>重量级比较大</strong>，占据独立内存，上下文进程间的切换开销（栈寄存器、虚拟内存、文件句柄）比较大，但相对稳定安全。进程的上级为操作系统，有自己固定的堆栈。</p><p><strong>进程间通信（IPC）</strong></p><ul><li><strong>管道（Pipe）</strong>：管道是Unix中最古老的进程间通信的形式，我们把从一个进程连接到另一个进程的一个数据流称为一个“管道”。其本质是内核中固定大小的缓冲区。</li><li><strong>命名管道（Named Pipes）</strong>：“命名管道”又名“命名管线”（Named Pipes），命名管道支持可靠的、单向或双向的数据通信。不同于匿名管道的是：命名管道可以在不相关的进程之间和不同计算机之间使用，服务器建立命名管道时给它指定一个名字，任何进程都可以通过该名字打开管道的另一端，根据给定的权限和服务器进程通信。</li><li><strong>消息队列（MQ，Message Quene）</strong>：消息队列用于在进程间通信的过程中将消息按照队列存储起来，常见的MQ有ActiveMQ、RocketMQ、RabbitMQ、Kafka等。</li><li><strong>信号量（Semaphore）</strong>：有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前,线程必须获取一个信号量。</li><li><strong>共享内存（Share Memory）</strong>：共享内存是三个IPC机制中的一个。它允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在进行的进程之间传递数据的一种非常有效的方式。</li><li><strong>套接字（Socket）</strong>：就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。</li></ul><p>对于游戏开发者来说，最为常用的无疑是Socket，这是长连接网络游戏的核心。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程也被称为轻量级进程，是<strong>操作系统调度（CPU调度）执行的最小单位</strong>，是进程的子集。</p><p>线程<strong>本身基本不拥有资源</strong>，而是访问隶属于进程的资源，一个进程拥有至少一个或多个线程，<strong>线程间共享进程的地址空间</strong>。</p><p>由于<strong>线程是阻塞式</strong>的，如果想要同步执行IO，每个IO都必须开启一个新线程，<strong>多线程开销较大</strong>，适合多任务处理，进程崩溃不影响其他进程，而线程只是一个进程的不同执行路线。</p><p><strong>线程有自己的堆栈</strong>，却<strong>没有单独的地址空间</strong>，<strong>进程死就等于所有线程死</strong>，所以多进程要比多线程健壮。但在进程切换时，消耗资源较大，效率较差。</p><p>线程是并发的，且是阻塞式同步的，一旦资源死锁，线程将陷入混乱。在同步线程的执行过程中，<strong>线程的执行切换是由CPU轮转时间片的分配来决定的</strong>。</p><p><img src="https://image.flashfish777.cn/img/post_8_4.jpg" alt="线程状态图"></p><ul><li>新建状态：new创建一个线程时，还没开始运行，就是新建状态。</li><li>就绪状态：新建后，调用start()方法，线程就处于就绪态，等待CPU调度。</li><li>运行状态：当线程获得了CPU时间后，进入运行状态，执行run()里的内容</li><li>阻塞状态：线程运行中随时可能被阻塞：比如调用sleep()方法；等待获取锁被阻塞；线程在等待其他触发条件。暂时让出CPU资源。</li><li>死亡状态：有两个原因导致线程死亡：run()方法正常结束；一个未捕获的异常终止了run()方法</li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><strong>Unity 中所有脚本运行公用一条主线程，而协程是开辟的伪线程。这个伪线程可以让一个方法分多次执行，相当于让主线程劈几个叉。</strong></p><p>协程还称微线程，纤程，<strong>本质是一个单线程</strong>。<strong>协程是比线程更轻量级的存在</strong>，协程<strong>不由操作系统内核所管理</strong>，而是完全由程序所控制（也就是在<strong>用户态执行</strong>）。</p><p>协程的好处是性能大幅提升，不会像线程切换那样消耗资源。同一时间只能执行某个协程，开辟<strong>多个协程开销不大</strong>。<strong>适合对任务进行分时处理</strong>。</p><p><strong>协程有自己的寄存器和上下文栈</strong>。协程调度切换时，将寄存器和<strong>上下文栈保存到其他地方</strong>，并在协程切换回来时<strong>恢复之前保存的寄存器和上下文栈</strong>。由于<strong>直接对栈进行操作</strong>，<strong>基本没有内核切换的开销</strong>，可以<strong>不加锁的访问全局变量</strong>，所以上下文切换非常快。</p><p>一个线程可以有多个协程，一个进程也可以单独拥有多个协程。<strong>线程和进程都是同步机制，而协程是异步机制，无需阻塞</strong>。协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用时的状态。多协程间对CPU的使用是依次进行的，每次只有一个协程工作，而其他协程处于休眠状态。</p><p>实际上多个协程是在一个线程中的，只不过每个协程对CPU进行分时。<strong>协程可以访问和使用Unity的所有方法和Component</strong>。<strong>函数（子程序）的调用是通过栈实现的</strong>，一个线程就是执行一个函数，函数调用总是一个入口，一个返回，调用顺序是明确的，而<strong>协程在函数内部是可以中断的</strong>，然后<strong>转而执行其他函数</strong>，在<strong>适当的时候再返回来继续执行</strong>。函数（子程序）的切换不是由线程切换，而是程序自身控制，因此没有线程切换开销。和多线程相比，线程越多，协程的性能优势就越明显，切协程因为依次执行，<strong>不存在线程安全问题，变量访问不会冲突</strong>，共享资源也无需加锁，只需要判断状态即可，所以执行效率比线程高很多。</p><p><strong>协程的语法</strong></p><ul><li><code>yield</code>：暂停，通常用 <code>yield return null</code> 来暂停协程。</li><li><code>StartCoroutine(方法名())</code>：恢复执行。</li><li><code>WaitForSeconds</code>：引入时间延迟，默认情况下，协程将在 yield 后的帧上恢复。使用 <code>yield return new WaitForSecond(.1f)</code> 后，将延迟0.1秒后执行协程。</li></ul><p>例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> url = <span class="string">&quot;https://xxxx.xxxx.xxxx/xxxx.jpg&quot;</span>;</span><br><span class="line">    WWW www = <span class="keyword">new</span> WWW(url);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> WWW;</span><br><span class="line">    renderer.material.mainTexture = www.texture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当程序执行到 <code>yield return WWW</code>; 时就不会直接往下执行了，而是等到网络请求结束后的第一帧的<code>WWW</code>协程节点触发时才继续执行，也就是说，当网络请求结束后，纹理才会被替换。</p><p><strong>yield return对象</strong></p><ul><li><code>null或数字</code>：在Update后执行，适合分解耗时的逻辑处理。</li><li><code>WaitForFixedUpdate</code>：在FixedUpdate后执行，适合分解物理操作。</li><li><code>WaitForSeconds</code>：在指定时间后执行，适合延迟调用。</li><li><code>WaitForSecondsRealtime</code>：在指定时间后执行，适合延迟调用。不受时间缩放影响。</li><li><code>WaitForEndOfFrame</code>：在每帧结束后执行，适合相机跟随操作。</li><li><code>Coroutine</code>：在另一个协程执行完毕后再执行。</li><li><code>WaitUntil</code>：在委托返回true时执行，适合等待某一操作。</li><li><code>WaitWhile</code>：在委托返回false时执行，适合等待某一操作。</li><li><code>WWW</code>：在请求结束后执行，适合加载数据，如文件、贴图、材质等。</li></ul><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>通过并发编程，我们可以实现更复杂的游戏逻辑，如大规模场景中的动态光照计算、复杂物理效果的实时模拟等，而无需担心这些任务会拖慢游戏的主循环。此外，随着Unity对并发编程支持的不断增强，开发者们将有更多机会探索和利用现代硬件的并行处理能力，为玩家带来更加流畅、逼真的游戏体验。</p><p>从场景切换的异步加载到并发编程的深入探索，我学到了很多。通过掌握并发编程的精髓，我们不仅能够提升游戏的运行效率，还能为游戏设计带来更多可能性，让创意与技术的碰撞绽放出更加璀璨的光芒。</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity日记：小地图</title>
      <link href="/posts/bf08e6b6.html"/>
      <url>/posts/bf08e6b6.html</url>
      
        <content type="html"><![CDATA[<div class="note primary morden flat"><p><strong>今天分享一下如何在Unity小游戏中制作小地图！</strong></p></div><p>在Unity中制作小地图（或雷达）是游戏开发中常见的需求，用于展示游戏世界的局部或全局信息，帮助玩家更好地理解游戏环境。</p><h2 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h2><h3 id="搭建场景"><a href="#搭建场景" class="headerlink" title="搭建场景"></a>搭建场景</h3><p>首先，你需要在Unity中搭建一个简单的游戏场景。这可以包括玩家角色、敌人、障碍物等。</p><h3 id="创建新摄像机"><a href="#创建新摄像机" class="headerlink" title="创建新摄像机"></a>创建新摄像机</h3><ul><li><strong>新建摄像机</strong>：在Unity的层级列表（Hierarchy）中，直接右键选择<code>Camera</code>来创建一个新的摄像机。命名为<code>Minimap Camera</code>以区分主摄像机。</li><li><strong>设置摄像机位置</strong>：将<code>Minimap Camera</code>的位置设置为主角上方或其他你需要的地方，高度和角度都可以根据需要调整，确保摄像机可以捕捉到整个场景或你想要在小地图上显示的部分。</li><li><strong>移除Audio Listener</strong>：因为场景中只能有一个<code>Audio Listener</code>，所以需要从<code>Minimap Camera</code>中移除<code>Audio Listener</code>组件。</li></ul><h3 id="创建Render-Texture"><a href="#创建Render-Texture" class="headerlink" title="创建Render Texture"></a>创建Render Texture</h3><p>在Unity的Assets文件夹中，右键点击选择<code>Create</code> -&gt; <code>Render Texture</code>，创建一个新的Render Texture，命名为<code>Small Map</code>。</p><p><img src="https://image.flashfish777.cn/img/post_7_1.jpg"></p><h3 id="添加Raw-Image"><a href="#添加Raw-Image" class="headerlink" title="添加Raw Image"></a>添加Raw Image</h3><p>在Canvas中右键点击，选择<code>UI</code> -&gt; <code>Raw Image</code>来创建一个新的Raw Image，命名为<code>Minimap Image</code>。</p><p><img src="https://image.flashfish777.cn/img/post_7_2.jpg"></p><h2 id="配置摄像机"><a href="#配置摄像机" class="headerlink" title="配置摄像机"></a>配置摄像机</h2><h3 id="设置Render-Texture"><a href="#设置Render-Texture" class="headerlink" title="设置Render Texture"></a>设置Render Texture</h3><p><strong>分配Render Texture</strong>：选中<code>Minimap Camera</code>，在检视面板（Inspector）中找到<code>Target Texture</code>字段，将之前创建的<code>Minimap Render Texture</code>拖拽进去。</p><p><img src="https://image.flashfish777.cn/img/post_7_3.jpg"></p><h3 id="设置Raw-Image"><a href="#设置Raw-Image" class="headerlink" title="设置Raw Image"></a>设置Raw Image</h3><ul><li><strong>分配Render Texture</strong>：将之前创建的<code>Minimap Render Texture</code>拖拽到<code>Minimap Image</code>的<code>Texture</code>字段中。</li></ul><p><img src="https://image.flashfish777.cn/img/post_7_4.jpg"></p><h3 id="调整大小和位置"><a href="#调整大小和位置" class="headerlink" title="调整大小和位置"></a>调整大小和位置</h3><p>最后根据需要调整<code>Minimap Image</code>的大小和位置，确保它适合你的UI布局，小地图就做好啦！</p><h2 id="丰富小地图操作"><a href="#丰富小地图操作" class="headerlink" title="丰富小地图操作"></a>丰富小地图操作</h2><p>除了简单的地图显示之外，还可以添加一些交互操作，丰富玩家的体验。</p><p>比如我增加了放大、缩小按钮，还实现了点击小地图全屏查看，再次点击恢复的操作。</p><p><img src="https://image.flashfish777.cn/img/post_7_5.jpg"></p><p><strong>示例：</strong></p><p>放大缩小：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MapSize</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject player; <span class="comment">// player</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 保持在玩家上方</span></span><br><span class="line">        transform.position = <span class="keyword">new</span> Vector3(player.transform.position.x, transform.position.y, player.transform.position.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将相机下移实现放大</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Big</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (transform.position.y &gt; <span class="number">20</span>)</span><br><span class="line">            transform.position = <span class="keyword">new</span> Vector3(transform.position.x, transform.position.y - <span class="number">20</span>, transform.position.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将相机上移实现缩小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Small</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (transform.position.y &lt; <span class="number">400</span>)</span><br><span class="line">            transform.position = <span class="keyword">new</span> Vector3(transform.position.x, transform.position.y + <span class="number">20</span>, transform.position.z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>点击全屏：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClickMap</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject Mapp; <span class="comment">// 地图</span></span><br><span class="line">    <span class="built_in">bool</span> isBig = <span class="literal">false</span>; <span class="comment">// 大小状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Click</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBig) smaller(); <span class="comment">// 变小</span></span><br><span class="line">        <span class="keyword">else</span> Bigger(); <span class="comment">// 变大</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过改变Raw Image在Canvas的大小和位置来实现全屏效果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bigger</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isBig = <span class="literal">true</span>;</span><br><span class="line">        Mapp.GetComponent&lt;RectTransform&gt;().sizeDelta = <span class="keyword">new</span> Vector2(<span class="number">1080</span>, <span class="number">1080</span>);</span><br><span class="line">        Mapp.GetComponent&lt;RectTransform&gt;().anchoredPosition = <span class="keyword">new</span> Vector2(<span class="number">960</span>, <span class="number">-540</span>);</span><br><span class="line">        GetComponent&lt;RectTransform&gt;().sizeDelta = <span class="keyword">new</span> Vector2(<span class="number">1080</span>, <span class="number">1080</span>);</span><br><span class="line">        GetComponent&lt;RectTransform&gt;().anchoredPosition = <span class="keyword">new</span> Vector2(<span class="number">960</span>, <span class="number">-540</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">smaller</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isBig = <span class="literal">false</span>;</span><br><span class="line">        Mapp.GetComponent&lt;RectTransform&gt;().sizeDelta = <span class="keyword">new</span> Vector2(<span class="number">320</span>, <span class="number">320</span>);</span><br><span class="line">        Mapp.GetComponent&lt;RectTransform&gt;().anchoredPosition = <span class="keyword">new</span> Vector2(<span class="number">160</span>, <span class="number">-160</span>);</span><br><span class="line">        GetComponent&lt;RectTransform&gt;().sizeDelta = <span class="keyword">new</span> Vector2(<span class="number">320</span>, <span class="number">320</span>);</span><br><span class="line">        GetComponent&lt;RectTransform&gt;().anchoredPosition = <span class="keyword">new</span> Vector2(<span class="number">160</span>, <span class="number">-160</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多有意思的操作层出不穷，这里只是做个示例哈。分享就到这里啦，别的文章再会！</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
            <tag> 小地图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我与口袋方舟的故事...</title>
      <link href="/posts/83f43b84.html"/>
      <url>/posts/83f43b84.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直对游戏开发很感兴趣的我，经常在寻找与了解很多相关知识。</p><p>我们计算机与软件学院有幸组织了一次意义非凡的企业参访活动——走进成都西山居。这次活动让我对游戏行业有了更加深入的了解。</p><p>走进西山居的那一刻，我就被公司内浓厚的文化氛围和创意气息所吸引。位于中国（四川）自由贸易试验区成都高新区万象南路669号佳辰国际中心B座12层15号的西山居，不仅地理位置优越，更在行业内享有盛誉。作为一家以从事研究和试验发展为主的企业，西山居在游戏开发领域取得了令人瞩目的成就，特别是其经典游戏产品《剑侠情缘》系列，更是被誉为中国游戏第一品牌。</p><p>在参访过程中，人力资源总监曾荣竺老师为我们详细介绍了西山居的发展历程、公司文化以及在游戏领域的各项成果。她不仅让我们了解了西山居在游戏制作中的程序、策划、美术三大岗位的具体职责、技能要求以及发展方向，还通过生动的案例和深入浅出的讲解，为我们勾勒出了清晰的职业发展框架。这让我深刻认识到，在游戏行业这个充满挑战与机遇的领域中，只有不断学习、不断进步，才能立于不败之地。</p><p>除了企业介绍外，我们还聆听了正就职于西山居的往届学长的经验分享。他用自己的亲身经历告诉我们，如何通过参与项目制作、参加各类比赛积累实战经验，并最终成功入职西山居。他的建议让我受益匪浅，特别是关于如何尽早制定职业规划、关注行业动态与企业需求、重视实习与实践经历等方面的建议，更是为我未来的学习和实践提供了宝贵的指导。</p><p>在实地参观环节，我们走进了西山居的办公区，亲身感受到了游戏公司的日常工作环境与氛围。有序的办公空间、专注工作的团队成员、充满创意元素的装饰，都让我对游戏从业者的真实生活有了更加直观的了解。这种近距离的接触让我更加坚定了自己投身游戏行业的决心。</p><p>此次参访活动不仅让我对西山居公司有了更加深入的了解，也让我对游戏行业有了更加全面的认识。我深刻感受到，在这个充满竞争与机遇的时代里，只有不断学习、勇于创新、敢于挑战自我，才能在游戏行业这个充满魅力的领域中脱颖而出。同时，我也更加明确了自己的职业规划和发展方向。</p><p><img src="https://image.flashfish777.cn/img/post_6_1.jpg" alt="参观照片"></p><p><img src="https://image.flashfish777.cn/img/post_6_2.jpg" alt="参观照片"></p><p><img src="https://image.flashfish777.cn/img/post_6_3.jpg" alt="参观照片"></p><p>除此之外，我还报名了网易Y3高校游戏制作人大赛（尽管结果不尽人意…）</p><p><img src="https://image.flashfish777.cn/img/post_6_4.jpg" alt="网易Y3高校游戏制作人大赛"></p><p>直到我又看见口袋方舟的游戏创作训练营，毫不犹豫的报名了。</p><p><img src="https://image.flashfish777.cn/img/post_6_5.jpg" alt="口袋方舟训练营"></p><hr><div class="note success flat"><p><a href="https://creator.ark.online/">口袋方舟官网</a></p></div><h1 id="口袋方舟之旅"><a href="#口袋方舟之旅" class="headerlink" title="口袋方舟之旅"></a>口袋方舟之旅</h1><p>在这个充满无限创意与可能的时代，我有幸踏上了一段非凡的旅程——参与MetaApp的口袋方舟游戏开发训练营。这不仅是一次技术的探索，更是一场心灵的冒险，让我在游戏开发的浩瀚星海中找到了属于自己的小小方舟。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>口袋方舟编辑器以其低门槛、高自由度的特点，让即便是像我这样的游戏开发新手，也能轻松上手，实现自己的游戏创意。怀揣着对游戏开发的热爱与憧憬，我在学习与尝试中慢慢的熟悉了编辑器的使用。</p><p><img src="https://image.flashfish777.cn/img/post_6_6.jpg" alt="口袋方舟编辑器"></p><h2 id="学习与开发"><a href="#学习与开发" class="headerlink" title="学习与开发"></a>学习与开发</h2><p>学习并开发小游戏的日子紧张而充实。从基础的编程知识到高级的游戏设计原理，从界面布局到交互逻辑，每一步都充满了挑战与收获。还有老师们细心解答问题，老师们不仅拥有深厚的专业知识，更有着对游戏开发的无限热情，他们耐心地解答我们的每一个疑问，鼓励我们大胆尝试，勇于创新。</p><p>在这个过程中，我逐渐掌握了使用口袋方舟编辑器开发游戏的各项技能。从构思游戏概念、设计关卡流程、使用预制体搭建游戏，到自己编写需要的代码、调试优化，每一个环节我都亲力亲为，深刻体会到了游戏开发的艰辛与乐趣。</p><p><img src="https://image.flashfish777.cn/img/post_6_7.jpg" alt="TypeScript"></p><h2 id="两款小作品的诞生与发布"><a href="#两款小作品的诞生与发布" class="headerlink" title="两款小作品的诞生与发布"></a>两款小作品的诞生与发布</h2><p>经过无数个日夜的努力，我终于独立开发出了两款小游戏，并成功发布到了233平台上。第一款游戏《天空公主》是一款以帮助公主回家为主题的跑酷游戏，玩家需要操控主角越过各种障碍与陷阱，最终到达目的地。第二款游戏《探秘金字塔》则是一款find类游戏，玩家需要找到各种道具解开谜题，收集奖杯，找到最终宝藏。</p><p>这两款游戏的成功发布，不仅让我收获了满满的成就感，更让我看到了自己在游戏开发领域的潜力与可能。当第一个玩家进入游戏，我的心情无比激动！我收到了许多玩家的反馈与鼓励，他们的认可与支持成为了我继续前行的动力。</p><p><img src="https://image.flashfish777.cn/img/post_6_12.jpg" alt="天空公主"></p><p><img src="https://image.flashfish777.cn/img/post_6_13.jpg" alt="天空公主"></p><p><img src="https://image.flashfish777.cn/img/post_6_14.jpg" alt="探秘金字塔"></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>在参与训练营开发过程中，首先我收获了很多奖品与证书：</p><p><img src="https://image.flashfish777.cn/img/post_6_8.jpg" alt="证书"></p><p><img src="https://image.flashfish777.cn/img/post_6_9.jpg" alt="证书"></p><p><img src="https://image.flashfish777.cn/img/post_6_10.jpg" alt="鼠标垫"></p><p>其次，游戏本身也有广告收入：</p><p><img src="https://image.flashfish777.cn/img/post_6_11.jpg" alt="游戏数据"></p><p>当然，回顾这段经历，我收获的更多的是知识与技能，更重要的是对游戏开发的热爱与坚持。我学会了如何在困难面前不屈不挠，如何在失败中寻找机遇，如何在成功中保持谦逊。这些宝贵的经验将伴随我走过未来的游戏开发之路。<strong>我十分感谢口袋方舟，让我实现了“做游戏给别人玩”的梦想。</strong></p><p>展望未来，我希望能继续深化自己在游戏开发领域的专业知识与技能，不断挑战自我，创作出更多优秀、有趣、富有创意的游戏作品。同时，我也期待能与更多志同道合的朋友一起交流学习，共同推动游戏开发行业的繁荣发展。</p><p>口袋方舟之旅虽然告一段落，但我的游戏开发之路才刚刚开始。我相信，只要心中有梦，脚下就有路。在未来的日子里，我将以更加饱满的热情和坚定的信念，继续在游戏开发的道路上勇往直前！</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 游戏 </category>
          
          <category> 非Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode插件推荐</title>
      <link href="/posts/c5a23961.html"/>
      <url>/posts/c5a23961.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习编程的过程中，我有幸邂逅并深入使用了多款编译器与集成开发环境（IDE），如经典的<code>Dev-C++</code>，功能强大的<code>Visual Studio（VS）</code>，以及专为C&#x2F;C++和Python等语言设计的<code>CLion</code>，它们各自以其独特的魅力，在不同阶段陪伴并助力了我的学习与成长。</p><div class="note info no-icon flat"><p><strong>Dev-C++</strong></p></div><p>Dev-C++轻量级且易上手，是我初识编程时用的第一款编译器，让我能够快速上手C&#x2F;C++，打好基础。然而，随着学习的深入与项目规模的扩大和需求的复杂化，我开始意识到其在项目管理、代码补全及调试功能上的局限性。</p><div class="note primary no-icon flat"><p><strong>Visual Studio（VS）</strong></p></div><p>之后我接触到了VS2022这款IDE，最初相对Dev，我被它的高级感以及全面的开发能力、强大的调试工具和丰富的插件生态系统吸引。在VS的怀抱中，我感受到了前所未有的开发效率与便捷，虽然我学识尚浅，但我了解到无论是在Web开发、桌面应用还是游戏开发，VS都能提供强大的支持。但与此同时，VS的庞大体积与内存和偶尔的复杂配置也让我在追求轻量级与灵活性的项目中感到些许不便。</p><div class="note success no-icon flat"><p><strong>CLion</strong></p></div><p>CLion则以其对C&#x2F;C++的深入理解和优化，为我提供了更为专业和高效的C&#x2F;C++开发体验。智能的代码分析、快速重构工具以及无缝的集成调试，都让C&#x2F;C++项目的开发变得得心应手。然而，对于多语言支持或是特定框架的快速搭建，CLion或许不是最全面的选择。</p><p><strong>正是在这样的背景下，我遇到了<mark class="hl-label blue">VSCode</mark>。VSCode以其轻量级、跨平台、高度可扩展的特点，迅速成为了我的新宠。它不仅能够提供流畅的代码编辑体验，还通过丰富的插件生态，支持几乎所有主流编程语言及框架，从前端到后端，从Web到移动应用，无所不能。更重要的是，VSCode的启动迅速、界面简洁，让我在快节奏的编程生活中能够保持高效与专注。</strong></p><p>因此，今天我想和大家分享一些我在使用VSCode过程中发现的好用插件，这些插件不仅极大地提升了我的开发效率，也让我对VSCode的热爱更加深厚。接下来，就让我们一起探索这些宝藏插件吧！</p><hr><h1 id="功能篇"><a href="#功能篇" class="headerlink" title="功能篇"></a>功能篇</h1><h2 id="Prettier-Code-formatter"><a href="#Prettier-Code-formatter" class="headerlink" title="Prettier - Code formatter"></a>Prettier - Code formatter</h2><p><img src="https://image.flashfish777.cn/img/post_5_1.jpg" alt="Prettier - Code formatter"></p><p><code>Prettier - Code formatter</code> 是一款用于代码格式化的插件，‌它支持多种编程语言的代码格式化，‌旨在确保代码风格的一致性。‌Prettier 提供了一种简单的方法来自动调整代码格式，‌使其符合一组预定义的规则，‌从而帮助开发者提高代码的可读性和一致性。‌以下是关于 Prettier - Code formatter 插件的一些详细介绍：‌</p><ul><li><p><strong>配置方式：‌</strong>Prettier 的配置可以通过多种方式进行，‌包括在项目的根目录创建 <code>.prettierrc</code> 文件（‌支持 YML、‌JSON 等格式）‌，‌创建 <code>.prettier.config.js</code> 文件，‌或者在 <code>package.json</code> 文件中添加 Prettier 配置属性。‌这些配置文件允许用户自定义 Prettier 的规则，‌如缩进大小、‌是否使用制表符、‌引号风格等。‌</p></li><li><p><strong>集成使用：‌</strong>Prettier 可以与多种编辑器和构建工具集成，‌包括 Visual Studio Code（‌VSCode）‌、‌GitHub Actions 等。‌在 VSCode 中，‌Prettier 插件可以在保存文件时自动格式化代码，‌确保代码风格的一致性。‌此外，‌Prettier 还可以与 ESLint 集成，‌以确保代码不仅格式正确，‌而且符合一定的编码规范。</p></li><li><p><strong>角色分工：‌</strong>Prettier 主要负责代码的格式化工作，‌而 ESLint 则专注于代码质量和风格的检查。‌通过这种结合使用，‌开发者可以确保代码既没有语法错误，‌又具有一致的格式。‌</p></li><li><p><strong>配置选项：‌</strong>Prettier 提供了丰富的配置选项，‌允许用户根据自己的需求调整代码格式化的具体规则。‌例如，‌可以设置打印宽度、‌制表符宽度、‌是否使用单引号或双引号等。‌</p></li></ul><p>  总的来说，‌Prettier - Code formatter 是一个强大的工具，‌它通过自动化代码格式化过程，‌帮助开发者提高代码的可读性和一致性，‌是现代软件开发中不可或缺的一部分。‌</p><h2 id="Path-Intellisense"><a href="#Path-Intellisense" class="headerlink" title="Path Intellisense"></a>Path Intellisense</h2><p><img src="https://image.flashfish777.cn/img/post_5_2.jpg" alt="Path Intellisense"></p><p><code>Path Intellisense</code>是一个简单但极其实用的VSCode扩展，‌它能够智能感知并自动补全你在代码中引用的文件路径。‌这个扩展通过实时提供匹配的路径建议，‌大大提高了编码效率。‌以下是该扩展的主要特点和功能：‌</p><ul><li><strong>自动补全：‌</strong>一旦你开始键入文件或目录名称，‌插件会实时提供匹配的路径建议，‌帮助你快速找到目标文件。‌</li><li><strong>忽略配置：‌</strong>你可以通过设置禁用TypeScript和JavaScript的内置路径提示，‌以便Path Intellisense成为默认的补全源。‌</li><li><strong>Node包智能感知：‌</strong>配合<code>npm intellisense</code>插件，‌可以实现对Node.js包的智能补全。‌</li><li><strong>应用场景：‌</strong>适用于任何需要引入文件的场景，‌如导入模块、‌读取配置文件等，‌特别适用于大型项目，‌其中有很多层级目录和众多文件。‌</li><li><strong>项目特点：‌</strong>无论是在当前目录还是其他目录，‌Path Intellisense都能即时提供准确的路径建议。‌支持自定义设置，‌如是否显示隐藏文件、‌是否添加文件扩展名，‌以及自动触发下一个建议等功能。‌此外，‌它还尊重<code>tsconfig.json</code>配置，‌特别是<code>baseUrl</code>选项，‌无需重复定义。‌还允许自定义路径映射，‌方便使用绝对路径或者与<code>webpack</code>的r<code>esolve</code>选项搭配使用。‌<br>安装与使用方面，‌你可以在VSCode命令面板中选择“Install Extension”，‌搜索Path Intellisense进行安装。‌然后在设置中添加相关配置，‌即可启用插件。‌通过GIF图可以看到，‌在编写代码时，‌只需敲击几下键盘，‌Path Intellisense就会展示出相应的文件路径，‌让你轻松完成引用。‌</li></ul><h2 id="Image-preview"><a href="#Image-preview" class="headerlink" title="Image preview"></a>Image preview</h2><p><img src="https://image.flashfish777.cn/img/post_5_3.jpg" alt="Image preview"></p><p><code>Image Preview</code>是一个专为Visual Studio Code设计的高效扩展，‌它允许用户在代码文件中直接预览图片，‌无需离开当前的工作流，‌从而极大地提升了工作效率。‌这个扩展在代码行号旁显示图像预览，‌并且在鼠标悬停时也会出现预览，‌提供了实时预览功能，‌能够实时检测并解析代码中的图像路径，‌无论它们是相对路径还是绝对URL。‌Image Preview支持各种文件类型，‌如CSS、‌HTML、‌Markdown等，‌甚至可以识别数据URI。‌它还支持本地文件和网络URL，‌提供了高度自定义性，‌允许用户通过配置项调整预览样式，‌比如设置最大宽度和高度。‌</p><p><img src="https://image.flashfish777.cn/img/post_5_4.jpg" alt="示例"></p><p>Image Preview非常适合前端开发、‌Markdown写作以及图片资源管理。‌在编写CSS或HTML时，‌可以立即查看所引用图片的效果，‌而不需要频繁切换到浏览器预览。‌在编辑Markdown文档时，‌可以快速验证插入的图片是否正确展示。‌对于大型项目，‌它可以方便地查看代码中的所有图片，‌避免了手动查找的问题。‌Image Preview的安装过程简单快捷，‌只需通过Visual Studio Code扩展市场搜索并安装即可。‌无论用户是新手还是经验丰富的开发者，‌这个扩展都会成为日常工作中不可或缺的工具。‌</p><p>此外，‌Image Preview还具有智能更新的功能，‌能够自动检测代码变化，‌实时更新预览，‌确保信息始终同步。‌它的简洁直观的预览效果和全面支持的特性，‌以及高度定制化和智能更新的功能，‌使得Image Preview成为提高编码体验和开发生产效率的有力工具。‌</p><h2 id="Error-Lens"><a href="#Error-Lens" class="headerlink" title="Error Lens"></a>Error Lens</h2><p><img src="https://image.flashfish777.cn/img/post_5_5.jpg" alt="Error Lens"></p><p><code>Error Lens</code> 是一个非常有用的 Visual Studio Code 扩展，‌它主要改进了错误、‌警告和其他语言诊断的突出显示。‌通过安装这个扩展，‌你可以更直观地看到代码中的问题，‌从而更快地定位和解决错误。‌Error Lens 帮助开发者快速发现代码中的错误，‌直达问题所在，‌提高了代码调试的效率。‌安装完成后，‌需要重启 Visual Studio Code 以使扩展生效。‌此外，‌Error Lens 还提供了键盘快捷方式，‌使得操作更加便捷。‌通过按住 Alt 键，‌可以使用数字键选择和导航指示器，‌进一步提高了使用效率。‌</p><h2 id="Competitive-Programming-Helper-cph"><a href="#Competitive-Programming-Helper-cph" class="headerlink" title="Competitive Programming Helper (cph)"></a>Competitive Programming Helper (cph)</h2><p><img src="https://image.flashfish777.cn/img/post_5_6.jpg" alt="Competitive Programming Helper (cph)"></p><p><strong>超级好用超级推荐的扩展！特别适合热衷刷题以及算法竞赛的小伙伴！</strong></p><p><code>Competitive Programming Helper (cph)</code>是一个非常实用的扩展工具，‌专门为竞赛编程设计，‌旨在提高编程效率和准确性。‌</p><p>cph的主要功能特点包括：‌</p><ol><li><strong>跨平台支持：‌</strong>兼容多种竞赛平台，‌满足多样化的编程需求。‌</li><li><strong>多语言支持：‌</strong>支持包括C++, C, Rust, Go, Python, Java, JavaScript (Node.js)等多种常见编程语言。‌</li><li><strong>一键操作：‌</strong>通过快捷键（‌如Ctrl+Alt+B）‌可以运行测试用例，‌简化操作流程，‌提高使用便捷性。‌</li><li><strong>可定制化：‌</strong>用户可以根据自己的偏好调整设置，‌甚至参与项目的贡献和开发，‌增加使用的灵活性和个性化。‌</li><li><strong>样例测试：‌</strong>以样例的方式对代码进行测试，‌帮助用户检查代码的正确性。‌</li><li><strong>错误流输出：‌</strong>如果在代码执行过程中出现错误流，‌cph会额外显示错误流信息，‌方便用户进行调试。‌</li></ol><p>用户通过VSCode插件中心安装即可用，简单方便。‌此外，‌cph扩展还提供了一个网页插件，‌可以在刷题时打开要做的题目的页面，‌然后在VSCode中通过点击网页上面的绿色小按钮，‌自动创建文件并将所有的测试用例的输入输出复制粘贴过来，‌用户只需直接编写代码即可。‌编写完之后，‌可以通过一键运行判断对错，‌从而提高刷题效率。‌</p><p><img src="https://image.flashfish777.cn/img/post_5_7.jpg" alt="cph"></p><h2 id="Code-Runner"><a href="#Code-Runner" class="headerlink" title="Code Runner"></a>Code Runner</h2><p><img src="https://image.flashfish777.cn/img/post_5_8.jpg" alt="Code Runner"></p><p><code>Code Runner</code>扩展是一款强大的Visual Studio Code插件，‌支持运行多种编程语言的代码文件和代码片段。‌</p><p>Code Runner扩展的主要特点包括：‌</p><ul><li><strong>广泛的语言支持：‌</strong>支持包括C、‌C++、‌Java、‌JavaScript、‌PHP、‌Python、‌Ruby、‌Go、‌Lua、‌Groovy、‌PowerShell、‌TypeScript、‌Swift、‌Julia、‌Rust、‌Kotlin、‌Dart、‌Haskell等在内的多种流行编程语言，‌使得这个扩展对于使用多种语言的开发者来说非常有用。‌</li><li><strong>便捷的代码运行：‌</strong>可以直接从编辑器或文件资源管理器中运行代码，‌无需切换到终端或配置复杂的运行环境，‌提高了使用便捷性。‌</li><li><strong>自定义命令执行：‌</strong>允许用户根据需要配置和运行自定义命令，‌为不同的项目和工作流程提供灵活性。‌</li><li><strong>输出控制和展示：‌</strong>直观地在输出窗口中显示代码运行结果，‌方便调试和结果检查。‌</li><li><strong>支持REPL：‌</strong>支持REPL(读取-求值-打印循环)，‌可以提高生产力和效率。‌</li></ul><p>Code Runner扩展的开发者是韩骏，‌他是VS Code中文社区创始人，‌该扩展目前已经有了超过450万的下载量，‌并且在其GitHub项目页面上有详细的文档和社区支持。‌此外，‌Code Runner扩展还支持执行自定义命令，‌使得用户可以根据自己的需求进行灵活配置，‌进一步提高工作效率。‌</p><hr><h1 id="美化篇"><a href="#美化篇" class="headerlink" title="美化篇"></a>美化篇</h1><h2 id="OSU-Mode-3"><a href="#OSU-Mode-3" class="headerlink" title="OSU Mode 3"></a>OSU Mode 3</h2><p><img src="https://image.flashfish777.cn/img/post_5_9.jpg" alt="OSU Mode 3"></p><p>这款扩展比较小众，是我在逛b站时偶然发现，启用后，在敲代码时，键入的字母及按键会俏皮的弹出，甚至右上角会显示连击次数，在达到一定次数后还可以弹出图片，这让枯燥的敲代码的过程变得十分有趣，虽然本质上意义不大，但还是挺有意思的。</p><p>我在使用的过程中只开启了按键的弹出，毕竟我认为小小花样可以调情，太花里胡哨就适得其反了。</p><p>字母大小、速度以及连击样式与图片都可以按自己的喜好调节，即使追溯起这个扩展的历史有些混乱，但作为使用者我也没有去考虑那么多……</p><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1dR4y1n7tW&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><h2 id="One-Dark-Pro"><a href="#One-Dark-Pro" class="headerlink" title="One Dark Pro"></a>One Dark Pro</h2><p><img src="https://image.flashfish777.cn/img/post_5_10.jpg" alt="One Dark Pro"></p><p><strong>它真的很火，因为它真的很不错！超级赞的素颜主题！</strong></p><p><code>One Dark Pro</code>是一款源自Atom的经典主题，‌现已成为VS Code中最受欢迎的主题插件之一。‌它的设计简洁而深邃，‌无论是在编码还是阅读代码时，‌都能为用户提供舒适的视觉体验。‌One Dark Pro主题基于Material Design理念打造，‌提供多种内置风格，‌包括默认、‌扁平、‌暗黑和复古等，‌以适应不同的工作环境和个人喜好。‌此外，‌它还支持自定义配色，‌用户可以通过设置<code>workbench.colorCustomizations</code>和<code>editor.tokenColorCustomizations</code>来个性化调整颜色方案。‌One Dark Pro的特色功能还包括与Markdown预览的完美融合，‌使得文档编写更加美观易读。‌对于喜欢使用斜体代码的开发者，‌One Dark Pro提供了可配置的斜体模式，‌只需在设置中进行调整即可。‌此外，‌为了提高Python开发者的体验，‌它特别兼容了Pylance扩展，‌允许用户定制语义高亮颜色。‌One Dark Pro适用于各种开发场景，‌无论你是前端工程师、‌后端开发者还是数据科学家，‌都可以在这款主题下高效地工作。‌尤其是在长时间编程的情况下，‌其柔和的色彩搭配有助于减轻视觉疲劳，‌保持良好的专注力。‌</p><h2 id="Material-Icon-Theme"><a href="#Material-Icon-Theme" class="headerlink" title="Material Icon Theme"></a>Material Icon Theme</h2><p><img src="https://image.flashfish777.cn/img/post_5_11.jpg" alt="Material Icon Theme"></p><p><strong>特别推荐！</strong></p><p><code>Material Icon Theme</code>无疑是一款让VScode界面焕然一新的必备神器，它不仅极大地提升了开发者的视觉体验，还通过细致入微的设计让代码库变得更加整洁、专业。</p><p>首先，Material Icon Theme以其精美的Material Design风格图标著称，这些图标被精心设计并应用到文件和文件夹上，使得开发者在浏览代码库时能够迅速识别出不同类型的文件。这种直观性不仅提高了工作效率，还减少了因寻找文件而浪费的时间。</p><p>其次，该扩展插件采用了SVG图形，这意味着图标在不同分辨率下都能保持极高的清晰度，无论是高分辨率的4K屏幕还是低分辨率的普通显示器，都能呈现出完美的视觉效果。此外，Material Icon Theme还支持自定义颜色、透明度和饱和度，让开发者可以根据个人喜好调整图标样式，打造个性化的开发环境。</p><p>更令人称赞的是，Material Icon Theme提供了一套完善的设置选项，允许开发者定制文件和文件夹的图标关联，甚至可以导入自己的SVG图标，实现真正的个性化图标设计。这种高度的可定制性使得Material Icon Theme能够满足不同开发者的需求，无论你是前端开发者、后端工程师，还是数据科学家，都能找到适合自己的图标配置。</p><p>在实用性方面，Material Icon Theme同样表现出色。它涵盖了多种编程语言、框架和通用文件类型的图标库，满足各类项目需求。同时，该插件还能与版本控制系统如Git紧密集成，显示文件的状态标记，如未跟踪、已修改和已暂存等，帮助开发者更好地管理代码变更。</p><p>最后，Material Icon Theme的易用性也是其一大亮点。通过VScode的命令面板或用户设置，开发者可以轻松完成图标配置，无需复杂的操作。这种简单而强大的功能使得Material Icon Theme成为VScode用户不可或缺的扩展插件之一。</p><p>综上所述，Material Icon Theme以其精美的图标设计、高度的可定制性、实用的功能以及简单易用的特点赢得了广泛的赞誉。如果你希望让你的VScode界面更具美感和实用性，那么这款插件绝对值得一试。</p><h2 id="background-cover"><a href="#background-cover" class="headerlink" title="background-cover"></a>background-cover</h2><p><img src="https://image.flashfish777.cn/img/post_5_12.jpg" alt="background-cover"></p><p><code>background-cover</code>是一个用于Visual Studio Code（‌VSCode）‌的插件，‌它允许用户替换VSCode界面的整体背景，‌而不仅仅是代码区的背景。‌这个插件提供了快捷的图形化配置界面，‌可以满足基本的配置需求，‌如设置图片路径、‌启用&#x2F;停用插件、‌背景透明度等功能。‌用户还可以通过图形界面快捷添加多张图片，‌并实现随机切换功能。‌此外，‌通过修改插件的配置文件，‌用户可以自定义背景样式，‌如调整图片大小、‌位置等，‌以实现个性化的界面背景设置。‌</p><p>该插件的原理是在VSCode加载、‌修改插件设置时，‌自动更新VSCode对应的CSS样式，‌以实现界面背景的更改。‌因此，‌用户可以通过找到插件中配置CSS样式的代码，‌并按照CSS的规则修改对应内容，‌来实现想要的效果。‌这包括调整背景图片的大小、‌位置以及背景颜色的设置等。‌</p><p>总的来说，‌background-cover插件为VSCode用户提供了一个方便的方式来个性化他们的开发环境，‌通过简单的图形化界面或通过修改配置文件来实现复杂的背景设置需求。‌</p><p>注：推荐，但静态壁纸还好，gif动图较占内存</p><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1bs4y1w7fw&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><hr><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>以上就是我精心挑选而且正在使用的一些VSCode插件，它们各具特色，功能强大，无论是在提升编码效率、增强代码质量，还是在美化编辑器、代码方面，都展现出了非凡的价值。我相信，随着你深入使用这些插件，它们将会成为你编程旅程中不可或缺的伙伴，助你在编码的世界里畅游无阻，探索无限可能。</p><p>当然，VSCode的插件生态如此丰富，我推荐的这些只是冰山一角。鼓励大家根据自己的实际需求和偏好，去发现更多适合自己的插件，不断优化自己的开发环境。记住，工欲善其事，必先利其器，一款好的开发工具加上高效的插件辅助，定能让你的编程之路更加顺畅，成就更加辉煌。</p><p>最后，感谢大家的阅读，希望这篇博客能为你带来一些启发和帮助。如果你有任何推荐的VSCode插件或者独特的使用心得，欢迎在评论区留言分享，让我们一起学习，共同进步！期待在未来的编程道路上，与更多的你相遇，共同书写属于我们的精彩篇章。</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp与算法浅记</title>
      <link href="/posts/c50a51df.html"/>
      <url>/posts/c50a51df.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自从学习C语言考进了团队之后，先是跟着学长的教程学习了一些 C++ 的基础知识。毕竟在做题方面，C++提供了很多实用的数据结构和函数，十分的方便。之后我就一直在学算法，直到今年的蓝桥杯大赛。算法这东西真是深奥的很，也很有魅力。我学的不是很快，也并不是很好，只学了一些常用的算法，记了一些模板。这期间我也打过很多的学校的算法比赛，都取得的较优异的成绩，可惜最后蓝桥杯的结果并不是很好。<br>但说白了学习这么久的算法又不是只为了那些奖，不管结果如何，这段时间的学习属实是给我带来了不小的收获。<br>首先就是我从“二指禅”的打字方法也是练到了很快的打字速度，以前还为打字慢而焦虑，现在一想都是熟能生巧，没什么好急的。再就是学习算法让我从只会C语言语法的小白真正理解并体会到了编程的含义与魅力，也让我的打下了扎实良好的编程习惯，真是收益匪浅啊。</p><h1 id="一些算法模板"><a href="#一些算法模板" class="headerlink" title="一些算法模板"></a>一些算法模板</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> x = q[l], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">while</span> (q[++i] &lt; x);</span><br><span class="line">        <span class="keyword">while</span> (q[--j] &gt; x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>边界问题</strong><br>因为边界问题只有这两种组合，不能随意搭配</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x不能取q[l]和q[l+r&gt;&gt;1]; </span></span><br><span class="line"><span class="built_in">quick_sort</span>(q,l,i<span class="number">-1</span>),<span class="built_in">quick_sort</span>(q,i,r);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x不能取q[r]和q[(l+r+1)&gt;&gt;1];</span></span><br><span class="line"><span class="built_in">quick_sort</span>(q,l,j),<span class="built_in">quick_sort</span>(q,j<span class="number">+1</span>,r);</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//递归的终止情况 </span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//第一步：分成子问题 </span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二步：递归处理子问题</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid); </span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三步：合并子问题 </span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) </span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) </span><br><span class="line">            tmp[k ++ ] = q[i ++ ]; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            tmp[k ++ ] = q[j ++ ]; </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ]; </span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ]; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第四步：复制回原数组 </span></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) </span><br><span class="line">        q[i] = tmp[j]; &#125;</span><br></pre></td></tr></table></figure><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p>对lower_bound来说，它寻找的就是第一个满足条件“值大于等于x”的元素的位置；对upper_bound函 数来说，它寻找的是第一个满足“值大于 x”的元素的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125;  <span class="comment">// 检查x是否满足某种性质 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) </span><br><span class="line">            r = mid; <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>; <span class="comment">//左加右减 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> l; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>; <span class="comment">//如果下方else后面是l则这里加1 </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>; <span class="comment">//左加右减</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> l; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>; </span><br><span class="line">    <span class="comment">// eps 表示精度，取决于题目对精度的要求 </span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid; </span><br><span class="line">        <span class="keyword">else</span> l = mid; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> l; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//c为答案 </span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c; </span><br><span class="line">    <span class="comment">//t为进位 </span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>() ||i &lt; b.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//不超过a的范围添加a[i] </span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; a.<span class="built_in">size</span>()) t += a[i]; </span><br><span class="line">        <span class="comment">//不超过b的范围添加b[i] </span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; b.<span class="built_in">size</span>()) t += b[i]; </span><br><span class="line">        <span class="comment">//取当前位的答案 </span></span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>); </span><br><span class="line">        <span class="comment">//是否进位</span></span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//如果t!=0的话向后添加1 </span></span><br><span class="line">    <span class="keyword">if</span>(t) c.<span class="built_in">push_back</span>(<span class="number">1</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> c; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//答案 </span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; </span><br><span class="line">    <span class="comment">//遍历最大的数 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ ) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//t为进位 </span></span><br><span class="line">        t = A[i] - t; </span><br><span class="line">        <span class="comment">//不超过B的范围t = A[i] - B[i] - t; </span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i]; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//合二为一，取当前位的答案</span></span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//t&lt;0则t=1 </span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>; </span><br><span class="line">        <span class="comment">//t&gt;=0则t=0 </span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//去除前导零 </span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>(); </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> C; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度比大小"><a href="#高精度比大小" class="headerlink" title="高精度比大小"></a>高精度比大小</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度比大小 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) </span><br><span class="line">        <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) </span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i]) </span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i]; </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//类似于高精度加法 </span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; </span><br><span class="line">    <span class="comment">//t为进位 </span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ ) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//不超过A的范围t=t+A[i]*b </span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b; </span><br><span class="line">        <span class="comment">//取当前位的答案 </span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>); </span><br><span class="line">        <span class="comment">//进位 </span></span><br><span class="line">        t /= <span class="number">10</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//去除前导零 </span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) </span><br><span class="line">        C.<span class="built_in">pop_back</span>(); </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度乘高精度"><a href="#高精度乘高精度" class="headerlink" title="高精度乘高精度"></a>高精度乘高精度</h2><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1LA411v7mt&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(A.size() + B.size())</span></span>; </span><br><span class="line">    <span class="comment">// 初始化为 0，C的size可以大一点 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; B.<span class="built_in">size</span>(); j++) </span><br><span class="line">            C[i + j] += A[i] * B[j]; </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,t = <span class="number">0</span>; i &lt; C.<span class="built_in">size</span>(); i++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// i = C.size() - 1时 t 一定小于 10</span></span><br><span class="line">        t += C[i]; </span><br><span class="line">        C[i] = t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) </span><br><span class="line">        C.<span class="built_in">pop_back</span>(); <span class="comment">// 必须要去前导 0，因为最高 位很可能是 0 </span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> C; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度除低精度"><a href="#高精度除低精度" class="headerlink" title="高精度除低精度"></a>高精度除低精度</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span> <span class="comment">//高精度A，低精度b，余数r </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; <span class="comment">//答案 </span></span><br><span class="line">    r = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) </span><br><span class="line">    &#123; </span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        <span class="comment">//补全r&gt;=b </span></span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        <span class="comment">//取当前位的答案 </span></span><br><span class="line">        r %= b;</span><br><span class="line">        <span class="comment">//r%b为下一次计算 </span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>()); <span class="comment">//倒序为答案 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) </span><br><span class="line">        C.<span class="built_in">pop_back</span>(); <span class="comment">//去除前导零 </span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> C; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度除高精度"><a href="#高精度除高精度" class="headerlink" title="高精度除高精度"></a>高精度除高精度</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B, vector&lt;<span class="type">int</span>&gt; &amp;r)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cmp</span>(A, B)) </span><br><span class="line">    &#123; </span><br><span class="line">        C.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        r.<span class="built_in">assign</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> C; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> j = B.<span class="built_in">size</span>();</span><br><span class="line">    r.<span class="built_in">assign</span>(A.<span class="built_in">end</span>() - j, A.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= A.<span class="built_in">size</span>()) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cmp</span>(r, B)) </span><br><span class="line">        &#123;</span><br><span class="line">            r = <span class="built_in">sub</span>(r, B);</span><br><span class="line">            k ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        C.<span class="built_in">push_back</span>(k); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (j &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            r.<span class="built_in">insert</span>(r.<span class="built_in">begin</span>(), A[A.<span class="built_in">size</span>() - j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (r.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; r.<span class="built_in">back</span>() == <span class="number">0</span>) </span><br><span class="line">            r.<span class="built_in">pop_back</span>();</span><br><span class="line">            </span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><p>前缀和可以用于快速计算一个序列的区间和，也有很多问题里不是直接用前缀和，但是借用了前缀 和的思想。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">预处理:s[i]=a[i]+a[i-1] </span><br><span class="line">求区间[l,r]:sum=s[r]-s[l-1] </span><br><span class="line">&quot;前缀和数组&quot;和&quot;原数组&quot;可以合二为一</span><br></pre></td></tr></table></figure><p>应用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>; </span><br><span class="line"><span class="type">int</span> a[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        a[i] = a[i - <span class="number">1</span>] + a[i]; </span><br><span class="line">        </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m); </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[r] - a[l - <span class="number">1</span>]); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">计算矩阵的前缀和：s[x][y] = s[x - 1][y] + s[x][y -1] - s[x-1][y-1] + a[x][y] </span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： </span><br><span class="line">计算子矩阵的和：s = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 -1]</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i][j]); </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) </span><br><span class="line">            s[i][j] += s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">while</span>(q --)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2; </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x2][y1 - <span class="number">1</span>] - s[x1 - <span class="number">1</span>][y2] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><p>差分是前缀和的逆运算，对于一个数组a，其差分数组b的每一项都是<code> a[i]</code> 和前一项 <code>a[i − 1]</code> 的差。<br><strong>注意：差分数组和原数组必须分开存放！！！！</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c</span><br></pre></td></tr></table></figure><p>应用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">100010</span>], s[<span class="number">100010</span>]; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n, m; </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        s[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 读入并计算差分数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> l, r, c; </span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        s[l] += c;</span><br><span class="line">        s[r + <span class="number">1</span>] -= c; </span><br><span class="line">        <span class="comment">// 在原数组中将区间[l, r]加上c</span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123; </span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">        cout &lt;&lt; s[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给差分数组计算前缀和，就求出了原数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： </span><br><span class="line">S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c</span><br></pre></td></tr></table></figure><p>应用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>; </span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c; </span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c; </span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">insert</span>(i, j, i, j, a[i][j]); <span class="comment">//构建差分数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(x1, y1, x2, y2, c); <span class="comment">//加c</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">//二维前缀和 </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span> </span><br><span class="line">返回n的最后一位<span class="number">1</span>：<span class="built_in">lowbit</span>(n) = n &amp; -n</span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ ) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ; </span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">常见问题分类：</span><br><span class="line">    (<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">    (<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><p>离散化的本质是建立了一段数列到自然数之间的映射关系（value -&gt; index)，通过建立新索引，来缩 小目标区间，使得可以进行一系列连续数组可以进行的操作比如二分，前缀和等…</p><p>离散化首先需要排序去重：</p><ol><li>排序：<code>sort(alls.begin(),alls.end())</code> </li><li>去重：<code>alls.earse(unique(alls.begin(),alls.end()),alls.end())</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>()); <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x)</span><br><span class="line">            r = mid; </span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], s[N]; </span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">//存入下标容器</span></span><br><span class="line">vector&lt;PII&gt; add, query; <span class="comment">//add增加容器，存入对应下标和增加的值的大小 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//query存入需要计算下标区间和的容器 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) <span class="comment">//查找大于等于x的最小的值的下标</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">//因为使用前缀和，其下标要+1可以不考虑边界问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, c; cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x, c&#125;); <span class="comment">//存入下标即对应的数值c</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(x); <span class="comment">//存入数组下标x=add.first</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> l, r; cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l, r&#125;); <span class="comment">//存入要求的区间</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(l); <span class="comment">//存入区间左右下标 </span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(r); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 区间去重 </span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); </span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>()); <span class="comment">// 处理插入</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : add) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first); <span class="comment">//将add容器的add.secend值存入数组a[]当中，</span></span><br><span class="line">        a[x] += item.second; <span class="comment">//在去重之后的下标集合alls内寻找对应的下标并添加数值 </span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + a[i]; </span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 处理询问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">find</span>(item.first), r = <span class="built_in">find</span>(item.second); <span class="comment">//在下标容器中查找对应的左右 两端[l~r]下标，然后通过下标得到前缀和相减再得到区间a[l~r]的和</span></span><br><span class="line">        cout &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs) </span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) </span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) </span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">        </span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-STL"><a href="#C-STL" class="headerlink" title="C++ STL"></a>C++ STL</h2><p><img src="https://image.flashfish777.cn/img/post_4_1.jpg" alt="stl"></p><html> <div align="center" class="aspect-ratio">    <iframe      src="https://player.bilibili.com/player.html?bvid=BV1tF411G73c&&page=1&as_wide=1&high_quality=1&danmaku=0"      scrolling="no"      border="0"      frameborder="no"      framespacing="0"      high_quality="1"      danmaku="1"      allowfullscreen="true"    ></iframe>  </div></html><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line">    size() 返回元素个数</span><br><span class="line">    empty() 返回是否为空 </span><br><span class="line">    clear() 清空 </span><br><span class="line">    front()/back()</span><br><span class="line">    push_back()/pop_back() </span><br><span class="line">    begin()/end()</span><br><span class="line">    []</span><br><span class="line">    支持比较运算，按字典序</span><br><span class="line">    </span><br><span class="line">pair&lt;int, int&gt;</span><br><span class="line">    first, 第一个元素 </span><br><span class="line">    second, 第二个元素</span><br><span class="line">    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br><span class="line">    </span><br><span class="line">string，字符串 </span><br><span class="line">    size()/length() 返回字符串长度</span><br><span class="line">    empty()</span><br><span class="line">    clear() </span><br><span class="line">    substr(起始下标，(子串长度)) 返回子串</span><br><span class="line">    c_str() 返回字符串所在字符数组的起始地址 </span><br><span class="line">    </span><br><span class="line">queue, 队列</span><br><span class="line">    size()</span><br><span class="line">    empty() </span><br><span class="line">    push() 向队尾插入一个元素</span><br><span class="line">    front() 返回队头元素</span><br><span class="line">    back() 返回队尾元素</span><br><span class="line">    pop() 弹出队头元素 </span><br><span class="line">    </span><br><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line">    size() </span><br><span class="line">    empty()</span><br><span class="line">    push() 插入一个元素</span><br><span class="line">    top() 返回堆顶元素</span><br><span class="line">    pop() 弹出堆顶元素 </span><br><span class="line">    定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</span><br><span class="line">    </span><br><span class="line">stack, 栈</span><br><span class="line">    size()</span><br><span class="line">    empty()</span><br><span class="line">    push() 向栈顶插入一个元素 </span><br><span class="line">    top() 返回栈顶元素</span><br><span class="line">    pop() 弹出栈顶元素</span><br><span class="line">    </span><br><span class="line">deque, 双端队列 </span><br><span class="line">    size()</span><br><span class="line">    empty() </span><br><span class="line">    clear()</span><br><span class="line">    front()/back()</span><br><span class="line">    push_back()/pop_back() </span><br><span class="line">    push_front()/pop_front()</span><br><span class="line">    begin()/end()</span><br><span class="line">    [] </span><br><span class="line">    </span><br><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 </span><br><span class="line">    size() </span><br><span class="line">    empty()</span><br><span class="line">    clear() </span><br><span class="line">    begin()/end() </span><br><span class="line">    ++, -- 返回前驱和后继，时间复杂度 O(logn)</span><br><span class="line">    </span><br><span class="line">    set/multiset insert() 插入一个数 </span><br><span class="line">        find() 查找一个数 </span><br><span class="line">        count() 返回某一个数的个数</span><br><span class="line">        erase()</span><br><span class="line">            (1) 输入是一个数x，删除所有x O(k + logn) </span><br><span class="line">            (2) 输入一个迭代器，删除这个迭代器</span><br><span class="line">        lower_bound()/upper_bound()</span><br><span class="line">            lower_bound(x) 返回大于等于x的最小的数的迭代器</span><br><span class="line">            upper_bound(x) 返回大于x的最小的数的迭代器 </span><br><span class="line">            </span><br><span class="line">    map/multimap </span><br><span class="line">        insert() 插入的数是一个pair</span><br><span class="line">        erase() 输入的参数是pair或者迭代器 </span><br><span class="line">        find() </span><br><span class="line">        [] 注意multimap不支持此操作。 时间复杂度是 O(logn)      </span><br><span class="line">        lower_bound()/upper_bound()</span><br><span class="line">        </span><br><span class="line">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 </span><br><span class="line">    和上面类似，增删改查的时间复杂度是 O(1)</span><br><span class="line">    不支持 lower_bound()/upper_bound()， 迭代器的++，-- </span><br><span class="line"></span><br><span class="line">bitset, 圧位 </span><br><span class="line">    bitset&lt;10000&gt; s;</span><br><span class="line">    ~, &amp;, |, ^ </span><br><span class="line">    &gt;&gt;, &lt;&lt; ==, != </span><br><span class="line">    [] </span><br><span class="line">    </span><br><span class="line">    count() 返回有多少个1 </span><br><span class="line">    </span><br><span class="line">    any() 判断是否至少有一个1 </span><br><span class="line">    none() 判断是否全为0 </span><br><span class="line">    </span><br><span class="line">    set() 把所有位置成1 </span><br><span class="line">    set(k, v) 将第k位变成v </span><br><span class="line">    reset() 把所有位变成0 </span><br><span class="line">    flip() 等价于~ </span><br><span class="line">    flip(k) 把第k位取反</span><br></pre></td></tr></table></figure><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> j = e[i]; </span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用：数字全排列、树的重心、n-皇后等。</p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q; st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i]) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用：走迷宫、八数码等。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>这里只学了背包</p><p>01背包每件物品只能装一次<br>完全背包每件物品可以装无限次<br>多重背包每件物品只能装有限次（多次）<br>分组背包每组只能选择一件物品装入（01背包升级）</p><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>; </span><br><span class="line"><span class="type">int</span> n, m; </span><br><span class="line"><span class="type">int</span> v[N], w[N]; <span class="comment">//v代表体积，w代表价值 </span></span><br><span class="line"><span class="type">int</span> f[N][N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i]; </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="comment">//i代表这n件物品 </span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) <span class="comment">//j代表背包容量</span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span>(v[i] &gt; j) <span class="comment">//如果v[i]的容量大于当前的背包容量则不装进行下一个 </span></span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j]; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j],f[i - <span class="number">1</span>][j - v[i]] + w[i]); <span class="comment">//如果v[i]的容量小于当 前背包容量则可以选择装与不装得到最大值 </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl; <span class="comment">//输出最后的一个一定是最大的 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>01背包，使用滚动数组，倒序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>; </span><br><span class="line"><span class="type">int</span> n, m; </span><br><span class="line"><span class="type">int</span> v[N], w[N]; <span class="comment">//v代表体积，w代表价值 </span></span><br><span class="line"><span class="type">int</span> dp[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="comment">//i代表这n件物品 </span></span><br><span class="line">    &#123; </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i]; <span class="comment">//在线算法 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j --) <span class="comment">//j代表背包容量，滚动数组必须倒序遍历</span></span><br><span class="line">        &#123; </span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i]] + w[i]); <span class="comment">//滚动数组 </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; dp[m] &lt;&lt; endl; <span class="comment">//输出最后的一个一定是最大的 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态转移方程：<code>dp[j] = max(dp[j], dp[j - v[i]] + w[i])</code></p><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> v[N], w[N]; </span><br><span class="line"><span class="type">int</span> dp[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n, m; </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="comment">//遍历物品</span></span><br><span class="line">    &#123; </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i]; <span class="comment">//在线算法 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = v[i]; j &lt;= m; j ++) <span class="comment">//正序遍历背包容量</span></span><br><span class="line">        &#123; </span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i]] + w[i]); <span class="comment">//滚动数组 </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; dp[m] &lt;&lt; endl; <span class="comment">//输出答案 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全背包问题和01背包优化版的区别在于第二重循环的 <code>v[i]</code> 和m做交换<br>状态转移方程：<code>dp[j] = max(dp[j], dp[j - v[i]] + w[i])</code></p><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N]; </span><br><span class="line"><span class="type">int</span> dp[N][N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        cin &gt;&gt; v[i] &gt; &gt;w[i] &gt;&gt; s[i]; </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; =n; i ++) <span class="comment">//物品 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++) <span class="comment">//背包容量 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k ++) </span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - v[i] * k] + w[i] * k); </span><br><span class="line">                </span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态转移方程：<code>dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i] * k] + w[i] * k)</code> k为第i个物品的个数</p><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>; </span><br><span class="line"><span class="type">int</span> f[N]; </span><br><span class="line"><span class="type">int</span> v[N][N], w[N][N], s[N];</span><br><span class="line"><span class="type">int</span> n, m ,k; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123; </span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; s[i]; j ++)</span><br><span class="line">        &#123; </span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j]; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; s[i]; k ++) <span class="comment">//for(int k=s[i];k&gt;=1;k--)也可以 </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v[i][k]) </span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态转移方程：<code>f[j] = max(f[j], f[j - v[i][k]] + w[i][k])</code></p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Roefian的大冒险：初识面向对象!</title>
      <link href="/posts/961490cd.html"/>
      <url>/posts/961490cd.html</url>
      
        <content type="html"><![CDATA[<h1 id="引言——一些简单的尝试"><a href="#引言——一些简单的尝试" class="headerlink" title="引言——一些简单的尝试"></a>引言——一些简单的尝试</h1><h2 id="万年历"><a href="#万年历" class="headerlink" title="万年历"></a>万年历</h2><a class="btn-beautify outline pink larger" href="/pages/WanNianLi/" title="源码"><i class="far fa-hand-point-right"></i><span>源码</span></a><p><img src="https://image.flashfish777.cn/img/post_3_1.jpg" alt="万年历"></p><div class="note info flat"><p><strong>图片展示功能有限，源码复制粘贴到编译器运行即可使用！</strong></p></div><p>该程序使用C++<strong>基本语法</strong>及一些<strong>字符串操作</strong>实现了判断闰年、判断某天为星期几、输出某年日历、输出某月日历四个功能。在代码实现中定义并实现了判断闰年、判断星期、输出日历等函数，在主函数中的主循环里做操作判断，分别调用这些函数来实现目标操作。（更多细节可以查看源码，这里不多做赘述）</p><p>‌在该程序中，我除对C语言的熟悉外，最大的收获是了解并使用了<strong>蔡勒公式</strong>来计算星期：<br><code>蔡勒（Zeller）公式</code>是一个用于计算星期的复杂公式，其推导过程涉及对历法规则（如‌闰年、月份天数等）的深入理解和数学运算。蔡勒公式基于‌格里高利历（公历），该历法在1582年进行了改革，废除了儒略历中的10天，并引入了更精确的闰年规则。在蔡勒公式中，为了简化计算，通常将1月和2月视为上一年的13月和14月。公式主要由几个部分组成，包括世纪数、年份、月份和日期，每个部分都通过特定的数学运算（如取整、乘法、加法等）与星期数相关联，<strong>最终，通过将所有部分相加并对7取模（即求余数），得到的结果即为所求日期的星期数（0代表星期日，1代表星期一，依此类推）</strong>。‌由于推导过程涉及大量数学细节和历法知识，这里不展开具体步骤。但可以通过查阅相关数学书籍或文献，了解更详细的推导过程。</p><h2 id="商城商品管理系统"><a href="#商城商品管理系统" class="headerlink" title="商城商品管理系统"></a>商城商品管理系统</h2><a class="btn-beautify outline red larger" href="/pages/ShopManager/" title="源码"><i class="far fa-hand-point-right"></i><span>源码</span></a><p><img src="https://image.flashfish777.cn/img/post_3_2.jpg" alt="商品管理系统"></p><div class="note info flat"><p><strong>图片展示功能有限，源码复制粘贴到编译器运行即可使用！</strong></p></div><p>该程序使用了C++的<code>Vector（容器）</code>动态数组，使用<strong>结构体Vector</strong>代替了常见的管理系统练习项目常用的<strong>结构体链表</strong>这种数据结构。除了Vector相关操作，我还掌握并使用了<code>重载运算符</code>、<code>迭代器</code>等相关知识。</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>C++中的<code>vector</code>是一个非常灵活且功能强大的序列容器，它能够存储具有相同类型的元素序列，并自动管理这些元素的内存。<code>vector</code>属于C++标准模板库（STL）的一部分，它提供了<strong>动态数组</strong>的功能，但与普通数组相比，<code>vector</code>具有更高的<strong>灵活性</strong>和<strong>安全性</strong>。</p><h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><ol><li><p><strong>动态数组</strong>：Vector可以动态地增长和缩小，以适应不同数量的元素。这意味着你不需要在编译时就知道数组的大小，也不需要在数组满时手动分配更大的数组并复制元素。</p></li><li><p><strong>自动内存管理</strong>：Vector自动管理其元素的内存分配和释放。当Vector被销毁时，其所有元素也会被自动销毁。这减少了内存泄漏的风险。</p></li><li><p><strong>随机访问</strong>：Vector支持随机访问其元素，即你可以通过索引直接访问任何位置的元素，类似于普通数组。这使得Vector在处理需要频繁访问元素的应用时非常高效。</p></li><li><p><strong>迭代器</strong>：Vector提供了迭代器，允许你遍历容器中的元素。迭代器提供了对容器中元素的间接访问，并可以递增以访问下一个元素。</p></li><li><p><strong>容量和大小</strong>：Vector有两个重要的属性：<code>size()</code>和<code>capacity()</code>。<code>size()</code>返回容器中元素的数量，而<code>capacity()</code>返回容器在不重新分配内存的情况下可以存储的元素数量。</p></li></ol><h4 id="选择Vector的原因"><a href="#选择Vector的原因" class="headerlink" title="选择Vector的原因"></a>选择Vector的原因</h4><p>我认为结构体Vector相对于结构体链表的优点主要包括以下几点：</p><ul><li><p><strong>高效的随机访问能力</strong>：‌Vector在内存中通常以数组的形式存储，‌这使其支持高效的随机访问。‌与链表相比，‌通过索引直接访问Vector中的元素速度更快，‌因为不需要从头开始遍历链表。‌</p></li><li><p><strong>线程安全性</strong>：‌Vector的所有方法都是线程安全的，‌这意味着在多线程环境中，‌对Vector的操作可以保证数据的一致性和完整性。‌相比之下，‌链表通常不提供线程安全保证，‌因此在多线程环境下使用时需要额外的同步机制。‌</p></li><li><p><strong>较低的空间消耗</strong>：‌虽然链表在空间使用上具有较好的灵活性，‌能够根据需要动态添加和删除节点，‌但在某些情况下，‌Vector可能具有较低的空间消耗。‌这是因为Vector在初始化时分配足够的内存空间，‌减少了频繁内存分配和释放的开销，‌这在处理大量数据时尤其重要。‌</p></li><li><p><strong>简洁方便的写法</strong>：最重要的一点是，无论是在定义调用或删除等任何操作中，Vector的写法总要比链表简单很多。</p></li></ul><h3 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h3><p>C++ 中的<code>运算符重载（Operator Overloading）</code>是一种特殊形式的函数重载，它允许程序员为已存在的运算符（如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>!=</code> 等）赋予新的意义，以便它们可以<strong>用于类的对象</strong>。通过运算符重载，可以使对象的使用更加直观和方便，类似于内置数据类型的操作。更多概念与使用可以查看这里-&gt;<a href="https://www.runoob.com/cplusplus/cpp-overloading.html">菜鸟教程</a></p><p>在本程序中，为商品结构体重定义<code>==</code>运算符，方便find函数查找。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p><code>迭代器</code>是一种用于遍历容器元素的对象，它提供了一种通用的访问容器元素的方式，无论容器的类型和数据结构如何。迭代器在C++标准库中占有重要地位，是<strong>连接容器和算法的重要桥梁</strong>。<code>迭代器(Iterator)</code>是<code>指针(pointer)</code>的泛化，它允许程序员用相同的方式处理不同的数据结构（容器）。每种容器类型都定义了自己的迭代器类型，这种类型支持迭代器的各种行为。迭代器提供了一种方法来顺序访问容器中的各个元素，同时不需要暴露容器的内部表示，这使得算法能够独立于容器的具体实现。</p><p>在程序中我广泛应用迭代器查找和获取元素信息，同时配合find函数（<span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">相关概念</button><span class="hide-content">C++的find函数是定义在algorithm头文件中的一个通用算法，用于在给定范围内查找元素。它返回一个迭代器，指向查找到的元素的位置，如果没有找到，则返回结束迭代器（end迭代器）。</span></span>）与distance函数（<span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">相关概念</button><span class="hide-content">C++的distance函数用于计算两个迭代器之间的距离。它接受两个迭代器作为参数，并返回它们之间的距离。</span></span>）使用，大大提高了效率。</p><h2 id="关于程序设计方法"><a href="#关于程序设计方法" class="headerlink" title="关于程序设计方法"></a>关于程序设计方法</h2><p>程序设计方法是指在进行软件开发过程中，<strong>按照一定的规范和策略来设计和实现计算机程序</strong>的方法论。它涵盖了从需求分析、系统设计、编码实现到测试调试等多个环节，是软件开发领域中的重要理论支撑。程序设计方法旨在通过科学、合理的方法论指导程序的设计和实现，以提高软件的质量和开发效率，同时降低后期维护成本。它使得软件开发过程更加规范化和可控，有助于开发出高效、可靠的计算机程序。</p><p>主要的程序设计方法有：结构化程序设计、面向对象程序设计（OOP）、函数式编程、响应式程序设计、并行程序设计、领域驱动设计（DDD）等。</p><h3 id="结构化程序设计"><a href="#结构化程序设计" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h3><p>在初次尝试自己实现小型功能的项目时，我其实在懵懵懂懂中使用的是简易的<code>结构化程序设计方法（Structured Programming）</code>，也称为面向过程（POP）的程序设计方法。这种方法最早由E.W.Dijkstra在1965年提出，是软件发展的一个重要里程碑。</p><p>结构化程序设计方法主张按功能来分析系统需求，其主要原则可概括为<strong>自顶向下</strong>、<strong>逐步求精</strong>、<strong>模块化</strong>等。它强调将复杂的程序设计任务分解成若干个简单、易于理解和实现的模块，每个模块完成一个特定的功能。</p><h4 id="主要特点-1"><a href="#主要特点-1" class="headerlink" title="主要特点"></a>主要特点</h4><ol><li><strong>模块化</strong>：将程序划分为若干个模块，每个模块完成一个相对独立的功能。这样做的好处是提高了程序的可读性、可维护性和可重用性。</li><li><strong>自顶向下</strong>：从程序的整体功能出发，逐步细化到各个子功能，直到每个子功能都足够简单，可以直接用编程语言实现。</li><li><strong>逐步求精</strong>：在自顶向下的过程中，不断对程序进行细化，确保每个步骤都清晰明确，易于实现。</li><li><strong>控制结构</strong>：结构化程序设计非常强调程序的控制结构，即程序的执行流程。它认为任何算法都可以由<code>顺序结构</code>、<code>选择结构</code>和<code>循环结构</code>这三种基本结构组成。</li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong>：</p><ul><li>结构清晰，易于理解和维护。</li><li>提高了程序的可重用性。</li><li>有利于团队协作和分工。</li></ul><p><strong>缺点</strong>：</p><ul><li>设计不够直观，与人类习惯思维不一致。</li><li>适应性差，可扩展性不强。当用户需求发生改变时，可能需要自顶而下地修改模块结构，维护成本较高。</li></ul><p>结构化程序设计方法是面向对象程序设计之前的一种重要程序设计方法，它在软件工程中发挥了重要作用。然而，随着软件技术的不断发展，面向对象程序设计方法逐渐成为了主流。</p><hr><h1 id="Roefian的大冒险"><a href="#Roefian的大冒险" class="headerlink" title="Roefian的大冒险"></a>Roefian的大冒险</h1><a class="btn-beautify outline purple larger" href="https://github.com/flashfish777/roefian-s-adventure" title="GitHub仓库"><i class="far fa-hand-point-right"></i><span>GitHub仓库</span></a> <div class="note info flat"><p><strong>仓库中有源码及exe程序压缩包，下载即可运行</strong></p></div><p><img src="https://image.flashfish777.cn/img/post_3_3.jpg" alt="Boss"></p><p>在项目开发中，我选择了VS2022这款IDE、C++为编程语言以及EasyX图形库实现图形化界面。</p><h2 id="EasyX图形库"><a href="#EasyX图形库" class="headerlink" title="EasyX图形库"></a>EasyX图形库</h2><p><a href="https://easyx.cn/">EasyX图形库官方文档</a></p><h3 id="什么是图形库"><a href="#什么是图形库" class="headerlink" title="什么是图形库"></a>什么是图形库</h3><p><code>图形库（Graphics Library）</code>是一组用于<strong>图形处理</strong>的软件函数或类的集合，它们提供了<strong>绘制图形</strong>、<strong>处理图像</strong>、<strong>显示文本</strong>等功能的接口。图形库通常封装了底层的图形系统（如操作系统的图形接口或硬件的图形加速器）的复杂性，使得开发者可以更容易地在应用程序中实现图形界面和视觉效果。</p><p>图形库的主要作用包括：</p><ol><li><p><strong>简化图形开发</strong>：图形库提供了高级的图形处理功能，如绘图、图像处理、动画等，使得开发者无需深入了解底层的图形系统细节，就能实现复杂的图形效果。</p></li><li><p><strong>提高开发效率</strong>：通过使用图形库，开发者可以重用已有的图形处理函数和类，避免重复编写相同的代码，从而提高开发效率。</p></li><li><p><strong>跨平台兼容性</strong>：一些图形库被设计为跨平台的，即它们可以在不同的操作系统上运行，而无需对代码进行大量修改。这使得开发者可以编写一次代码，然后在多个平台上运行图形应用程序。</p></li><li><p><strong>性能优化</strong>：图形库通常会进行性能优化，以确保图形处理的高效性。它们可能会利用硬件加速功能（如GPU加速）来加快图形渲染速度，并提供对图形缓存、批处理等技术的支持。</p></li><li><p><strong>提供高级功能</strong>：除了基本的绘图功能外，图形库还可能提供一些高级功能，如文本渲染、图像处理（如缩放、旋转、裁剪等）、动画效果、用户交互（如鼠标和键盘事件处理）等。</p></li></ol><p>（简单来说就是让我们的代码运行不止于“小黑框”，而是拥有更漂亮的界面与更丰富的交互）</p><h3 id="为什么选择EasyX"><a href="#为什么选择EasyX" class="headerlink" title="为什么选择EasyX"></a>为什么选择EasyX</h3><p><code>EasyX</code>是一款基于C++语言开发的图形库，专为Windows平台设计，具有易于使用、功能强大等特点。基于C++语言开发，采用面向对象的编程方式，封装了Windows API中的GDI+接口。</p><ol><li><strong>简单易学</strong>：EasyX的API设计简单明了，无需掌握复杂的Win32或MFC开发技术，新手可以快速上手，制作出简单的图形界面和动画效果。</li><li><strong>功能全面</strong>：支持多种常用图形和文本操作，包括像素绘制、线条绘制、矩形绘制、圆形绘制、文字输出等功能，还可以播放音效和视频，支持鼠标键盘事件和定时器事件等高级功能。</li><li><strong>高效稳定</strong>：EasyX底层基于Windows API的GDI+接口实现，采用C++面向对象的设计方式，使得其运行高效稳定，能够充分利用计算机硬件资源，保证运行效果流畅。</li><li><strong>轻量级</strong>：EasyX是一个轻量级的图形库，不需要复杂的安装和配置过程，方便开发者快速集成和使用。</li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>（近四千五百行代码两周完成当时真是写麻了，甚至之后还加做了修改器……）</p><p><img src="https://image.flashfish777.cn/img/post_3_4.jpg" alt="修改器"></p><p>游戏类型是横板2d闯关类型，有单、双人两种模式，内含八个关卡（包括一个隐藏关）、两个BOSS，玩家通过发射子弹攻击怪物，战胜一个关卡内全部怪物可获得补给并走进下一关，通过全部关卡即为通关，并按操作难度给出成就评价。</p><p>一些代码细节包括：</p><ul><li>每个游戏对象（Game Object）的封装</li><li>图片及音效素材的优化</li><li>游戏地图的链表实现及切换操作</li><li>子弹与怪物的生成与销毁（vector）</li><li>碰撞检测</li><li>单&#x2F;双人的模式</li><li>游戏UI与交互按钮的实现</li></ul><p>等等这些在这里先不做介绍，文章主要想写一些关于面向对象与对程序设计方法的浅谈（虽然前面写的确实过于冗杂了……）如有想了解细节可以通过研究代码以及评论或联系我等方式。</p><p>收获： </p><ul><li>熟悉并熟练应用了C++面向对象编程思想，熟悉了STL库的使用。 </li><li>应用了链表等数据结构与各种算法使程序更优化更简洁易懂。 </li><li>掌握了EasyX图形库的基本用法。 </li><li>了解了从抽象的代码到具象化的小游戏程序的过程。 </li><li>实现了简单的UI与交互按钮。</li></ul><p><strong>Roefian的大冒险小游戏的完成，实现了我“做游戏给自己玩”的梦想！虽然游戏本身很简陋，bug高级多，但能做出来我就已经很满足了！</strong></p><hr><h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在了解我使用C++结合EasyX图形库开发的小游戏之后，让我们对<code>面向对象程序设计（Object-Oriented Programming, OOP）</code>这一核心概念进行一番概览。面向对象程序设计是一种广泛使用的编程范式，<strong>它通过将现实世界中的事物抽象为“对象”来组织代码</strong>，这些对象之间通过消息传递进行交互，从而构建出复杂而灵活的软件系统。</p><h3 id="面向对象的核心概念"><a href="#面向对象的核心概念" class="headerlink" title="面向对象的核心概念"></a>面向对象的核心概念</h3><ol><li><p><strong>对象（Object）</strong>：<br>对象是面向对象编程中的基本单元，它封装了数据（属性）和操作这些数据的方法（行为）。每个对象都是某个类的实例，具有该类的所有属性和方法。</p></li><li><p><strong>类（Class）</strong>：<br>类是对一组具有相同属性和方法的对象的抽象描述。它定义了对象的蓝图，包括对象的属性（数据成员）和可以执行的操作（成员函数）。通过类，我们可以创建具有相似特性和行为的对象集合。</p></li><li><p><strong>封装（Encapsulation）</strong>：<br>封装是隐藏对象的属性和实现细节，仅对外公开接口（即方法）的过程。这有助于保护数据不被随意修改，同时简化了对象的使用方式，只需通过接口与对象交互即可。</p></li><li><p><strong>继承（Inheritance）</strong>：<br>继承允许我们定义一个类（子类或派生类）来继承另一个类（父类或基类）的属性和方法。子类可以拥有父类的所有特性，并可以添加新的特性或覆盖（重写）父类的某些方法。继承是实现代码复用的重要手段。</p></li><li><p><strong>多态（Polymorphism）</strong>：<br>多态允许我们以统一的方式处理不同类型的对象。在面向对象编程中，这通常通过接口（在C++中通过虚函数实现）来实现，使得子类对象可以替换父类对象的位置，而程序仍能正常运行，表现出不同的行为。</p></li></ol><h3 id="面向对象编程的优势"><a href="#面向对象编程的优势" class="headerlink" title="面向对象编程的优势"></a>面向对象编程的优势</h3><ul><li><strong>代码复用</strong>：通过继承，我们可以重用已有的代码，减少重复编写相同功能的代码。</li><li><strong>可维护性</strong>：封装使得每个对象都负责自己的数据和操作，降低了模块间的耦合度，使得系统更易于维护和扩展。</li><li><strong>灵活性</strong>：多态性使得程序能够灵活地处理不同类型的对象，提高了程序的扩展性和可重用性。</li><li><strong>易于理解</strong>：面向对象编程将现实世界中的事物抽象为对象，使得程序结构更加贴近人类思维方式，易于理解和设计。</li></ul><h3 id="在我的小游戏中的应用"><a href="#在我的小游戏中的应用" class="headerlink" title="在我的小游戏中的应用"></a>在我的小游戏中的应用</h3><p>在Roefian的大冒险小游戏中，我充分利用了面向对象编程的这些特性。例如，我定义了多个<strong>类</strong>来表示游戏中的不同元素，如玩家、敌人、子弹等。每个<strong>类</strong>都封装了相应的属性和方法，如位置、速度、绘制方法、移动方法等。通过继承怪物与子弹等的<strong>基类</strong>，我创建了不同类型的敌人及Boss，以及不同特征的子弹，它们共享一些基本的属性和方法，但又有各自独特的行为。此外，我还利用了多态性，在游戏的主循环中统一处理不同类型的对象，使得游戏逻辑更加清晰和灵活。</p><p>通过这个小游戏的开发，我深刻体会到了面向对象编程的强大和魅力，它不仅提高了我的编程效率，还让我对软件设计有了更深入的理解。</p><h2 id="面向对象程序设计的深入理解"><a href="#面向对象程序设计的深入理解" class="headerlink" title="面向对象程序设计的深入理解"></a>面向对象程序设计的深入理解</h2><h3 id="抽象与封装"><a href="#抽象与封装" class="headerlink" title="抽象与封装"></a>抽象与封装</h3><ul><li><p><strong>抽象</strong>：面向对象编程的核心之一是抽象。抽象意味着从复杂的现实世界中提取出最重要的特征，忽略掉不相关的细节。在编程中，我们通过定义类来抽象出具有共同属性和行为的一组对象。这种抽象不仅简化了问题，还使得代码更加通用和可复用。</p></li><li><p><strong>封装的进一步探讨</strong>：封装不仅仅是隐藏数据，它还涉及到如何<strong>安全地访问和修改这些数据</strong>。在C++中，我们通常使用<code>private</code>、<code>protected</code>和<code>public</code>关键字来控制成员的访问权限。<code>private</code>成员只能被类内部的成员函数访问，而<code>public</code>成员则对外部可见。<code>protected</code>成员在继承中扮演特殊角色，它们对派生类可见，但对外部不可见。</p></li></ul><h3 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h3><ul><li><p><strong>继承的层次与类型</strong>：除了基本的单继承外，C++还支持多重继承，即<strong>一个类可以继承自多个基类</strong>。然而，多重继承可能会引入复杂的菱形继承问题（Diamond Problem），因此在实际应用中需要谨慎使用。此外，还有虚继承的概念，它用于解决菱形继承中的二义性问题。</p></li><li><p><strong>组合</strong>：除了继承外，另一种实现代码复用的方式是组合（也称为聚合或包含）。组合是通过在类中包含其他类的对象作为成员来实现的。与继承不同，组合表示的是“has-a”关系，而不是“is-a”关系。组合更加灵活，因为它允许我们在<strong>运行时动态地改变对象的组合方式</strong>。</p></li></ul><h3 id="多态性的实现"><a href="#多态性的实现" class="headerlink" title="多态性的实现"></a>多态性的实现</h3><ul><li><p><strong>虚函数</strong>：在C++中，多态性主要通过虚函数实现。当一个基类的指针或引用指向派生类对象时，通过该指针或引用调用的虚函数将表现出派生类的行为。这是通过虚函数表（vtable）实现的，每个包含虚函数的类都有一个指向vtable的指针，vtable中存储了该类及其所有基类中虚函数的地址。</p></li><li><p><strong>纯虚函数与抽象类</strong>：如果一个类中含有至少一个纯虚函数（即只有声明没有实现的虚函数），则该类为抽象类。抽象类不能被实例化，但可以作为基类被其他类继承。纯虚函数用于在基类中定义一个接口，让派生类去实现具体的行为。</p></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>面向对象编程的一个高级应用是设计模式。设计模式是在软件工程中反复出现的问题的解决方案。它们不是代码本身，而是关于如何组织代码的指导原则。一些常见的面向对象设计模式包括：</p><ul><li><strong>工厂模式</strong>：用于创建对象而不将具体类的代码与客户端代码混合在一起。</li><li><strong>单例模式</strong>：确保一个类只有一个实例，并提供一个全局访问点。</li><li><strong>观察者模式</strong>：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</li></ul><h3 id="面向对象与游戏开发"><a href="#面向对象与游戏开发" class="headerlink" title="面向对象与游戏开发"></a>面向对象与游戏开发</h3><p>在游戏开发中，面向对象编程的优势尤为明显。通过将游戏世界中的每个实体（如角色、怪物、道具等）抽象为对象，并使用类来定义它们的属性和行为，我们可以构建出一个灵活且可扩展的游戏框架。此外，利用继承和多态性，我们可以轻松地实现不同类型的实体和它们之间的交互，从而增加游戏的多样性和可玩性。</p><p>比如游戏引擎 <strong>Unity</strong> 中的 <strong>C#</strong> 语言就是 <strong>面向对象的高级编程语言</strong> ，在Unity中，几乎所有的游戏元素都是通过<code>GameObject</code>来创建的。每个<code>GameObject</code>都可以附加多个<code>Component（组件）</code>，这些<code>Component</code>实际上就是类的<strong>实例</strong>，它们定义了<code>GameObject</code>的行为和属性。例如，一个角色<code>GameObject</code>可以附加<code>Rigidbody</code>组件来控制物理行为，附加<code>Animator</code>组件来控制动画等。在Unity中编写游戏逻辑时，通常会定义多个类来表示不同的游戏元素和逻辑模块。这些类之间通过继承、组合和聚合等关系相互关联，共同构成游戏的核心逻辑。</p><p>总之，面向对象编程是一种强大的编程范式，它为我们提供了一种更加自然和直观的方式来构建复杂的软件系统。通过深入理解面向对象的核心概念和设计原则，我们可以编写出更加高效、可维护和可扩展的代码。</p><h2 id="面向对象方法论"><a href="#面向对象方法论" class="headerlink" title="面向对象方法论"></a>面向对象方法论</h2><p><code>面向对象分析（OOA）</code>、<code>面向对象设计（OOD）</code>和<code>面向对象编程（OOP）</code>是软件工程中紧密相连且逐步深入的三个概念，它们共同构成了面向对象方法论的重要组成部分。</p><h3 id="面向对象分析（OOA）"><a href="#面向对象分析（OOA）" class="headerlink" title="面向对象分析（OOA）"></a>面向对象分析（OOA）</h3><p><strong>定义</strong>：<br>OOA是指通过对问题领域进行分析，识别出其中的实体、关系、行为等要素，并将其抽象为对象、类、继承等概念，以便更好地理解和描述问题。在OOA阶段，通常使用UML（统一建模语言）等工具来进行建模和描述。</p><p><strong>主要任务</strong>：</p><ul><li>确定对象和类：识别并定义系统中的关键对象和类。</li><li>确定结构：分析对象之间的关系，如继承、关联等。</li><li>确定属性和方法：定义对象的属性和操作这些属性的方法。</li></ul><p><strong>重要性</strong>：<br>OOA为后续的OOD和OOP阶段提供了基础，确保了对问题领域的深入理解和准确表达。</p><h3 id="面向对象设计（OOD）"><a href="#面向对象设计（OOD）" class="headerlink" title="面向对象设计（OOD）"></a>面向对象设计（OOD）</h3><p><strong>定义</strong>：<br>OOD是指在OOA的基础上，进一步考虑系统的结构和组织方式，确定类的属性、方法、接口等细节，并进行模块划分、关系建立等设计工作。OOD的目标是将问题领域的抽象模型转化为可执行的软件设计。</p><p><strong>主要任务</strong>：</p><ul><li>细化类和接口：为类和接口添加详细的属性和方法。</li><li>划分模块：将系统划分为多个模块，每个模块包含一组相关的类和接口。</li><li>设计交互：定义对象之间的交互方式和通信机制。</li></ul><p><strong>与OOA的关系</strong>：<br>OOD是对OOA结果的进一步细化和规范化，为OOP阶段提供了详细的设计蓝图。</p><h3 id="面向对象编程（OOP）"><a href="#面向对象编程（OOP）" class="headerlink" title="面向对象编程（OOP）"></a>面向对象编程（OOP）</h3><p><strong>定义</strong>：<br>OOP是指使用面向对象的思想和方法来实现软件系统。在OOP中，程序被组织为一组相互协作的对象，每个对象都有自己的状态和行为，并通过消息传递来进行交互。</p><p><strong>主要特点</strong>：</p><ul><li>封装：将对象的属性和方法绑定在一起，并限制外部对属性的直接访问。</li><li>继承：子类继承父类的属性和方法，实现代码重用和层次化组织。</li><li>多态：同一个操作在不同对象上表现出不同行为的能力。</li></ul><p><strong>与OOD的关系</strong>：<br>OOP是OOD的具体实现阶段，它按照OOD提供的设计蓝图，使用具体的编程语言来编写代码，实现软件系统。</p><h3 id="三者之间的关系"><a href="#三者之间的关系" class="headerlink" title="三者之间的关系"></a>三者之间的关系</h3><ul><li><strong>顺序关系</strong>：从OOA到OOD再到OOP，三者之间存在一定的顺序关系。首先进行面向对象的分析（OOA），然后基于分析结果进行面向对象的设计（OOD），最后根据设计进行面向对象的编程（OOP）。</li><li><strong>相互影响</strong>：虽然存在顺序关系，但三者之间并不是简单的线性关系，而是相互影响、相互支持的。OOA的结果会影响OOD的设计决策，而OOD的设计又会影响OOP的实现方式。同时，OOP的实践经验也可以反馈到OOA和OOD阶段，帮助改进和优化分析和设计过程。</li></ul><p>所以，面向对象分析、面向对象设计和面向对象程序设计是面向对象方法论中不可或缺的三个环节，它们共同推动了软件工程的发展和进步。</p><h2 id="面向对象程序设计的发展"><a href="#面向对象程序设计的发展" class="headerlink" title="面向对象程序设计的发展"></a>面向对象程序设计的发展</h2><p>面向对象程序设计的起源可以追溯到20世纪50年代末期，但其真正作为软件开发范式的主流思想则是在20世纪90年代以后。面向对象的思想是对结构化程序设计的一种继承和发展，它旨在改善结构化程序设计中的不足，使程序设计更加接近于人们看待真实世界的情况。</p><h3 id="关键里程碑"><a href="#关键里程碑" class="headerlink" title="关键里程碑"></a>关键里程碑</h3><ol><li><p><strong>ALGOL 60的封装尝试</strong>：</p><ul><li>50年代后期，在用FORTRAN语言编写大型程序时，常出现变量名在程序不同部分发生冲突的问题。为了解决这一问题，ALGOL语言的设计者在ALGOL 60中采用了以Begin……End为标识的程序块，使块内变量名是局部的，以避免它们与程序中块外的同名变量相冲突。这是编程语言中首次提供封装（保护）的尝试。</li></ul></li><li><p><strong>Simula语言的诞生</strong>：</p><ul><li>1960年代初期，Kristen Nygaard和Ole-Johan Dahl在挪威计算机中心工作时，为了满足系统模拟的需要，开始研发一种更加高抽象层面的编程语言。经过两年的努力，他们于1964年成功推出了Simula语言，这是人类历史上第一款面向对象的编程语言。在Simula中，类被称为process，属性被称为station，方法被称为customer。</li></ul></li><li><p><strong>Smalltalk语言的奠基</strong>：</p><ul><li>随后，Alan Kay结合前人的工作，开发出了Smalltalk语言。Smalltalk在系统设计中强调对象概念的统一，引入了对象、对象类、方法、实例等概念和术语，并采用了动态联编和单继承机制。Smalltalk被认为是真正的面向对象编程语言（OOP）的奠基者。</li></ul></li><li><p><strong>面向对象语言的蓬勃发展</strong>：</p><ul><li>从80年代起，基于以往提出的信息隐蔽和抽象数据类型等概念，以及由Modula2、Ada和Smalltalk等语言所奠定的基础，不同类型的面向对象语言（如Object-C、Eiffel、C++、Java、Object-Pascal、Python等）逐步发展和建立起来。这些语言各具特色，但都遵循面向对象的基本原则。</li></ul></li></ol><h3 id="面向对象程序设计的优点"><a href="#面向对象程序设计的优点" class="headerlink" title="面向对象程序设计的优点"></a>面向对象程序设计的优点</h3><p>与其他程序设计方法相比，面向对象程序设计具有以下显著优点：</p><ol><li><p><strong>符合人们习惯的思维方法</strong>：</p><ul><li>面向对象程序设计将现实世界中的事物抽象为对象，使得程序结构更加接近于人们的思维方式。这种方式便于分解大型的复杂多变的问题，使得软件开发者可以更方便地与问题提出者进行沟通和交流。</li></ul></li><li><p><strong>易于软件的维护和功能的增减</strong>：</p><ul><li>面向对象程序设计中的封装性和对象之间的松散组合，使得软件的修改和维护变得更加容易。当需要增加或修改软件功能时，只需要关注相关的对象和类，而不需要对整个系统进行全面的修改。</li></ul></li><li><p><strong>可重用性好</strong>：</p><ul><li>通过定义和实例化对象，可以在不同的项目中重复使用已经编写好的类。这种重用性不仅提高了软件开发的效率，还减少了代码中的冗余和错误。</li></ul></li><li><p><strong>可扩展性强</strong>：</p><ul><li>面向对象程序设计支持继承和多态等特性，使得代码更具扩展性。通过继承，可以创建新的类来扩展已有类的功能；通过多态，可以在运行时动态地选择不同的方法实现，提供更大的灵活性和可扩展性。</li></ul></li><li><p><strong>封装性提高了代码的安全性和可靠性</strong>：</p><ul><li>面向对象编程通过封装将数据和相关的方法组合在一起，形成类的实例。这样可以隐藏实现的细节，只暴露必要的接口给外部使用，从而提高了代码的安全性和可靠性。</li></ul></li></ol><p>因为这些原因，面向对象程序设计以其独特的优势在软件开发领域占据了重要地位，并成为了当今软件开发的主流范式之一。</p><hr><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>在软件开发的世界里，程序设计方法的多样性是其繁荣与创新的重要源泉。每一种程序设计方法，无论是结构化编程、面向对象编程、函数式编程，还是响应式编程、事件驱动编程、面向切面编程（AOP）等，都拥有其独特的优势与适用场景，而<strong>没有绝对的优与劣之分</strong>。关键在于，开发者需要根据具体项目的需求、团队的技能集、维护的便捷性、以及未来可扩展性等因素，灵活选择和运用最适合当前情况的程序设计方法。</p><p>结构化编程以其清晰的逻辑流程和模块化设计，特别适合处理那些<strong>流程控制较为明确</strong>、<strong>业务逻辑相对简单</strong>的应用场景。而面向对象编程则通过封装、继承和多态等特性，有效提升了代码的重用性、可维护性和可扩展性，尤其适合构建<strong>复杂</strong>、<strong>多变</strong>且<strong>需要长期维护</strong>的系统。函数式编程以其不可变性、纯函数和声明式编程模型，为<strong>并发编程</strong>和<strong>数据流处理</strong>等领域带来了新的思路和效率提升。</p><p>每一种方法都有其光芒四射的场合，也都有可能在某些情境下显得力不从心。因此，重要的是培养一种“<strong>以问题为中心</strong>”的思维模式，而不是盲目追求某种方法的“先进性”或“时髦性”。只有深刻理解项目需求，全面评估各种方法的利弊，才能在众多的选择中找到那把最合适的“钥匙”，打开通往高效、可靠软件开发之路的大门。最终，程序设计的成功与否，不在于方法本身，而在于我们如何智慧地运用这些方法，以解决实际问题并创造价值。</p><p>程序设计方法的不断完善和应用推动了软件开发行业的发展和进步。通过合理运用不同的程序设计方法，开发人员可以在保证软件质量的同时提高开发效率，实现更加高效、可靠的计算机程序。此外，随着新技术和新方法的不断涌现，程序设计方法也在不断演进和发展，以适应不断变化的软件开发需求。在未来，相信随着技术的不断进步和应用场景的不断拓展，程序设计方法也将继续演进和发展，为软件开发行业带来更多的创新和变革。</p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 游戏 </category>
          
          <category> 非Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> OOP </tag>
            
            <tag> Easyx图形库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记</title>
      <link href="/posts/13675369.html"/>
      <url>/posts/13675369.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p><strong>C语言知识点</strong></p></div><h1 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h1><p>打空格！！！</p><p>逗号后面要打空格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d %d&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运算符前后要打空格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环里的分号后面要打空格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小括号和花括号之间要打空格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双斜杠注释后面打空格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双斜杠和这句话中间有空格</span></span><br></pre></td></tr></table></figure><p>其他还有什么地方要打空格自己意会</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="C主框架"><a href="#C主框架" class="headerlink" title="C主框架"></a>C主框架</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*****************</span></span><br><span class="line"><span class="comment">    *****************/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code>函数，又称主函数，是程序执行的起点。在执行程序时，由系统调用主函数，最后返回，结束程序。主要代码要写在主函数里。</p><p>主函数的类型一般是<code>int</code>，最后由<code>return</code>返回<code>0</code>来结束运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*****************</span></span><br><span class="line"><span class="comment">    *****************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数也可由其他类型定义，如<code>void</code>、<code>signed</code>等，但一般不常见且在一些情况下可能报错。以上为以<code>void</code>做主函数头（无需返回值）。</p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><h3 id="C语言标准库"><a href="#C语言标准库" class="headerlink" title="C语言标准库"></a>C语言标准库</h3><p><code>stdio.h</code>是C语言标准库，提供了C语言最基本的语法以及一些函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数学函数库"><a href="#数学函数库" class="headerlink" title="数学函数库"></a>数学函数库</h3><p><code>math.h</code>里有大量关于数学操作的函数，可以用来更方便的解决问题。常用的有：</p><ul><li><p><code>abs()</code>    对整形数据取绝对值</p></li><li><p><code>fabs()</code>    对浮点型数据取绝对值</p></li><li><p><code>sqrt()</code>    对数据取平方根（<code>double</code>型）</p></li><li><p><code>pow(x, y)</code>    求x的y次幂（<code>double</code>型）</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incude<span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">-3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> c = <span class="number">12.5</span>;</span><br><span class="line">    <span class="type">float</span> d = <span class="number">-5.123</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %lf %f\n&quot;</span>, <span class="built_in">abs</span>(a), <span class="built_in">abs</span>(b), <span class="built_in">fabs</span>(c), <span class="built_in">fabs</span>(d));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> aa = <span class="built_in">sqrt</span>(a);</span><br><span class="line">    <span class="type">int</span> bb = <span class="built_in">pow</span>(b, <span class="number">3</span>); <span class="comment">// -3的3次方</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, aa, bb);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9 3 12.5 5.123</span><br><span class="line">3 -27</span><br></pre></td></tr></table></figure><h3 id="string库"><a href="#string库" class="headerlink" title="string库"></a>string库</h3><ul><li><p><code>string.h</code>中的函数主要用于对字符串进行操作,常用的函数有：</p></li><li><p><code>strlen()</code>    返回字符串的长度。</p></li><li><p><code>strcmp(x, y)</code>    比较字符串<code>x</code>和<code>y</code>，当<code>x &lt; y</code>，返回值小于<code>0</code>；当<code>x = y</code>，返回值等于<code>0</code>；当<code>x &gt; y</code>，返回值大于<code>0</code>。</p></li><li><p><code>strcpy(x, y)</code>    将<code>y</code>指向的字符复制到<code>x</code>中</p></li><li><p><code>strcat(x, y)</code>    将字符串<code>y</code>连接到<code>x</code>的尾部</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">6</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">6</span>] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">6</span>] = <span class="string">&quot;55555&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(a));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">strcmp</span>(a, b);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小于\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;等于\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大于\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(c, b);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcat</span>(a, c);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">小于</span><br><span class="line">HelloWorld</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li><p><code>//</code>    单行注释</p></li><li><p><code>/**/</code>    整段注释</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;Hello World&quot;);</span></span><br><span class="line">    <span class="comment">//printf(&quot;Hello World&quot;);</span></span><br><span class="line">    <span class="comment">//printf(&quot;Hello World&quot;);</span></span><br><span class="line">    <span class="comment">//printf(&quot;Hello World&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    printf(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="define定义标识符"><a href="#define定义标识符" class="headerlink" title="#define定义标识符"></a>#define定义标识符</h2><p>C语言中可以使用<code>#define</code>来定义一个标识符来表示一个常量,或定义一些宏，定义的标识符,并不占用程序内存,在预编译阶段对程序代码进行文本替换。定义标识符的操作在主函数外面。</p><p>最常见的用法就是<code>#define</code>来定义一些常量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI = 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;圆周率 = %d&quot;</span>, PI);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="typedef-关键字定义"><a href="#typedef-关键字定义" class="headerlink" title="typedef 关键字定义"></a>typedef 关键字定义</h2><p>C语言允许用户使用 <code>typedef</code> 关键字来定义自己习惯的数据类型名称，<code>typedef</code> 的真正含义是给一个已经存在的类型名称起一个别名，注意是已经存在的数据类型，而非变量，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LL a = <span class="number">12345678</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="定义和赋值"><a href="#定义和赋值" class="headerlink" title="定义和赋值"></a>定义和赋值</h2><p><strong>定义：</strong><code>数据类型</code>  <code>数据名</code> <code>;</code></p><p><strong>定义时赋初值：</strong><code>数据类型</code>  <code>数据名</code>  <code>赋值符号（=）</code>  <code>初值</code> <code>;</code></p><p><strong>同时定义多个：</strong><code>数据类型</code>  <code>数据名</code>  <code>,</code>  <code>数据名</code> <code>;</code></p><p><strong>注意！</strong>  定义时没有赋初值的话这个数据的值就是随机的，有需要时千万别忘了赋初值，没有需要时也赋初值也是一个很好的习惯。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">3.14</span>, d = <span class="number">2.2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %lf %lf&quot;</span>, a, b, c, d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 5 3.14 2.2</span><br></pre></td></tr></table></figure><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><p>在程序运行的过程中，可以改变值的变量称为变量。</p><p>程序运行过程中，不可以发生改变的量叫做常量。</p><p>一般定义的数据默认为变量，可以用<code>define</code>定义常量，也可以在定义时的数据类型前加上<code>const</code>使之成为常量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3</span>,<span class="number">1415926</span>;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><table><thead><tr><th></th><th align="left">类型</th><th>存储大小</th><th>值范围</th></tr></thead><tbody><tr><td><strong>char</strong></td><td align="left">字符型</td><td>1字节</td><td>-128 到 127</td></tr><tr><td><strong>short</strong></td><td align="left">短整型</td><td>2字节</td><td>-32,768 到 32,767</td></tr><tr><td><strong>int</strong></td><td align="left">整型</td><td>4字节</td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td><strong>long</strong></td><td align="left">长整型</td><td>4字节</td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td><strong>long long</strong></td><td align="left">长长整形</td><td>8字节</td><td></td></tr></tbody></table><h3 id="浮点型（实型）"><a href="#浮点型（实型）" class="headerlink" title="浮点型（实型）"></a>浮点型（实型）</h3><table><thead><tr><th></th><th>类型</th><th>存储大小</th><th>值范围</th><th>精度</th></tr></thead><tbody><tr><td><strong>float</strong></td><td>单精度浮点数</td><td>4字节</td><td>1.2E-38 到 3.4E+38</td><td>6 位有效位</td></tr><tr><td><strong>double</strong></td><td>双精度浮点数</td><td>8字节</td><td>2.3E-308 到 1.7E+308</td><td>15 位有效位</td></tr><tr><td><strong>long double</strong></td><td>长双精度浮点数</td><td>16字节</td><td>3.4E-4932 到 1.1E+4932</td><td>19位有效位</td></tr></tbody></table><h3 id="unsigned"><a href="#unsigned" class="headerlink" title="unsigned"></a>unsigned</h3><p>整型变量的值的范围包括负数到正数。 但是在实际应用中，有的数据的范围常常只有正值（如学号、年龄等），为了充分利用变量的值的范围，可以将变量定义为“无符号”类型。可以在类型符号前面加上修饰符 <code>unsigned</code> ，表示指定该变量是“无符号整数”类型。如果加上修饰符 <code>signed</code>或什么都不加，则是“有符号”类型。</p><p>有符号整型数据存储单元中最高位代表数值的符号，如果指定为无符号型，不能存放负数，如 -123 等。由于无符号整型变量不用符号位，所以可表示数值的范围是一般整型变量中的两倍。</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p><a href="https://blog.csdn.net/xiandang8023/article/details/126036564">内存分配-CSDN</a></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在进行运算时，不同类型的数据要转换成同一类型。</p><h3 id="自动类型转换（隐式类型转换）"><a href="#自动类型转换（隐式类型转换）" class="headerlink" title="自动类型转换（隐式类型转换）"></a>自动类型转换（隐式类型转换）</h3><ul><li><p><code>float</code>型数据自动转换成<code>double</code>型；</p></li><li><p><code>char</code>与<code>short</code>型数据自动转换成<code>int</code>型；</p></li><li><p><code>int</code>型与<code>double</code>型数据运算，直接将<code>int</code>型转换成<code>double</code>型</p></li><li><p><code>int</code>型与<code>unsigned</code>型数据、直接将<code>int</code>型转换成<code>unsigned</code>型；</p></li><li><p><code>int</code>型与<code>long</code>型数据，直接将<code>int</code>型转换成<code>long</code>型。</p><p>如此等等，总之是由低级向高级型转换。另外不要错误地理解为先将<code>char</code>型或<code>short</code>型转换成<code>int</code>型，再转换成<code>unsigned</code>型，再转换成<code>long</code>型，直至<code>double</code>型。</p></li></ul><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>强制类型转换的一般形式为：<code>（类型名）</code> <code>（表达式）</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">7</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="type">float</span> y1, y2;</span><br><span class="line"><span class="type">float</span> y1 = a / b; <span class="comment">// y1的值a/b为3.0</span></span><br><span class="line">y2 = (<span class="type">float</span>) (a / b); <span class="comment">// y2的值为3.5， float将a强制转换为实型，b也随之自动转换为实型</span></span><br></pre></td></tr></table></figure><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p>每个字符都对应着一个ASCII码：<a href="https://www.runoob.com/w3cnote/ascii.html">ASCII码表</a></p><p><strong>常用：</strong></p><p><code>0</code>-&gt;<code>48</code></p><p><code>9</code>-&gt;<code>57</code></p><p><code>A</code>-&gt;<code>65</code></p><p><code>Z</code>-&gt;<code>90</code></p><p><code>a</code>-&gt;<code>97</code></p><p><code>z</code>-&gt;<code>122</code></p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>**十进制：**默认数制</p><p> **二进制：**以<code>0B</code>或<code>0b</code>前缀表示，如<code>0b0101</code></p><p>**八进制：**以<code>0</code>前缀表示，如<code>0123</code></p><p>**十六进制：**以<code>0X</code>或<code>0x</code>前缀表示，如<code>0x1A</code></p><p><strong>vc6.0中整形后加<code>l</code>或<code>L</code>表示是<code>long</code>型，加<code>u</code>表示是<code>unsigned</code>型</strong></p><h1 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h1><p>在C语言中，程序的执行分为三种结构：顺序结构、选择结构（分支结构）和循环结构。</p><p>顺序结构：代码从上到下顺序执行，中间没有任何判断和跳转。</p><h2 id="变量输入输出"><a href="#变量输入输出" class="headerlink" title="变量输入输出"></a>变量输入输出</h2><p>在C语言中，输入和输出是通过库函数<code>stdio.h</code>中的<code>scanf()</code>和<code>printf()</code>函数来实现的。在输入与输出时，<code>printf()</code>函数与<code>scanf()</code>函数的格式字符串用于指定输入输出的格式。格式字符串中的格式说明符（如<code>%d</code>表示整数，<code>%f</code>表示浮点数）必须与后面参数的类型和数量相匹配。如果格式字符串与参数不匹配，可能会导致未定义的行为或输出错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">float</span> c;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> e;</span><br><span class="line">    <span class="type">char</span> f[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    %d 十进制有符号整数</span></span><br><span class="line"><span class="comment">    %lld long long整数</span></span><br><span class="line"><span class="comment">    %u 十进制无符号整数</span></span><br><span class="line"><span class="comment">    %f 浮点数</span></span><br><span class="line"><span class="comment">    %lf 双精度浮点数</span></span><br><span class="line"><span class="comment">    %s 字符串</span></span><br><span class="line"><span class="comment">    %c 单个字符</span></span><br><span class="line"><span class="comment">    %p 指针的值</span></span><br><span class="line"><span class="comment">    %e 指数形式的浮点数</span></span><br><span class="line"><span class="comment">    %x,%X 无符号以十六进制表示的整数</span></span><br><span class="line"><span class="comment">    %0 无符号以八进制表示的整数</span></span><br><span class="line"><span class="comment">    %g 自动选择合适的表示法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c %d %f %lf %lld %s&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d, &amp;e, f); <span class="comment">// 输入时变量要加取地址符（&amp;），字符串不用，详见指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    %nd 表示输出n位整型数,不够n位右对齐</span></span><br><span class="line"><span class="comment">    %.nf 表示小数点后保留n位</span></span><br><span class="line"><span class="comment">    %n.mf 表示输出场宽为n+m的浮点数，其中小数位为m,整数位为n,小数点占一位不够n+m位右对齐</span></span><br><span class="line"><span class="comment">    %0nd 表示在输出一个小于n位的数值时,将在前面补0使其总宽度为n位</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%8d%8d%8d\n&quot;</span>, b, b*<span class="number">10</span>, b*<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%8.2f%8.2f%8.2f\n&quot;</span>, c, c*<span class="number">10</span>, c*<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%08lld%08lld%08lld&quot;</span>, e, e*<span class="number">10</span>, e/<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输入：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a 25 3.456 12.3456 111 hello</span><br></pre></td></tr></table></figure><p><strong>输出如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      25     250    2500</span><br><span class="line">    3.46   34.56  345.60</span><br><span class="line">000001110000111000000011</span><br></pre></td></tr></table></figure><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>C语言中的表达式主要由运算符和操作数构成。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><strong>算术运算符</strong>：<code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code></li><li><strong>赋值运算符</strong>：C语言中的赋值运算符<code>=</code>用于将一个表达式的值赋给变量。此外，C语言还支持复合赋值运算符，如<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code> 等，这些运算符可以简化赋值和算术运算的组合。</li><li><strong>自增自减运算符</strong>：C语言中的自增<code>++</code>和自减 <code>--</code> 运算符用于将变量的值增加或减少1。这些运算符只能用于变量，不能用于常量或表达式。</li><li><strong>位运算符</strong>：<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>^</code>、<code>&amp;</code>、<code>|</code></li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>在C语言中，运算符的优先级决定了表达式中各个运算对象之间的计算顺序，即哪个部分先计算，哪个部分后计算。下面是C语言中常用的运算符优先级列表，从高到低排列：</p><ol><li>括号 ()</li><li>一元运算符：++ - - !</li><li>算术运算符：* &#x2F; %</li><li>算术运算符：+ -</li><li>关系运算符：&lt; &gt; &lt;&#x3D; &gt;&#x3D;</li><li>等价运算符：&#x3D;&#x3D; !&#x3D;</li><li>位运算符：&lt;&lt; &gt;&gt;</li><li>位运算符：&amp;</li><li>位运算符：^</li><li>位运算符：|</li><li>条件运算符 ?:</li><li>赋值运算符：&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</li><li>逗号运算符: ,</li></ol><p>需要注意的是，同一优先级的运算符按照结合性进行计算，大部分运算符遵循<strong>从左至右</strong>的结合性，只有<strong>单目运算符</strong>、<strong>条件运算符</strong>、<strong>赋值运算符</strong>遵循<strong>从右至左</strong>的结合性。</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>C语言中的语句可以分为以下几类：</p><ul><li><strong>表达式语句</strong>：由表达式加上分号<code>;</code>组成，用于计算表达式的值并执行副作用。</li><li><strong>函数调用语句</strong>：由函数名、实际参数加上分号<code>;</code>组成，用于调用函数。</li><li><strong>控制语句</strong>：用于控制程序的执行流程，包括条件判断、循环执行、转向等。</li><li><strong>复合语句</strong>：用花括号<code>&#123;&#125;</code>括起来的一条或多条语句，也称为块。</li><li><strong>空语句</strong>：只有分号<code>;</code>组成的语句，不执行任何操作的语句。</li></ul><h1 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h1><h2 id="if-else-if-else判断结构"><a href="#if-else-if-else判断结构" class="headerlink" title="if-else if- else判断结构"></a>if-else if- else判断结构</h2><h3 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)&#123;</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">    ……</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个if语句，如果表示条件的逻辑表达式的结果不是0，那么就执行后面跟着的这对大括号内的语句；否则就跳过不执行，继续下面的其他语句。</p><p><strong>但是if语句还有一种形式可以不用{}。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &gt; b)</span><br><span class="line">    a += b + <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>if语句这一行结束的时候并没有表示语句结束的”;”，而后面的赋值语句写在if的下一行，而且缩进了，在这一行结束的时候有一个分号。</p><p>表明这条赋值语句是if语句的一部分，if语句拥有和控制这条赋值语句，决定其是否被执行。</p><p>简单地说就是if(逻辑表达式)后要么跟上”{“，要么跟上语句，不能直接写分号。</p><p>**总结：**有大括号的时候 条件满足的情况执行所有括号内语句，无大括号的时候 条件满足执行最近邻语句。</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>​<code>&lt;</code>  <code>&gt;=</code>  <code>&lt;</code>  <code>&lt;=</code> </p><p>​<code>!=</code>   用于测试“不相等”</p><p>​<code>==</code>   用于测试“相等”</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>​<code>&amp;&amp;</code>    </p><p>​逻辑与       理解为： 即 怎么  又 怎么       一假全假，全真为真</p><p>​<code>||</code>        </p><p>​逻辑或     理解为：   要么 怎么 要么 怎么      一真为真， 全假为假</p><p>​<code>！</code></p><p>​逻辑非     真取假  假取真</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;少年\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">18</span> &amp;&amp; age &lt; <span class="number">30</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;青年\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">30</span> &amp;&amp; age &lt; <span class="number">50</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;中年\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">50</span> &amp;&amp; age &lt; <span class="number">80</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;老年\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;老寿星\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch-case选择结构"><a href="#switch-case选择结构" class="headerlink" title="switch-case选择结构"></a>switch-case选择结构</h2><p><code>switch</code>语句也是一种分支语句。 常常用于多分支的情况。<code>else if</code> 语句也能实现多分支情况，但在某些情况下使用<code>else if</code>来实现，会使代码过于复杂。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(整型表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在一个 switch 中可以有任意数量的 case 语句。</span></span><br><span class="line">    <span class="keyword">case</span> 整形常量表达式:</span><br><span class="line">    语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch-case</code>语句一般搭配<code>break</code>和<code>default</code>使用</p><p>中断语句<code>break</code>是C语言中的关键字，用于跳出循环或<code>switch</code>语句的执行。<code>break</code>语句通常用于在满足某个条件时提前终止循环，或在<code>switch</code>语句中匹配到某个<code>case</code>后跳出。</p><p>当 <code>switch</code> 表达式的值并不匹配所有 <code>case</code> 标签的值时，这个 <code>default</code> 子句后面的语句就会执行，<code>switch</code> 语句可以有一个可选的 <code>default</code> <code>case</code>，出现在 <code>switch</code> 的结尾。<code>default</code> <code>case</code> 可用于在上面所有 <code>case</code> 都不为真时执行一个任务。<code>default</code> <code>case</code> 中的 <code>break</code> 语句不是必需的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;day);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (day)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期天\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注</strong>：C语言中的<code>switch</code>语句具有“穿透”性，这意味着如果在<code>switch case</code>中没有使用<code>break</code>语句，那么匹配的<code>case</code>之后的所有<code>case</code>都将被执行。</p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a ? b : c;</span><br></pre></td></tr></table></figure><p>意为若a成立，则执行b，否则执行c。相当于if-else中的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a)</span><br><span class="line">&#123;</span><br><span class="line">    b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三目运算符有很多用法，如判断赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">x = a &gt; b ? a : b; <span class="comment">// x = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用三目运算符求出了a与b的最大值并赋给x，相较于</span></span><br><span class="line"><span class="comment">if (a &gt; b)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    x = a;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    x = b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">要简单。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如直接返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a * <span class="number">2</span> : b + a + b / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="布尔变量"><a href="#布尔变量" class="headerlink" title="布尔变量"></a>布尔变量</h2><p><strong>布尔类型</strong>是一种包含两种值的数据类型，即<code>0</code>和<code>1</code>。基本上，<code>bool</code>类型的值表示两种行为，即<code>true</code>或<code>false</code>。在这里，’<code>0&#39;</code>表示<code>false</code>值，而’<code>1</code>‘表示<code>true</code>值。</p><p><strong>在C中，<code>&#39;0&#39; </code>以<code>0</code>的形式存储，而其他整数以<code>1</code>的形式存储,即“非零即true”</strong></p><p>C语言标准库不自带<strong>bool</strong>类型，需要引用<code>stdbool.h</code>头文件或用<code>typedef</code>手动定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span> </span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span><span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="type">bool</span>;</span><br></pre></td></tr></table></figure><p>应用示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> x = <span class="literal">false</span>;  <span class="comment">// 变量初始化 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">true</span>) <span class="comment">// 条件语句</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x的值为真&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x的值为假&quot;</span>);  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x的值为假</span><br></pre></td></tr></table></figure><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><p>循环语句具有在某些条件满足的情况下，反复执行特定代码的功能。</p><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>语法形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">    语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h2><p>语法形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    语句;</span><br><span class="line">&#125; <span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure><p><code>do while</code> 循环是先直接进⼊循环体，执⾏循环语句，然后再执⾏ <code>while</code> 后的判断表达式，表达式为真，就会进⾏下⼀次，表达式为假，则不再继续循环。</p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>语法形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式1 ⽤于循环变量的初始化 ，表达式2 ⽤于循环结束条件的判断 ，表达式3 ⽤于循环变量的调整，三种表达式都可以省略，但分号不能省略。</p><p><code>for</code>循环和<code>while</code>循环可以相互转换。二者没有性能上的差别。实际开发中，根据具体结构的情况，选择哪个格式更合适、美观。</p><h2 id="break、continue"><a href="#break、continue" class="headerlink" title="break、continue"></a>break、continue</h2><p>在循环执行的过程中，如果某些状况发⽣的时候，需要提前终止循环，这是非常常见的现象。C语言中提供了 <code>break</code> 和 <code>continue</code> 两个关键字，就是应⽤到循环中的。</p><p><code>break</code> 的作用是用于永久的终止循环，只要 <code>break</code> 被执行，直接就会跳出循环，继续往后执行。</p><p><code>continue</code> 的作用是跳过本次循环 <code>continue</code> 后边的代码，在 <code>for</code>循环和 <code>while</code> 循环中有所差异的。</p><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>分支结构和循环结构在使用中都可以嵌套，像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Flag = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Flag) &#123;</span><br><span class="line">        <span class="type">int</span> Flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (Flag) &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> Flag = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            Flag++;</span><br><span class="line">            <span class="keyword">if</span> (Flag &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> Flag = <span class="number">0</span>; Flag &lt;= <span class="number">100</span>; ++Flag) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> Flag = <span class="number">0</span>; Flag &lt;= <span class="number">100</span>; ++Flag) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">static</span> <span class="type">int</span> Flag = <span class="number">-100</span>;</span><br><span class="line">                </span><br><span class="line">                Flag++;</span><br><span class="line">                <span class="keyword">if</span> (Flag &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> Flag = <span class="number">0</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (Flag) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Test 1\r\n&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Test 0\r\n&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong>函数</strong>是指将一组能完成一个功能或多个功能的语句放在一起的<strong>代码结构</strong>。在C语言程序中，至少会包含一个函数，即主函数<code>main()</code>。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><p>​库函数就是存放在函数库中的函数，具有明确的功能、入口调用参数和返回值。</p><p>​<strong>库函数必须知道的一个秘密就是：使用库函数，必须包含 #include 对应的头文件。</strong></p><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>​自定义函数和库函数一样，有函数名，返回值类型和函数参数。</p><p>​例：写一个函数可以找出两个整数中的最大值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? (x) : (y);<span class="comment">//三目运算符：x大于y返回x，x小于y返回y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h2><p>一个在两个数中返回最大值的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? (x) : (y);<span class="comment">//三目运算符：x大于y返回x，x小于y返回y</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> max = cmp(num1, num2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max = %d\n&quot;</span>, max);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 20</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max = 20</span><br></pre></td></tr></table></figure><p><strong>函数可以先声明后定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> max = cmp(num1, num2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max = %d\n&quot;</span>, max);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cmp(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? (x) : (y);<span class="comment">//三目运算符：x大于y返回x，x小于y返回y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上的代码中，<code>int cmp(int x, int y);</code>先将函数声明，这样的语句叫做函数原型。</p><p>声明即告诉编译器有一个函数叫什么，参数是什么，返回类型是什么。但是具体是不是存在，函数声明决定不了。</p><p>创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</p><p>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。</p><h2 id="返回类型、函数名、形参、实参、返回"><a href="#返回类型、函数名、形参、实参、返回" class="headerlink" title="返回类型、函数名、形参、实参、返回"></a>返回类型、函数名、形参、实参、返回</h2><p>C 语言中的函数定义的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return_type <span class="title function_">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>**返回类型：**一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li><li>**函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li><li><strong>参数：<strong>当函数被调用时，您向参数传递一个值，这个值被称为</strong>实际参数</strong>。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。<strong>形式参数</strong>是指函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才实例化（分配内存单元），所以叫形式参数。形式参数当函数调用完成之后就自动销毁了。因此形式参数只在函数中有效。</li><li>**函数主体：**函数主体包含一组定义函数执行任务的语句。</li></ul><h2 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h2><p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：</p><ul><li><p>在函数或块内部的<strong>局部</strong>变量</p></li><li><p>在所有函数外部的<strong>全局</strong>变量</p></li><li><p>在<strong>形式</strong>参数的函数参数定义中</p></li></ul><p>在某个函数或块的内部声明的变量称为<strong>局部变量</strong>。它们只能被该函数或该代码块内部的语句使用。<strong>局部变量</strong>在函数外部是不可知的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 实际初始化 */</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  c = a + b;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// a，b，c，sum都是main函数的局部变量</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; i ++ )</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">int</span> d;</span><br><span class="line">      d = i * <span class="number">2</span>;</span><br><span class="line">      </span><br><span class="line">      sum += d;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// i，d是for语句中的局部变量</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of a = %d, b = %d and c = %d\n&quot;</span>, a, b, c);</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;sum = %d&quot;</span>, sum);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全局变量</strong>是定义在主函数外部，通常是在程序的顶部。<strong>全局变量</strong>在整个程序生命周期内都是有效的，在任意的函数内部能访问<strong>全局变量</strong>。</p><p>全局变量可以被任何函数或语句访问。也就是说，全局变量在声明后整个程序中都是可用的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 全局变量声明 */</span></span><br><span class="line"><span class="type">int</span> g;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 实际初始化 */</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  g = a + b;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;value of a = %d, b = %d and g = %d\n&quot;</span>, a, b, g);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全局变量在定义时默认初值为0</strong></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><a href="https://www.runoob.com/cprogramming/c-recursion.html">递归-菜鸟驿站</a></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><strong>数组</strong>是一种<strong>数据结构</strong>，它可以存储一个固定大小的相同类型元素的<strong>顺序集合</strong>。数组中的元素可以通过索引访问，<strong>索引通常从0开始</strong>。</p><h2 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type arrayName [ arraySize ];</span><br></pre></td></tr></table></figure><p>这叫做一维数组。<code>arraySize</code> 必须是一个大于零的整数常量，<code>type</code> 可以是任意有效的 C 数据类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>]; <span class="comment">// 声明一个整型数组，其中包含5个元素，未初始化</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 声明一个整型数组，并初始化</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 声明并初始化一个整型数组</span></span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = arr[3]; // a = 4</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>可以使用循环语句对数组进行遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n[<span class="number">10</span>]; <span class="comment">/* n 是一个包含 10 个整数的数组 */</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化数组元素 */</span>         </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        n[i] = i + <span class="number">100</span>; <span class="comment">/* 设置元素 i 为 i + 100 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出数组中每个元素的值 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;n[%d] = %d\n&quot;</span>, j, n[j] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n[0] = 100</span><br><span class="line">n[1] = 101</span><br><span class="line">n[2] = 102</span><br><span class="line">n[3] = 103</span><br><span class="line">n[4] = 104</span><br><span class="line">n[5] = 105</span><br><span class="line">n[6] = 106</span><br><span class="line">n[7] = 107</span><br><span class="line">n[8] = 108</span><br><span class="line">n[9] = 109</span><br></pre></td></tr></table></figure><h2 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h2><p>数组长度可以使用 <code>sizeof</code> 运算符来获取数组的长度，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); <span class="comment">// 获取数组长度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组长度为: %d\n&quot;</span>, length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组长度为: 5</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>C 语言支持多维数组。多维数组声明的一般形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type name[size1][size2]...[sizeN];</span><br></pre></td></tr></table></figure><p>多维数组最简单的形式是<strong>二维数组</strong>。一个二维数组，在本质上，是一个一维数组的列表。下面是一个二维数组，包含 3 行和 4 列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p><strong>初始化二维数组</strong></p><p>多维数组可以通过在括号内为每行指定值来进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   <span class="comment">/*  初始化索引号为 0 的行 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   <span class="comment">/*  初始化索引号为 1 的行 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;   <span class="comment">/*  初始化索引号为 2 的行 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样也是一样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br></pre></td></tr></table></figure><p>二维数组可以用嵌套的两个循环来遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 一个带有 5 行 2 列的数组 */</span></span><br><span class="line">   <span class="type">int</span> a[<span class="number">5</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">2</span>,<span class="number">4</span>&#125;, &#123;<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">4</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">   <span class="type">int</span> i, j;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出数组中每个元素的值 */</span></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++ )</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d] = %d\n&quot;</span>, i,j, a[i][j] );</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a[0][0] = 0</span><br><span class="line">a[0][1] = 0</span><br><span class="line">a[1][0] = 1</span><br><span class="line">a[1][1] = 2</span><br><span class="line">a[2][0] = 2</span><br><span class="line">a[2][1] = 4</span><br><span class="line">a[3][0] = 3</span><br><span class="line">a[3][1] = 6</span><br><span class="line">a[4][0] = 4</span><br><span class="line">a[4][1] = 8</span><br></pre></td></tr></table></figure><h1 id="字符串（字符数组）"><a href="#字符串（字符数组）" class="headerlink" title="字符串（字符数组）"></a>字符串（字符数组）</h1><p>字符串实际上是使用空字符 <code>\0 </code>结尾的一维字符数组。因此，字符串的实际长度总要多一位，<code>\0</code> 是用于标记字符串的结束。在定义一个字符串时不需要把 <code>\0</code>字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 <code>\0</code> 放在字符串的末尾。</p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>在C语言中，转义字符是以反斜杠<code>\</code>开头，后跟一个字符。它用来表示非打印字符，比如换行<code>\n</code>以及其他一些特殊的字符。</p><p>以下是C语言中常用的转义字符的完整列表：</p><p><code>\\</code>：反斜杠<br><code>\&#39;</code>：单引号<br><code>\&quot;</code>：双引号<br><code>\?</code>：问号<br><code>\a</code>：警报（响铃）<br><code>\b</code>：退格<br><code>\f</code>：换页<br><code>\n</code>：换行<br><code>\r</code>：回车<br><code>\t</code>：制表符（水平制表）<br><code>\v</code>：垂直制表<br><code>\0</code>：空字符<br><code>\ooo</code>：八进制表示的字符（其中 ooo 是一个八进制数，范围为 0-377）<br><code>\xhh</code>：十六进制表示的字符（其中 hh 是一个十六进制数，范围为 00-FF）</p><h2 id="定义与赋值"><a href="#定义与赋值" class="headerlink" title="定义与赋值"></a>定义与赋值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> site[<span class="number">7</span>] = &#123;<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> site[] = <span class="string">&quot;RUNOOB&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>实际上，字符串就是char类型的数组，各种操作都与数组大同小异。</strong></p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>字符串用<code>%s</code>输入输出，且输入时不用加取地址符<code>&amp;</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">char</span> ch[<span class="number">11</span>] = &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">  <span class="type">char</span> ch2[<span class="number">11</span>] = <span class="string">&quot;javatpoint&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Char Array Value is: %s\n&quot;</span>, ch);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;String Literal Value is: %s\n&quot;</span>, ch2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Char Array Value is: javatpoint</span><br><span class="line">String Literal Value is: javatpoint</span><br></pre></td></tr></table></figure><p><strong>注</strong></p><ul><li><code>getchar()</code></li></ul><p>读取一个字符，包括任何字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a = getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, getchar());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, a);</span><br><span class="line">    </span><br><span class="line">    reutnr <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcdefg</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">a</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>gets()</code></li></ul><p>读取整行输入，直至遇到换行符，然后把换行符，储存其余字符，并在这些字符的末尾添加一个空字符使其成为一个 C 字符串。</p><p>1.<code>gets()</code>函数不安全。<br>2.C11标准委员会已经将其废除，建议能不用尽量不用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    gets(str);  <span class="comment">// 从标准输入流中读取一行字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World！</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World！</span><br></pre></td></tr></table></figure><ul><li><code>%[^\n]</code></li></ul><p><code>%[^\n]</code>是一种输入方法，用到了正则表达式相关用法。它代表输入至换行符时停止。同样的，<code>%[^1]</code>表示输入到1停止，以此类推。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%[^1]&quot;</span>, str);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxxxxxxxxxxx1</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>（能理解多少就理解多少，知道地址与变量的关系就行）</p><p><a href="https://www.runoob.com/cprogramming/c-pointers.html">指针-菜鸟驿站</a></p><p><a href="https://blog.csdn.net/u012060033/article/details/127600005">指针-CSDN</a></p><h2 id="取地址符"><a href="#取地址符" class="headerlink" title="取地址符"></a>取地址符</h2><p>每一个变量都有一个内存位置，每一个内存位置都定义了可使用 <code>&amp;</code> 运算符访问的地址，它表示了在内存中的一个地址。</p><p>下面一个例子输出变量的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p;              <span class="comment">// 定义指针变量</span></span><br><span class="line">    p = &amp;var_runoob;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a 变量的地址： %p\n&quot;</span>, p);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a 变量的地址： 0x7ffeeaae08d8</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_41823495/article/details/133692629">指针与地址</a></p><h2 id="取内容符"><a href="#取内容符" class="headerlink" title="取内容符"></a>取内容符</h2><p>指针变量定义格式：存储类型 数据类型 指针变量名；</p><p><code>int *p</code>: 定义了一个指针变量p,指向的数据是int类型的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="type">char</span> c=<span class="string">&#x27;v&#x27;</span>;</span><br><span class="line"><span class="type">char</span> *q=&amp;c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>, p, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>,q,&amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,a,*p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c %c\n&quot;</span>,c,*q);</span><br></pre></td></tr></table></figure><p><strong>访问指针所指向空间的内容用取内容运算符<code>*</code></strong></p><p>那么p变量存放的就是a的地址，q变量存放的是c的地址。</p><p>符号<code>*</code>可以访问地址里面的内容。</p><h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><p>在 C 语言中，数组名表示数组的地址，即数组首元素的地址。当我们在声明和定义一个数组时，该数组名就代表着该数组的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br></pre></td></tr></table></figure><p>在这里，<code>myArray</code> 是数组名，它表示整数类型的数组，包含 5 个元素。<code>myArray</code> 也代表着数组的地址，即第一个元素的地址。</p><p>数组名本身是一个常量指针，意味着它的值是不能被改变的，一旦确定，就不能再指向其他地方。</p><p>我们可以使用&amp;运算符来获取数组的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;myArray[<span class="number">0</span>]; <span class="comment">// 或者直接写作 int *ptr = myArray;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>ptr</code> 指针变量被初始化为 <code>myArray</code> 的地址，即数组的第一个元素的地址。</p><p>需要注意的是，虽然数组名表示数组的地址，但在大多数情况下，数组名会自动转换为指向数组首元素的指针。这意味着我们可以直接将数组名用于指针运算，例如在函数传递参数或遍历数组时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]); <span class="comment">// 数组名arr被当作指针使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    printArray(myArray, <span class="number">5</span>); <span class="comment">// 将数组名传递给函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>printArray</code> 函数接受一个整数数组和数组大小作为参数，我们将 <code>myArray</code> 数组名传递给函数，函数内部可以像使用指针一样使用 <code>arr</code> 数组名。</p><h2 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h2><p><strong>传递指针给函数</strong></p><p>C 语言允许传递指针给函数，只需要简单地 <strong>声明函数参数为指针类型</strong> 即可。</p><p>下面的实例中，我们传递一个无符号的 long 型指针给函数，并在函数内改变这个值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">getSeconds</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *par)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> sec;</span><br><span class="line">   getSeconds( &amp;sec );</span><br><span class="line">   <span class="comment">/* 输出实际值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Number of seconds: %ld\n&quot;</span>, sec );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getSeconds</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *par)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 获取当前的秒数 */</span></span><br><span class="line">   *par = time( <span class="literal">NULL</span> );</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number of seconds :1294450468</span><br></pre></td></tr></table></figure><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体（<code>struct</code>）是一种构造类型，它可以将不同的数据类型组合在一起形成一个新的数据类型，这种新的数据类型就是结构体。 </p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>定义和声明结构体的同时创建变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; stu; <span class="comment">// 创建了一个名为stu的结构体变量</span></span><br></pre></td></tr></table></figure><p>先定义结构体，然后声明变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>;</span> <span class="comment">// 创建了一个名为stu的结构体变量</span></span><br></pre></td></tr></table></figure><p>使用typedef定义别名，然后创建变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; Student;</span><br><span class="line"> </span><br><span class="line">Student stu; <span class="comment">// 创建了一个名为stu的结构体变量</span></span><br></pre></td></tr></table></figure><p>在结构体内部不初始化成员，而是在创建结构体变量后初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; stu = &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>, <span class="number">90.5f</span>&#125;; <span class="comment">// 在定义变量的同时进行初始化</span></span><br></pre></td></tr></table></figure><h2 id="访问-1"><a href="#访问-1" class="headerlink" title="访问"></a>访问</h2><p>使用指针访问结构体成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span> =</span> &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>, <span class="number">90.5f</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p</span> =</span> &amp;stu;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (*p).name); <span class="comment">// 使用指针访问结构体成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p-&gt;name); <span class="comment">// 另一种访问结构体成员的方式</span></span><br></pre></td></tr></table></figure><p>在结构体数组中存储数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; stu[<span class="number">3</span>]; <span class="comment">// 创建了一个结构体数组，可以存储3个学生的信息</span></span><br></pre></td></tr></table></figure><p>使用结构体指针访问结构体数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; stu[<span class="number">3</span>], *p;</span><br><span class="line"> </span><br><span class="line">p = stu;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (p+<span class="number">1</span>)-&gt;name); <span class="comment">// 访问第二个学生的名字</span></span><br></pre></td></tr></table></figure><p>在结构体中使用结构体类型成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">birthday</span>;</span></span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span> =</span> &#123;<span class="string">&quot;Tom&quot;</span>, &#123;<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>&#125;, <span class="number">90.5f</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, stu.birthday.year); <span class="comment">// 访问学生的出生年份</span></span><br></pre></td></tr></table></figure><h2 id="链表-结构体指针"><a href="#链表-结构体指针" class="headerlink" title="链表-结构体指针"></a>链表-结构体指针</h2><p><a href="https://blog.csdn.net/Ruaaa_iiiiiiiii/article/details/129499703">结构体链表</a></p><p>—end—</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/posts/d95d7e09.html"/>
      <url>/posts/d95d7e09.html</url>
      
        <content type="html"><![CDATA[<p><strong>一天晚上，一个懵懵懂懂的电脑小白决心创建一个自己的博客网页，他找了很多教程，因为什么都不懂，这期间他也遇到了很多困难。但他没有放弃，失败了就删掉文件从头开始，哪里不懂就上网查，终于搞出了自己的第一个博客网站……</strong></p><h3 id="一、自我介绍"><a href="#一、自我介绍" class="headerlink" title="一、自我介绍"></a>一、自我介绍</h3><div class="note info flat"><p><strong>首先允许我郑重的以主人的身份入驻我的博客网站！</strong></p></div><p>想当高手.jpg<br>本人男性取向女，梦想是<mark class="hl-label blue">做游戏</mark>（做很棒很棒的游戏，让所有人都玩我的游戏！），性格<mark class="hl-label green">INFP</mark>，乐观开朗，跟不熟的人有点腼腆，喜欢运动，会踢足球，会打羽毛球乒乓球台球，但是不厉害，喜欢交朋友，喜欢敲代码，学习新知识，喜欢打游戏，什么游戏都玩 但是都很菜，最喜欢的是<mark class="hl-label orange">吃糖</mark>。<br>此时此刻我才是一名刚刚接触计算机与编程的大一学生，在开学之前苦战两个月c语言考进了学校的计科院学生团队，有很多厉害的学长学姐带我学习，带我走进这个神奇的世界，一步步实现自己的梦想。</p><h3 id="二、为什么是博客"><a href="#二、为什么是博客" class="headerlink" title="二、为什么是博客"></a>二、为什么是博客</h3><p>刚开始的时候，编程对我来说只是一个遥远而神秘的词汇。每当看到屏幕上那些密密麻麻的代码，我就像是一个站在高墙之外的旁观者，既好奇又敬畏。但随着时间的推移，我逐渐发现，编程不仅仅是一堆冷冰冰的字符和逻辑，它更是一种创造力和思维方式的展现。每一次编写代码，都是在构建一个属于自己的世界，那种从无到有的过程，让我感受到了前所未有的成就感和满足感。使我更加坚定了我的目标。<br>我眼中的博客，是大佬们记录和分享知识的圣地，记录了学习的点滴进步，分享遇到的挑战和解决方案，以及各种奇闻异事或趁手的工具。在这里我可以写下任何我想写的东西。<br><strong>作为程序员，我们每天都在进行无穷无尽知识输入却很少有机会能够输出。输出的重要性一是在于反思和总结，能让我更加清晰地认识到自己的不足和需要改进的地方，二是太多的知识无法消化便可以先记录下来，学习是一个在实践中不断碰壁的过程，三是一个人的思考不如大家的思考，我可以同他人一起交流我的观点与思路，可以让我结识更多多志同道合的朋友和前辈，他们的经验和建议都能让我受益匪浅。</strong><br>而且我相信，<strong>在撰写博客的过程中，我可以逐渐形成了自己的写作风格和思考方式。可以尝试用通俗易懂的语言解释复杂的技术问题，用生动的例子和贴切的比喻帮助读者更好地理解编程概念。这本身也是对我的表达能力的一种很好的锻炼。同时我也希望通过我的努力，能够让更多的人感受到编程的乐趣和魅力，从而激发他们对编程的兴趣和热情。</strong><br>我相信，知识的力量在于传播和共享。通过分享我的学习心得和项目经验，我不仅能够帮助到那些正在学习编程的朋友，还能够从他们的反馈和建议中汲取新的灵感和思路。这种双向的交流和学习，可以让我感受到智慧的碰撞和传承的力量。</p><p>另外，谁不想拥有一个可以DIY的属于自己的炫酷的网页呢……</p><h3 id="三、未来"><a href="#三、未来" class="headerlink" title="三、未来"></a>三、未来</h3><p>对未来，我充满了期待和憧憬。我希望能够继续深化我的编程技能，特别是在游戏开发领域，因为我始终相信，游戏是传递快乐和创意的最佳载体。我要通过一点一滴的积累来实现我的目标。<br>我也希望能够将我的博客打造成一个更专业、更全面、更有影响力的平台。我会发表很多很多的文章来记录我的成长之路。<br>我相信，只要我们保持对知识的渴望和对梦想的追求，就一定能够在编程的道路上不断前行、不断超越自我，实现自己的理想！</p><p>—end—</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"flashfish777_blog","short_name":"flashfish777_blog","theme_color":"#3b70fc","background_color":"#3b70fc","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/144.png","sizes":"144x144","type":"image/png"},{"src":"/img/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>时间轴</title>
      <link href="/archives/index.html"/>
      <url>/archives/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/progress_bar.css"/>
      <url>/css/progress_bar.css</url>
      
        <content type="html"><![CDATA[.pace {    -webkit-pointer-events: none;    pointer-events: none;    -webkit-user-select: none;    -moz-user-select: none;    user-select: none;    z-index: 2000;    position: fixed;    margin: auto;    top: 10px;    left: 0;    right: 0;    height: 8px;    border-radius: 8px;    width: 4rem;    background: #eaecf2;    border: 1px #e3e8f7;    overflow: hidden;}.pace-inactive .pace-progress {    opacity: 0;    transition: 0.3s ease-in;}.pace .pace-progress {    -webkit-box-sizing: border-box;    -moz-box-sizing: border-box;    -ms-box-sizing: border-box;    -o-box-sizing: border-box;    box-sizing: border-box;    -webkit-transform: translate3d(0, 0, 0);    -moz-transform: translate3d(0, 0, 0);    -ms-transform: translate3d(0, 0, 0);    -o-transform: translate3d(0, 0, 0);    transform: translate3d(0, 0, 0);    max-width: 200px;    position: absolute;    z-index: 2000;    display: block;    top: 0;    right: 100%;    height: 100%;    width: 100%;    background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);    animation: gradient 1.5s ease infinite;    background-size: 200%;}.pace.pace-inactive {    opacity: 0;    transition: 0.3s;    top: -8px;}@keyframes gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/anzhiyu.js"/>
      <url>/js/anzhiyu.js</url>
      
        <content type="html"><![CDATA[var navMusicEl = document.getElementById("nav-music");var anzhiyu = {  //切换音乐播放状态  musicToggle: function (changePaly = true) {    if (!anzhiyu_musicFirst) {      musicBindEvent();      anzhiyu_musicFirst = true;    }    let msgPlay = '<i class="fa-solid fa-play"></i><span>播放音乐</span>'; // 此處可以更改為你想要顯示的文字    let msgPause = '<i class="fa-solid fa-pause"></i><span>暂停音乐</span>'; // 同上，但兩處均不建議更改    if (anzhiyu_musicPlaying) {      navMusicEl.classList.remove("playing");      // 修改右键菜单文案为播放      // document.getElementById("menu-music-toggle").innerHTML = msgPlay;      document.getElementById("nav-music-hoverTips").innerHTML = "音乐已暂停";      // document.querySelector("#consoleMusic").classList.remove("on");      anzhiyu_musicPlaying = false;      navMusicEl.classList.remove("stretch");    } else {      navMusicEl.classList.add("playing");      // 修改右键菜单文案为暂停      // document.getElementById("menu-music-toggle").innerHTML = msgPause;      // document.querySelector("#consoleMusic").classList.add("on");      anzhiyu_musicPlaying = true;      navMusicEl.classList.add("stretch");    }    if (changePaly) document.querySelector("#nav-music meting-js").aplayer.toggle();  },  // 音乐伸缩  musicTelescopic: function () {    if (navMusicEl.classList.contains("stretch")) {      navMusicEl.classList.remove("stretch");    } else {      navMusicEl.classList.add("stretch");    }  },  //音乐上一曲  musicSkipBack: function () {    document.querySelector("#nav-music meting-js").aplayer.skipBack();  },  //音乐下一曲  musicSkipForward: function () {    document.querySelector("#nav-music meting-js").aplayer.skipForward();  },  //获取音乐中的名称  musicGetName: function () {    var x = $(".aplayer-title");    var arr = [];    for (var i = x.length - 1; i >= 0; i--) {      arr[i] = x[i].innerText;    }    return arr[0];  },};]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;}/* maple-mono-latin-400-italic */@font-face {    font-family: 'MapleMono';    font-style: italic;    font-display: swap;    font-weight: 400;    src: url(https://cdn.jsdelivr.net/fontsource/fonts/maple-mono@latest/latin-400-italic.woff2) format('woff2')}div#menus {    font-family: "ZhuZiAYuanJWD";}h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;}a.article-title,a.blog-slider__title,a.categoryBar-list-link,h1.post-title {    font-family: ZhuZiAYuanJWD;}.iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;}/* 时间轴生肖icon *//* svg.icon {    这里定义svg.icon，避免和Butterfly自带的note标签冲突    width: 1em;    height: 1em;    width和height定义图标的默认宽度和高度    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;} */.icon-zhongbiao::before {    color: #f7c768;}/* 解决artitalk的图标问题 */#uploadSource>svg {    width: 1.19em;    height: 1.5em;}/*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 *//* #page-header:not(.not-top-img):before {    background-color: transparent !important;} */:root {    --trans-light: rgba(255, 255, 255, 0.88);    --trans-dark: rgba(25, 25, 25, 0.88);    --border-style: 1px solid rgb(169, 169, 169);    --backdrop-filter: blur(5px) saturate(150%);}/* 首页文章卡片 */#recent-posts>.recent-post-item {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 25px;    border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 18px;    border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive,div#tag,div#category {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border: var(--border-style);    border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {    background: rgba(255, 255, 255, 0.75);    backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {    background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts>.recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page,[data-theme="dark"] div#tag, [data-theme="dark"] div#category {    background: var(--trans-dark);}/* 夜间模式伪类遮罩层透明[data-theme="dark"] #recent-posts>.recent-post-item {    background: #121212;}[data-theme="dark"] .card-widget {    background: #121212 !important;}[data-theme="dark"] div#post {    background: #121212 !important;}[data-theme="dark"] div#tag {    background: #121212 !important;}[data-theme="dark"] div#archive {    background: #121212 !important;}[data-theme="dark"] div#page {    background: #121212 !important;}[data-theme="dark"] div#category {    background: #121212 !important;}[data-theme="dark"] div#category {    background: transparent !important;} */[data-theme="dark"] #footer::before {    background: transparent !important;}/* [data-theme="dark"] #page-header::before {    background: transparent !important;} *//* 阅读模式 */.read-mode #aside-content .card-widget {    background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {    background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;}[data-theme="dark"] .read-mode div#post {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;}/* 页脚透明 */#footer {    background: transparent !important;}/* 头图透明 *//* #page-header {    background: transparent !important;} */#rightside>div>button {    border-radius: 5px;}/* 滚动条 */::-webkit-scrollbar {    width: 10px;    height: 10px;}::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;}::-webkit-scrollbar-corner {    background-color: transparent;}::-moz-selection {    color: #fff;    background-color: #3b70fc;}/* 音乐播放器 *//* .aplayer .aplayer-lrc {  display: none !important;} */.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */}.aplayer.aplayer-fixed {    z-index: 999999 !important;}/* 评论框  */.vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;}/* 设置评论框 */.vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;}/* md网站下划线 */#article-container a:hover {    text-decoration: none !important;}#article-container #hpp_talk p img {    display: inline;}/* 404页面 */#error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);}#error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;}#error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;}#error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;}#error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;}#error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;}#error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);}#body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;}#body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;}#body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;}#body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;}#body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;}#body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;}#body-wrap.error .aside-list .aside-list-item .content time {    display: none;}/* 代码框主题 */#article-container figure.highlight {    border-radius: 10px;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content>.card-widget.card-info {    background: linear-gradient(-45deg,            #e8d8b9,            #eccec5,            #a3e9eb,            #bdbdf0,            #eec1ea);    box-shadow: 0 0 5px rgb(66, 68, 68);    position: relative;    background-size: 400% 400%;    -webkit-animation: Gradient 10s ease infinite;    -moz-animation: Gradient 10s ease infinite;    animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@-moz-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content>.card-widget.card-info {    background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content>.card-widget.card-info>#card-info-btn {    background-color: #3eb8be;    border-radius: 8px;}/* 鼠标样式 */#cursor {    position: fixed;    width: 16px;    height: 16px;    /* 这里改变跟随的底色 */    background: rgb(111, 57, 197);    border-radius: 8px;    opacity: 0.25;    z-index: 10086;    pointer-events: none;    transition: 0.2s ease-in-out;    transition-property: background, opacity, transform;}#cursor.hidden {    opacity: 0;}#cursor.hover {    opacity: 0.1;    transform: scale(2.5);    -webkit-transform: scale(2.5);    -moz-transform: scale(2.5);    -ms-transform: scale(2.5);    -o-transform: scale(2.5);}#cursor.active {    opacity: 0.5;    transform: scale(0.5);    -webkit-transform: scale(0.5);    -moz-transform: scale(0.5);    -ms-transform: scale(0.5);    -o-transform: scale(0.5);}/* 一级菜单居中 */#nav .menus_items {    position: absolute !important;    width: fit-content !important;    left: 50% !important;    transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {    display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(2) .menus_item_child {    left: -90px;}.menus_items .menus_item:nth-child(3) .menus_item_child {    left: -75px;}/* 日间模式不生效 */[data-theme="light"] #site-name,[data-theme="light"] #site-title {    animation: light_15px 10s linear infinite;}[data-theme="light"] #site-subtitle {    animation: light_10px 10s linear infinite;}[data-theme="light"] #post-info {    animation: light_5px 10s linear infinite;}/* 夜间模式生效 */[data-theme="dark"] #site-name,[data-theme="dark"] #site-title {    animation: light_15px 10s linear infinite;}[data-theme="dark"] #site-subtitle {    animation: light_10px 10s linear infinite;}[data-theme="dark"] #post-info {    animation: light_5px 10s linear infinite;}/* 关键帧描述 */@keyframes light_15px {    0% {        text-shadow: #5636ed 0 0 15px;    }    12.5% {        text-shadow: #11ee5e 0 0 15px;    }    25% {        text-shadow: #f14747 0 0 15px;    }    37.5% {        text-shadow: #f1a247 0 0 15px;    }    50% {        text-shadow: #f1ee47 0 0 15px;    }    50% {        text-shadow: #b347f1 0 0 15px;    }    62.5% {        text-shadow: #002afa 0 0 15px;    }    75% {        text-shadow: #ed709b 0 0 15px;    }    87.5% {        text-shadow: #39c5bb 0 0 15px;    }    100% {        text-shadow: #5636ed 0 0 15px;    }}@keyframes light_10px {    0% {        text-shadow: #5636ed 0 0 10px;    }    12.5% {        text-shadow: #11ee5e 0 0 10px;    }    25% {        text-shadow: #f14747 0 0 10px;    }    37.5% {        text-shadow: #f1a247 0 0 10px;    }    50% {        text-shadow: #f1ee47 0 0 10px;    }    50% {        text-shadow: #b347f1 0 0 10px;    }    62.5% {        text-shadow: #002afa 0 0 10px;    }    75% {        text-shadow: #ed709b 0 0 10px;    }    87.5% {        text-shadow: #39c5bb 0 0 10px;    }    100% {        text-shadow: #5636ed 0 0 10px;    }}@keyframes light_5px {    0% {        text-shadow: #5636ed 0 0 5px;    }    12.5% {        text-shadow: #11ee5e 0 0 5px;    }    25% {        text-shadow: #f14747 0 0 5px;    }    37.5% {        text-shadow: #f1a247 0 0 15px;    }    50% {        text-shadow: #f1ee47 0 0 5px;    }    50% {        text-shadow: #b347f1 0 0 5px;    }    62.5% {        text-shadow: #002afa 0 0 5px;    }    75% {        text-shadow: #ed709b 0 0 5px;    }    87.5% {        text-shadow: #39c5bb 0 0 5px;    }    100% {        text-shadow: #5636ed 0 0 5px;    }}/* 背景宇宙星光  */#universe {    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;}body::-webkit-scrollbar {    width: 0;}.neko {    width: 80px;    height: 80px;    background-image: url("https://image.flashfish777.cn/img/zyg.gif");    position: absolute;    right: 25px;    background-repeat: no-repeat;    background-size: contain;    transform: translateX(50%);    cursor: pointer;    font-family: tzy;    font-weight: 600;    font-size: 16px;    color: #6f42c1;    display: none;}.neko::after {    display: none;    width: 100px;    height: 100px;    background-image: url("https://bu.dusays.com/2022/07/20/62d812d95e6f5.png");    background-size: contain;    z-index: 9999;    position: absolute;    right: 50%;    text-align: center;    line-height: 100px;    top: -115%;}.neko.showMsg::after {    content: attr(data-msg);    display: block;    overflow: hidden;    text-overflow: ellipsis;}.neko:hover::after {    content: attr(data-msg);    display: block;    overflow: hidden;    text-overflow: ellipsis;}.neko.fontColor::after {    color: #333;}/** * @description: 滚动条样式  跟猫二选一 */@media screen and (max-width:992px) {    ::-webkit-scrollbar {        width: 8px !important;        height: 8px !important    }    ::-webkit-scrollbar-track {        border-radius: 2em;    }    ::-webkit-scrollbar-thumb {        background-color: rgb(255 255 255 / .3);        background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent);        border-radius: 2em    }    ::-webkit-scrollbar-corner {        background-color: transparent    }}/* 文章页H1-H6图标样式效果 */h1::before,h2::before,h3::before,h4::before,h5::before,h6::before {    -webkit-animation: ccc 1.6s linear infinite;    animation: ccc 1.6s linear infinite;}@-webkit-keyframes ccc {    0% {        -webkit-transform: rotate(0deg);        transform: rotate(0deg);    }    to {        -webkit-transform: rotate(-1turn);        transform: rotate(-1turn);    }}@keyframes ccc {    0% {        -webkit-transform: rotate(0deg);        transform: rotate(0deg);    }    to {        -webkit-transform: rotate(-1turn);        transform: rotate(-1turn);    }}#content-inner.layout h1::before {    color: #ef50a8;    margin-left: -1.55rem;    font-size: 1.3rem;    margin-top: -0.23rem;}#content-inner.layout h2::before {    color: #fb7061;    margin-left: -1.35rem;    font-size: 1.1rem;    margin-top: -0.12rem;}#content-inner.layout h3::before {    color: #ffbf00;    margin-left: -1.22rem;    font-size: 0.95rem;    margin-top: -0.09rem;}#content-inner.layout h4::before {    color: #a9e000;    margin-left: -1.05rem;    font-size: 0.8rem;    margin-top: -0.09rem;}#content-inner.layout h5::before {    color: #57c850;    margin-left: -0.9rem;    font-size: 0.7rem;    margin-top: 0rem;}#content-inner.layout h6::before {    color: #5ec1e0;    margin-left: -0.9rem;    font-size: 0.66rem;    margin-top: 0rem;}#content-inner.layout h1:hover,#content-inner.layout h2:hover,#content-inner.layout h3:hover,#content-inner.layout h4:hover,#content-inner.layout h5:hover,#content-inner.layout h6:hover {    color: #3b70fc;}#content-inner.layout h1:hover::before,#content-inner.layout h2:hover::before,#content-inner.layout h3:hover::before,#content-inner.layout h4:hover::before,#content-inner.layout h5:hover::before,#content-inner.layout h6:hover::before {    color: #3b70fc;    -webkit-animation: ccc 3.2s linear infinite;    animation: ccc 3.2s linear infinite;}/* 页面设置icon转动速度调整 */#rightside_config i.fas.fa-cog.fa-spin {    animation: fa-spin 1s linear infinite;}/*哔哩哔哩视频适配*/.aspect-ratio {    position: relative;    width: 100%;    height: 0;    padding-bottom: 75%;    margin: 3% auto;    text-align: center;}.aspect-ratio iframe {    position: absolute;    width: 100%;    height: 100%;    left: 0;    top: 0;}.pace {    -webkit-pointer-events: none;    pointer-events: none;    -webkit-user-select: none;    -moz-user-select: none;    user-select: none;    z-index: 2000;    position: fixed;    margin: auto;    top: 10px;    left: 0;    right: 0;    height: 8px;    border-radius: 8px;    width: 4rem;    background: #eaecf2;    border: 1px #e3e8f7;    overflow: hidden;}.pace-inactive .pace-progress {    opacity: 0;    transition: 0.3s ease-in;}.pace .pace-progress {    -webkit-box-sizing: border-box;    -moz-box-sizing: border-box;    -ms-box-sizing: border-box;    -o-box-sizing: border-box;    box-sizing: border-box;    -webkit-transform: translate3d(0, 0, 0);    -moz-transform: translate3d(0, 0, 0);    -ms-transform: translate3d(0, 0, 0);    -o-transform: translate3d(0, 0, 0);    transform: translate3d(0, 0, 0);    max-width: 200px;    position: absolute;    z-index: 2000;    display: block;    top: 0;    right: 100%;    height: 100%;    width: 100%;    background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);    animation: gradient 1.5s ease infinite;    background-size: 200%;}.pace.pace-inactive {    opacity: 0;    transition: 0.3s;    top: -8px;}@keyframes gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}/* 设置文字内容 :nth-child(1)的作用是选择第几个 */.el-input.el-input--small.el-input-group.el-input-group--prepend:nth-child(1):before {    content: '输入QQ号会自动获取昵称和头像🐧';}.el-input.el-input--small.el-input-group.el-input-group--prepend:nth-child(2):before {    content: '收到回复将会发送到您的邮箱📧';}.el-input.el-input--small.el-input-group.el-input-group--prepend:nth-child(3):before {    content: '可以通过昵称访问您的网站🔗';}/* 当用户点击输入框时显示 */.el-input.el-input--small.el-input-group.el-input-group--prepend:focus-within::before,.el-input.el-input--small.el-input-group.el-input-group--prepend:focus-within::after {    display: block;}/* 主内容区 */.el-input.el-input--small.el-input-group.el-input-group--prepend::before {    /* 先隐藏起来 */    display: none;    /* 绝对定位 */    position: absolute;    /* 向上移动60像素 */    top: -60px;    /* 文字强制不换行，防止left:50%导致的文字换行 */    white-space: nowrap;    /* 圆角 */    border-radius: 10px;    /* 距离左边50% */    left: 50%;    /* 然后再向左边挪动自身的一半，即可实现居中 */    transform: translate(-50%);    /* 填充 */    padding: 14px 18px;    background: #444;    color: #fff;}/* 小角标 */.el-input.el-input--small.el-input-group.el-input-group--prepend::after {    display: none;    content: '';    position: absolute;    /* 内容大小（宽高）为0且边框大小不为0的情况下，每一条边（4个边）都是一个三角形，组成一个正方形。    我们先将所有边框透明，再给其中的一条边添加颜色就可以实现小三角图标 */    border: 12px solid transparent;    border-top-color: #444;    left: 50%;    transform: translate(-50%, -48px);} /* 加载样式 */.loading-img {    background: url(/img/144.png) no-repeat center center;    background-size: cover;}.card-info-avatar .author-status-box {    position: absolute;    bottom: 0;    left: calc(100% - 28px);    width: 28px;    height: 28px;    border: 1px solid #d0d7de;    border-radius: 2em;    background-color: #f8f8f8f8;    transition: 0.4s;    overflow: hidden;}[data-theme="dark"] .card-info-avatar .author-status-box {    background-color: #222222f2;    border: 1px solid #5c6060;}/* 信息卡片头像状态 */.card-info-avatar .author-status-box .author-status {    display: flex;    align-items: center;    justify-content: center;    height: 28px;    padding: 0 5px;}.card-info-avatar .author-status-box:hover {    width: 105px;}.card-info-avatar .author-status-box:hover .author-status span {    width: 105px;    margin-left: 4px;}.card-info-avatar .author-status-box .author-status span {    width: 0;    font-size: 12px;    height: 100%;    overflow: hidden;    text-overflow: ellipsis;    white-space: nowrap;    transition: 0.4s;}.card-widget .card-info-avatar {    display: inline-block;    position: relative;}/* 头像呼吸灯 *//* 头像呼吸灯 */[data-theme="light"] .avatar-img {    animation: huxi_light 4s ease-in-out infinite;}[data-theme="dark"] .avatar-img {    animation: huxi_dark 4s ease-in-out infinite;}@keyframes huxi_light {    0% {        box-shadow: 0px 0px 1px 1px #d1f8cc;    }    50% {        box-shadow: 0px 0px 5px 5px #6ff984;    }    100% {        box-shadow: 0px 0px 1px 1px #14eb05;    }}@keyframes huxi_dark {    0% {        box-shadow: 0px 0px 1px 1px #39c5bb;    }    50% {        box-shadow: 0px 0px 5px 5px #39c5bb;    }    100% {        box-shadow: 0px 0px 1px 1px #39c5bb;    }}/* 文章页波浪 *//* 波浪css */.main-hero-waves-area {    width: 100%;    position: absolute;    left: 0;    bottom: -11px;    z-index: 5;}.waves-area .waves-svg {    width: 100%;    height: 5rem;}/* Animation */.parallax>use {    animation: move-forever 25s cubic-bezier(0.55, 0.5, 0.45, 0.5) infinite;}.parallax>use:nth-child(1) {    animation-delay: -2s;    animation-duration: 7s;    fill: #f7f9febd;}.parallax>use:nth-child(2) {    animation-delay: -3s;    animation-duration: 10s;    fill: #f7f9fe82;}.parallax>use:nth-child(3) {    animation-delay: -4s;    animation-duration: 13s;    fill: #f7f9fe36;}.parallax>use:nth-child(4) {    animation-delay: -5s;    animation-duration: 20s;    fill: #f7f9fe;}/* 黑色模式背景 */[data-theme="dark"] .parallax>use:nth-child(1) {    animation-delay: -2s;    animation-duration: 7s;    fill: #18171dc8;}[data-theme="dark"] .parallax>use:nth-child(2) {    animation-delay: -3s;    animation-duration: 10s;    fill: #18171d80;}[data-theme="dark"] .parallax>use:nth-child(3) {    animation-delay: -4s;    animation-duration: 13s;    fill: #18171d3e;}[data-theme="dark"] .parallax>use:nth-child(4) {    animation-delay: -5s;    animation-duration: 20s;    fill: #18171d;}@keyframes move-forever {    0% {        transform: translate3d(-90px, 0, 0);    }    100% {        transform: translate3d(85px, 0, 0);    }}/*Shrinking for mobile*/@media (max-width: 768px) {    .waves-area .waves-svg {        height: 40px;        min-height: 40px;    }}/* 滚动条样式 */::-webkit-scrollbar {    width: 8px;    height: 8px;}::-webkit-scrollbar-track {    background-color: rgba(73, 177, 245, 0.2);    border-radius: 2em;}::-webkit-scrollbar-thumb {    background-color: #E06C75;    background-image: -webkit-linear-gradient(45deg,            rgba(255, 255, 255, 0.4) 25%,            transparent 25%,            transparent 50%,            rgba(255, 255, 255, 0.4) 50%,            rgba(255, 255, 255, 0.4) 75%,            transparent 75%,            transparent);    border-radius: 2em;}::-webkit-scrollbar-corner {    background-color: transparent;}::-moz-selection {    color: #fff;    background-color: #E06C75;}/* 颜色 */:root {    --anzhiyu-theme-op: #4259ef23;    --anzhiyu-card-bg-none: rgba(255, 255, 255, 0);    --anzhiyu-main-op-deep: var(--anzhiyu-theme-op-deep) !important;    --anzhiyu-gray-op: #9999992b;    --anzhiyu-theme-top: var(--anzhiyu-theme);    --anzhiyu-white: #fff;    --anzhiyu-white-op: rgba(255, 255, 255, 0.2);    --anzhiyu-black: #000;    --anzhiyu-black-op: rgba(0, 0, 0, 0.2);    --anzhiyu-none: rgba(0, 0, 0, 0);    --anzhiyu-gray: #999999;    --anzhiyu-yellow: #ffc93e;    --anzhiyu-orange: #e38100;    --anzhiyu-border-radius: 8px;    --anzhiyu-main: var(--anzhiyu-theme);    --anzhiyu-main-op: var(--anzhiyu-theme-op);    --anzhiyu-shadow-theme: 0 8px 12px -3px var(--anzhiyu-theme-op);    --anzhiyu-shadow-main: 0 8px 12px -3px var(--anzhiyu-main-op);    --anzhiyu-shadow-blue: 0 8px 12px -3px rgba(40, 109, 234, 0.2);    --anzhiyu-shadow-white: 0 8px 12px -3px rgba(255, 255, 255, 0.2);    --anzhiyu-shadow-black: 0 0 12px 4px rgba(0, 0, 0, 0.05);    --anzhiyu-shadow-yellow: 0px 38px 77px -26px rgba(255, 201, 62, 0.12);    --anzhiyu-shadow-red: 0 8px 12px -3px #ee7d7936;    --anzhiyu-shadow-green: 0 8px 12px -3px #87ee7936;    --anzhiyu-shadow-border: 0 8px 16px -4px #2c2d300c;    --anzhiyu-shadow-blackdeep: 0 2px 16px -3px rgba(0, 0, 0, 0.15);    --anzhiyu-logo-color: linear-gradient(215deg, #4584ff 30%, #ff7676 70%);    --style-border: 1px solid var(--anzhiyu-card-border);    --anzhiyu-blue-main: #3b70fc;    --style-border-hover: 1px solid var(--anzhiyu-main);    --style-border-dashed: 1px dashed var(--anzhiyu-theme-op);    --style-border-avatar: 4px solid var(--anzhiyu-background);    --style-border-always: 1px solid var(--anzhiyu-card-border);    --style-border-none: 1px solid transparent;    --anzhiyu-white-acrylic1: #fefeff !important;    --anzhiyu-white-acrylic2: #fcfdff !important;    --anzhiyu-black-acrylic2: #08080a !important;    --anzhiyu-black-acrylic1: #0b0b0e !important;    --anzhiyu-main-none: #b8b8b800 !important;}[data-theme="light"] {    --anzhiyu-theme-op-deep: #4259efdd;    --global-bg: #f7f9fe;    --anzhiyu-theme: #3b70fc;    --anzhiyu-theme-deep: #1856fb;    --anzhiyu-theme-op: #4259ef23;    --anzhiyu-blue: #3b70fc;    --anzhiyu-red: #d8213c;    --anzhiyu-pink: #ff7c7c;    --anzhiyu-green: #57bd6a;    --anzhiyu-fontcolor: #363636;    --anzhiyu-background: #f7f9fe;    --anzhiyu-reverse: #000;    --anzhiyu-maskbg: rgba(255, 255, 255, 0.6);    --anzhiyu-maskbgdeep: rgba(255, 255, 255, 0.85);    --anzhiyu-hovertext: var(--anzhiyu-theme);    --anzhiyu-ahoverbg: #f7f7fa;    --anzhiyu-lighttext: var(--anzhiyu-main);    --anzhiyu-secondtext: rgba(60, 60, 67, 0.6);    --anzhiyu-scrollbar: rgba(60, 60, 67, 0.4);    --anzhiyu-card-btn-bg: #edf0f7;    --anzhiyu-post-blockquote-bg: #fafcff;    --anzhiyu-post-tabs-bg: #f2f5f8;    --anzhiyu-secondbg: #f1f3f8;    --anzhiyu-shadow-nav: 0 5px 12px -5px rgba(102, 68, 68, 0.05);    --anzhiyu-card-bg: #fff;    --anzhiyu-shadow-lightblack: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-shadow-light2black: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-card-border: #e3e8f7;}[data-theme="dark"] {    --anzhiyu-theme-op-deep: #0084ffdd;    --global-bg: #18171d;    --anzhiyu-theme: #0084ff;    --anzhiyu-theme-deep: #0076e5;    --anzhiyu-theme-op: #0084ff23;    --anzhiyu-blue: #0084ff;    --anzhiyu-red: #ff3842;    --anzhiyu-pink: #ff7c7c;    --anzhiyu-green: #57bd6a;    --anzhiyu-fontcolor: #f7f7fa;    --anzhiyu-background: #18171d;    --anzhiyu-reverse: #fff;    --anzhiyu-maskbg: rgba(0, 0, 0, 0.6);    --anzhiyu-maskbgdeep: rgba(0, 0, 0, 0.85);    --anzhiyu-hovertext: #0a84ff;    --anzhiyu-ahoverbg: #fff;    --anzhiyu-lighttext: #f2b94b;    --anzhiyu-secondtext: #a1a2b8;    --anzhiyu-scrollbar: rgba(200, 200, 223, 0.4);    --anzhiyu-card-btn-bg: #30343f;    --anzhiyu-post-blockquote-bg: #000;    --anzhiyu-post-tabs-bg: #121212;    --anzhiyu-secondbg: #30343f;    --anzhiyu-shadow-nav: 0 5px 20px 0px rgba(28, 28, 28, 0.4);    --anzhiyu-card-bg: #1d1b26;    --anzhiyu-shadow-lightblack: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-shadow-light2black: 0 5px 12px -5px rgba(102, 68, 68, 0);    --anzhiyu-card-border: #42444a;}/* 音乐播放器 */.aplayer.aplayer-narrow .aplayer-body,.aplayer.aplayer-narrow .aplayer-pic {    height: 66px;    width: 66px;}#page:has(.aplayer):has(.aplayer-body):has(.aplayer-list) #post-comment .tk-comments-container>.tk-comment {    border: none;    box-shadow: none;}/* 导航栏音乐 */@media screen and (max-width: 1300px) {    #nav-music {        display: none !important;    }}#nav-music {    display: flex;    align-items: center;    z-index: 9;    position: fixed;    bottom: 20px;    left: 20px;    cursor: pointer;    transition: 0.5s;    transform-origin: left bottom;    box-shadow: var(--anzhiyu-shadow-border);    border-radius: 40px;    overflow: hidden;}#nav-music:active {    transform: scale(0.97);}#nav-music.playing {    box-shadow: 0 0px 12px -3px var(--anzhiyu-none);    animation: playingShadow 5s linear infinite;}@keyframes playingShadow {    0% {        box-shadow: 0 0px 12px -3px var(--anzhiyu-none);    }    50% {        box-shadow: 0 0px 12px 0px var(--anzhiyu-main);    }    100% {        box-shadow: 0 0px 12px -3px var(--anzhiyu-none);    }}#nav-music .aplayer.aplayer-withlrc .aplayer-pic {    height: 25px;    width: 25px;    border-radius: 40px;    z-index: 1;    transition: 0.3s;    transform: rotate(0deg) scale(1);    border: var(--style-border-always);    animation: changeright 24s linear infinite;    animation-play-state: paused;}#nav-music.playing .aplayer.aplayer-withlrc .aplayer-pic {    box-shadow: 0 0 14px #ffffffa6;    transform: rotate(0deg) scale(1.1);    border-color: var(--anzhiyu-white);    animation-play-state: running;}@keyframes changeright {    0% {        transform: rotate(0deg) scale(1.1);        box-shadow: 0 0 2px #ffffff00;    }    25% {        transform: rotate(90deg) scale(1.1);        box-shadow: 0 0 14px #ffffff;    }    50% {        transform: rotate(180deg) scale(1.1);        box-shadow: 0 0 2px #ffffff00;    }    75% {        transform: rotate(270deg) scale(1.1);        box-shadow: 0 0 14px #ffffff;    }    100% {        transform: rotate(360deg) scale(1.1);        box-shadow: 0 0 2px #ffffff00;    }}#nav-music .aplayer.aplayer-withlrc .aplayer-info {    height: 100%;    color: var(--anzhiyu-fontcolor);    margin: 0;    padding: 0;    display: flex;    align-items: center;}#nav-music.playing .aplayer.aplayer-withlrc .aplayer-info {    color: var(--anzhiyu-white);}#nav-music.playing #nav-music-hoverTips {    width: 0;    opacity: 0;}#nav-music #nav-music-hoverTips {    color: var(--anzhiyu-white);    background: var(--anzhiyu-main);    width: 100%;    height: 100%;    position: absolute;    top: 0;    left: 0;    align-items: center;    justify-content: center;    display: flex;    border-radius: 40px;    opacity: 0;    font-size: 12px;    z-index: 2;    transition: 0.3s;}#nav-music:hover:not(.playing) #nav-music-hoverTips {    opacity: 1;}#nav-music .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap:hover .aplayer-bar .aplayer-played .aplayer-thumb {    display: none;}#nav-music .aplayer {    background: var(--card-bg);    border-radius: 60px;    height: 41px;    display: flex;    margin: 0;    transition: 0.3s;    border: var(--style-border);    box-shadow: none;}#nav-music.playing .aplayer {    background: var(--anzhiyu-main-op-deep);    border: var(--style-border-hover);    backdrop-filter: saturate(180%) blur(20px);    backdrop-filter: blur(20px);}#nav-music .aplayer .aplayer-notice {    display: none;}#nav-music .aplayer .aplayer-miniswitcher {    display: none;}#nav-music .aplayer .aplayer-body {    position: relative;    display: flex;    align-items: center;}#nav-music .aplayer-list {    display: none;}#nav-music .aplayer .aplayer-info .aplayer-music {    margin: 0;    display: flex;    align-items: center;    padding: 0 12px 0 8px;    cursor: pointer;    z-index: 1;    height: 100%;}#nav-music .aplayer .aplayer-info .aplayer-controller .aplayer-time {    display: none;}#nav-music .aplayer .aplayer-info .aplayer-music .aplayer-author {    display: none;}#nav-music .aplayer.aplayer-withlist .aplayer-info {    border: none;}#nav-music .aplayer .aplayer-pic .aplayer-button {    bottom: 50%;    right: 50%;    transform: translate(50%, 50%);    margin: 0;    transition: 0.3s;}#nav-music .aplayer .aplayer-pic:has(.aplayer-button.aplayer-play) {    animation-play-state: paused;    transform: rotate(0deg) scale(1) !important;}#nav-music .aplayer.aplayer-withlrc .aplayer-pic {    margin-left: 8px;}#nav-music .aplayer .aplayer-info .aplayer-music .aplayer-title {    cursor: pointer;    line-height: 1;    display: inline-block;    white-space: nowrap;    max-width: 120px;    overflow: hidden;    text-overflow: ellipsis;    transition: 0.3s;    user-select: none;}#nav-music .aplayer .aplayer-info .aplayer-controller {    position: absolute;    width: 100%;    height: 100%;    top: 0;    left: 0;}#nav-music .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap {    margin: 0;    padding: 0;}#nav-music .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar {    height: 100%;    background: none;}#nav-music .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-loaded {    display: none;}#nav-music .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played {    height: 100%;    opacity: 0.1;    background-color: var(--anzhiyu-white) !important;    animation: lightBar 5s ease infinite;    animation-play-state: paused;}#nav-music.playing .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played {    animation-play-state: running;}@keyframes lightBar {    0% {        opacity: 0.1;    }    60% {        opacity: 0.3;    }    100% {        opacity: 0.1;    }}/* 歌词 */#nav-music .aplayer.aplayer-withlrc .aplayer-lrc {    width: 0;    opacity: 0;    transition: 0.3s;    margin-top: -2px;    padding: 5px 0;}#nav-music.stretch .aplayer.aplayer-withlrc .aplayer-lrc {    margin-left: 8px;}#nav-music.stretch .aplayer.aplayer-withlrc .aplayer-lrc {    width: 200px;    margin-bottom: 0;    opacity: 1;}#nav-music .aplayer .aplayer-lrc p.aplayer-lrc-current {    color: var(--anzhiyu-white);    border: none;}#nav-music .aplayer .aplayer-lrc:after,#nav-music .aplayer .aplayer-lrc:before {    display: none;}#nav-music .aplayer .aplayer-lrc p {    color: #ffffffb1;}#nav-music .aplayer .aplayer-pic {    pointer-events: none;}#nav-music .aplayer .aplayer-pic .aplayer-button {    pointer-events: all;}/* 自定义字体 */@font-face {    /* 为载入的字体取名字(随意) */    font-family: 'Masa';    /* 字体文件地址(相对或者绝对路径都可以) */    src: url(/source/Font/MasaFont-Regular-2.ttf);    /* 定义加粗样式(加粗多少) */    font-weight: normal;    /* 定义字体样式(斜体/非斜体) */    font-style: normal;    /* 定义显示样式 */    font-display: block;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/anzhiyuOnlyOne.js"/>
      <url>/js/anzhiyuOnlyOne.js</url>
      
        <content type="html"><![CDATA[var anzhiyu_musicPlaying = false;var anzhiyu_musicFirst = false;]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/anzhiyufunction.js"/>
      <url>/js/anzhiyufunction.js</url>
      
        <content type="html"><![CDATA[// 音乐绑定事件function musicBindEvent() {  document.querySelector("#nav-music .aplayer-music").addEventListener("click", function () {    anzhiyu.musicTelescopic();  });  document.querySelector("#nav-music .aplayer-button").addEventListener("click", function () {    anzhiyu.musicToggle(false);  });}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) {}    return "";};class Cursor {    constructor() {        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='1.0' fill='rgb(236, 49, 139)'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove("hidden");};        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown  = e => this.cursor.classList.add("active");        document.onmouseup    = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cat.js"/>
      <url>/js/cat.js</url>
      
        <content type="html"><![CDATA[if (document.body.clientWidth > 992) {    function getBasicInfo() {        /* 窗口高度 */        var ViewH = $(window).height();        /* document高度 */        var DocH = $("body")[0].scrollHeight;        /* 滚动的高度 */        var ScrollTop = $(window).scrollTop();        /* 可滚动的高度 */        var S_V = DocH - ViewH;        var Band_H = ScrollTop / (DocH - ViewH) * 100;        return {            ViewH: ViewH,            DocH: DocH,            ScrollTop: ScrollTop,            Band_H: Band_H,            S_V: S_V        }    };    function show(basicInfo) {        if (basicInfo.ScrollTop > 0.001) {            $(".neko").css('display', 'block');        } else {            $(".neko").css('display', 'none');        }    }    (function ($) {        $.fn.nekoScroll = function (option) {            var defaultSetting = {                top: '0',                scroWidth: 6 + 'px',                z_index: 9999,                zoom: 0.9,                borderRadius: 5 + 'px',                right: 60 + 'px',                // 这里可以换为你喜欢的图片，例如我就换为了雪人，但是要抠图                nekoImg: "https://s2.loli.net/2024/08/20/n1JarOiLfmy9xC3.gif",                hoverMsg: "精神状态belike",                color: "#6f42c1",                during: 500,                blog_body: "body",            };            var setting = $.extend(defaultSetting, option);            var getThis = this.prop("className") !== "" ? "." + this.prop("className") : this.prop("id") !== "" ? "#" +                this.prop("id") : this.prop("nodeName");            if ($(".neko").length == 0) {                this.after("<div class=\"neko\" id=" + setting.nekoname + " data-msg=\"" + setting.hoverMsg + "\"></div>");            }            let basicInfo = getBasicInfo();            $(getThis)                .css({                    'position': 'fixed',                    'width': setting.scroWidth,                    'top': setting.top,                    'height': basicInfo.Band_H * setting.zoom * basicInfo.ViewH * 0.01 + 'px',                    'z-index': setting.z_index,                    'background-color': setting.bgcolor,                    "border-radius": setting.borderRadius,                    'right': setting.right,                    'background-image': 'url(' + setting.scImg + ')',                    'background-image': '-webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent)', 'border-radius': '2em',                    'background-size': 'contain'                });            $("#" + setting.nekoname)                .css({                    'position': 'fixed',                    'top': basicInfo.Band_H * setting.zoom * basicInfo.ViewH * 0.01 - 50 + 'px',                    'z-index': setting.z_index * 10,                    'right': setting.right,                    'background-image': 'url(' + setting.nekoImg + ')',                });            show(getBasicInfo());            $(window)                .scroll(function () {                    let basicInfo = getBasicInfo();                    show(basicInfo);                    $(getThis)                        .css({                            'position': 'fixed',                            'width': setting.scroWidth,                            'top': setting.top,                            'height': basicInfo.Band_H * setting.zoom * basicInfo.ViewH * 0.01 + 'px',                            'z-index': setting.z_index,                            'background-color': setting.bgcolor,                            "border-radius": setting.borderRadius,                            'right': setting.right,                            'background-image': 'url(' + setting.scImg + ')',                            'background-image': '-webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent)', 'border-radius': '2em',                            'background-size': 'contain'                        });                    $("#" + setting.nekoname)                        .css({                            'position': 'fixed',                            'top': basicInfo.Band_H * setting.zoom * basicInfo.ViewH * 0.01 - 50 + 'px',                            'z-index': setting.z_index * 10,                            'right': setting.right,                            'background-image': 'url(' + setting.nekoImg + ')',                        });                    if (basicInfo.ScrollTop == basicInfo.S_V) {                        $("#" + setting.nekoname)                            .addClass("showMsg")                    } else {                        $("#" + setting.nekoname)                            .removeClass("showMsg");                        $("#" + setting.nekoname)                            .attr("data-msg", setting.hoverMsg);                    }                });            this.click(function (e) {                btf.scrollToDest(0, 500)            });            $("#" + setting.nekoname)                .click(function () {                    btf.scrollToDest(0, 500)                });            return this;        }    })(jQuery);    $(document).ready(function () {        //部分自定义        $("#myscoll").nekoScroll({            bgcolor: 'rgb(0 0 0 / .5)', //背景颜色，没有绳子背景图片时有效            borderRadius: '2em',            zoom: 0.9        }        );        //自定义（去掉以下注释，并注释掉其他的查看效果）        /*        $("#myscoll").nekoScroll({            nekoname:'neko1', //nekoname，相当于id            nekoImg:'img/猫咪.png', //neko的背景图片            scImg:"img/绳1.png", //绳子的背景图片            bgcolor:'#1e90ff', //背景颜色，没有绳子背景图片时有效            zoom:0.9, //绳子长度的缩放值            hoverMsg:'你好~喵', //鼠标浮动到neko上方的对话框信息            right:'100px', //距离页面右边的距离            fontFamily:'楷体', //对话框字体            fontSize:'14px', //对话框字体的大小            color:'#1e90ff', //对话框字体颜色            scroWidth:'8px', //绳子的宽度            z_index:100, //不用解释了吧            during:1200, //从顶部到底部滑动的时长        });        */    })}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/day.js"/>
      <url>/js/day.js</url>
      
        <content type="html"><![CDATA[var d = new Date();m = d.getMonth() + 1;dd = d.getDate();y = d.getFullYear();// 公祭日if (m == 9 && dd == 18) {    document.getElementsByTagName("html")[0].setAttribute("style", "filter: grayscale(60%);");    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("今天是九一八事变" + (y - 1931).toString() + "周年纪念日\n🪔勿忘国耻，振兴中华🪔");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 7 && dd == 7) {    document.getElementsByTagName("html")[0].setAttribute("style", "filter: grayscale(60%);");    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("今天是卢沟桥事变" + (y - 1937).toString() + "周年纪念日\n🪔勿忘国耻，振兴中华🪔");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 12 && dd == 13) {    document.getElementsByTagName("html")[0].setAttribute("style", "filter: grayscale(60%);");    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("今天是南京大屠杀" + (y - 1937).toString() + "周年纪念日\n🪔勿忘国耻，振兴中华🪔");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 8 && dd == 14) {    document.getElementsByTagName("html")[0].setAttribute("style", "filter: grayscale(60%);");    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("今天是世界慰安妇纪念日\n🪔勿忘国耻，振兴中华🪔");        sessionStorage.setItem("isPopupWindow", "1");    }}// 节假日if (m == 10 && dd <= 3) {//国庆节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("祝祖国" + (y - 1949).toString() + "岁生日快乐！");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 8 && dd == 15) {//搞来玩的，小日子投降    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("小日子已经投降" + (y - 1945).toString() + "年了😃");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 1 && dd == 1) {//元旦节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire(y.toString() + "年元旦快乐！🎉");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 3 && dd == 8) {//妇女节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("各位女神们，妇女节快乐！👩");        sessionStorage.setItem("isPopupWindow", "1");    }}l = ["非常抱歉，因为不可控原因，博客将于明天停止运营！", "好消息，日本没了！", "美国垮了，原因竟然是川普！", "微软垮了！", "你的电脑已经过载，建议立即关机！", "你知道吗？站长很喜欢你哦！", "一分钟有61秒哦", "你喜欢的人跟别人跑了！"]if (m == 4 && dd == 1) {//愚人节，随机谎话    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire(l[Math.floor(Math.random() * l.length)]);        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 5 && dd == 1) {//劳动节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("劳动节快乐\n为各行各业辛勤工作的人们致敬！");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 5 && dd == 4) {//青年节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("青年节快乐\n青春不是回忆逝去,而是把握现在！");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 5 && dd == 20) {//520    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("今年是520情人节\n快和你喜欢的人一起过吧！💑");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 7 && dd == 1) {//建党节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("祝中国共产党" + (y - 1921).toString() + "岁生日快乐！");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 9 && dd == 10) {//教师节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("各位老师们教师节快乐！👩‍🏫");        sessionStorage.setItem("isPopupWindow", "1");    }}if (m == 12 && dd == 25) {//圣诞节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("圣诞节快乐！🎄");        sessionStorage.setItem("isPopupWindow", "1");    }}//传统节日部分if ((y == 2023 && m == 4 && dd == 5) || (y == 2024 && m == 4 && dd == 4) || (y == 2025 && m == 4 && dd == 4)) {//清明节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("清明时节雨纷纷,一束鲜花祭故人💐");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((y == 2023 && m == 12 && dd == 22) || (y == 2024 && m == 12 && dd == 21) || (y == 2025 && m == 12 && dd == 21)) {//冬至    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("冬至快乐\n快吃上一碗热热的汤圆和饺子吧🧆");        sessionStorage.setItem("isPopupWindow", "1");    }}var lunar = calendarFormatter.solar2lunar();//农历采用汉字计算，防止出现闰月导致问题if ((lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初六") || (lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初五") || (lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初四") || (lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初三") || (lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初二") || (lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "初一") || (lunar["IMonthCn"] == "腊月" && lunar["IDayCn"] == "三十") || (lunar["IMonthCn"] == "腊月" && lunar["IDayCn"] == "廿九")) {    //春节，本来只有大年三十到初六，但是有时候除夕是大年二十九，所以也加上了    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire(y.toString() + "年新年快乐\n🎊祝你心想事成，诸事顺利🎊");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((lunar["IMonthCn"] == "正月" && lunar["IDayCn"] == "十五")) {    //元宵节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("元宵节快乐\n送你一个大大的灯笼🧅");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((lunar["IMonthCn"] == "五月" && lunar["IDayCn"] == "初五")) {    //端午节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("端午节快乐\n请你吃一条粽子🍙");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((lunar["IMonthCn"] == "七月" && lunar["IDayCn"] == "初七")) {    //七夕节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("七夕节快乐\n黄昏后,柳梢头,牛郎织女来碰头");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((lunar["IMonthCn"] == "八月" && lunar["IDayCn"] == "十五")) {    //中秋节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("中秋节快乐\n请你吃一块月饼🍪");        sessionStorage.setItem("isPopupWindow", "1");    }}if ((lunar["IMonthCn"] == "九月" && lunar["IDayCn"] == "初九")) {    //重阳节    if (sessionStorage.getItem("isPopupWindow") != "1") {        Swal.fire("重阳节快乐\n独在异乡为异客，每逢佳节倍思亲");        sessionStorage.setItem("isPopupWindow", "1");    }}// 切换主题提醒// if (y == 2022 && m == 12 && (dd >= 18 && dd <= 20)) {//     if (sessionStorage.getItem("isPopupWindow") != "1") {//         Swal.fire("网站换成冬日限定主题啦⛄");//         sessionStorage.setItem("isPopupWindow", "1");//     }// }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/lunar.js"/>
      <url>/js/lunar.js</url>
      
        <content type="html"><![CDATA[var lunarInfo=[19416,19168,42352,21717,53856,55632,91476,22176,39632,21970,19168,42422,42192,53840,119381,46400,54944,44450,38320,84343,18800,42160,46261,27216,27968,109396,11104,38256,21234,18800,25958,54432,59984,28309,23248,11104,100067,37600,116951,51536,54432,120998,46416,22176,107956,9680,37584,53938,43344,46423,27808,46416,86869,19872,42416,83315,21168,43432,59728,27296,44710,43856,19296,43748,42352,21088,62051,55632,23383,22176,38608,19925,19152,42192,54484,53840,54616,46400,46752,103846,38320,18864,43380,42160,45690,27216,27968,44870,43872,38256,19189,18800,25776,29859,59984,27480,23232,43872,38613,37600,51552,55636,54432,55888,30034,22176,43959,9680,37584,51893,43344,46240,47780,44368,21977,19360,42416,86390,21168,43312,31060,27296,44368,23378,19296,42726,42208,53856,60005,54576,23200,30371,38608,19195,19152,42192,118966,53840,54560,56645,46496,22224,21938,18864,42359,42160,43600,111189,27936,44448,84835,37744,18936,18800,25776,92326,59984,27424,108228,43744,41696,53987,51552,54615,54432,55888,23893,22176,42704,21972,21200,43448,43344,46240,46758,44368,21920,43940,42416,21168,45683,26928,29495,27296,44368,84821,19296,42352,21732,53600,59752,54560,55968,92838,22224,19168,43476,41680,53584,62034,54560],solarMonth=[31,28,31,30,31,30,31,31,30,31,30,31],Gan=["甲","乙","丙","丁","戊","己","庚","辛","壬","癸"],Zhi=["子","丑","寅","卯","辰","巳","午","未","申","酉","戌","亥"],Animals=["鼠","牛","虎","兔","龙","蛇","马","羊","猴","鸡","狗","猪"],solarTerm=["小寒","大寒","立春","雨水","惊蛰","春分","清明","谷雨","立夏","小满","芒种","夏至","小暑","大暑","立秋","处暑","白露","秋分","寒露","霜降","立冬","小雪","大雪","冬至"],sTermInfo=["9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf97c3598082c95f8c965cc920f","97bd0b06bdb0722c965ce1cfcc920f","b027097bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf97c359801ec95f8c965cc920f","97bd0b06bdb0722c965ce1cfcc920f","b027097bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf97c359801ec95f8c965cc920f","97bd0b06bdb0722c965ce1cfcc920f","b027097bd097c36b0b6fc9274c91aa","9778397bd19801ec9210c965cc920e","97b6b97bd19801ec95f8c965cc920f","97bd09801d98082c95f8e1cfcc920f","97bd097bd097c36b0b6fc9210c8dc2","9778397bd197c36c9210c9274c91aa","97b6b97bd19801ec95f8c965cc920e","97bd09801d98082c95f8e1cfcc920f","97bd097bd097c36b0b6fc9210c8dc2","9778397bd097c36c9210c9274c91aa","97b6b97bd19801ec95f8c965cc920e","97bcf97c3598082c95f8e1cfcc920f","97bd097bd097c36b0b6fc9210c8dc2","9778397bd097c36c9210c9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf97c3598082c95f8c965cc920f","97bd097bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf97c3598082c95f8c965cc920f","97bd097bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf97c359801ec95f8c965cc920f","97bd097bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf97c359801ec95f8c965cc920f","97bd097bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf97c359801ec95f8c965cc920f","97bd097bd07f595b0b6fc920fb0722","9778397bd097c36b0b6fc9210c8dc2","9778397bd19801ec9210c9274c920e","97b6b97bd19801ec95f8c965cc920f","97bd07f5307f595b0b0bc920fb0722","7f0e397bd097c36b0b6fc9210c8dc2","9778397bd097c36c9210c9274c920e","97b6b97bd19801ec95f8c965cc920f","97bd07f5307f595b0b0bc920fb0722","7f0e397bd097c36b0b6fc9210c8dc2","9778397bd097c36c9210c9274c91aa","97b6b97bd19801ec9210c965cc920e","97bd07f1487f595b0b0bc920fb0722","7f0e397bd097c36b0b6fc9210c8dc2","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf7f1487f595b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf7f1487f595b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf7f1487f531b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c965cc920e","97bcf7f1487f531b0b0bb0b6fb0722","7f0e397bd07f595b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b97bd19801ec9210c9274c920e","97bcf7f0e47f531b0b0bb0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","9778397bd097c36b0b6fc9210c91aa","97b6b97bd197c36c9210c9274c920e","97bcf7f0e47f531b0b0bb0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","9778397bd097c36b0b6fc9210c8dc2","9778397bd097c36c9210c9274c920e","97b6b7f0e47f531b0723b0b6fb0722","7f0e37f5307f595b0b0bc920fb0722","7f0e397bd097c36b0b6fc9210c8dc2","9778397bd097c36b0b70c9274c91aa","97b6b7f0e47f531b0723b0b6fb0721","7f0e37f1487f595b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc9210c8dc2","9778397bd097c36b0b6fc9274c91aa","97b6b7f0e47f531b0723b0b6fb0721","7f0e27f1487f595b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","9778397bd097c36b0b6fc9274c91aa","97b6b7f0e47f531b0723b0787b0721","7f0e27f0e47f531b0b0bb0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","9778397bd097c36b0b6fc9210c91aa","97b6b7f0e47f149b0723b0787b0721","7f0e27f0e47f531b0723b0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","9778397bd097c36b0b6fc9210c8dc2","977837f0e37f149b0723b0787b0721","7f07e7f0e47f531b0723b0b6fb0722","7f0e37f5307f595b0b0bc920fb0722","7f0e397bd097c35b0b6fc9210c8dc2","977837f0e37f14998082b0787b0721","7f07e7f0e47f531b0723b0b6fb0721","7f0e37f1487f595b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc9210c8dc2","977837f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc920fb0722","977837f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e397bd097c35b0b6fc920fb0722","977837f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","977837f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","977837f0e37f14998082b0787b06bd","7f07e7f0e47f149b0723b0787b0721","7f0e27f0e47f531b0b0bb0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","977837f0e37f14998082b0723b06bd","7f07e7f0e37f149b0723b0787b0721","7f0e27f0e47f531b0723b0b6fb0722","7f0e397bd07f595b0b0bc920fb0722","977837f0e37f14898082b0723b02d5","7ec967f0e37f14998082b0787b0721","7f07e7f0e47f531b0723b0b6fb0722","7f0e37f1487f595b0b0bb0b6fb0722","7f0e37f0e37f14898082b0723b02d5","7ec967f0e37f14998082b0787b0721","7f07e7f0e47f531b0723b0b6fb0722","7f0e37f1487f531b0b0bb0b6fb0722","7f0e37f0e37f14898082b0723b02d5","7ec967f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e37f1487f531b0b0bb0b6fb0722","7f0e37f0e37f14898082b072297c35","7ec967f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e37f0e37f14898082b072297c35","7ec967f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e37f0e366aa89801eb072297c35","7ec967f0e37f14998082b0787b06bd","7f07e7f0e47f149b0723b0787b0721","7f0e27f1487f531b0b0bb0b6fb0722","7f0e37f0e366aa89801eb072297c35","7ec967f0e37f14998082b0723b06bd","7f07e7f0e47f149b0723b0787b0721","7f0e27f0e47f531b0723b0b6fb0722","7f0e37f0e366aa89801eb072297c35","7ec967f0e37f14998082b0723b06bd","7f07e7f0e37f14998083b0787b0721","7f0e27f0e47f531b0723b0b6fb0722","7f0e37f0e366aa89801eb072297c35","7ec967f0e37f14898082b0723b02d5","7f07e7f0e37f14998082b0787b0721","7f07e7f0e47f531b0723b0b6fb0722","7f0e36665b66aa89801e9808297c35","665f67f0e37f14898082b0723b02d5","7ec967f0e37f14998082b0787b0721","7f07e7f0e47f531b0723b0b6fb0722","7f0e36665b66a449801e9808297c35","665f67f0e37f14898082b0723b02d5","7ec967f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e36665b66a449801e9808297c35","665f67f0e37f14898082b072297c35","7ec967f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e26665b66a449801e9808297c35","665f67f0e37f1489801eb072297c35","7ec967f0e37f14998082b0787b06bd","7f07e7f0e47f531b0723b0b6fb0721","7f0e27f1487f531b0b0bb0b6fb0722"],nStr1=["日","一","二","三","四","五","六","七","八","九","十"],nStr2=["初","十","廿","卅"],nStr3=["正","二","三","四","五","六","七","八","九","十","冬","腊"];function lYearDays(b){var f,c=348;for(f=32768;f>8;f>>=1)c+=lunarInfo[b-1900]&f?1:0;return c+leapDays(b)}function leapMonth(b){return 15&lunarInfo[b-1900]}function leapDays(b){return leapMonth(b)?65536&lunarInfo[b-1900]?30:29:0}function monthDays(b,f){return f>12||f<1?-1:lunarInfo[b-1900]&65536>>f?30:29}function solarDays(b,f){if(f>12||f<1)return-1;var c=f-1;return 1===c?b%4==0&&b%100!=0||b%400==0?29:28:solarMonth[c]}function toGanZhiYear(b){var f=(b-3)%10,c=(b-3)%12;return 0===f&&(f=10),0===c&&(c=12),Gan[f-1]+Zhi[c-1]}function toAstro(b,f){return"魔羯水瓶双鱼白羊金牛双子巨蟹狮子处女天秤天蝎射手魔羯".substr(2*b-(f<[20,19,21,21,21,22,23,23,23,23,22,22][b-1]?2:0),2)+"座"}function toGanZhi(b){return Gan[b%10]+Zhi[b%12]}function getTerm(b,f){if(b<1900||b>2100)return-1;if(f<1||f>24)return-1;var c=sTermInfo[b-1900],e=[parseInt("0x"+c.substr(0,5)).toString(),parseInt("0x"+c.substr(5,5)).toString(),parseInt("0x"+c.substr(10,5)).toString(),parseInt("0x"+c.substr(15,5)).toString(),parseInt("0x"+c.substr(20,5)).toString(),parseInt("0x"+c.substr(25,5)).toString()],a=[e[0].substr(0,1),e[0].substr(1,2),e[0].substr(3,1),e[0].substr(4,2),e[1].substr(0,1),e[1].substr(1,2),e[1].substr(3,1),e[1].substr(4,2),e[2].substr(0,1),e[2].substr(1,2),e[2].substr(3,1),e[2].substr(4,2),e[3].substr(0,1),e[3].substr(1,2),e[3].substr(3,1),e[3].substr(4,2),e[4].substr(0,1),e[4].substr(1,2),e[4].substr(3,1),e[4].substr(4,2),e[5].substr(0,1),e[5].substr(1,2),e[5].substr(3,1),e[5].substr(4,2)];return parseInt(a[f-1])}function toChinaMonth(b){if(b>12||b<1)return-1;var f=nStr3[b-1];return f+="月"}function toChinaDay(b){var f;switch(b){case 10:f="初十";break;case 20:f="二十";break;case 30:f="三十";break;default:f=nStr2[Math.floor(b/10)],f+=nStr1[b%10]}return f}function getAnimal(b){return Animals[(b-4)%12]}function solar2lunar(b,f,c){if(b<1900||b>2100)return-1;if(1900===b&&1===f&&c<31)return-1;var e,a,r=null,t=0;b=(r=b?new Date(b,parseInt(f)-1,c):new Date).getFullYear(),f=r.getMonth()+1,c=r.getDate();var d=(Date.UTC(r.getFullYear(),r.getMonth(),r.getDate())-Date.UTC(1900,0,31))/864e5;for(e=1900;e<2101&&d>0;e++)d-=t=lYearDays(e);d<0&&(d+=t,e--);var n=new Date,s=!1;n.getFullYear()===b&&n.getMonth()+1===f&&n.getDate()===c&&(s=!0);var u=r.getDay(),o=nStr1[u];0===u&&(u=7);var l=e;a=leapMonth(e);var i=!1;for(e=1;e<13&&d>0;e++)a>0&&e===a+1&&!1===i?(--e,i=!0,t=leapDays(l)):t=monthDays(l,e),!0===i&&e===a+1&&(i=!1),d-=t;0===d&&a>0&&e===a+1&&(i?i=!1:(i=!0,--e)),d<0&&(d+=t,--e);var h=e,D=d+1,g=f-1,v=toGanZhiYear(l),y=getTerm(b,2*f-1),m=getTerm(b,2*f),p=toGanZhi(12*(b-1900)+f+11);c>=y&&(p=toGanZhi(12*(b-1900)+f+12));var M=!1,T=null;y===c&&(M=!0,T=solarTerm[2*f-2]),m===c&&(M=!0,T=solarTerm[2*f-1]);var I=toGanZhi(Date.UTC(b,g,1,0,0,0,0)/864e5+25567+10+c-1),C=toAstro(f,c);return{lYear:l,lMonth:h,lDay:D,Animal:getAnimal(l),IMonthCn:(i?"闰":"")+toChinaMonth(h),IDayCn:toChinaDay(D),cYear:b,cMonth:f,cDay:c,gzYear:v,gzMonth:p,gzDay:I,isToday:s,isLeap:i,nWeek:u,ncWeek:"星期"+o,isTerm:M,Term:T,astro:C}}var calendarFormatter={solar2lunar:function(b,f,c){return solar2lunar(b,f,c)},lunar2solar:function(b,f,c,e){if((e=!!e)&&leapMonth!==f)return-1;if(2100===b&&12===f&&c>1||1900===b&&1===f&&c<31)return-1;var a=monthDays(b,f),r=a;if(e&&(r=leapDays(b,f)),b<1900||b>2100||c>r)return-1;for(var t=0,d=1900;d<b;d++)t+=lYearDays(d);var n=0,s=!1;for(d=1;d<f;d++)n=leapMonth(b),s||n<=d&&n>0&&(t+=leapDays(b),s=!0),t+=monthDays(b,d);e&&(t+=a);var u=Date.UTC(1900,1,30,0,0,0),o=new Date(864e5*(t+c-31)+u);return solar2lunar(o.getUTCFullYear(),o.getUTCMonth()+1,o.getUTCDate())}};]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/title.js"/>
      <url>/js/title.js</url>
      
        <content type="html"><![CDATA[//动态标题var OriginTitile = document.title;var titleTime;document.addEventListener("visibilitychange", function () {  if (document.hidden) {    //离开当前页面时标签显示内容    document.title = "w(ﾟДﾟ)w 干嘛去啦！";    clearTimeout(titleTime);  } else {    //返回当前页面时标签显示内容    document.title = "♪(^∇^*)欢迎回来！" + OriginTitile;    //两秒后变回正常标题    titleTime = setTimeout(function () {      document.title = OriginTitile;    }, 2000);  }});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>随笔 · 说说</title>
      <link href="/shuoshuo/index.html"/>
      <url>/shuoshuo/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/coin/coin.css"/>
      <url>/css/coin/coin.css</url>
      
        <content type="html"><![CDATA[.tip-button {    border: 0;    border-radius: 0.25rem;    cursor: pointer;    font-size: 20px;    font-weight: 600;    height: 2.6rem;    margin-bottom: -4rem;    outline: 0;    position: relative;    top: 0;    transform-origin: 0% 100%;    transition: transform 50ms ease-in-out;    width: auto;    -webkit-tap-highlight-color: transparent;}.tip-button:active {    transform: rotate(4deg);}.tip-button.clicked {    animation: 150ms ease-in-out 1 shake;    pointer-events: none;}.tip-button.clicked .tip-button__text {    opacity: 0;    transition: opacity 100ms linear 200ms;}.tip-button.clicked::before {    height: 0.5rem;    width: 60%;    background: button-hover-color;}.tip-button.clicked .coin {    transition: margin-bottom 1s linear 200ms;    margin-bottom: 0;}.tip-button.shrink-landing::before {    transition: width 200ms ease-in;    width: 0;}.tip-button.coin-landed::after {    opacity: 1;    transform: scale(1);    transform-origin: 50% 100%;}.tip-button.coin-landed .coin-wrapper {    background: radial-gradient(circle at 35% 97%, rgba(3, 16, 50, 0.4) 0.04rem, transparent 0.04rem), radial-gradient(circle at 45% 92%,            rgba(3, 16, 50, 0.4) 0.04rem,            transparent 0.02rem), radial-gradient(circle at 55% 98%, rgba(3, 16, 50, 0.4) 0.04rem, transparent 0.04rem), radial-gradient(circle at 65% 96%, rgba(3, 16, 50, 0.4) 0.06rem, transparent 0.06rem);    background-position: center bottom;    background-size: 100%;    bottom: -1rem;    opacity: 0;    transform: scale(2) translateY(-10px);}.tip-button__text {    color: #fff;    margin-right: 1.8rem;    opacity: 1;    position: relative;    transition: opacity 100ms linear 500ms;    z-index: 3;}.tip-button::before {    border-radius: 0.25rem;    bottom: 0;    content: "";    display: block;    height: 100%;    left: 50%;    position: absolute;    transform: translateX(-50%);    transition: height 250ms ease-in-out 400ms, width 250ms ease-in-out 300ms;    width: 100%;    z-index: 2;}.tip-button::after {    bottom: -1rem;    color: white;    content: "ヾ(≧O≦)〃嗷~";    /*点击后显示的内容*/    height: 110%;    left: 0;    opacity: 0;    position: absolute;    pointer-events: none;    text-align: center;    transform: scale(0);    transform-origin: 50% 20%;    transition: transform 200ms cubic-bezier(0, 0, 0.35, 1.43);    width: 100%;    z-index: 1;}.coin-wrapper {    background: none;    bottom: 0;    height: 18rem;    left: 0;    opacity: 1;    overflow: hidden;    pointer-events: none;    position: absolute;    transform: none;    transform-origin: 50% 100%;    transition: opacity 200ms linear 100ms, transform 300ms ease-out;    width: 100%;}.coin {    --front-y-multiplier: 0;    --back-y-multiplier: 0;    --coin-y-multiplier: 0;    --coin-x-multiplier: 0;    --coin-scale-multiplier: 0;    --coin-rotation-multiplier: 0;    --shine-opacity-multiplier: 0.4;    --shine-bg-multiplier: 50%;    bottom: calc(var(--coin-y-multiplier) * 1rem - 3.5rem);    height: 3.5rem;    margin-bottom: 3.05rem;    position: absolute;    right: calc(var(--coin-x-multiplier) * 34% + 16%);    transform: translateX(50%) scale(calc(0.4 + var(--coin-scale-multiplier))) rotate(calc(var(--coin-rotation-multiplier) * -1deg));    transition: opacity 100ms linear 200ms;    width: 3.5rem;    z-index: 3;}.coin__front,.coin__middle,.coin__back,.coin::before,.coin__front::after,.coin__back::after {    border-radius: 50%;    box-sizing: border-box;    height: 100%;    left: 0;    position: absolute;    width: 100%;    z-index: 3;}.coin__front {    background: radial-gradient(circle at 50% 50%, transparent 50%, rgba(115, 124, 153, 0.4) 54%, #c2cadf 54%),        linear-gradient(210deg, #8590b3 32%, transparent 32%), linear-gradient(150deg, #8590b3 32%, transparent 32%),        linear-gradient(to right, #8590b3 22%, transparent 22%, transparent 78%, #8590b3 78%), linear-gradient(to bottom,            #fcfaf9 44%,            transparent 44%,            transparent 65%,            #fcfaf9 65%,            #fcfaf9 71%,            #8590b3 71%), linear-gradient(to right, transparent 28%, #fcfaf9 28%, #fcfaf9 34%, #8590b3 34%, #8590b3 40%, #fcfaf9 40%, #fcfaf9 47%, #8590b3 47%, #8590b3 53%, #fcfaf9 53%, #fcfaf9 60%, #8590b3 60%, #8590b3 66%, #fcfaf9 66%, #fcfaf9 72%, transparent 72%);    background-color: #8590b3;    background-size: 100% 100%;    transform: translateY(calc(var(--front-y-multiplier) * 0.3181818182rem / 2)) scaleY(var(--front-scale-multiplier));}.coin__front::after {    background: rgba(0, 0, 0, 0.2);    content: "";    opacity: var(--front-y-multiplier);}.coin__middle {    background: #737c99;    transform: translateY(calc(var(--middle-y-multiplier) * 0.3181818182rem / 2)) scaleY(var(--middle-scale-multiplier));}.coin__back {    background: radial-gradient(circle at 50% 50%, transparent 50%, rgba(115, 124, 153, 0.4) 54%, #c2cadf 54%),        radial-gradient(circle at 50% 40%, #fcfaf9 23%, transparent 23%), radial-gradient(circle at 50% 100%, #fcfaf9 35%, transparent 35%);    background-color: #8590b3;    background-size: 100% 100%;    transform: translateY(calc(var(--back-y-multiplier) * 0.3181818182rem / 2)) scaleY(var(--back-scale-multiplier));}.coin__back::after {    background: rgba(0, 0, 0, 0.2);    content: "";    opacity: var(--back-y-multiplier);}.coin::before {    background: radial-gradient(circle at 25% 65%, transparent 50%, rgba(255, 255, 255, 0.9) 90%), linear-gradient(55deg, transparent calc(var(--shine-bg-multiplier) + 0%), #e9f4ff calc(var(--shine-bg-multiplier) + 0%), transparent calc(var(--shine-bg-multiplier) + 50%));    content: "";    opacity: var(--shine-opacity-multiplier);    transform: translateY(calc(var(--middle-y-multiplier) * 0.3181818182rem / -2)) scaleY(var(--middle-scale-multiplier)) rotate(calc(var(--coin-rotation-multiplier) * 1deg));    z-index: 10;}.coin::after {    background: #737c99;    content: "";    height: 0.3181818182rem;    left: 0;    position: absolute;    top: 50%;    transform: translateY(-50%);    width: 100%;    z-index: 2;}@keyframes shake {    0% {        transform: rotate(4deg);    }    66% {        transform: rotate(-4deg);    }    100% {        transform: rotate();    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/coin/coin.js"/>
      <url>/js/coin/coin.js</url>
      
        <content type="html"><![CDATA[var tipButtons = document.querySelectorAll(".tip-button");function coinAudio() {  var coinAudio = document.getElementById("coinAudio");  if (coinAudio) {    coinAudio.play(); //有音频时播放  }}// Loop through all buttons (allows for multiple buttons on page)tipButtons.forEach(button => {  var coin = button.querySelector(".coin");  // The larger the number, the slower the animation  coin.maxMoveLoopCount = 90;  button.addEventListener("click", () => {    if (/Android|webOS|BlackBerry/i.test(navigator.userAgent)) return true; //媒体选择    if (button.clicked) return;    button.classList.add("clicked");    // Wait to start flipping th coin because of the button tilt animation    setTimeout(() => {      // Randomize the flipping speeds just for fun      coin.sideRotationCount = Math.floor(Math.random() * 5) * 90;      coin.maxFlipAngle = (Math.floor(Math.random() * 4) + 3) * Math.PI;      button.clicked = true;      flipCoin();      coinAudio();    }, 50);  });  var flipCoin = () => {    coin.moveLoopCount = 0;    flipCoinLoop();  };  var resetCoin = () => {    coin.style.setProperty("--coin-x-multiplier", 0);    coin.style.setProperty("--coin-scale-multiplier", 0);    coin.style.setProperty("--coin-rotation-multiplier", 0);    coin.style.setProperty("--shine-opacity-multiplier", 0.4);    coin.style.setProperty("--shine-bg-multiplier", "50%");    coin.style.setProperty("opacity", 1);    // Delay to give the reset animation some time before you can click again    setTimeout(() => {      button.clicked = false;    }, 300);  };  var flipCoinLoop = () => {    coin.moveLoopCount++;    var percentageCompleted = coin.moveLoopCount / coin.maxMoveLoopCount;    coin.angle = -coin.maxFlipAngle * Math.pow(percentageCompleted - 1, 2) + coin.maxFlipAngle;    // Calculate the scale and position of the coin moving through the air    coin.style.setProperty("--coin-y-multiplier", -11 * Math.pow(percentageCompleted * 2 - 1, 4) + 11);    coin.style.setProperty("--coin-x-multiplier", percentageCompleted);    coin.style.setProperty("--coin-scale-multiplier", percentageCompleted * 0.6);    coin.style.setProperty("--coin-rotation-multiplier", percentageCompleted * coin.sideRotationCount);    // Calculate the scale and position values for the different coin faces    // The math uses sin/cos wave functions to similate the circular motion of 3D spin    coin.style.setProperty("--front-scale-multiplier", Math.max(Math.cos(coin.angle), 0));    coin.style.setProperty("--front-y-multiplier", Math.sin(coin.angle));    coin.style.setProperty("--middle-scale-multiplier", Math.abs(Math.cos(coin.angle), 0));    coin.style.setProperty("--middle-y-multiplier", Math.cos((coin.angle + Math.PI / 2) % Math.PI));    coin.style.setProperty("--back-scale-multiplier", Math.max(Math.cos(coin.angle - Math.PI), 0));    coin.style.setProperty("--back-y-multiplier", Math.sin(coin.angle - Math.PI));    coin.style.setProperty("--shine-opacity-multiplier", 4 * Math.sin((coin.angle + Math.PI / 2) % Math.PI) - 3.2);    coin.style.setProperty("--shine-bg-multiplier", -40 * (Math.cos((coin.angle + Math.PI / 2) % Math.PI) - 0.5) + "%");    // Repeat animation loop    if (coin.moveLoopCount < coin.maxMoveLoopCount) {      if (coin.moveLoopCount === coin.maxMoveLoopCount - 6) button.classList.add("shrink-landing");      window.requestAnimationFrame(flipCoinLoop);    } else {      button.classList.add("coin-landed");      coin.style.setProperty("opacity", 0);      setTimeout(() => {        button.classList.remove("clicked", "shrink-landing", "coin-landed");        setTimeout(() => {          resetCoin();        }, 300);      }, 1500);    }  };});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Links</title>
      <link href="/menus/flink/index.html"/>
      <url>/menus/flink/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/menus/music/index.html"/>
      <url>/menus/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>万年历</title>
      <link href="/pages/WanNianLi/index.html"/>
      <url>/pages/WanNianLi/index.html</url>
      
        <content type="html"><![CDATA[<a class="btn-beautify outline green larger" href="/posts/961490cd.html#%E4%B8%87%E5%B9%B4%E5%8E%86" title="返回"><i class="far fa-hand-point-right"></i><span>返回</span></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 万年历</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *MONTH_NAMES[<span class="number">12</span>] = &#123;<span class="string">&quot;                     January&quot;</span>, <span class="string">&quot;                    February&quot;</span>, <span class="string">&quot;                       March&quot;</span>,</span><br><span class="line">                               <span class="string">&quot;                       April&quot;</span>, <span class="string">&quot;                         May&quot;</span>, <span class="string">&quot;                        June&quot;</span>,</span><br><span class="line">                               <span class="string">&quot;                        July&quot;</span>, <span class="string">&quot;                      August&quot;</span>, <span class="string">&quot;                   September&quot;</span>,</span><br><span class="line">                               <span class="string">&quot;                     October&quot;</span>, <span class="string">&quot;                    November&quot;</span>, <span class="string">&quot;                    December&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLeap</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Wweek</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (month &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        month += <span class="number">12</span>;</span><br><span class="line">        year--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> h = (day + <span class="number">2</span> * month + <span class="number">3</span> * (month + <span class="number">1</span>) / <span class="number">5</span> + year + year / <span class="number">4</span> - year / <span class="number">100</span> + year / <span class="number">400</span>) % <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h &lt; <span class="number">0</span>)</span><br><span class="line">        h += <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    h++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pcalendar</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> DAYS_IN_MONTH[<span class="number">12</span>] = &#123;<span class="number">31</span>, <span class="built_in">isLeap</span>(year) ? <span class="number">29</span> : <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>,</span><br><span class="line">                                   <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, MONTH_NAMES[month]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            -%02d-            \n&quot;</span>, month + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; SUN MON TUE WED THU FRI SAI\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> firstDayOfWeek = <span class="built_in">Wweek</span>(year, month + <span class="number">1</span>, <span class="number">1</span>) % <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; firstDayOfWeek; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> day = <span class="number">1</span>; day &lt;= DAYS_IN_MONTH[month]; ++day)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>, day);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((day + firstDayOfWeek) % <span class="number">7</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    if ((DAYS_IN_MONTH[month] + firstDayOfWeek) % 7 != 0)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//        for (int i = (DAYS_IN_MONTH[month] + firstDayOfWeek) % 7; i &lt; 7; ++i)</span></span><br><span class="line">    <span class="comment">//            printf(&quot;    &quot;);</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n============================\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pyear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> year = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input the year: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;year);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Calendar                %04d\n&quot;</span>, year);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> month = <span class="number">0</span>; month &lt; <span class="number">12</span>; ++month)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Pcalendar</span>(year, month);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pmonth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">15</span>];</span><br><span class="line">    <span class="type">int</span> year = <span class="number">0</span>, month = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input the month&lt;YYYY-MM&gt;: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">                year = year * <span class="number">10</span> + str[i] - <span class="number">48</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">1</span>)</span><br><span class="line">                month = month * <span class="number">10</span> + str[i] - <span class="number">48</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Calendar                %04d\n&quot;</span>, year);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Pcalendar</span>(year, month - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1 -This year is leap or not\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2 -This day is which day of the week\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3 -The Calendar of this year\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;4 -The Calendar of this month of year\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0 -Exit\n\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please select the options: &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (n)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> year = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please input the year: &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;year);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isLeap</span>(year))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;The year %d is leap year.\n\n&quot;</span>, year);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;The year %d is not leap year.\n\n&quot;</span>, year);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> str[<span class="number">15</span>];</span><br><span class="line">            <span class="type">int</span> year = <span class="number">0</span>, month = <span class="number">0</span>, day = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please input the date&lt;YYYY-MM-DD&gt;: &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">                        year = year * <span class="number">10</span> + str[i] - <span class="number">48</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">1</span>)</span><br><span class="line">                        month = month * <span class="number">10</span> + str[i] - <span class="number">48</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">2</span>)</span><br><span class="line">                        day = day * <span class="number">10</span> + str[i] - <span class="number">48</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">Wweek</span>(year, month, day))</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;This day %d-%02d-%02d is Monday.\n\n&quot;</span>, year, month, day);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;This day %d-%02d-%02d is Tuesday.\n\n&quot;</span>, year, month, day);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;This day %d-%02d-%02d is Wednesday.\n\n&quot;</span>, year, month, day);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;This day %d-%02d-%02d is Thursday.\n\n&quot;</span>, year, month, day);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;This day %d-%02d-%02d is Friday.\n\n&quot;</span>, year, month, day);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;This day %d-%02d-%02d is Saturday.\n\n&quot;</span>, year, month, day);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;This day %d-%02d-%02d is Sunday.\n\n&quot;</span>, year, month, day);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">Pyear</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">Pmonth</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有该选项，请重新输入！\n\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>商城商品管理系统</title>
      <link href="/pages/ShopManager/index.html"/>
      <url>/pages/ShopManager/index.html</url>
      
        <content type="html"><![CDATA[<a class="btn-beautify outline green larger" href="/posts/961490cd.html#%E5%95%86%E5%9F%8E%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F" title="返回"><i class="far fa-hand-point-right"></i><span>返回</span></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 商城商品管理系统</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Product</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">    <span class="type">float</span> price;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Product &amp;other) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> id == other.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Product&gt; List, Car;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Product New;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n请输入新商品的id(id不可更改): &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;New.id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">count</span>(List.<span class="built_in">begin</span>(), List.<span class="built_in">end</span>(), Product&#123;New.id&#125;))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\a此id已经被使用!(1-重新输入/0-返回)请选择：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n请输入新商品的id(id不可更改): &quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;New.id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n\a没有该选项!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n输入新商品的名称: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, New.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n输入新商品的价格: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;New.price);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n输入新商品的库存: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;New.num);</span><br><span class="line"></span><br><span class="line">    List.<span class="built_in">push_back</span>(New);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n添加成功!\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n输入要删除的商品id: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find</span>(List.<span class="built_in">begin</span>(), List.<span class="built_in">end</span>(), Product&#123;id&#125;);</span><br><span class="line">    <span class="keyword">if</span> (it != List.<span class="built_in">end</span>())</span><br><span class="line">        List.<span class="built_in">erase</span>(it);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\a找不到id为%d的商品!\n\n&quot;</span>, id);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n删除成功!\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printAllProducts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : List)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; ID: %12d, 名称: %20s, 价格: %16.2f, 库存: %13d&quot;</span>, i.id, i.name, i.price, i.num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteCarProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> carid, carnum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n请输入要删除的商品的id: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;carid);</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find</span>(Car.<span class="built_in">begin</span>(), Car.<span class="built_in">end</span>(), Product&#123;carid&#125;);</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">distance</span>(Car.<span class="built_in">begin</span>(), it);</span><br><span class="line">    <span class="keyword">if</span> (it != Car.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n请输入要删除的数量: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;carnum);</span><br><span class="line">        <span class="keyword">if</span> (carnum &lt; Car[i].num)</span><br><span class="line">            Car[i].num -= carnum;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Car.<span class="built_in">erase</span>(it);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n删除成功!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\a购物车里没有id为%d的商品!\n&quot;</span>, carid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">payAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : Car)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">find</span>(List.<span class="built_in">begin</span>(), List.<span class="built_in">end</span>(), Product&#123;i.id&#125;);</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;num &gt; i.num)</span><br><span class="line">            List[<span class="built_in">distance</span>(List.<span class="built_in">begin</span>(), it)].num -= i.num;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            List.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    Car.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n购买成功!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printCarProducts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> op = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (op)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : Car)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; ID: %12d, 名称: %20s, 数量: %13d, 总价：%16.2f&quot;</span>, i.id, i.name, i.num, i.price * i.num);</span><br><span class="line">            cnt += i.price * i.num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 总价: %20.2f                          (1-支付全部/2-清空/3-删除商品/0-返回)&quot;</span>, cnt);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n请输入操作：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">switch</span> (op)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">payAll</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            Car.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n已清除全部商品!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">deleteCarProduct</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n\a没有该选项！\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Product A, Product B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.id &lt; B.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortPrintAll</span><span class="params">(vector&lt;Product&gt; A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : A)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; ID: %12d, 名称: %20s, 价格: %16.2f, 库存: %13d&quot;</span>, i.id, i.name, i.price, i.num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkProduct</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> id, n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n输入要查询的商品的id: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find</span>(List.<span class="built_in">begin</span>(), List.<span class="built_in">end</span>(), Product&#123;id&#125;);</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">distance</span>(List.<span class="built_in">begin</span>(), it);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != List.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; ID: %12d, 名称: %20s, 价格: %16.2f, 库存: %13d&quot;</span>, List[i].id, List[i].name, List[i].price, List[i].num);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n===========================================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="number">1010</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(n-将n件该商品加入购物车/0-返回): &quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n)</span><br><span class="line">            &#123;</span><br><span class="line">                Product buy&#123;List[i].id, <span class="string">&quot;&quot;</span>, List[i].price, n&#125;;</span><br><span class="line">                <span class="built_in">strcpy</span>(buy.name, List[i].name);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> inCar = <span class="built_in">find</span>(Car.<span class="built_in">begin</span>(), Car.<span class="built_in">end</span>(), Product&#123;id&#125;);</span><br><span class="line">                <span class="type">int</span> j = <span class="built_in">distance</span>(Car.<span class="built_in">begin</span>(), inCar);</span><br><span class="line">                <span class="keyword">if</span> (inCar != Car.<span class="built_in">end</span>())</span><br><span class="line">                    Car[j].num += n;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Car.<span class="built_in">push_back</span>(buy);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n添加成功!\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\a找不到ID为%d的商品!\n\n&quot;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n输入要修改商品的id: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find</span>(List.<span class="built_in">begin</span>(), List.<span class="built_in">end</span>(), Product&#123;id&#125;);</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">distance</span>(List.<span class="built_in">begin</span>(), it);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != List.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        <span class="type">bool</span> over = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (over)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nID: %d, 名称: %s, 价格: %.2f, 库存: %d\n\n&quot;</span>, List[i].id, List[i].name, List[i].price, List[i].num);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;要修改什么(名称-1/价格-2/库存-3/完成-0): &quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (op)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n请输入修改后的商品名称: &quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, List[i].name);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n修改成功!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n请输入修改后的商品价格: &quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;List[i].price);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n修改成功!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n请输入修改后的商品库存: &quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;List[i].num);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n修改成功!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                over = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n修改完成!\n\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n\a没有该选项!\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\a找不到ID为%d的商品!\n\n&quot;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List.<span class="built_in">push_back</span>(Product&#123;<span class="number">10001</span>, <span class="string">&quot;样品1&quot;</span>, <span class="number">10</span>, <span class="number">100</span>&#125;);</span><br><span class="line">    List.<span class="built_in">push_back</span>(Product&#123;<span class="number">10002</span>, <span class="string">&quot;样品2&quot;</span>, <span class="number">2.5</span>, <span class="number">2000</span>&#125;);</span><br><span class="line">    List.<span class="built_in">push_back</span>(Product&#123;<span class="number">10003</span>, <span class="string">&quot;样品3&quot;</span>, <span class="number">1024</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    <span class="type">int</span> key, op;</span><br><span class="line">    <span class="type">bool</span> login;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;登录...\n请输入身份密钥(客户-1010/商家-2020/退出系统-0): &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);</span><br><span class="line"></span><br><span class="line">        login = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">switch</span> (key)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2020</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n您好！商家:\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (login)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1-添加商品\n2-删除商品\n3-显示所有商品\n4-Id升序显示所有商品\n5-查询单个商品信息\n6-修改商品信息\n0-返回登录界面\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;请选择您要进行的操作: &quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (op)</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">addProduct</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="built_in">deleteProduct</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="built_in">printAllProducts</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="built_in">sortPrintAll</span>(List);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    <span class="built_in">checkProduct</span>(key);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                    <span class="built_in">reProduct</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    login = <span class="literal">false</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n\a没有该选项!\n\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1010</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n您好！客户:\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (login)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1-显示所有商品\n2-Id升序显示所有商品\n3-查询单个商品信息\n4-查看购物车\n0-返回登录界面\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;请选择您要进行的操作: &quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (op)</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">printAllProducts</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="built_in">sortPrintAll</span>(List);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="built_in">checkProduct</span>(key);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="built_in">printCarProducts</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    login = <span class="literal">false</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n\a没有该选项!\n\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n\a请输入正确的密钥!\n\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>古诗文</title>
      <link href="/menus/poem/index.html"/>
      <url>/menus/poem/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
